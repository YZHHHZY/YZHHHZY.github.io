<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/%E5%8D%9A%E5%AE%A2.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/%E5%8D%9A%E5%AE%A2-copy.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Java上常用的dos命令    作用 命令    切换盘符 盘符名:-&gt;   查看目录下文件 dir   跳转文件夹 cd   清空 cls   退出 exit   创建文件夹 mkdir   删除文件夹 rd   删除文件 del   jvm和跨平台 121、jvm：Java运行程序的假想虚拟机，主要用来运行Java程序2、跨平台：Java代码可以在不同的操作系统上运行    java是">
<meta property="og:type" content="article">
<meta property="og:title" content="Java入门学习">
<meta property="og:url" content="http://example.com/2024/10/09/Java%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="妙妙屋">
<meta property="og:description" content="Java上常用的dos命令    作用 命令    切换盘符 盘符名:-&gt;   查看目录下文件 dir   跳转文件夹 cd   清空 cls   退出 exit   创建文件夹 mkdir   删除文件夹 rd   删除文件 del   jvm和跨平台 121、jvm：Java运行程序的假想虚拟机，主要用来运行Java程序2、跨平台：Java代码可以在不同的操作系统上运行    java是">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240601133633823.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240601133733346.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240601134430217.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240601194854742.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240602101902325.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240602120911121.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240602164324489.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240602220039241.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240603171101185.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240603171441822.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240603195815403.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240603202706652.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240603221549141.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240603225038086.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240604222613517.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240605153546987.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240605154558597.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240605164045536.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240605170403893.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240605170719595.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240605171901185.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240605175519804.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240605212357849.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240605213400036.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240605214015132.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240605214750649.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240606173648473.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240606204111385.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240606211249275.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240606212442130.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240606215302104.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240607145638128.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240704183926597.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240704184415375.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240704211741799.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240704212445576.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240704214535249.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240704215758742.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240704224134475.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240705211413762.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240708154426053.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240708155932065.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240708162747315.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240708212431809.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240708213430874.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240708215553755.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240708222135613.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240708223319330.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240708224511099.png">
<meta property="og:image" content="http://example.com/2024/10/09/%E5%9B%BE%E7%89%87/image-20240708225857252.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240709134231364.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240709134348318.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240709135331805.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240709135918444.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240709140358236.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240709150804921.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240709152216046.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240709151841212.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240709161141298.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240709163703601.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240709202601853.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240709202954094.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240709210419074.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240709211240996.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240709213155605.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240709230959676.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240709231620186.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240710222320914.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240710223709233.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240710224422591.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240710231951379.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240710232348458.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240710233101853.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240710233705340.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240710233953734.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240710234511279.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240711001057714.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240712140005159.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240712141206432.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240712143430357.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240712143708424.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240712144355763.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240712172206591.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240712180450765.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240712180934217.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240712182037010.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240712185356217.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240712190214070.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240712195049760.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240712215725839.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240712220101112.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240712222402317.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240712223833312.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240712224332386.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240712225700354.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240712230119350.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240712230514533.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240712230801133.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240713111557786.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240713113958896.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240713115035035.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240713115157530.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240713115832529.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240713121008607.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240713152801971.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240713162603427.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240713162944893.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240713175148947.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240717165337495.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240717170023463.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240717170224882.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240717175339488.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240719200404369.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240719203320666.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240719211259568.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240719213600905.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240719220403029.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240721082927838.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240721084358237.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240721090259358.png">
<meta property="og:image" content="http://example.com/2024/10/09/%E5%9B%BE%E7%89%87/image-20240721141112175.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240721141317663.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240721142831844.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240721144126690.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240721145328684.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240721150000075.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240721150616062.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240721151802182.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240721152244804.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240721153125484.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240721155303756.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240721155804211.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240721161343003.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240721161821324.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240721161950990.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240722110050634.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240722140236041.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240722162134895.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240722233753304.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240723111733526.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240723112136329.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240723124842454.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240723225734056.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240723235751452.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240724000911543.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240724002151190.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240724002356860.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240724004012437.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240724004121059.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240724010223543.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240724012739416.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240724121834301.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240724223841431.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240725152609092.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240725215058436.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240726002053215.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240726155347084.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240726160303827.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240726165131748.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240726165512521.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240726170227837.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240726204949047.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240726205010962.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240726210940683.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240726224857001.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240726230110401.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240726230547130.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240727125831744.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240727212633731.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240727215416205.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240727221033472.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240727222521344.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240727223441205.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240727225026712.png">
<meta property="og:image" content="http://example.com/2024/10/09/%E5%9B%BE%E7%89%87/image-20240728000014776.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240728104917624.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240728172518571.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240728175705980.png">
<meta property="og:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240728180710086.png">
<meta property="article:published_time" content="2024-10-09T07:34:19.000Z">
<meta property="article:modified_time" content="2024-10-09T07:38:11.262Z">
<meta property="article:author" content="没事数命的猫">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/%E5%9B%BE%E7%89%87/image-20240601133633823.png">

<link rel="canonical" href="http://example.com/2024/10/09/Java%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java入门学习 | 妙妙屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">妙妙屋</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">思而不学则殆</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/09/Java%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="没事数命的猫">
      <meta itemprop="description" content="学而不思则罔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="妙妙屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java入门学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-10-09 15:34:19 / 修改时间：15:38:11" itemprop="dateCreated datePublished" datetime="2024-10-09T15:34:19+08:00">2024-10-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Java上"><a href="#Java上" class="headerlink" title="Java上"></a>Java上</h1><p>常用的dos命令</p>
<table>
<thead>
<tr>
<th>作用</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>切换盘符</td>
<td>盘符名:-&gt;</td>
</tr>
<tr>
<td>查看目录下文件</td>
<td>dir</td>
</tr>
<tr>
<td>跳转文件夹</td>
<td>cd</td>
</tr>
<tr>
<td>清空</td>
<td>cls</td>
</tr>
<tr>
<td>退出</td>
<td>exit</td>
</tr>
<tr>
<td>创建文件夹</td>
<td>mkdir</td>
</tr>
<tr>
<td>删除文件夹</td>
<td>rd</td>
</tr>
<tr>
<td>删除文件</td>
<td>del</td>
</tr>
</tbody></table>
<p>jvm和跨平台</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、jvm：Java运行程序的假想虚拟机，主要用来运行Java程序</span><br><span class="line">2、跨平台：Java代码可以在不同的操作系统上运行</span><br></pre></td></tr></table></figure>



<p>java是运行命令，javac是编译命令，跳过让人头疼的环境变量吧</p>
<h5 id="写一个helloword"><a href="#写一个helloword" class="headerlink" title="写一个helloword"></a>写一个helloword</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、编写</span><br><span class="line">   a.新建一个.java文件</span><br><span class="line">2、编译</span><br><span class="line">   a.命令javac java文件名.java</span><br><span class="line">   b.javac会将Java文件编译生成一个.class文件，jvm只认识.class文件</span><br><span class="line">3、运行</span><br><span class="line">   a.命令：Java class文件名</span><br></pre></td></tr></table></figure>



<p>这里我一直错误，配置了好久的环境变量，结果不是环境变量的问题</p>
<p>输入运一下java -cd .&#x2F; Hello 即可，神经</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240601133633823.png" alt="image-20240601133633823"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240601133733346.png" alt="image-20240601133733346"></p>
<p>注释</p>
<p>有三种注释方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   文档注释：文档注释的内容可以根据javadoc命令生成一个文档（API文档），拿到文档可以快速对此类和此类实现的功能快速了解</span></span><br><span class="line"><span class="comment">   命令：javadoc -d 要生成的文件夹名称 -author（作者） -version（版本） 文件名.Java</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240601134430217.png" alt="image-20240601134430217"></p>
<h5 id="解释一下之前的入门程序"><a href="#解释一下之前的入门程序" class="headerlink" title="解释一下之前的入门程序"></a>解释一下之前的入门程序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hello</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  public class Hello 定义一个类</span></span><br><span class="line"><span class="comment">  class：代表的就是类，类是Java程序最基本的组成单元，所有代码都需要在类中写</span></span><br><span class="line"><span class="comment">  class 后面跟的名字叫做类名，类名要求要和文件名保持一致，有求一致</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       main是一个方法，是程序的入口，jvm运行程序要找这个main当入口开始执行</span></span><br><span class="line"><span class="comment">       public static void main(String[] args)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">           下面的语句是输出语句</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>养成语句结束使用分号的好习惯</p>
<h5 id="字符编码问题"><a href="#字符编码问题" class="headerlink" title="字符编码问题"></a>字符编码问题</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、保存数据的过程就是编码的过程</span><br><span class="line">2、读取数据的过程就是解码的过程</span><br><span class="line">3、编解码要是同一个编码</span><br><span class="line">   常见的编码规范：</span><br><span class="line">      GDK：专门为中文设计的编码（ANSI），一个中文汉字占两个字节</span><br><span class="line">      utf-8：一个中文汉字占三个字节</span><br><span class="line">      dos窗口默认编码为GDK</span><br></pre></td></tr></table></figure>





<h5 id="源文件名与类目一致问题"><a href="#源文件名与类目一致问题" class="headerlink" title="源文件名与类目一致问题"></a>源文件名与类目一致问题</h5><p>并不是必须的，如果不一致，需要将class前的public删掉</p>
<p>javac编译生成的class文件名称与类名相同</p>
<p>一个Java文件中可以有多个类名，但是只能有一个类带public，建议不要在一个文件中随意写class</p>
<p>main方法必须写在带public的类中</p>
<h5 id="println和print的区别"><a href="#println和print的区别" class="headerlink" title="println和print的区别"></a>println和print的区别</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">相同点：都是输出语句</span><br><span class="line">不同点：println输出后带换行效果；相当于python中print</span><br><span class="line">       print输出后不带换行效果；相当于python中的print(end=&#x27;&#x27;)</span><br></pre></td></tr></table></figure>





<h3 id="常量、变量、类型转化"><a href="#常量、变量、类型转化" class="headerlink" title="常量、变量、类型转化"></a>常量、变量、类型转化</h3><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>在代码的运行过程中其值不会发生改变的数据</p>
<p>分类：</p>
<p>整数常量：所有整数</p>
<p>小数常量：带小数点就算</p>
<p>字符常量：带单引号的，单引号中必须有且只能有一个内容 <code>&#39;1&#39;(算) &#39;11&#39;(不算) &#39;&#39;(不算) &#39; &#39;(算) &#39;  &#39;(不算) </code>  单引号内打一个Tab键也算</p>
<p>字符串常量：带双引号的，双引号内容随意</p>
<p>布尔常量：true和false</p>
<p>空常量：null（不能直接使用）</p>
<h4 id="注意一下常量的运算"><a href="#注意一下常量的运算" class="headerlink" title="注意一下常量的运算"></a>注意一下常量的运算</h4><p>除法是：如果前后都是整数那么，结果只取整数部分</p>
<p>前后只要有一个带小数点，结果就是正常小数</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、基本数据类型：四类八种</span><br><span class="line">    整型：byte、short、int、long</span><br><span class="line">    浮点型：float、double</span><br><span class="line">    字符型：char</span><br><span class="line">    布尔型：boolean</span><br><span class="line">2、引用数据类型</span><br><span class="line">    类、数组、接口、枚举、注解</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">关键字</th>
<th align="center">内存占用</th>
<th align="center">数值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字节型</td>
<td align="center">byte</td>
<td align="center">1字节</td>
<td align="center">-128至127</td>
</tr>
<tr>
<td align="center">短整型</td>
<td align="center">short</td>
<td align="center">2字节</td>
<td align="center">-32768至32767</td>
</tr>
<tr>
<td align="center">整型</td>
<td align="center">int</td>
<td align="center">4字节</td>
<td align="center">-2^31^ 至 2^31^  正负21亿</td>
</tr>
<tr>
<td align="center">长整型</td>
<td align="center">long</td>
<td align="center">8字节</td>
<td align="center">-2^63^ 至 2^63^</td>
</tr>
<tr>
<td align="center">单精度浮点数</td>
<td align="center">float</td>
<td align="center">4字节</td>
<td align="center">1.4013E-45 至 1.4013E+38  1.4乘十的负45次方</td>
</tr>
<tr>
<td align="center">双精度浮点数</td>
<td align="center">double</td>
<td align="center">8字节</td>
<td align="center">4.9E-324 至 1.7977E+308</td>
</tr>
<tr>
<td align="center">字符型</td>
<td align="center">char</td>
<td align="center">2字节</td>
<td align="center">0 至 2^16^-1</td>
</tr>
<tr>
<td align="center">布尔类型</td>
<td align="center">boolean</td>
<td align="center">1字节</td>
<td align="center">true 和 false</td>
</tr>
</tbody></table>
<p>注意：</p>
<p>定义Long类型是后面要加一个大写的L</p>
<p>定义float类型时后面加上一个F</p>
<p>float 和 double的区别</p>
<p>float的小数位只有23位二进制，能表示最大的十进制位（8388608），七位数</p>
<p>double的小数位有52位，能表示最大的十进制位（4 503 599 627 370 496），十六位数</p>
<p>&#x3D;&#x3D;不要用float和double直接参与运算&#x3D;&#x3D;，精度不准</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240601194854742.png" alt="image-20240601194854742"></p>
<p>输出结果为  1.4300001</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>在代码运行过程中，值会随着不同的情况而随时发生改变的数据</p>
<p>定义方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、数据类型 变量名 = 值</span><br><span class="line"></span><br><span class="line">2、数据类型 变量名;</span><br><span class="line">变量名 = 值</span><br><span class="line"></span><br><span class="line">3、数据类型 变量1 变量2 变量3;</span><br><span class="line">变量1 = 值</span><br><span class="line">变量2 = 值</span><br><span class="line">变量3 = 值</span><br><span class="line"></span><br><span class="line">4、数据类型 变量名1 = 值, 变量名2 = 值, 变量名3 = 值;</span><br></pre></td></tr></table></figure>



<p>字符串属于引用数据类型，用String表示，String是一个类，只不过是字符串定义是和基本数据类型定义格式一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name = &quot;张三&quot;;</span><br></pre></td></tr></table></figure>



<p>变量没赋值，没有初始化无法使用，在同一个作用域中不能定义重名的变量</p>
<p>不同作用域的变量不要随意访问</p>
<p>小作用域中可以访问大作用域的变量</p>
<p>大作用域中不可以访问小作用域的变量 </p>
<h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><p><code>\</code> ：将普通字符转换成具有特殊含义的字符，将带有特殊含义的字符转换为普通字符</p>
<h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>给类、方法、变量取的名字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">    硬性规定：</span><br><span class="line">        标识符可以包含数字，字母 $_</span><br><span class="line">        标识符不能以数字开头</span><br><span class="line">        标识符不能是关键字</span><br><span class="line">    软性建议：</span><br><span class="line">    	给类取名字是遵循大驼峰式命名 -&gt; 每个单词首字母大写</span><br><span class="line">    	给方法和变量遵循小驼峰式命名 -&gt; 从第二个单词开始大写</span><br><span class="line">    	见名知意</span><br></pre></td></tr></table></figure>





<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">什么时候发生数据类型转换：</span><br><span class="line">	等号两边类型不一致的时候，如：long和float定义值时需要加L、F，如果不加的话会类型转化</span><br><span class="line">	不同类型的数据做运算</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">基本数据类型按照取值范围从小到大排序</span><br><span class="line">byte,short,char -&gt; int -&gt; long -&gt; float -&gt; double</span><br></pre></td></tr></table></figure>



<h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><p>将取值范围小的数据类型赋值给取值范围大的数据类型会自动数据转换 -&gt; 小转大</p>
<p>取值范围小的数据类型和取值范围大的数据类型做运算 -&gt; 小转大</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       main是一个方法，是程序的入口，jvm运行程序要找这个main当入口开始执行</span></span><br><span class="line"><span class="comment">       public static void main(String[] args)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 等号右边是整数，整数默认类型为int，等号左边是long型的变量</span></span><br><span class="line"><span class="comment">         * 将取值范围小的数据赋值给取值范围大的数据类型，发生了自动数据类型转换</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        System.out.print(num1);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2.5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * double = int + double</span></span><br><span class="line"><span class="comment">         * double = double + double</span></span><br><span class="line"><span class="comment">         * int 自动提升为 double ，发生了自动数据类型转换</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> i + x;</span><br><span class="line">        System.out.print(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>当取值范围大的数据类型赋值给取值范围小的数据类型 -&gt; 强制转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">取值范围小的数据类型 变量名 = （取值范围小的数据类型）取值范围大的数据类型</span><br><span class="line">	// 右边的数据是小数，小数默认类型为double</span><br><span class="line">	float num = (float)2.5;</span><br><span class="line">	float num = 2.5F;</span><br></pre></td></tr></table></figure>



<p>注意，不要随意写成强制转换的形式，会有精度损失问题以及数量溢出现象</p>
<p>精度损失问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = (int)2.9</span><br><span class="line">// 这个时候 i 的值为2，0.9损失掉了，不是四舍五入，而是抹零</span><br></pre></td></tr></table></figure>



<p>数据溢出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 数据溢出</span></span><br><span class="line"><span class="comment"> * int型占内存4个字节，四个字节变为二进制是32位</span></span><br><span class="line"><span class="comment"> * 100亿的二进制 ：10 0101 0100 0000 1011 1110 0100 0000 0000 -&gt; 34位</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 100亿的二进制位比int型的二进制位多出来两位，因此要干掉两位</span></span><br><span class="line"><span class="comment"> *      0101 0100 0000 1011 1110 0100 0000 0000</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">10000000000L</span>;</span><br><span class="line"> <span class="comment">// 这里相当于把10升水倒入2升的容器内，将值位100亿的长整型赋值给整型，会出现损失，但是输出结果并不是整型的极限，这里涉及到二进制</span></span><br><span class="line"> System.out.print(j); <span class="comment">// 输出结果1410065408</span></span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240602101902325.png" alt="image-20240602101902325"></p>
<p>但是也有不得不用强制转换的时候例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">调用find()功能获取2.5这个数据，以为find()要求必须使用float型的变量接收</span><br><span class="line"></span><br><span class="line">float number = 对象.find()</span><br></pre></td></tr></table></figure>



<p>数字默认为int</p>
<p>byte 和 short 定义的时候如果等号右边是常量，但是取值在范围内，不需要强转，jvm会自动转型</p>
<p>byte 和 short 如果&#x3D;&#x3D;等号右边有变量参与&#x3D;&#x3D;，byte和short自动提升为int，然后结果再次赋值给byte和short，需要我们自己手动强转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">byte i = 10;</span><br><span class="line">System.out.print(i)</span><br><span class="line">// 输出没问题</span><br><span class="line"></span><br><span class="line">i = i + 1;</span><br><span class="line">System.out.print(i)</span><br><span class="line">// 这个时候就会给出提示，从int转化为byte可能会有损失</span><br><span class="line"></span><br><span class="line">i = (byte)(i+1)</span><br><span class="line">// 转化</span><br></pre></td></tr></table></figure>





<p>char类型数据，如果参与运算会自动提升为int类型</p>
<p>如果char转换为int类型，如果是字母会去ASCII码表中去查，对应数字</p>
<p>如果在ASCII码表中没有找到对应字符，那么就会去Unicode（万国码）码表中找</p>
<p>byte类型强转有一点事</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte i = (byte)200</span><br><span class="line">System.out.print(i)  // 输出-56</span><br></pre></td></tr></table></figure>



<p>这里涉及到二进制的源码、反码、补码的问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">200，转换成二进制</span><br><span class="line">原码：1100 1000</span><br><span class="line"></span><br><span class="line">反码是原码第一位不变，其余0、1互换</span><br><span class="line">反码：1011 0111</span><br><span class="line"></span><br><span class="line">补码是在反码的基础上加一</span><br><span class="line">补码：1011 1000</span><br><span class="line"></span><br><span class="line">注意一下，因为byte的取值范围为 -128至127，所以正数的时候第一位是一直为0，因此，第一位代码的0、1设计为了正负的判断，第一位为1是负数，为0是正数</span><br><span class="line">现在再看补码，除去第一位是56，第一位是1，因此结果为-56</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">还有一种更简单的理解方式</span><br><span class="line">byte i = (byte)128</span><br><span class="line"></span><br><span class="line">这个时候也是超出范围的输出结果为 -128 再结合200找一下规律，发现也可以理解为 byte 的数是从 -128至127循环的，128就变为了 -128</span><br></pre></td></tr></table></figure>





<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><table>
<thead>
<tr>
<th align="center">位运算符</th>
<th align="center">符号解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&amp;</code></td>
<td align="center">按位与，当两位相同时为1才返回1，and</td>
</tr>
<tr>
<td align="center">&#96;</td>
<td align="center">&#96;</td>
</tr>
<tr>
<td align="center"><code>~</code></td>
<td align="center">按位非，将操作数的每个位（包括符号位）全部取反</td>
</tr>
<tr>
<td align="center"><code>^</code></td>
<td align="center">按位异或，当两位相同时返回0，不同时返回1</td>
</tr>
<tr>
<td align="center"><code>&lt;&lt;</code></td>
<td align="center">左移运算符</td>
</tr>
<tr>
<td align="center"><code>&gt;&gt;</code></td>
<td align="center">右移运算符</td>
</tr>
<tr>
<td align="center"><code>&gt;&gt;&gt;</code></td>
<td align="center">无符号右移运算符</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&amp;	-&gt; 有假则假</span><br><span class="line">|	-&gt; 有真则真</span><br><span class="line">~	-&gt; 取反</span><br><span class="line">^	-&gt; 前后结果一样为false，不一样为true</span><br><span class="line">&lt;&lt;	-&gt; 左移几位相当于乘以2的几次方，很好理解吧，左移指的是二进制的左移</span><br><span class="line">&gt;&gt;	-&gt; 右移几位相当于乘以2的负几次方，向下取整，理解为二进制右移即可</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>



<p>计算机在存储数据的时候都是存储的数据的补码，计算也用的补码，但是最终看到的结果是原码，正数最高位为0，负数最高位为1</p>
<p>如果是正数，原反补是一致的，负数的原反补之前在byte是写过，我的理解是128八位二进制时最高位为1，对于byte来说只有八位二进制，因此使用了负数的原反补形式</p>
<h4 id="右移"><a href="#右移" class="headerlink" title="右移"></a>右移</h4><p>说一下右移，除了&#x3D;&#x3D;负数的右移是补1，其他的都是补0&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">9&gt;&gt;2</span><br><span class="line">结果为2</span><br><span class="line">0000 1001右移两位，补零，成为 0000 0010</span><br><span class="line"></span><br><span class="line">正数还好，看一下负数</span><br><span class="line">-9&gt;&gt;2</span><br><span class="line"></span><br><span class="line">-9的原码</span><br><span class="line">1000 …0… 0000 1001</span><br><span class="line"></span><br><span class="line">-9的反码</span><br><span class="line">1111 …1… 1111 0110</span><br><span class="line"></span><br><span class="line">-9的补码</span><br><span class="line">1111 …1… 1111 0111</span><br><span class="line"></span><br><span class="line">补码右移两位，这个时候左边空了，但是不能补0，因为补0就是正数了，因此要补1</span><br><span class="line">1111 …1… 1111 1101</span><br><span class="line"></span><br><span class="line">根据补码算反码</span><br><span class="line">1111 …1… 1111 1100</span><br><span class="line"></span><br><span class="line">反码推原码</span><br><span class="line">1000 …0… 0000 0011</span><br><span class="line"></span><br><span class="line">结果为-3</span><br></pre></td></tr></table></figure>





<h4 id="无符号右移"><a href="#无符号右移" class="headerlink" title="无符号右移"></a>无符号右移</h4><p>向右移动后，&#x3D;&#x3D;左边空出来的位直接补0&#x3D;&#x3D;，无论正负，无符号还是很生动形象的</p>
<p>负数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-9&gt;&gt;&gt;2</span><br><span class="line"></span><br><span class="line">补码成为了这个，中间很多1，变为原码时数字会变得很大，因为第二位会是1</span><br><span class="line">0011 …1… 1111 1101</span><br><span class="line"></span><br><span class="line">结果为</span><br><span class="line">1073741821</span><br></pre></td></tr></table></figure>



<p>这里有个很有意思的事情</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8&gt;&gt;&gt;32  -&gt;  8一共只有32为，右移32为结果是不变的，意思是右移32为相当于没移</span><br><span class="line"></span><br><span class="line">8&gt;&gt;&gt;34  -&gt;  8右移了两位</span><br></pre></td></tr></table></figure>





<h4 id="位运算符-1"><a href="#位运算符-1" class="headerlink" title="位运算符"></a>位运算符</h4><h5 id="与"><a href="#与" class="headerlink" title="与&amp;"></a>与&amp;</h5><p>运算规则：对应位都是1才是1，相当于符号左右两边都是true，结果才是true</p>
<p>有个比较抽象的地方</p>
<p>1&amp;1 结果为1</p>
<p>0&amp;0 结果为0</p>
<p>1&amp;0 结果为0</p>
<p>这都很好理解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">5&amp;3 结果为1</span><br><span class="line"></span><br><span class="line">用二进制解释一下：</span><br><span class="line">5、3的二进制</span><br><span class="line">0000 0101</span><br><span class="line">0000 0011</span><br><span class="line">同0为0，不同为0，同1为1</span><br><span class="line">0000 0001</span><br><span class="line">因此</span><br><span class="line"></span><br><span class="line">5&amp;3为</span><br><span class="line">0000 0001</span><br><span class="line">结果为1</span><br></pre></td></tr></table></figure>



<h5 id="或"><a href="#或" class="headerlink" title="或|"></a>或|</h5><p>运算规则：</p>
<p>有1则1，同0则0</p>
<p>1|1  &gt;&gt;&gt;&gt;	1</p>
<p>0|1	&gt;&gt;&gt;&gt;	1</p>
<p>0|0	&gt;&gt;&gt;&gt;	0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">5|3</span><br><span class="line"></span><br><span class="line">5、3的二进制</span><br><span class="line">0000 0101</span><br><span class="line">0000 0011</span><br><span class="line"></span><br><span class="line">0000 0111</span><br><span class="line">结果为7</span><br></pre></td></tr></table></figure>



<h5 id="异或"><a href="#异或" class="headerlink" title="异或^"></a>异或^</h5><p>运算规则：相同为0，不同为1</p>
<p>1^1		0</p>
<p>0^1		1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5^3</span><br><span class="line"></span><br><span class="line">0000 0101</span><br><span class="line">0000 0011</span><br><span class="line"></span><br><span class="line">0000 0110</span><br><span class="line">结果为6</span><br></pre></td></tr></table></figure>





<h5 id="按位取反"><a href="#按位取反" class="headerlink" title="按位取反"></a>按位取反</h5><p>运算规则：<del>0就是1，</del>1就是0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">~10   结果为-11</span><br><span class="line"></span><br><span class="line">10为正数</span><br><span class="line">0000 …0… 0000 1010</span><br><span class="line"></span><br><span class="line">~10</span><br><span class="line"></span><br><span class="line">按位取反后的补码</span><br><span class="line">1111 …1… 1111 0101</span><br><span class="line"></span><br><span class="line">反码</span><br><span class="line">1111 …1… 1111 0100</span><br><span class="line"></span><br><span class="line">原码</span><br><span class="line">1000 …0… 0000 1011</span><br><span class="line"></span><br><span class="line">结果为-11</span><br></pre></td></tr></table></figure>



<h4 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h4><p>1、表达式不要太复杂，有小括号先算小括号里的内容<br>2、</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240602120911121.png" alt="image-20240602120911121"></p>
<h3 id="使用开发工具idea"><a href="#使用开发工具idea" class="headerlink" title="使用开发工具idea"></a>使用开发工具idea</h3><p>idea 的目录结构</p>
<p>一个根目录project（项目）</p>
<p>项目下面会有子文件夹module（模块）</p>
<p>模块下面的文件夹叫做package（包）package需要放到模块文件夹下的src目录下</p>
<p>package取名规范</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">域名倒着写</span><br><span class="line">	比如：www.sdpc.com</span><br><span class="line">	写为：com.sdpc 来创建包</span><br></pre></td></tr></table></figure>



<p>而创建包的时候就会发现com.sdpc不是一个文件夹，而是嵌套文件夹com&#x2F;sdpc</p>
<h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><p>AIt + Enter  快速修复</p>
<p>Ctrl + d   复制粘贴行</p>
<p>Ctrl + k   格式化代码</p>
<p>ctrl  +  &#x2F;   单行注释</p>
<p>Ctrl  + shift   + &#x2F;    多行注释</p>
<p>10.var   可以直接生成等号左边的内容</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>简单的运算符直接省略了</p>
<h4 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1、格式</span><br><span class="line">	模式：</span><br><span class="line">		变量++    -&gt;   后自加</span><br><span class="line">		++变量	-&gt;   前自加</span><br><span class="line">		</span><br><span class="line">		变量--    -&gt;   后自减</span><br><span class="line">		--变量	-&gt;   前自减</span><br><span class="line">		</span><br><span class="line">		自增自减只变化1</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">2、使用</span><br><span class="line">	a.单独使用	++   --    单独为一句，不和其他语句混合使用</span><br><span class="line">		i++;</span><br><span class="line">		符号在前在后都是先运算</span><br><span class="line">	b.混合使用</span><br><span class="line">		++  --  和其他语句掺和使用（如：输出语句，赋值语句）</span><br><span class="line">		符号在前：先运算、再使用运算后的值</span><br><span class="line">			int j = 100;</span><br><span class="line">			int i = ++j;</span><br><span class="line">			这个时候分别输出i和j输出结构均为101，先运算</span><br><span class="line">		符号在后：先使用原值，使用原值后再运算</span><br><span class="line">			int x = 10;</span><br><span class="line">			int y = x++;</span><br><span class="line">				这个时候分别输出y和x输出结果分别为10，11，先输出，再运算</span><br></pre></td></tr></table></figure>





<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">作用：连接多个Boolean结果</span><br><span class="line">结果：Boolean类型</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;（与，和）</td>
<td>有假则假，and</td>
</tr>
<tr>
<td>||（或者）</td>
<td>有真则真，or</td>
</tr>
<tr>
<td>！（非，取反）</td>
<td>取反，true就是false</td>
</tr>
<tr>
<td>^（异或）</td>
<td>结果一样是false，不一样为true</td>
</tr>
</tbody></table>
<p>区别一下单与和双与</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>1、单与，如果前后都是布尔型，有假则假，第一个运算为false时。第二个仍会继续运算<br>2、如果判断的是数字，看作是位运算符，算二进制</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>双与，有假则假，但是有短路效果，第一个运算为false时，会停止运算</td>
</tr>
<tr>
<td>|</td>
<td>1、单或，有真则真，第一个运算为true时。第二个仍会继续运算<br/>2、如果前后都是数字，看作位运算符</td>
</tr>
<tr>
<td>||</td>
<td>双或，有真则真，第一个运算为true时，会停止运算</td>
</tr>
</tbody></table>
<p>可以用代码验证一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int a = 10</span><br><span class="line">int b = 20</span><br><span class="line">boolean c = (++a&gt;100) &amp; (++b&gt;10)</span><br><span class="line">System.out.print(a,b)</span><br><span class="line">//  输出结果位11，21</span><br><span class="line"></span><br><span class="line">boolean c = (++a&gt;100) &amp;&amp; (++b&gt;10)</span><br><span class="line">System.out.print(a,b)</span><br><span class="line">//  输出结果为11，20</span><br></pre></td></tr></table></figure>



<p>Java内使用逻辑运算符拼接各种运算</p>
<h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	boolean 表达式？表达式1:表达式2</span><br><span class="line">	</span><br><span class="line">执行流程：</span><br><span class="line">	先判断，如果是true，则执行表达式1，如果是false则执行表达式2</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">使用三元运算符时</span><br><span class="line">经常会提示我可以使用,Math.max(表达式1，表达式2)的形式来替换三元运算</span><br></pre></td></tr></table></figure>





<h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><h3 id="Scanner键盘录入"><a href="#Scanner键盘录入" class="headerlink" title="Scanner键盘录入"></a>Scanner键盘录入</h3><p>功能相当于python的input，比input麻烦</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、Scanner：Java定义好的一个类</span><br><span class="line">2、作用：将数据通过键盘录入的方式放到代码中参与运行</span><br><span class="line">3、位置：java.util</span><br><span class="line">4、使用：</span><br><span class="line">	a.导包（引入/import）</span><br><span class="line">		import java.util.Scanner;</span><br><span class="line">		位置在类的上面</span><br><span class="line">	b.创建对象</span><br><span class="line">		Scanner 变量名 = new Scanner(System.in);</span><br><span class="line">	c.调用方法</span><br><span class="line">		变量名.nextInt()   输入整数int的</span><br><span class="line">		变量名.next()   输入字符串String的</span><br></pre></td></tr></table></figure>



<p>next 和 nextLine 的区别</p>
<p>next 遇到空格和回车就结束了，不能接收空格</p>
<p>nextLine 遇到回车结束</p>
<p>一个有意思的事情</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjjws.a;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">i</span> <span class="operator">=</span> input.next();</span><br><span class="line">        <span class="type">String</span> <span class="variable">i2</span> <span class="operator">=</span> input.nextLine();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(i2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我只录入了一次，缺分别给i和i2赋值了，因此，尽量不要将next和next Line连起来使用</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240602164324489.png" alt="image-20240602164324489"></p>
<h3 id="Random随机数"><a href="#Random随机数" class="headerlink" title="Random随机数"></a>Random随机数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">random老朋友了</span><br><span class="line">也是Java自带的一个类</span><br><span class="line">位置在：Java.util</span><br><span class="line">使用方法和Scanner类似</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Random</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">date</span> <span class="operator">=</span> sum.nextInt();</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>设置随机范围</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int date = sum.nextInt();</span><br><span class="line">// 和python类似，写一个x 从0开始到x-1结束</span><br></pre></td></tr></table></figure>





<h3 id="流程控制语句-1"><a href="#流程控制语句-1" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	switch(变量)&#123;</span><br><span class="line">		case 常量值1:</span><br><span class="line">			执行语句1;</span><br><span class="line">			break;</span><br><span class="line">			</span><br><span class="line">		case 常量值2:</span><br><span class="line">			执行语句2;</span><br><span class="line">			break;</span><br><span class="line">			</span><br><span class="line">			…………</span><br><span class="line">			</span><br><span class="line">		default:</span><br><span class="line">			执行语句n;</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">执行流程：</span><br><span class="line">	用变量接收的值和下面case后面的常量值匹配，匹配上哪个case就执行哪个case对应的执行语句</span><br><span class="line">	如果都没有匹配上，就执行default对应的语句</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">break：结束关键字</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">switch可以匹配到的数据类型：byte、short、int、char、枚举、String</span><br></pre></td></tr></table></figure>



<p>case有穿透性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果没有break，就会出现case的穿透性，程序就一直往下穿透运行，直到遇到break或者switch代码执行完毕，停止</span><br></pre></td></tr></table></figure>



<h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if的一些操作懒得说了，说点不一样的，第一个如果使用if比较的数据类型为布尔类型，可以只写一个等号</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if两种情况以上的判断</span><br><span class="line">if()&#123;</span><br><span class="line"></span><br><span class="line">&#125; else if()&#123;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 最后不一定使用else但是要保证所有情况都有</span><br></pre></td></tr></table></figure>





<h4 id="switch和if的区别"><a href="#switch和if的区别" class="headerlink" title="switch和if的区别"></a>switch和if的区别</h4><p>打个断点看一下，右键&#x3D;&#x3D;调试&#x3D;&#x3D;，看一下if判断的流程，发现有高亮有暗点，可以发现if从上往下便利到if等于三时，if判断结束，再看一下switch，switch会直接跳到匹配的case</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240602220039241.png" alt="image-20240602220039241"></p>
<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	for(初始化变量;比较;步进表达式)&#123;</span><br><span class="line">		循环语句</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">执行流程：</span><br><span class="line">	a.先走初始化变量</span><br><span class="line">	b.比较如果为true，走循环语句，走步进表达式（初始化变量）</span><br><span class="line">	c.再比较，如果还是true，继续走循环语句，走步进表达式</span><br><span class="line">	d.比较，如果为false，结束</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">先循环，再加一</span><br><span class="line">循环快捷键</span><br><span class="line">次数.fori</span><br></pre></td></tr></table></figure>



<h4 id="do……while循环"><a href="#do……while循环" class="headerlink" title="do……while循环"></a>do……while循环</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	do&#123;</span><br><span class="line">		循环语句；</span><br><span class="line">		步进表达式；</span><br><span class="line">	&#125; while （比较）；</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	1、初始化变量</span><br><span class="line">	2、循环语句</span><br><span class="line">	3、步进表达式</span><br><span class="line">	4、判断循环</span><br><span class="line">	</span><br><span class="line">do……while的特点是至少循环一次，先循环再判断</span><br></pre></td></tr></table></figure>





<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">特点：</span><br><span class="line">	即可以储存基本类型数据，还能引用储存的数据</span><br><span class="line">	定长（定义数组时长度为多长，最多就能存多少数据）</span><br><span class="line">	</span><br><span class="line">	定长是数组最大的特点，也是最大的缺点</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">定义：</span><br><span class="line">	1、动态初始化：在定义数组的时候，我们没有给具体的数据，只指定了长度</span><br><span class="line">		数据类型[] 数组名 = new 数据类型[长度]</span><br><span class="line">		</span><br><span class="line">			等号左边的数据类型：规定了数组中只能存储什么类型的数据</span><br><span class="line">			[]:代表的是数组，一个[]代表一维数组，两个[][]代表二维数组</span><br><span class="line">			new:代表创建数组</span><br><span class="line">			等号右边的数据类型要和左边的数据类型一致</span><br><span class="line">			[长度]：表示数组最多能存贮多少数据</span><br><span class="line">		</span><br><span class="line">	2、静态初始化：在定义数组的时候，我们直接给出数据</span><br><span class="line">		数据类型[] 数组名 = new 数据类型[]&#123;元素1，元素2，……&#125;</span><br><span class="line">		数据类型 数组名[] = new 数据类型[]&#123;元素1，元素2，……&#125;</span><br><span class="line">		</span><br><span class="line">		静态初始化的简化：</span><br><span class="line">			数据类型[] 数组名 = &#123;元素1，元素2，……&#125;</span><br></pre></td></tr></table></figure>





<h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><p>在数组中数据的存储、查询都需要指定索引</p>
<h4 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数组名.length</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">	length后面不要带小括号，因为length不是数组中的方法，而是数组中的一个属性</span><br></pre></td></tr></table></figure>



<h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">元素赋值格式</span><br><span class="line">	数组名[索引] = 值</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">获取元素</span><br><span class="line">	数组名[索引]</span><br><span class="line">	</span><br><span class="line">	注意点:</span><br><span class="line">		直接输出数组名，会输出数组在内存中的地址值</span><br><span class="line">		地址值：数组在内存中的一个身份证号，唯一标识，我们可以通过这个唯一标识在内存中找到这个数组，从而操作这个数组中的数据</span><br><span class="line">		</span><br><span class="line">		如果数组中没有数据，那么也是可以获取到默认的数据</span><br><span class="line">		整数：0</span><br><span class="line">		小数：0.0</span><br><span class="line">		字符：&#x27;\u0000&#x27;   对应是int值是0 </span><br><span class="line">		布尔：false</span><br><span class="line">		引用：null</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">遍历数组的快捷方式</span><br><span class="line">数组名.fori</span><br></pre></td></tr></table></figure>

<h4 id="数组操作的常见异常"><a href="#数组操作的常见异常" class="headerlink" title="数组操作的常见异常"></a>数组操作的常见异常</h4><h5 id="数组索引越界异常-ArrayIndexOutOfBoundsException"><a href="#数组索引越界异常-ArrayIndexOutOfBoundsException" class="headerlink" title="数组索引越界异常_ArrayIndexOutOfBoundsException"></a>数组索引越界异常_ArrayIndexOutOfBoundsException</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">操作的索引超过数组的长度范围</span><br><span class="line"></span><br><span class="line">注意Java的索引是没有负数的，不想python那样-1表示倒数第一个元素</span><br></pre></td></tr></table></figure>



<h5 id="空指针异常-NullPinterException"><a href="#空指针异常-NullPinterException" class="headerlink" title="空指针异常_NullPinterException"></a>空指针异常_NullPinterException</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组为null时，再调用此对象中的其他成员</span><br></pre></td></tr></table></figure>





<h4 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">新建一个数组，将老数组的元素赋值给新数组，然后将老数组的地址值改为新数组的地址值</span><br><span class="line"></span><br><span class="line">int[] old = &#123;1,2,3,4,5&#125;</span><br><span class="line">int[] now = new int[10];</span><br><span class="line">for……</span><br><span class="line"></span><br><span class="line">old = now</span><br><span class="line"></span><br><span class="line">但是我就产生了一个问题，新建的数组地址值是多少，去哪了,</span><br><span class="line">结果是，新老两个数组此时的地址值是相同的</span><br></pre></td></tr></table></figure>





<h4 id="内存图"><a href="#内存图" class="headerlink" title="内存图"></a>内存图</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1、内存可以理解为“内存条”，所有的软件，程序运行起来都会进入到内存中，占用内存，在Java的世界中，将内存划分为了五块</span><br><span class="line"></span><br><span class="line">2、</span><br><span class="line">	a.栈（重点）（Stack）</span><br><span class="line">		主要运行方法，方法的运行都会进入栈内存运行，运行完毕后，需要“弹栈”，为了腾空间</span><br><span class="line">		</span><br><span class="line">	b.堆（重点）(Heap)</span><br><span class="line">		保存的是对象，数组，每new一次，都会在堆内存中开辟空间，并为这个空间分配一个地址值，堆中的数据都是有默认值的</span><br><span class="line">		整数：0；</span><br><span class="line">		小数：0.0；</span><br><span class="line">		字符：“\u0000”；</span><br><span class="line">		布尔：false；</span><br><span class="line">		引用：null;</span><br><span class="line">		</span><br><span class="line">	c.方法区（重点）（Method Area）</span><br><span class="line">		代码的“预备区”，记录了类的信息以及方法的信息</span><br><span class="line">		方法区中主要保存class文件以及其中的信息</span><br><span class="line">		代码运行之前，需要先进内存（方法区）</span><br><span class="line"></span><br><span class="line">	d.本地方法栈（了解）（Native Method Stack）:专门运行native方法（本地方法）</span><br><span class="line">		本地方法可以理解为堆对Java功能的补充</span><br><span class="line">		有很多功能Java实现不了。所有需要依靠本地方法完成（C语言编写）</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	e.寄存器（了解）（pc register） -&gt; (和CPU有关)</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240603171101185.png" alt="image-20240603171101185"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240603171441822.png" alt="image-20240603171441822"></p>
<p>现在再回顾一下之前的数组扩容操作，新老数组的地址值是一样的，这个时候两个数组同时指向了堆内存的同一个空间，这个时候，更改任意一个数组另一个数组都会变化</p>
<h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">概述：数组中嵌套数组</span><br><span class="line">格式：</span><br><span class="line">	1、动态初始化</span><br><span class="line">		数据类型[][] 数组名 = new 数据类型[m][n]</span><br><span class="line">		数据类型 数组名[][] = new 数据类型[m][n]</span><br><span class="line">		数据类型[] 数组名[] = new 数据类型[m][n]</span><br><span class="line">		</span><br><span class="line">		m：代表的是二维数组的长度</span><br><span class="line">		n：代表的是二维数组内每个一维数组的长度</span><br><span class="line">		</span><br><span class="line">	2、静态初始化</span><br><span class="line">		数据类型[][] 数组名 = new 数据类型[][]&#123;&#123;元素1，元素2……&#125;，&#123;元素1，元素2……&#125;……&#125;</span><br><span class="line">		数据类型 数组名[][] = new 数据类型[][]&#123;&#123;元素1，元素2……&#125;，&#123;元素1，元素2……&#125;……&#125;</span><br><span class="line">		数据类型[] 数组名[] = new 数据类型[][]&#123;&#123;元素1，元素2……&#125;，&#123;元素1，元素2……&#125;……&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	简化静态初始化：</span><br><span class="line">		数据类型[][] 数组名 = &#123;&#123;元素1，元素2……&#125;，&#123;元素1，元素2……&#125;……&#125;</span><br><span class="line">		数据类型 数组名[][] = &#123;&#123;元素1，元素2……&#125;，&#123;元素1，元素2……&#125;……&#125;</span><br><span class="line">		数据类型[] 数组名[] = &#123;&#123;元素1，元素2……&#125;，&#123;元素1，元素2……&#125;……&#125;</span><br></pre></td></tr></table></figure>





<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">之前的所有代码都在main方法中写，如果我们将来所有的功能代码都放到main方法内，会显得main方法代码太多，太乱，不便于维护</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">将对应的代码封装成方法，使用时调用即可</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">	修饰符 返回值类型 方法名（参数）&#123;</span><br><span class="line">		方法体</span><br><span class="line">		return 结果</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">修饰符：public static（这个并不是固定搭配，public表示该成员变量或方法是公开的，可以被任何其他类访问，static表示成员变量或方法是静态的）</span><br><span class="line">返回值类型：</span><br><span class="line">	该方法返回的结果的数据类型，无返回值为 void</span><br><span class="line">	比如：return 1 -&gt; int</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">可以分为四种方法：</span><br><span class="line">	无参无返回值方法</span><br><span class="line">	有参无返回值方法</span><br><span class="line">	无参有返回值方法</span><br><span class="line">	有参有返回值方法</span><br></pre></td></tr></table></figure>



<h3 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">无参无返回值方法</span><br><span class="line"></span><br><span class="line">	public static void 方法名()&#123;</span><br><span class="line">		方法体</span><br><span class="line">	&#125;</span><br><span class="line">	void 方法表示无返回值，写了void就不要写（return 结果）了，只写return是没问题的；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">有参无返回值方法</span><br><span class="line"></span><br><span class="line">	public static void 方法名(数据类型 变量名)&#123;</span><br><span class="line">		方法体</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">无参有返回值方法</span><br><span class="line"></span><br><span class="line">	public static 返回值类型 方法名()&#123;</span><br><span class="line">		方法体</span><br><span class="line">		return 返回值</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">有参有返回值方法</span><br><span class="line"></span><br><span class="line">	public static 返回值类型 方法名(参数)&#123;</span><br><span class="line">		方法体</span><br><span class="line">		return 返回值</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">形式参数（形参）：在定义方法的时候形式上定义的参数，此时参数还没有值</span><br><span class="line">实际参数（实参）：在调用方法的时候给形参赋予的具体的值</span><br></pre></td></tr></table></figure>



<h4 id="三层架构思想"><a href="#三层架构思想" class="headerlink" title="三层架构思想"></a>三层架构思想</h4><p><img src="/../%E5%9B%BE%E7%89%87/image-20240603195815403.png" alt="image-20240603195815403"></p>
<h4 id="数组作为参数"><a href="#数组作为参数" class="headerlink" title="数组作为参数"></a>数组作为参数</h4><p>传递到方法中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定义的int[]，就传int[]，就接收int[]</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240603202706652.png" alt="image-20240603202706652"></p>
<p>数据本身是引用数据类型，引用数据类型传入的是地址值</p>
<p>返回值也是数组时，返回值也是地址值</p>
<h4 id="重载方法"><a href="#重载方法" class="headerlink" title="重载方法"></a>重载方法</h4><p>如果，我写一个加法的方法，但是会有不同的需要，比如两个数相加，三个数相加，四个数相加，这个时候再去找哪些定义的那些方法会很麻烦，我们可以通过方法的重载，来达到节省方法名的目的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如：我写一个方法名称是sum，传递两个参数，再写一个方法名称仍然是sum，传递三个参数，以此类推，当我向调用时。只需要传入不同的参数个数，就可以找到相应的方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方法名相同，参数列表不同的方法——重载方法</span><br></pre></td></tr></table></figure>





<p>重载方法主要通过参数的不同来区分，什么叫做参数列表不同</p>
<ul>
<li>参数个数不同</li>
<li>参数类型不同</li>
<li>参数类型顺序不同</li>
</ul>
<p>只要是参数列表不同的，都可以重载，可以共存</p>
<p>判断不可以重载的与什么无关</p>
<ul>
<li>与参数名无关</li>
<li>与返回值无关</li>
</ul>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、面向过程：自己的事情自己干，代表语言C语言</span><br><span class="line"></span><br><span class="line">2、面向对象：自己的事情要别人帮忙干，代表Java</span><br><span class="line">	很多功能都是被封装好的，我们只需要拿过来直接使用即可，简化了编写过程，减少代码量</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">之前使用的获取键盘录入和随机数字就是面向对象的一种体现</span><br><span class="line">这里回忆一下当时的使用方法，可以看到这里是引入，然后赋值，然后创建对象</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjjws.a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetNumGame</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">Random</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sum.nextInt(<span class="number">1</span>,<span class="number">101</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;请输入数字：&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">                <span class="keyword">if</span> (number == num) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;次，恭喜猜对了，答案为&quot;</span>+num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (number &gt; num)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;次，数字偏大了&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;次，数字偏小了&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请输入正确的数字&quot;</span>);</span><br><span class="line">                input.next();</span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240603221549141.png" alt="image-20240603221549141"></p>
<p>通过图片可以发现，这里没有static，只要是定义的时候没有static的，调用时都需要new，如果调用时带static，就不需要new，直接类目即可</p>
<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类class</span><br><span class="line">	测试类：带main方法，主要是运行代码的</span><br><span class="line">	实体类：是一类事务的抽象表示形式</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">组成部分：</span><br><span class="line">	1、属性（成员变量）（全局变量）</span><br><span class="line">		a.定义位置：类中方法外</span><br><span class="line">		b.作用范围：当前类</span><br><span class="line">		c.定义格式：数据类型 变量名</span><br><span class="line">		d.有默认值</span><br><span class="line">	2、行为（成员方法）</span><br><span class="line">		只需要将static干掉，就是成员方法</span><br></pre></td></tr></table></figure>



<p>对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">概述：一类事物的具体体现</span><br><span class="line">使用：</span><br><span class="line">	1、导包（如果在同一个包下，不需要导包。</span><br><span class="line">		特殊包：使用java.long下的，不需要导包）</span><br><span class="line">	2、创建对象</span><br><span class="line">		用哪个类的成员，就new哪个对象</span><br><span class="line">		类名 对象名 = new 类名（）</span><br><span class="line">	3、调用成员</span><br><span class="line">		想要使用哪个类中的成员，就用哪个类的对象.成员</span><br></pre></td></tr></table></figure>





<h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">正常的对象：</span><br><span class="line">	int i = 10</span><br><span class="line">	Random p = new Random()</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">所谓的匿名对象：其实就是没有等号左边的部分，只有等号右边的部分（对象）</span><br><span class="line">使用：</span><br><span class="line">	new 成员()</span><br><span class="line">	</span><br><span class="line">注意，如果只是调用一下方法，可以直接匿名调用，但是如果有赋值操作的话，不能使用这个操作</span><br></pre></td></tr></table></figure>



<h4 id="一个对象调用时的内存图"><a href="#一个对象调用时的内存图" class="headerlink" title="一个对象调用时的内存图"></a>一个对象调用时的内存图</h4><p><img src="/../%E5%9B%BE%E7%89%87/image-20240603225038086.png" alt="image-20240603225038086"></p>
<p>new一下就会在堆中开辟，新的地址，互不干涉</p>
<h4 id="全局变量（成员变量）和局部变量的区别"><a href="#全局变量（成员变量）和局部变量的区别" class="headerlink" title="全局变量（成员变量）和局部变量的区别"></a>全局变量（成员变量）和局部变量的区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1、定义位置不同</span><br><span class="line">2、初始化值不同</span><br><span class="line">	成员变量有默认值可以不初始化直接使用</span><br><span class="line">	局部变量没有默认值，必须赋值后使用</span><br><span class="line">	</span><br><span class="line">3、作用范围不同</span><br><span class="line"></span><br><span class="line">一二三都很熟悉了，懒得说，还有四五两个事</span><br><span class="line"></span><br><span class="line">4、内存位置不同</span><br><span class="line">	成员变量：在堆中，跟着对象走</span><br><span class="line">	局部变量：在栈中，跟着方法走</span><br><span class="line">	</span><br><span class="line">5、生命周期不同</span><br><span class="line">	成员变量：随着对象的创建而产生，随着对象的消失而消失</span><br><span class="line">	局部变量：随着方法的调用而产生，随着方法的调用完毕而消失</span><br></pre></td></tr></table></figure>





<h3 id="封装思想"><a href="#封装思想" class="headerlink" title="封装思想"></a>封装思想</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">面向对象的三大特征：封装 继承 多态</span><br></pre></td></tr></table></figure>





<h4 id="private隐藏"><a href="#private隐藏" class="headerlink" title="private隐藏"></a>private隐藏</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1、问题：</span><br><span class="line">	定义的成员变量，可以拿来随意赋值，哪怕赋值不合理，解决方法呢：</span><br><span class="line">		将属性封装起来（隐藏细节）</span><br><span class="line">		</span><br><span class="line">	关键字：private（私有化的） -&gt; 被private修饰的成员只能在本类中使用，在别的类用不了</span><br><span class="line">	</span><br><span class="line">	注意：将代码放到一个方法中，也是封装的体现</span><br><span class="line">	一个成员被private修饰也是封装的体现，只不过private最具代表性</span><br><span class="line">	</span><br><span class="line">	private的使用：</span><br><span class="line">		修饰成员变量：private 数据类型 变量名</span><br><span class="line">		修饰方法：将public改为private，其他的都一样</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">	这个时候属性被私有化了，外界调用不了，那么此时属性就不能直接赋值取值了，所以需要提供公共的接口</span><br><span class="line">	</span><br><span class="line">	get/set方法</span><br><span class="line">	</span><br><span class="line">	set方法：为属性赋值</span><br><span class="line">	get方法：获取属性值</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjjws.method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pervate</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String Name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String xingMing)</span>&#123;</span><br><span class="line">        Name = xingMing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Setage</span><span class="params">(<span class="type">int</span> nianling)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nianling &lt; <span class="number">0</span> || nianling &gt; <span class="number">150</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;错误年龄&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            age = nianling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>小结：</p>
<p>  用private将属性封装起来，外界不能直接调用，保护了属性</p>
<p>  对外提供set\get方法，通过公共接口间接使用隐藏起来的属性</p>
<h4 id="this的使用"><a href="#this的使用" class="headerlink" title="this的使用"></a>this的使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果成员变量和局部变量重名时，遵循就近原则，先找局部变量</span><br><span class="line">this概述：代表的是当前变量</span><br><span class="line">	this可以区分重名的成员变量和局部变量</span><br><span class="line">	this点出来的是成员变量</span><br><span class="line">	</span><br><span class="line">this代表的是哪个对象呢？</span><br><span class="line">	哪个对象调用的this所在的方法，this就代表哪个对象，如下图，如果想要调用到成员变量，需要在选中的name前加一个this，这里的this代表的是Person对象，因为是在Person对象中调用的，所以指向person中的name</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240604222613517.png" alt="image-20240604222613517"></p>
<p>如果在person内打印this，这个时候打印出来的地址值是和person这个对象打印出来的地址值是一样的</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">之前使用的new 类名()</span><br><span class="line">这种形式就是一种构造方法，这个类名就是一种方法，记作类名只是为了好记</span><br><span class="line"></span><br><span class="line">概述：</span><br><span class="line">	方法名和类名一致并且能初始化对象的方法</span><br><span class="line">	</span><br><span class="line">分类：</span><br><span class="line">	无参构造：没有参数</span><br><span class="line">	有参构造：有参数，参数是为指定的属性赋值</span><br><span class="line">	满参构造：给所有属性赋值</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">特点：</span><br><span class="line">	方法名和类名一致</span><br><span class="line">	没有返回值，连void都没有</span><br></pre></td></tr></table></figure>



<h5 id="无参构造"><a href="#无参构造" class="headerlink" title="无参构造"></a>无参构造</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	public 类名()&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">作用：</span><br><span class="line">	new对象使用</span><br><span class="line">	</span><br><span class="line">特点：</span><br><span class="line">	每个类中默认有一个无参构造，不写也有，jvm会自动提供</span><br><span class="line">	</span><br><span class="line">使用：</span><br><span class="line">	之前使用的new 对象就是在调用构造方法</span><br></pre></td></tr></table></figure>



<h5 id="有参构造"><a href="#有参构造" class="headerlink" title="有参构造"></a>有参构造</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	public 类名(参数)&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">作用：</span><br><span class="line">	new对象</span><br><span class="line">	为属性赋值</span><br><span class="line">	</span><br><span class="line">注意：</span><br><span class="line">	jvm不会自动提供有参构造，只能自己写出来，但是如果写上有参构造，那么jvm将不会提供无参构造，所有建议写有参构造的时候把无参构造一起写进去</span><br></pre></td></tr></table></figure>





<h5 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h5><p>JavaBean是Java语言编写类的一种标准规范，符合 <code>JavaBean</code> 的类，要求：</p>
<ul>
<li>类必须是具体的（非抽象abstract  和公共的  public  class 类名）</li>
<li>并且具有无参数的构造方法，有参构造</li>
<li>成员变量私有化，并提供用来操作成员变量的 set 和 get 方法</li>
</ul>
<p>开发的时候需要分包分层：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">com.…….controller -&gt; 专门放和页面打交道的类（表现层）</span><br><span class="line">com.…….service -&gt; 专门放业务处理的类（业务层）</span><br><span class="line">com.…….dao -&gt; 专门放和数据库打交道的类（持久层）</span><br><span class="line">com.…….pojo -&gt; 专门放JavaBean类</span><br><span class="line">com.…….utils -&gt; 专门放工具类</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">快捷键：</span><br><span class="line">	快速生成标准JavaBean：Alt+insert</span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、将来的JavaBean都是和数据库的表相关联的</span><br><span class="line">	类名 -&gt; 表名</span><br><span class="line">	属性名 -&gt; 列名</span><br><span class="line">	对象 -&gt; 表中每行数据</span><br><span class="line">	属性值 -&gt; 表中单元格的数据</span><br></pre></td></tr></table></figure>



<p>这样的一个JavaBean类</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240605153546987.png" alt="image-20240605153546987"></p>
<p>在其他页面为其添加数据，可以直接调用有参构造</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user user1 = new user(1,&quot;tom&quot;,&quot;111&quot;);</span><br><span class="line">user user1 = new user(2,&quot;joker&quot;,&quot;admin&quot;);</span><br></pre></td></tr></table></figure>



<p>JavaBean添加业务过程</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240605154558597.png" alt="image-20240605154558597"></p>
<p>查询业务过程</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240605164045536.png" alt="image-20240605164045536"></p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static是一个静态关键字</span><br><span class="line">使用：</span><br><span class="line">	a.修饰一个成员变量</span><br><span class="line">	static 数据类型 变量名</span><br><span class="line">	</span><br><span class="line">	b.修饰一个方法</span><br><span class="line">	修饰符 static 返回值类型 方法名(形参)&#123;</span><br><span class="line">		方法体</span><br><span class="line">		return 结果</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">调用静态成员：</span><br><span class="line">	类名直接调用，不需要new对象</span><br><span class="line">	</span><br><span class="line">静态成员特点：</span><br><span class="line">	a.静态成员属于类成员，不属于对象成员（非静态的成员属于对象成员）</span><br><span class="line">	b.静态成员会随着类的加载而加载</span><br><span class="line">	c.静态成员优先于非静态成员存在于内存中</span><br><span class="line">	d.凡是根据静态成员所在的类创建出来的对象，都可以共享这个静态成员</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240605170403893.png" alt="image-20240605170403893"></p>
<p>静态成员在内存中的说明</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240605170719595.png" alt="image-20240605170719595"></p>
<h5 id="static修饰成员的访问特点"><a href="#static修饰成员的访问特点" class="headerlink" title="static修饰成员的访问特点"></a>static修饰成员的访问特点</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">注意一下静态成员的特点，思考一下</span><br><span class="line">1、在静态方法中能直接访问非静态成员吗？ F</span><br><span class="line">	想要调用的时候使用new对象调用</span><br><span class="line"></span><br><span class="line">2、在非静态方法中能直接访问静态成员吗？ Y</span><br><span class="line"></span><br><span class="line">3、在静态方法中能直接访问静态成员吗？ Y</span><br><span class="line">	同类：</span><br><span class="line">		直接调用</span><br><span class="line">		类名调用（new对象调用）</span><br><span class="line">	不同类：</span><br><span class="line">		类名调用</span><br><span class="line"></span><br><span class="line">4、在非静态方法中能直接访问非静态成员吗？ Y</span><br><span class="line">	同类：</span><br><span class="line">		直接调用</span><br><span class="line">		类名调用</span><br><span class="line">	不同类：</span><br><span class="line">		类名调用</span><br></pre></td></tr></table></figure>



<p>思考一</p>
<p>显然易见静态成员先加载，是不能直接调用的，但是可以另辟蹊径，这是访问自己的非静态，访问别人的非静态流程相同都是new对象</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240605171901185.png" alt="image-20240605171901185"></p>
<p>思考二</p>
<p>显然可以，后来者调用前者没啥毛病，直接调，如果是掉别人的静态方法，直接点出来，不用new对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">总结：</span><br><span class="line">	不管在不在同一个类当中，非静态成员都可以new对象调用</span><br><span class="line">	不管在不在同一个类当中，静态成员都可以类名调用</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">注意，不要将所有的成员都定义为静态成员</span><br><span class="line">	因为静态成员会随着类的加载而加载，如果将所有的成员都变为静态的，那么类一加载，所有的静态成员都会进入内存，占用大量空间</span><br><span class="line">	</span><br><span class="line">	一般情况下，我们在抽取工具类的时候可以将工具类中的所有成员定义为静态的</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">那么什么时候定义工具类？</span><br><span class="line">	比如在写代码的时候，发现很多功能反复使用，那么就可以把这个功能定义</span><br></pre></td></tr></table></figure>



<p>构建工具类时注意</p>
<p>构造方法使用private修饰，工具类中的成员都是静态的，静态成员都是类名调用，不需要new对象，所以工具类的构造方法都是用private修饰</p>
<p>如果构造方法被private修饰，那么在别的类中，就不能利用构造方法new对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjjws.stati;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ArrayUtils</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max &lt;= arr[i]) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="定义可变参数"><a href="#定义可变参数" class="headerlink" title="定义可变参数"></a>定义可变参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">方法参数配置，只明确了参数的类型，但是不明确参数个数，此时就可以定义可变参数</span><br><span class="line"></span><br><span class="line">定义格式：</span><br><span class="line">	数据类型...变量名</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">参数位置不能写多个可变参数，可变参数和其他参数一起使用时，可变参数要放在最后</span><br><span class="line">可变参数的本质是一个数组</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240605175519804.png" alt="image-20240605175519804"></p>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">概述：</span><br><span class="line">	方法内部自己调用自己；</span><br><span class="line">	</span><br><span class="line">分类：</span><br><span class="line">	直接递归：</span><br><span class="line">		public static void method()&#123;</span><br><span class="line">			method</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	间接递归：</span><br><span class="line">		A调B，B调C，C调A</span><br><span class="line">		</span><br><span class="line">注意：</span><br><span class="line">	递归必须要有出口，否则会出现“栈内存溢出”</span><br><span class="line">	就算有出口，也不要调用次数太多，使用return结束方法。</span><br></pre></td></tr></table></figure>





<h4 id="数组翻转"><a href="#数组翻转" class="headerlink" title="数组翻转"></a>数组翻转</h4><p>Java中并没有数组翻转的封装方法，需要自己敲一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	int[] arr = &#123;1,2,3,4,5,6,7&#125;</span><br><span class="line">	for (int min = 0, max = arr.length-1; min&lt;max; min++ ; max--)&#123;</span><br><span class="line">		int temp = arr[min];</span><br><span class="line">		arr[min] = arr[max];</span><br><span class="line">		arr[max] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 左手导右手</span><br></pre></td></tr></table></figure>



<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="&#x3D;&#x3D;冒泡排序&#x3D;&#x3D;"></a>&#x3D;&#x3D;冒泡排序&#x3D;&#x3D;</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">一种按照从小到大，或者从大到小的方法</span><br><span class="line"></span><br><span class="line">	for(int j = 1; j &lt; arr.length; j++)&#123;</span><br><span class="line">		for(int i = 0; i &lt; arr.length-j; i++)&#123;</span><br><span class="line">			if(arr[i]&gt;arr[i+1])&#123;</span><br><span class="line">				int temp = arr[i];</span><br><span class="line">				arr[i] = arr[i+1];</span><br><span class="line">				arr[i+1] = arr[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">前提：数组中的数据必须是有序的</span><br><span class="line">查询思想：</span><br><span class="line">	老式查询：遍历数组，一个个比较 -&gt; 查询效率比较慢</span><br><span class="line">	二分查找：每次找中间索引对应的元素进行比较查询（每一次查询少一半数据）</span><br></pre></td></tr></table></figure>

<p>二分顾名思义，再加上数组中的数据是有序的，所以就很好理解</p>
<p>找中间索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int min = 0;</span><br><span class="line">int max = arr.length-1;</span><br><span class="line">int mid = (min + max)/2;</span><br><span class="line"></span><br><span class="line">// 因为这个中间索引是需要不断变化的，留个容器</span><br><span class="line"></span><br><span class="line">第一次二分没找到后，再找中间索引</span><br><span class="line"></span><br><span class="line">min = mid + 1;    或者     max = mid - 1;</span><br><span class="line">mid = (min + max)/2;</span><br></pre></td></tr></table></figure>



<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binary</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> data)</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr.length-<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(min&lt;=max)&#123;</span><br><span class="line">		mid = (min+max)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (data&gt;arr[mid])&#123;</span><br><span class="line">			min = mid + <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(data&lt;arr[mid])&#123;</span><br><span class="line">			max = mid - <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写一个封装方法，person，随便封装一个姓名年龄就行</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	创建int、double、String等数组的时候对需要</span></span><br><span class="line"><span class="comment">	int[] 变量名 = new int[x]</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	以此类推，我想定义一个对象数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	person[] arr = <span class="keyword">new</span> <span class="title class_">person</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建对象</span></span><br><span class="line">	<span class="type">person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">	<span class="type">person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">18</span>);</span><br><span class="line">	<span class="type">person</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保存到数组中</span></span><br><span class="line">	arr[<span class="number">0</span>] = p1;</span><br><span class="line">	arr[<span class="number">1</span>] = p2;</span><br><span class="line">	arr[<span class="number">2</span>] = p3;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240605212357849.png" alt="image-20240605212357849"></p>
<h4 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h4><h5 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h5><p>方法进栈是有一个压栈动作的，越早进入的在栈底，方法运行完毕，会进行一个弹栈动作</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240605213400036.png" alt="image-20240605213400036"></p>
<p>看一下上面的代码，基本数据类型当作实参传递时，只会传递值，不会传递变量本身，method方法执行完毕后，再输出a和b的值，还是main方法中的a和b的值，并没有什么变化</p>
<h5 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引用数据类型作为方法传递是会被影响的，因为传参传的是数组的地址值，是整个数组的内存空间，并不是基本数据类型的那种值，因此，传递引用数据类型，在方法内改变数据，到main方法中，数组也会改变，因为两个方法操作的是同一个数组</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240605214015132.png" alt="image-20240605214015132"></p>
<h5 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h5><p>命令行参数是给main方法中的args传参</p>
<p>第一种方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用原始的命令行</span><br><span class="line">javac 文件名.java</span><br><span class="line">Java 文件名 hello world</span><br><span class="line"></span><br><span class="line">// 通过这样的方式就给main传了两个参数，一个是hello，另一个是world</span><br></pre></td></tr></table></figure>



<p>IDEA中也可以手动配置参数</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240605214750649.png" alt="image-20240605214750649"></p>
<h4 id="debug调试"><a href="#debug调试" class="headerlink" title="debug调试"></a>debug调试</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">能清楚的看到每个变量在代码执行过程中的变化，便于寻找错误</span><br><span class="line">使用：</span><br><span class="line">	点击出现断点</span><br></pre></td></tr></table></figure>





<h2 id="Java下"><a href="#Java下" class="headerlink" title="Java下"></a>Java下</h2><p>内容还是面向对象里的继承的内容</p>
<h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">定义了多个类，发现这些类有很多重复性代码，我们就定义了一个父类，将相同的代码抽取出来放到父类中，其他的类直接继承这个父类，就可以直接使用父类的内容了</span><br><span class="line"></span><br><span class="line">如何继承：</span><br><span class="line">	子类 extends 父类</span><br><span class="line">	</span><br><span class="line">注意：</span><br><span class="line">	子类可以继承父类中私有和非私有成员，但是不能使用父类中私有成员</span><br><span class="line">	构造方法不能继承</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">继承不要从是否“拥有”方面来学习，要从是否能“使用方面来学习”</span><br></pre></td></tr></table></figure>





<h4 id="继承的使用"><a href="#继承的使用" class="headerlink" title="继承的使用"></a>继承的使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">定义一个父类，写入重复使用的代码</span><br><span class="line">定义一个子类 -&gt; 继承</span><br><span class="line">	子类 extends 父类</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240606173648473.png" alt="image-20240606173648473"></p>
<h4 id="继承中成员访问特点"><a href="#继承中成员访问特点" class="headerlink" title="继承中成员访问特点"></a>继承中成员访问特点</h4><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建父类对象，可以使用父类的数据。但是不能使用子类的数据</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">	看等号左边是谁，先调用谁中的成员，子类没有，找父类</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240606204111385.png" alt="image-20240606204111385"></p>
<p>父类对象不能调用子类对象的数据，子类可以继承调用父类非私有的数据，如果有重名的数据，子类先拿到自己的数据，如果自己没有才拿到父类的数据</p>
<p>这个思想在多态内也适用</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240606211249275.png" alt="image-20240606211249275"></p>
<p>这个时候拿父对象来new一个子，很迷的操作，我也不清楚，但是，从打印可以看到，打印了10000，是父类型里面的num，可以总结，先拿的数据是等号左边的相同类型</p>
<h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><p>以上是对成员变量的操作，下面是成员方法，方法与其相反，看new后面的是谁，就先调用谁的方法</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240606212442130.png" alt="image-20240606212442130"></p>
<h4 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">概述：子类中有一个和父类方法名以及参数列表相同的方法</span><br><span class="line">前提：继承</span><br><span class="line">访问：看new的是谁，先调用谁中的，如果new的是子类，调用子类重写的方法，子类没有，找父类</span><br><span class="line">检测是否有重写方法：在该方法上写</span><br><span class="line">	@Override</span><br><span class="line">	如果不报错说明是一个重写方法</span><br><span class="line">	</span><br><span class="line">使用场景：</span><br><span class="line">	功能升级改造，子类需要对父类已经实现好的功能进行重新改造</span><br></pre></td></tr></table></figure>



<p>之前举例子访问成员方法时就涉及方法的重写</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240606215302104.png" alt="image-20240606215302104"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">注意事项：</span><br><span class="line">	子类重写父类方法后，权限必须要保证大于等于父类权限</span><br><span class="line">	权限修饰符： public -&gt; protected -&gt; 默认(default) -&gt; private</span><br><span class="line">	</span><br><span class="line">	重写方法：方法名和参数列表要一样</span><br><span class="line">	私有方法不能被重写，构造方法不能被重写，静态方法static不能被重写</span><br></pre></td></tr></table></figure>

<p>不写修饰符就是default，但是也不能写public权限最大</p>
<h4 id="super和this"><a href="#super和this" class="headerlink" title="super和this"></a>super和this</h4><p>new子类时，会首先默认执行一个父类无参构造</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240607145638128.png" alt="image-20240607145638128"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原因：</span><br><span class="line">	每个构造方法的第一行，都默认有一个super()，不写jvm自动提供</span><br><span class="line">	super()代表的是父类的无参构造</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">super()的具体使用</span><br><span class="line">	概述：代表的是父类引用</span><br><span class="line">	</span><br><span class="line">	作用：可以调用父类中的成员</span><br><span class="line">	</span><br><span class="line">	使用：既然是调用父类的东西，肯定就是在子类中调用了</span><br><span class="line">		1、调用父类构造方法</span><br><span class="line">			super() -&gt; 调用无参构造</span><br><span class="line">			super(实参) -&gt; 调用有参构造</span><br><span class="line">			</span><br><span class="line">		2、调用父类成员变量</span><br><span class="line">			super.成员变量名</span><br><span class="line">			</span><br><span class="line">		3、调用父类成员方法</span><br><span class="line">			super.成员方法名</span><br></pre></td></tr></table></figure>

<p>感觉super和this类似，this指向当前对象，super指向继承的父对象</p>
<p>this的具体使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">this：代表的是当前对象</span><br><span class="line">作用：</span><br><span class="line">	区分重名的成员变量和局部变量</span><br><span class="line">	调用当前对象中的成员</span><br><span class="line">使用：</span><br><span class="line">	调用当前对象的构造：在构造中写</span><br><span class="line">	this()</span><br><span class="line">	this(实参)</span><br><span class="line">	</span><br><span class="line">	调用当前对象的成员变量：</span><br><span class="line">		this.成员变量名</span><br><span class="line">		</span><br><span class="line">	调用当前对象的成员方法</span><br><span class="line">		this.成员方法名</span><br></pre></td></tr></table></figure>



<p>super和this都是写在第一行的，因此两者&#x3D;&#x3D;不能同时出现&#x3D;&#x3D;</p>
<h4 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">继承只支持单继承，不能多继承（就是一个子类不能有多个父类）</span><br><span class="line">	public class A extends B&#123;&#125;</span><br><span class="line">	</span><br><span class="line">但是可以多层继承</span><br><span class="line">	public class B extends C&#123;&#125;</span><br><span class="line">	</span><br><span class="line">一个父类可以有多个子类</span><br><span class="line"></span><br><span class="line">构造方法不能继承，也不能重写</span><br><span class="line">私有方法可以继承，但是不能被重写</span><br><span class="line">静态方法可以继承，但是不能重写</span><br></pre></td></tr></table></figure>





<p>之前说私有属性，可以继承但是不能直接使用，那么应该如何使用呢？</p>
<p>成员变量：</p>
<p>利用父对象的get&#x2F;set方法</p>
<p>利用构造方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在子类中定义构造方法：</span><br><span class="line">	public zi(name,age)&#123;</span><br><span class="line">		super(name,age)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>这个super相当于调用了父对象的构造方法，原理就是子类的有参构造层层调用</p>
<h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>将共有的方法抽取出来，形成父类，但是抽取出来的这个方法方法体没法确定，此时该方法不用写方法体了，没有方法体的方法，可以定义成抽象方法</p>
<p>1、抽象类怎么来的？抽取共性方法，放到父类中，发现方法没办法确定具体实现，因为每个子类对此方法的实现不一样，此时方法体无法确定，就可以定位成抽象方法</p>
<p>&#x3D;&#x3D;抽象方法所在的类必须是抽象类&#x3D;&#x3D;</p>
<p>继承到子类后再重写抽象方法</p>
<p>2、关键字：&#x3D;&#x3D;abstract&#x3D;&#x3D;</p>
<p>3、定义抽象方法</p>
<p>​	修饰符 abstract 返回值类型 方法名(参数);</p>
<p>4、抽象类：</p>
<p>​	public abstract class 类名{}</p>
<p>5、注意：</p>
<p>​	抽象方法所在的类一定是抽象类</p>
<p>​	抽象类中不一定非得有抽象方法</p>
<p>​	子类继承抽象父类时，需要重写父类中所有的抽象方法，不然编译报错</p>
<p>​	抽象类不能new对象，只能通过new子类对象去调用重写的方法</p>
<p>6、可以将抽象类看成是一类事物的标准，要求只要是属于这一个类的，都必须要拥有抽象类中的方法，必须要实现</p>
<h5 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、抽象类不能直接new对象，只能创建非抽象子类的对象</span><br><span class="line">2、抽象类中不一定非得有抽象方法，但是有抽象方法一定是抽象类</span><br><span class="line">3、抽象类的子类必须重写父类中的所有抽象方法，除非子类也是抽象类</span><br><span class="line">4、抽象类中可以有成员变量，构造方法，成员方法</span><br><span class="line">5、抽象类中的构造方法不是为了new对象的，是供子类创建对象时，初始化父类属性使用的。使用需要利用super</span><br></pre></td></tr></table></figure>



<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>1、是一个引用数据类型，是一种标准、规则</p>
<p>2、关键字：</p>
<p>​	 a.interface 接口</p>
<p>​		public interface 接口名{}</p>
<p>​	b.implements 实现</p>
<p>​		实现类 implements 接口名{}</p>
<p>3、接口中可以定义的成员：</p>
<p>​	a.jdk7以及之前：</p>
<p>​		抽象方法：public abstract   -&gt;  即使不写public abstract，默认也是抽象方法</p>
<p>​		成员变量：public static final 数据类型名 变量名 &#x3D; 值  -&gt;  即使不写，默认写</p>
<p>​			final是最终的，被final修饰的变量不能二次赋值，所有final修饰的变量也可以看作常量</p>
<p>​	b.jdk8</p>
<p>​		默认方法：public default 返回值类型 方法名(形参){}</p>
<p>​		静态方法：public static 返回值类型 方法名(形参){}</p>
<p>​	c.jdk9开始</p>
<p>​		私有方法：private（用的不多）</p>
<p>接口的使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、定义接口：</span><br><span class="line">	public interface 接口名&#123;&#125;</span><br><span class="line">2、实现：</span><br><span class="line">	public class 实现类类名 implements 接口名&#123;&#125;</span><br><span class="line">3、使用：</span><br><span class="line">	a.实现类实现接口</span><br><span class="line">	b.重写接口中的抽象方法</span><br><span class="line">	c.创建实现类对象（接口不能直接new对象）</span><br><span class="line">	d.调用重写方法</span><br></pre></td></tr></table></figure>



<p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.sjjws.j_interface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">USB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口，重写方法</span></span><br><span class="line"><span class="comment">// 这里按照规范，实现类应该取名为xxImpl</span></span><br><span class="line"><span class="keyword">package</span> com.sjjws.j_interface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Monse</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用接口</span></span><br><span class="line"><span class="keyword">package</span> com.sjjws.j_interface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_">Monse</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Monse</span> <span class="variable">mouses</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Monse</span>();</span><br><span class="line">        mouses.open();</span><br><span class="line">        mouses.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="接口中的成员"><a href="#接口中的成员" class="headerlink" title="接口中的成员"></a>接口中的成员</h3><h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><p>上方的示例代码就是对抽象方法的使用</p>
<h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	public default 返回值类型 方法名(形参)&#123;</span><br><span class="line">		方法体</span><br><span class="line">		return 结果</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">使用：</span><br><span class="line">	a.实现定义类，实现接口</span><br><span class="line">	b.默认方法可以不重写</span><br><span class="line">	c.创建实现类对象，调用默认方法</span><br></pre></td></tr></table></figure>



<p>默认方法直接调用即可，如果默认方法需要重写的话，需要将default去掉，default只能在接口中使用，去除default仍然是重写方法</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240704183926597.png" alt="image-20240704183926597"></p>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	public static 返回值类型 方法名(形参)&#123;</span><br><span class="line">		方法体</span><br><span class="line">		return 结果</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">使用：</span><br><span class="line">	接口名直接调用</span><br></pre></td></tr></table></figure>



<p>直接使用接口名.静态方法调用</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240704184415375.png" alt="image-20240704184415375"></p>
<p>静态方法和默认方法主要是用于临时添加一个小功能使用，因为如果添加为抽象方法，所有与接口有关的类都会报错，需要重写</p>
<h4 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	public static final 数据类型 变量名 = 值</span><br><span class="line"></span><br><span class="line">final是最终的，被final修饰的变量不能二次赋值，所以final修饰的变量也可以看作常量</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">	不写public static final默认也有，调用和静态方法相同直接接口名调用</span><br><span class="line">	注意呢，变量必须要有值，因为是不能二次赋值的</span><br><span class="line">	习惯呢，将final修饰的变量名改为大写</span><br></pre></td></tr></table></figure>



<h3 id="接口的特点"><a href="#接口的特点" class="headerlink" title="接口的特点"></a>接口的特点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、接口可以多继承 -&gt; 一个接口可以继承多个接口</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceA</span> <span class="keyword">extends</span> <span class="title class_">InterfaceB</span>,InterfaceC&#123;&#125;</span><br><span class="line"><span class="number">2</span>、接口可以多实现 -&gt; 一个实现类可以实现一个或者多个接口</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceImpl</span> <span class="keyword">implements</span> <span class="title class_">InterfaceA</span>,InterfaceB&#123;&#125;</span><br><span class="line"><span class="number">3</span>、一个子类可以继承一个父类的同时实现一个或者多个结果</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> exthends Fu <span class="keyword">implements</span> <span class="title class_">InterfaceA</span>,InterfaceB&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、注意</span><br><span class="line">    继承、实现接口，只要是父类中或者接口的抽象方法，子类或者实现类都需要重写</span><br></pre></td></tr></table></figure>

<p>特殊情况：</p>
<p>​	当一个类实现多个接口时，如果接口中的抽象方法重名且变量名相同时，只需要重写一次</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240704211741799.png" alt="image-20240704211741799"></p>
<p>​	当一个类实现多个接口时，如果多个接口中默认方法有重名的，且参数一样的，必须重写一次默认方法</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240704212445576.png" alt="image-20240704212445576"></p>
<h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">相同点：</span><br><span class="line">	a.都位于继承体系的顶端，用于被其他类实现或者继承</span><br><span class="line">	b.都不能new</span><br><span class="line">	c.都包含抽象方法，其子类或者实现类都必须重写这些抽象方法</span><br><span class="line">	</span><br><span class="line">不同点：</span><br><span class="line">	a.抽象类：一般作为父类使用，可以有成员变量，构造，成员方法，抽象方法等</span><br><span class="line">	b.接口：成员单一，一般抽取接口，抽取的都是方法，视为功能的大集合</span><br><span class="line">	c.类不能多继承，但接口可以</span><br></pre></td></tr></table></figure>

<p>接口内一般定义只有抽象方法，偏向于功能的大集合，抽象类内什么都可以有</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>不要从字面意思上来理解多态，要从使用形式上来掌握</p>
<p>要知道多态的好处和前提</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">前提：</span><br><span class="line">	1、必须有子父类继承或者接口实现关系</span><br><span class="line">	2、必须有方法的重写（没有重写，多态没有意义），多态玩的就是重写方法</span><br><span class="line">	3、new对象：父类引用指向子类对象</span><br><span class="line">		之前也这么使用过一次</span><br><span class="line">		Fu fu = new zi() -&gt; 大致理解为大类型接收了应该小类型数据</span><br><span class="line">	注意：</span><br><span class="line">		多态下不能直接调用子类特有功能</span><br></pre></td></tr></table></figure>



<p>回忆一下</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240704214535249.png" alt="image-20240704214535249"></p>
<p>理解一下</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240704215758742.png" alt="image-20240704215758742"></p>
<h3 id="多态下成员访问的特点"><a href="#多态下成员访问的特点" class="headerlink" title="多态下成员访问的特点"></a>多态下成员访问的特点</h3><p>成员访问特点已经回忆完了</p>
<p>成员变量：</p>
<p>&#x3D;&#x3D;看等号左边是谁，先调用谁中的变量&#x3D;&#x3D;</p>
<p>成员方法：</p>
<p>&#x3D;&#x3D;看new的是谁，先带哦有谁中的成员方法&#x3D;&#x3D;</p>
<h3 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">问题：</span><br><span class="line">	如果使用原始方式new对象，既能调用重写的，还能调用继承的，还能调用自己特有的成员，但是多态方式new对象，只能调用重写的，不能直接调用子类特有的成员，那么为什么还要用多态</span><br><span class="line">	</span><br><span class="line">多态和原始方式的优缺点：</span><br><span class="line">	原始方式：</span><br><span class="line">		优点：既能调用重写的，还能调用继承的，还能调用自己特有的成员</span><br><span class="line">		缺点：扩展性差（主要是方法参数传递方面，会加大代码量）</span><br><span class="line">		</span><br><span class="line">	多态形式：</span><br><span class="line">		优点：扩展性强</span><br><span class="line">		缺点：不能直接调用子类特有功能</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240704224134475.png" alt="image-20240704224134475"></p>
<p>说一下我自己的感觉，多态的这个优点适用于同一个给方法很多人都在用，但是只有几个数不一样，是不是感觉很熟悉，微信小程序中的idx，解决大量重复代码的</p>
<p>形参传递父类类型，调用此方法父类类型可以接收任意他的子类对象</p>
<p>传递哪个子类对象，就指向哪个子类对象，就调用哪个子类对象重写的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">zi</span> <span class="variable">zi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">zi</span>()</span><br><span class="line">method(zi)</span><br><span class="line"><span class="comment">//虽然这里没有用到多态传递子类对象，但是！</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(fu fu)</span>&#123;</span><br><span class="line">    <span class="comment">// 子类对象传递到方法内，相当于是写了一个</span></span><br><span class="line">    <span class="comment">// fu fu = new zi();</span></span><br><span class="line">    fu.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="多态中的转型"><a href="#多态中的转型" class="headerlink" title="多态中的转型"></a>多态中的转型</h3><p>哎，就是想用多态调用子类特有方法怎么办？</p>
<h4 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">就好比是：double b = 1;</span><br><span class="line">表现方式：</span><br><span class="line">	父类类型 对象名1 = new 子类对象()</span><br></pre></td></tr></table></figure>



<h4 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">好比是：int i = (int)b  强转</span><br><span class="line">表现方式：</span><br><span class="line">	子类类型 对象名2 = (子类类型)对象名1</span><br></pre></td></tr></table></figure>



<p>想要调用子类特有功能就需要用到向下转型了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">fu</span> <span class="variable">name1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">zi</span>();</span><br><span class="line"><span class="type">zi</span> <span class="variable">name2</span> <span class="operator">=</span> (zi)name1</span><br><span class="line">name2.xxx(特有功能)</span><br></pre></td></tr></table></figure>



<h4 id="向下转型问题"><a href="#向下转型问题" class="headerlink" title="向下转型问题"></a>向下转型问题</h4><p>这个时候呢，由于强转是会出现一些问题的：如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">zii</span> <span class="variable">zii</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">zii</span>();</span><br><span class="line">        method(zii);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(fu fu)</span> &#123;</span><br><span class="line">        fu.eat();</span><br><span class="line"></span><br><span class="line">        <span class="type">zi</span> <span class="variable">zi</span> <span class="operator">=</span> (zi) fu;</span><br><span class="line">        zi.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码运行起来，会出现类型转换异常（ClassCastException）</p>
<p>当调用method时，传递zii对象，然后由fu向上转换成fu类型，但是方法中，将代表zii对象的fu强转成了zi</p>
<p>此时等号左右两边 不一样，所有出现了类型转换异常</p>
<p>解决方法也很简单，在向下转型之前，判断一下类型即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用关键字：instanceof</span><br><span class="line">判断结果为布尔型</span><br><span class="line">使用：</span><br><span class="line">	对象名 instanceof 类型</span><br><span class="line">	判断的是关键字前面的对象是否符合关键字后面的类型</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fu <span class="keyword">instanceof</span> zi)&#123;</span><br><span class="line">    <span class="type">zi</span> <span class="variable">zi</span> <span class="operator">=</span> (zi) fu;</span><br><span class="line">    zi.work();<span class="comment">//特有方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (fu <span class="keyword">instanceof</span> zii)&#123;</span><br><span class="line">    <span class="type">zii</span> <span class="variable">zii</span> <span class="operator">=</span> (zii) fu;</span><br><span class="line">    zii.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><p>Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限</p>
<ul>
<li>public：公共的，最高权限，被public修饰的成员，在哪里都能访问</li>
<li>protected：受保护的</li>
<li>default：默认的 注意 不写权限修饰符就是默认权限，不能直接将default写出来，只有在接口中可以用default</li>
<li>private：私有的，只能在自己的类中直接访问</li>
</ul>
<p>只需要知道一个成员被这四个权限修饰符修饰在四种情况下能不能访问就行了</p>
<table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>default</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>同类</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>同包不同类</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>不同包子父类</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>不同包非子父类</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
</tbody></table>
<p>public具有最大权限，private具有最小权限</p>
<p>如果没有特殊考虑的话</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、属性：用private -&gt; 封装思想</span><br><span class="line">2、成员方法：用public -&gt; 便于调用</span><br><span class="line">3、构造public -&gt; 便于new对象</span><br></pre></td></tr></table></figure>



<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final：最终的</span><br><span class="line">使用：</span><br><span class="line">	修饰一个类</span><br><span class="line">	修饰一个方法</span><br><span class="line">	修饰一个局部变量</span><br><span class="line">	修饰一个成员变量</span><br><span class="line">	修饰一个对象</span><br><span class="line">	</span><br><span class="line">只需要知道被final修饰之后的特点即可</span><br></pre></td></tr></table></figure>



<h4 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	public final class 类名&#123;&#125;</span><br><span class="line">	</span><br><span class="line">特点：</span><br><span class="line">	太监类，不能被继承，没后代</span><br></pre></td></tr></table></figure>



<h4 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	修饰符 final 返回值类型 方法名(形参)&#123;</span><br><span class="line">		方法体</span><br><span class="line">		return 结果</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">特点：</span><br><span class="line">	被final修饰的方法，不能被重写</span><br><span class="line">	</span><br><span class="line">注意：</span><br><span class="line">	final和abstract两个关键字冲突不能同时使用</span><br></pre></td></tr></table></figure>



<h4 id="修饰局部变量"><a href="#修饰局部变量" class="headerlink" title="修饰局部变量"></a>修饰局部变量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	final 数据类型 变量名 = 值</span><br><span class="line">	</span><br><span class="line">特点：</span><br><span class="line">	被final修饰的变量不能二次赋值</span><br><span class="line">	</span><br><span class="line">	final int i = 10;</span><br><span class="line">	&amp;&amp;</span><br><span class="line">	final int j;</span><br><span class="line">	j = 100;</span><br><span class="line">	</span><br><span class="line">	这都属于一次赋值</span><br></pre></td></tr></table></figure>



<h4 id="修饰对象"><a href="#修饰对象" class="headerlink" title="修饰对象"></a>修饰对象</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	final 数据类型 对象名 = new 对象()</span><br><span class="line">	</span><br><span class="line">特点：</span><br><span class="line">	被final修饰的对象，地址值不能改变。但是对象中的属性值可以改变</span><br></pre></td></tr></table></figure>



<p>举个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>)</span><br><span class="line">	System.out.println(p1);</span><br><span class="line">    p1 = <span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">10</span>)</span><br><span class="line">    System.out.println(p1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个时候输出p1的地址值是不同的，因为new了对象，所以说</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> <span class="type">person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>)</span><br><span class="line">	System.out.println(p1);</span><br><span class="line">    p1 = <span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">10</span>)</span><br><span class="line">    System.out.println(p1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个操作是报错的，因为地址值改变了，但是final修饰的对象，是可以使用set/get方法来更改数值的，这种方法并不会更改地址值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> <span class="type">person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>)</span><br><span class="line">	System.out.println(p1);</span><br><span class="line">	p1.setName(<span class="string">&quot;李四&quot;</span>)</span><br><span class="line">    p1.setAge(<span class="number">10</span>)</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 这样的操作是合法的</span></span><br></pre></td></tr></table></figure>



<h4 id="修饰成员变量"><a href="#修饰成员变量" class="headerlink" title="修饰成员变量"></a>修饰成员变量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	final 数据类型 变量名 = 值</span><br><span class="line">	</span><br><span class="line">特点：</span><br><span class="line">	1、需要手动赋值</span><br><span class="line">	2、不能二次赋值</span><br></pre></td></tr></table></figure>



<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><h4 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	&#123;</span><br><span class="line">		代码</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">特点：</span><br><span class="line">	构造代码块优先于无参构造方法执行</span><br><span class="line">	每new一个执行一次</span><br></pre></td></tr></table></figure>



<h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	static&#123;</span><br><span class="line">		代码</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">特点：</span><br><span class="line">	静态代码块优先于构造代码块执行</span><br><span class="line">	只执行一次</span><br></pre></td></tr></table></figure>



<p>静态代码块的使用更加广泛，他常用于需要有限执行，但是只需要执行一次的情况</p>
<p>小小的拓展一下</p>
<p>Java操作数据库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、注册驱动</span><br><span class="line">2、初始化操作数据库的地址</span><br><span class="line">3、初始化数据库用户名</span><br><span class="line">4、初始化数据库密码</span><br></pre></td></tr></table></figure>

<p>这些东西都是需要放到静态代码块内的</p>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">什么时候使用内部类：	</span><br><span class="line">	当一个事物内部，还有一个部分需要完整的结构去描述，而这个内部的完整结构又只为外部事物提供服务，那么整个内部的完成结构最好使用内部类</span><br><span class="line">	</span><br><span class="line">	比如：组织-器官-个体，人体本事具有一定属性，需要去描述，人体内部的一些器官也有一定的特殊属性和行为，这个时候，器官就可以看作人体中的一个内部类</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">在Java中允许定义位于另外一个类内部，前者就称之为内部类，后者称之为外部类</span><br><span class="line">class A&#123;</span><br><span class="line">	class B&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	类A就是类B的外部类</span><br><span class="line">	类B就是类A的内部类</span><br><span class="line">	</span><br><span class="line">分类：</span><br><span class="line">	成员内部类(静态、非静态)</span><br><span class="line">	局部内部类</span><br><span class="line">	匿名内部类(重点)</span><br></pre></td></tr></table></figure>



<h5 id="静态成员内部类"><a href="#静态成员内部类" class="headerlink" title="静态成员内部类"></a>静态成员内部类</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	直接在定义内部类的时候加上static关键字</span><br><span class="line">	public class A&#123;</span><br><span class="line">		static class B&#123;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	注意：</span><br><span class="line">		a.内部类可以定义属性，方法，构造等</span><br><span class="line">		b.静态内部类可以被final或者abstract修饰</span><br><span class="line">		  被final修饰之后，不能被继承</span><br><span class="line">		  被abstract修饰之后，不能new</span><br><span class="line">		c.静态内部类不能调用外部的非静态成员</span><br><span class="line">		d.内部类还可以被四种权限修饰符修饰</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">调用静态内部类成员：</span><br><span class="line">	外部类.内部类 对象名 = new 外部类.内部类()</span><br></pre></td></tr></table></figure>



<h5 id="非静态成员内部类"><a href="#非静态成员内部类" class="headerlink" title="非静态成员内部类"></a>非静态成员内部类</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	public class A&#123;</span><br><span class="line">		class B&#123;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	注意：</span><br><span class="line">		a.内部类可以定义属性，方法，构造等</span><br><span class="line">		b.静态内部类可以被final或者abstract修饰</span><br><span class="line">		  被final修饰之后，不能被继承</span><br><span class="line">		  被abstract修饰之后，不能new</span><br><span class="line">		c.静态内部类不能调用外部的非静态成员</span><br><span class="line">		d.内部类还可以被四种权限修饰符修饰</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">注意点和静态成员内部相同，但是调用方法不同:</span><br><span class="line">	外部类.内部类 对象名 = new 外部类().new 内部类()</span><br></pre></td></tr></table></figure>



<p>有一个问题：</p>
<p>​	外部类的成员变量和内部类的成员变量以及内部类的局部变量重名时，如何区分</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240705211413762.png" alt="image-20240705211413762"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">monse</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">person</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;王五&quot;</span>;</span><br><span class="line">            System.out.println(name); <span class="comment">// 内部类的局部变量</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.name); <span class="comment">// 内部类的成员变量</span></span><br><span class="line">            System.out.println(Test.<span class="built_in">this</span>.name); <span class="comment">// 外部类的成员变量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用this解决</span></span><br></pre></td></tr></table></figure>



<h5 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h5><h6 id="局部内部类基本操作"><a href="#局部内部类基本操作" class="headerlink" title="局部内部类基本操作"></a>局部内部类基本操作</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">可以定义在方法中，代码块中，构造中</span><br><span class="line">局部内部类使用起来很麻烦，演示一下</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">hemp</span>&#123;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;你好&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">hemp</span>().jump</span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部内部类在外面是没办法new的，也就意味着外界无法调用，因此在定义的时候，需要new好局部变量类的方法，很麻烦不建议使用</span></span><br></pre></td></tr></table></figure>



<h6 id="局部内部类实际操作"><a href="#局部内部类实际操作" class="headerlink" title="局部内部类实际操作"></a>局部内部类实际操作</h6><p>补充一下不同类作为方法参数和返回值的情况</p>
<p>接口类型作为方法参数传递和返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">接口不能直接<span class="keyword">new</span>对象，在多态部分提到过，接口作为方法参数传递时，传递的是他的实现类</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">monse</span> <span class="variable">monse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">monse</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 传递实现类</span></span><br><span class="line">        method(monse);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 接收实现类</span></span><br><span class="line">        <span class="type">USB</span> <span class="variable">usb</span> <span class="operator">=</span> method01();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	接口作为方法参数，传递实参时，传递的是实现类对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(USB usb)</span>&#123;</span><br><span class="line">        <span class="comment">// 这里接口作为方法参数，但是传进来的monse是USB的实现类，在这里进行了向上转化</span></span><br><span class="line">        <span class="comment">// USB usb = new monse();</span></span><br><span class="line">        usb.open()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> USB <span class="title function_">method01</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">mouse</span>();</span><br><span class="line">        <span class="comment">// 接口作为返回值类型时，实际返回的也是实现类对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<blockquote>
<p>接口作为方法参数，传递实参时，传递的是实现类对象</p>
<p>接口作为返回值类型时，实际返回的也是实现类对象</p>
</blockquote>
<hr>
<p>抽象类作为方法参数和返回值</p>
<blockquote>
<p>抽象类作为方法参数传递时，传递的是其子类对象</p>
<p>抽象类作为方法返回值类型返回，实际返回的是其子类对象</p>
</blockquote>
<hr>
<p>普通类作为方法参数和返回值</p>
<blockquote>
<p>普通类作为方法参数和返回值时，传递的是对象</p>
</blockquote>
<p>局部内部类实际操作</p>
<p>拿接口示范一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用多态接收实现类</span></span><br><span class="line">		<span class="type">USB</span> <span class="variable">usb</span> <span class="operator">=</span> method();</span><br><span class="line">		usb.open();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> USB <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 局部内部类，这个类定义为USB的实现类</span></span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">Monse</span> <span class="keyword">implements</span> <span class="title class_">USB</span> &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;鼠标打开&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 同时将new好的实现类对象返回出去</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Monse</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h5><blockquote>
<p>所谓的匿名内部类，可以理解为没有显示声明出类名的内部类</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">要想实现接口，或者抽象类的方法需要以下步骤</span><br><span class="line">	1、创建实现类，实现接口</span><br><span class="line">	2、重写方法</span><br><span class="line">	3、创建实现类对象</span><br><span class="line">	4、调用方法</span><br><span class="line">	</span><br><span class="line">如果呢，只想使用一次接口中的方法，那么麻烦大可不必，可以四合一</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">	new 接口/抽象类()&#123;</span><br><span class="line">		重写方法</span><br><span class="line">	&#125;.重写的方法();</span><br><span class="line">	</span><br><span class="line">	--------or-------</span><br><span class="line">	</span><br><span class="line">	类名 对象名 = new 接口/抽象类() &#123;</span><br><span class="line">		重写方法</span><br><span class="line">	&#125;</span><br><span class="line">	对象名.重写的方法();</span><br><span class="line">	</span><br><span class="line">	// 注意这里是对象名而不是类名，如果定义了类名就是实现类，不是匿名内部类了，感觉类似于python中的一行函数</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240708154426053.png" alt="image-20240708154426053"></p>
<blockquote>
<p>匿名内部类在代码编译时会生成class文件的</p>
<p>简单调用一次接口中的方法时，就可以使用匿名内部类</p>
<p>将一种格式代表实现类对象或者子类对象来看待</p>
</blockquote>
<h6 id="匿名内部类的复杂使用"><a href="#匿名内部类的复杂使用" class="headerlink" title="匿名内部类的复杂使用"></a>匿名内部类的复杂使用</h6><p><img src="/../%E5%9B%BE%E7%89%87/image-20240708155932065.png" alt="image-20240708155932065"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TEST01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">USB</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(USB usb)</span>&#123;</span><br><span class="line">        usb.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>同样的返回值也可以这样操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TEST01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">USB</span> <span class="variable">usb</span> <span class="operator">=</span> method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> USB <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">USB</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><img src="/../%E5%9B%BE%E7%89%87/image-20240708162747315.png" alt="image-20240708162747315"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> calss test &#123;</span><br><span class="line">	pubilc <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// 错误error，内存栈溢出</span></span><br><span class="line">        <span class="comment">// StackOverflowError</span></span><br><span class="line">		method();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 运行时期异常</span></span><br><span class="line">        <span class="comment">// ArrayIndexOutOfBoundsException</span></span><br><span class="line">        <span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        System.out.println(arr1[<span class="number">4</span>]);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 编译时期异常</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	下面就是一个编译时期异常，下面的parse方法会标红，但这个并不是代码写错了</span></span><br><span class="line"><span class="comment">        	这里标红是因为代码底层抛的一个编译时期异常</span></span><br><span class="line"><span class="comment">        	一旦触发了这个异常，jvm就会将异常信息打印到控制台上</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> <span class="string">&quot;2000-10-10 10:10:10&quot;</span>;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf.parse(time);</span><br><span class="line">        System.out.printlin(date);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">		method();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="创建异常对象（了解）"><a href="#创建异常对象（了解）" class="headerlink" title="创建异常对象（了解）"></a>创建异常对象（了解）</h4><blockquote>
<p>创建异常对象，只是为了后面学习如何处理异常，其他的暂时没有啥意义</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关键字：throw</span><br><span class="line">格式：</span><br><span class="line">	throw new 异常</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a.txt&quot;</span>;</span><br><span class="line">        method(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!s.endsWith(<span class="string">&quot;.txt&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">// s.endsWith的作用是检验字符串的结尾是否为.txt</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="comment">// 调用Java中写好的异常方法，制造一个异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240708212431809.png" alt="image-20240708212431809"></p>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h5 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">格式： 在方法参数和方法体之间写</span><br><span class="line">	throws 异常</span><br><span class="line">	</span><br><span class="line">	public static void 方法名(方法参数)throws 异常&#123;</span><br><span class="line">		方法体</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">作用方面比较鸡肋，是将异常信息向上抛，而jvm处理异常的逻辑也是往上抛，如果没人处理，最后再由jvm来打印异常信息，终止程序</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上抛多个异常：<br>throws 异常1,异常2</p>
<p>如果多个异常之间有子父类关系，可以直接throws父类异常</p>
<p>也可以擒贼擒王，直接throws Exception</p>
</blockquote>
<p>层层上抛，没啥意思</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240708213430874.png" alt="image-20240708213430874"></p>
<h5 id="try……catch"><a href="#try……catch" class="headerlink" title="try……catch"></a>try……catch</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	try &#123;</span><br><span class="line">		可能出现异常的代码</span><br><span class="line">	&#125;catch(异常 对象名)&#123;</span><br><span class="line">		处理异常的代码 -&gt; 正常开发是将异常信息保存到日志文件中</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a.txtl&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将详细的异常信息打印到控制台</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(String s)</span><span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!s.endsWith(<span class="string">&quot;.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// s.endsWith的作用是检验字符串的结尾是否为.txt</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>(<span class="string">&quot;找不到文件&quot;</span>);</span><br><span class="line">            <span class="comment">// 调用Java中写好的异常方法，制造一个异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240708215553755.png" alt="image-20240708215553755"></p>
<h6 id="处理多个异常"><a href="#处理多个异常" class="headerlink" title="处理多个异常"></a>处理多个异常</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	try &#123;</span><br><span class="line">		可能出现异常的代码</span><br><span class="line">	&#125;catch(异常 对象名)&#123;</span><br><span class="line">		处理异常的代码</span><br><span class="line">	&#125;catch(异常 对象名)&#123;</span><br><span class="line">		处理异常的代码</span><br><span class="line">	&#125;catch(异常 对象名)&#123;</span><br><span class="line">		处理异常的代码</span><br><span class="line">	&#125;catch(异常 对象名)&#123;</span><br><span class="line">		处理异常的代码</span><br><span class="line">	&#125;catch(异常 对象名)&#123;</span><br><span class="line">		处理异常的代码</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">和throws一样，如果多个异常之间有子父类关系，可以直接catch父类异常</span><br></pre></td></tr></table></figure>



<h4 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">概述：代表的是不管是否触发异常，都会执行的代码块</span><br><span class="line">	特殊情况：如果之前执行了System.exit(0) -&gt; 终止jvm虚拟机</span><br><span class="line">	</span><br><span class="line">需要搭配try……catch使用</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">	try &#123;</span><br><span class="line">		可能出现异常的代码</span><br><span class="line">	&#125;catch(异常 对象名)&#123;</span><br><span class="line">		需要处理的异常</span><br><span class="line">	&#125;finally&#123;</span><br><span class="line">		必须执行的代码</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>finally里有一个比较细的点，执行顺序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(s.length());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行&quot;</span>);</span><br><span class="line">        <span class="comment">// return 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里控制台会先输出 <code>执行</code> 然后输入返回值2，如果没有只是 <code>return 3</code> 的话会直接截胡，输出 执行 和 3</p>
<h5 id="finally的使用场景"><a href="#finally的使用场景" class="headerlink" title="finally的使用场景"></a>finally的使用场景</h5><blockquote>
<p>1、关闭资源</p>
<p>2、原因，对象如果没有用了，GC(垃圾回收器)回收，用来回收堆内存中的垃圾，释放内存，但是有一些对象GC回收不了，比如：连接对象(Connection)，IO流对象，Socker对象，这些对象GC回收不了，因此需要手动回收关闭。</p>
<p>​	将来不能回收的对象new完之后，后续不管是否操作成功，是否有异常，我们就手动关闭，这个时候就需要将关闭资源的代码放到finally中</p>
</blockquote>
<h4 id="抛异常的注意事项"><a href="#抛异常的注意事项" class="headerlink" title="抛异常的注意事项"></a>抛异常的注意事项</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、如果父类方法抛了异常，那么子类重写后需不要抛</span><br><span class="line">	可抛可不抛</span><br><span class="line">2、如果父类方法中没有抛异常，那么子类重写可不可以抛异常</span><br><span class="line">	不能抛</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240708222135613.png" alt="image-20240708222135613"></p>
<p>try  throws使用时机，三层架构</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240708223319330.png" alt="image-20240708223319330"></p>
<blockquote>
<p>1、编译时期异常必须要处理，不然没法往下写了</p>
<p>2、运行时期异常一般不处理，一旦出现运行时期异常，肯定是代码有问题，try catch没有意义，直接修改代码细节即可</p>
</blockquote>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>自定义异常，首先要有这个异常类</p>
<p>定义异常类时需要继承</p>
<blockquote>
<p>如果继承Exception就是编译时期异常</p>
<p>如果继承RuntimeException就是运行时期异常</p>
</blockquote>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240708224511099.png" alt="image-20240708224511099"></p>
<p>如果要传入异常原因的话，只需要在自定义异常写一个有参构造</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LoginUserException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">	<span class="built_in">super</span>(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="打印错误信息的三个方法"><a href="#打印错误信息的三个方法" class="headerlink" title="打印错误信息的三个方法"></a>打印错误信息的三个方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">都是Throwable类中的方法：</span><br><span class="line">	String toString();  // 输出异常类型和设置的异常信息</span><br><span class="line">	String getMessage();  // 输出设置的异常信息</span><br><span class="line">	void printStackTrace();  // 打印异常信息是最全的：包括异常类型，信息，以及出现的行数等</span><br></pre></td></tr></table></figure>



<img src="../图片/image-20240708225857252.png" alt="image-20240708225857252" style="zoom:50%;" />



<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>继承来继承去，最后继承的都是Object，所有类都会直接或者间接的继承Object，Object类是根类</p>
<p>这里的Object指的是lang包内的Object</p>
<p>ctrl+n 搜索</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240709134231364.png" alt="image-20240709134231364"></p>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p><img src="/../%E5%9B%BE%E7%89%87/image-20240709134348318.png" alt="image-20240709134348318"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">toString方法并不复杂</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">    <span class="comment">// 这句代码也很好理解，返回包名 + 类名 + @ + 地址值的十六进制</span></span><br><span class="line">    <span class="comment">// hashCode()是获取地址值的十进制，也是Obkect内的一个方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">    <span class="number">1</span>、如果没有重写Object中的toStrig方法，直接输出对象名会默认输出Objict中的toString方法，直接输出地址值</span><br><span class="line">    <span class="number">2</span>、如果重写了object中的toString，再输出地址值，重写没意义，所以重写完tostring之后，应该返回对象的内容</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240709135331805.png" alt="image-20240709135331805"></p>
<p>之前在学生管理系统的编写上，就使用过重写toString，toString也可以通过 ait+insert 快捷键快速生成</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240709135918444.png" alt="image-20240709135918444"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找一个写好的toString方法</span></span><br><span class="line">	ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">	list.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">	list.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">	System.out.println(list); <span class="comment">// -&gt; [张三、李四、王五]</span></span><br><span class="line">    System.out.println(list.toString()); <span class="comment">// -&gt; [张三、李四、王五]</span></span><br></pre></td></tr></table></figure>

<p>这个是写好的toString()重写</p>
<h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><p><img src="/../%E5%9B%BE%E7%89%87/image-20240709140358236.png" alt="image-20240709140358236"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">作用：</span><br><span class="line">    比较两个地址值是否相等</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240709150804921.png" alt="image-20240709150804921"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这里有两种方法</span><br><span class="line">第一个是直接p1==p2</span><br><span class="line"></span><br><span class="line">第二种是 p1.equals(p2);</span><br><span class="line">将p2作为方法参数传入equals方法，然后this和obj比较，由于是p1调用的equals，所以this是指向p1的</span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">==  针对于基本数据类型来说，比较的是值</span><br><span class="line">    对两个基本数据类型使用equals，调用的是重写后的equals，并不是object中的equals</span><br><span class="line">==  针对于引用数据类型来说，比较的是地址值</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240709152216046.png" alt="image-20240709152216046"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240709151841212.png" alt="image-20240709151841212"></p>
<p>如果没有重写object中的equals方法，那么就会调用object中的equals方法，如果重写了就调用重写后的equals方法</p>
<p>自己重写一个equals</p>
<p>考虑三个因素，空、自身、目的（比较内部信息）</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240709161141298.png" alt="image-20240709161141298"></p>
<p>这样比较好看，也可以直接根据引导生成重写后的equals，意思和上方代码是一样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成的equals	</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">object</span> <span class="variable">object</span> <span class="operator">=</span> (object) o;</span><br><span class="line">        <span class="keyword">return</span> age == object.age &amp;&amp; Objects.equals(name, object.name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>小结：</p>
<p>​	1、如果直接输出对象名，不想输出地址值，重写toString方法</p>
<p>​	2、如果想要比较两个对象的内容，就重写运行equals方法</p>
<p>​	3、输出对象名找toString，比较对象找equals</p>
<p>​	4、ait+insert 快捷键重写方法</p>
</blockquote>
<h4 id="clone方法-克隆"><a href="#clone方法-克隆" class="headerlink" title="clone方法(克隆)"></a>clone方法(克隆)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">作用：</span><br><span class="line">	复制一个属性值一样的新对象</span><br><span class="line">	</span><br><span class="line">使用：</span><br><span class="line">	需要被克隆的对象实现Cloneable接口</span><br><span class="line">	重写clone方法</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240709163703601.png" alt="image-20240709163703601"></p>
<p>截图少截了，重写clone之前，需要实现Cloneable接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class object implements Cloneable</span><br></pre></td></tr></table></figure>



<h3 id="经典接口"><a href="#经典接口" class="headerlink" title="经典接口"></a>经典接口</h3><h4 id="java-lang-Comparable"><a href="#java-lang-Comparable" class="headerlink" title="java.lang.Comparable"></a>java.lang.Comparable</h4><blockquote>
<p>基本数据类型（除布尔类型外）需要比较大小的话，直接使用比较运算符即可，但是引用数据类型是不能直接使用比较运算符来比较大小的。那么如何解决这个问题？</p>
</blockquote>
<p>java给所有引用数据类型的大小比较，指定了一个标准接口，就是java.lang.Comparable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object obj)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要使得我们某个类的对象可以比较大小，怎么做？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一： 哪个类的对象要比较大小，哪个类就实现Comparable接口，并重写方法</span><br><span class="line">	方法体就是你要如何比较当前对象和指定的另一个对象的大小</span><br><span class="line">	</span><br><span class="line">第二： 对象比较大小时，通过对象调用compareto方法，根据方法的返回值决定谁打谁小。</span><br><span class="line">	this对象（调用compareTo）减 指定对象（传入compareTo()的参数对象）大于0，返回正整数</span><br><span class="line">	this对象（调用compareTo）减 指定对象（传入compareTo()的参数对象）小于0，返回负整数</span><br><span class="line">	this对象（调用compareTo）减 指定对象（传入compareTo()的参数对象）等于0，返回零</span><br></pre></td></tr></table></figure>



<p>代码实例：</p>
<p>代码排序还是依靠冒泡排序，只是使用compareTo()方法进行比较的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjjws.a_comparable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        student[] students = <span class="keyword">new</span> <span class="title class_">student</span>[<span class="number">3</span>];</span><br><span class="line">        students[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">100</span>);</span><br><span class="line">        students[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">student</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">60</span>);</span><br><span class="line">        students[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">student</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;students.length-<span class="number">1</span> ; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;students.length-<span class="number">1</span>-j ; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (students[i].compareTo(students[i+<span class="number">1</span>])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="type">student</span> <span class="variable">temp</span> <span class="operator">=</span> students[i];</span><br><span class="line">                    students[i] = students[i+<span class="number">1</span>];</span><br><span class="line">                    students[i+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;students.length ; i++) &#123;</span><br><span class="line">            System.out.println(students[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	student&#123;name=&#x27;李四&#x27;, score=60&#125;</span></span><br><span class="line"><span class="comment">	student&#123;name=&#x27;王五&#x27;, score=80&#125;</span></span><br><span class="line"><span class="comment">	student&#123;name=&#x27;张三&#x27;, score=100&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p>实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjjws.a_comparable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, score=&quot;</span> + score +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">student</span><span class="params">(String name,<span class="type">int</span> score )</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    	<span class="type">student</span> <span class="variable">s1</span> <span class="operator">=</span> (student) o;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getScore() - o.getScore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="java-util-Comparator"><a href="#java-util-Comparator" class="headerlink" title="java.util.Comparator"></a>java.util.Comparator</h4><blockquote>
<p>思考：</p>
<p>​	1、如果一个类，没有实现Comparable接口，而这个类又不方便修改（例如：一些第三方的类，你只有.class文件，没有源文件）</p>
<p>​	2、如果一个类，实现了Comparable接口，也指定了两个对象比较大小的规则，但是此时此刻我不想按照它预定义的方法比较大小，但是我又不能随意修改，因为会影响其他地方的使用，怎么办？</p>
</blockquote>
<p>这个时候就需要用到Comparator接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1,Object o2)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们想要比较某个类的两个对象的大小，怎么做呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一步： 编写一个类，我们称之为比较器类型，实现java.util.Comparator接口，并重写方法</span><br><span class="line">	方法体就是你要如何指定的两个对象的大小</span><br><span class="line">	</span><br><span class="line">第二步：比较大小时，通过比较器类型的对象调用compare()方法，将要比较大小的两个对象作为compare方法的实参传入，根据方法的返回值决定谁大谁小。</span><br><span class="line">	o1对象减o2大于0返回正整数</span><br><span class="line">	o1对象减o2小于0返回负整数</span><br><span class="line">	o1对象减o2等于0返回零</span><br></pre></td></tr></table></figure>



<p>实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">student01</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">student01</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, score=&quot;</span> + score +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">student01</span><span class="params">(String name, <span class="type">int</span> score )</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="type">student01</span> <span class="variable">s1</span> <span class="operator">=</span> (student01) o1;</span><br><span class="line">        <span class="type">student01</span> <span class="variable">s2</span> <span class="operator">=</span> (student01) o2;</span><br><span class="line">        <span class="keyword">return</span> s1.getScore()-s2.getScore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        student01[] students = <span class="keyword">new</span> <span class="title class_">student01</span>[<span class="number">3</span>];</span><br><span class="line">        students[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">student01</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">100</span>);</span><br><span class="line">        students[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">student01</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">60</span>);</span><br><span class="line">        students[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">student01</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">student01</span> <span class="variable">student01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">student01</span>();</span><br><span class="line">        <span class="comment">// 注意这里新new了一个对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;students.length-<span class="number">1</span> ; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;students.length-<span class="number">1</span>-j ; i++) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 这里是用新new的对象来.compare的</span></span><br><span class="line">                <span class="keyword">if</span> (student01.compare(students[i],students[i+<span class="number">1</span>])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="type">student01</span> <span class="variable">temp</span> <span class="operator">=</span> students[i];</span><br><span class="line">                    students[i] = students[i+<span class="number">1</span>];</span><br><span class="line">                    students[i+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;students.length ; i++) &#123;</span><br><span class="line">            System.out.println(students[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="API部分"><a href="#API部分" class="headerlink" title="API部分"></a>API部分</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="了解string"><a href="#了解string" class="headerlink" title="了解string"></a>了解string</h4><p>string是lang包下的类，lang包下的类在使用的时候，不需要导包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String类代表字符串</span><br><span class="line">特点：</span><br><span class="line">	1、Java程序中的所有字符串面值（如&quot;abc&quot;）都作为此类的实例（对象）实现</span><br><span class="line">	   凡是带双引号的，都是String的对象</span><br><span class="line">	   String s = &quot;abc&quot;</span><br><span class="line">	   &quot;abc&quot;就是对象；String就是对象的数据类型；s就是对象名</span><br><span class="line">	2、字符串是常量，它们的值在创建后不能更改</span><br><span class="line">	   String s = &quot;hello&quot;;</span><br><span class="line">	   s += &quot;world&quot;;</span><br><span class="line">	   </span><br><span class="line">	   这种操作虽然存在，但底层的逻辑是产生一个新的对象的，它的地址值改变了，并不是修改了s，字符串是常量，在底层代码内是使用final修饰的</span><br><span class="line">	</span><br><span class="line">	3、String对象是不可变的，所以可以共享</span><br><span class="line">	   String s1 = &quot;abc&quot;;</span><br><span class="line">	   String s2 = &quot;abc&quot;;</span><br><span class="line">	   System.out.println(s1==s2)</span><br><span class="line">	   S1和s2的地址值是一样的，返回结果为true</span><br><span class="line">	   </span><br></pre></td></tr></table></figure>



<p>共享：指向的堆内存空间相同</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240709202601853.png" alt="image-20240709202601853"></p>
<blockquote>
<p>想到了一个很有意思的事情</p>
<p>学习equals是曾经比较过两个字符串，返回是false，如下图</p>
<p>解释一下：</p>
<p>​	常量池：</p>
<p>​		首先要引入常量池这个概念，当使用自负床字面量创建字符串时 如： String s1 &#x3D; “abc”; Java会在常量池内查找是否已经存在相同内容的字符串。如果存在，则直接返回该字符串的引用；如果不存在，则在常量池中创建一个新的字符串并返回其引用。这个机制也很好理解，减少内存栈资源占用。</p>
<p>​	new关键字：</p>
<p>​		当使用new关键字创建字符串时，Java会在堆内存中创建一个新的字符串对象，即使字符串常量池中已经存在相同内容的字符串</p>
<p>​	然后就很好理解了，s1和s2的地址值是相同的，但是s2,s3,s4的地址值各不相同</p>
</blockquote>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240709202954094.png" alt="image-20240709202954094"></p>
<p>值得注意的是，new的对象的内容是abc在常量池中的地址值，如果abc没有在常量池内，那么new的话会先在常量池中创建一个abc，然后将常量池中的abc的地址值给到 new 出的对象</p>
<h4 id="String的实现原理"><a href="#String的实现原理" class="headerlink" title="String的实现原理"></a>String的实现原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、jdk8的时候：String底层是一个被final修饰的char数组 -&gt; private final char[] value;</span><br><span class="line"></span><br><span class="line">2、jdk9开始到以后：底层是一个被final修饰的byte数组 -&gt; private final byte[] value;</span><br><span class="line"></span><br><span class="line">jdk8 - jdk9 版本更新出现了拉姆达表达式（函数式编程思想），因此有了很大变动，所有有些脚本、软件会要求Java的jdk8环境，其他的版本更新主要是优化内存</span><br><span class="line"></span><br><span class="line">一个char类型数据占两个字节，一个byte类型数据占一个字节，节省了内存空间</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串定义完之后，数组就创建好了，被final一修饰，数组的地址值就固定死了</span><br></pre></td></tr></table></figure>



<h4 id="String的创建"><a href="#String的创建" class="headerlink" title="String的创建"></a>String的创建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、String() -&gt; 利用String的无参构造创建String对象</span><br><span class="line"><span class="number">2</span>、String(String original) -&gt; 根据字符串创建String对象</span><br><span class="line"><span class="number">3</span>、String(<span class="type">char</span>[] value) -&gt; 根据<span class="type">char</span>数组创建String对象</span><br><span class="line"><span class="number">4</span>、String(<span class="type">byte</span>[] bytes) -&gt; 通过使用平台的默认字符集解码指定的 <span class="type">byte</span> 数组，构造一个新的 String</span><br><span class="line">    </span><br><span class="line">简化形式：</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>



<p>演示一下：注意char数组不能用双引号</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240709210419074.png" alt="image-20240709210419074"></p>
<blockquote>
<p>再说一下byte数组的事</p>
<p>-&gt; 通过平台的默认字符集解码指定的 byte 数组，构造一个新的 String</p>
<p>​	平台：操作系统</p>
<p>​	操作系统默认字符集：GBK</p>
<p>​	GBK这个东西前面说过</p>
<p>​		GBK：一个中文占2个字节</p>
<p>​		UTF-8：一个中文占3个字节</p>
</blockquote>
<p>中文在编码集中一般为负数，但是使用byte的时候注意，要在编码表中可以找到，否则就是乱码</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240709211240996.png" alt="image-20240709211240996"></p>
<blockquote>
<p>这里的“你”字是由三个字节的，原因是代码是在idea中写的，idea启动的时候，会自动加一个启动参数，此启动参数为UTF-8 -Dfile,encoding&#x3D;UTF-8</p>
</blockquote>
<p>以上是比较常用的几种构造，现在看几个不常用的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、String(<span class="type">char</span>[] value, <span class="type">int</span> offset, <span class="type">int</span> count) -&gt; 将<span class="type">char</span>数组的一部分转化成String对象</span><br><span class="line">    value:要转String的<span class="type">char</span>数组</span><br><span class="line">    offset:从数组的哪个索引开始转</span><br><span class="line">    count:转多少个</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、String(<span class="type">byte</span>[] bytes, <span class="type">int</span> offset, <span class="type">int</span> length) -&gt; 将<span class="type">byte</span>数组的一部分转成String对象</span><br><span class="line">    bytes:要转String的<span class="type">byte</span>数组</span><br><span class="line">    offset:从数组的哪个索引开始转</span><br><span class="line">    length:转多少个</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">问题：</span><br><span class="line">	String s = new String(&quot;abc&quot;); 共有几个对象</span><br><span class="line">		两个 new 和 &quot;abc&quot;</span><br><span class="line">		</span><br><span class="line">	String s = new String(&quot;abc&quot;); 共创建了几个对象	</span><br><span class="line">		一个或者两个</span><br><span class="line">		要看 &quot;abc&quot; 有没有提前创建，如果之前没有就会创建两个，先创建常量池中的 abc 再创建 new 对象，因为new对象的是abc在常量池中的地址值</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240709213155605.png" alt="image-20240709213155605"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;world&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">   System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">   System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">   System.out.println(s3 == s6);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>以上代码的输出结果分别为 true false false</p>
<p>为了能够可视化的看到区别呢，倒置了一个小时的反编译，解决了一个小问题 jd-gui 无法打开class文件时，将文件打成压缩包再放到jd-gui中，但是编译出来的情况和网课不一样</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240709230959676.png" alt="image-20240709230959676"></p>
<p>抛开上面不看了，这是XJad编译出来的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240709231620186.png" alt="image-20240709231620186"></p>
<p>从反编译结果可以看出s3和s4是等价的，但是s5、s6是new了新的对象的，因此地址值不同</p>
<blockquote>
<p>总结一下这个问题：</p>
<p>​	1、字符串拼接，如果等号右边是字符串字面值拼接，不会产生新的对象</p>
<p>​	2、字符串拼接，如果等号右边有变量参数拼接，会产生新字符串对象</p>
</blockquote>
<h4 id="String常用方法"><a href="#String常用方法" class="headerlink" title="String常用方法"></a>String常用方法</h4><h5 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">boolean equals(String s) -&gt; 比较字符串内容</span><br><span class="line">boolean equalsIgnoreCase(String s) -&gt; 比较字符串内容，忽略大小写（可用于图片验证码）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">equals方法还是一样</span><br><span class="line">s1.equals(s2)</span><br><span class="line">s1.equalsIgnoreCase(s2)</span><br></pre></td></tr></table></figure>



<p>Java中也有比较两个对象的方法</p>
<blockquote>
<p>工具类：Objects（注意是Objects不是根类Object）</p>
<p>方法：equals，这个是重写的equals方法，但是是传的两个对象，而且有防空指针的效果</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static boolean equals(Object a, Object b) &#123;</span><br><span class="line">	return (a == b) || (a != null &amp;&amp; a.equals(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="获取功能"><a href="#获取功能" class="headerlink" title="获取功能"></a>获取功能</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、获取字符串长度</span><br><span class="line">	int length();</span><br><span class="line">2、字符串拼接，返回新字符串</span><br><span class="line">	String concat(String s);</span><br><span class="line">3、根据索引获取对应字符</span><br><span class="line">	char charAt(int index);</span><br><span class="line">4、获取指定字符在大字符串中第一次出现的索引位置</span><br><span class="line">	int indexOf(String s);</span><br><span class="line">5、截取字符串，从指定索引开始截取到最后，返回新字符串</span><br><span class="line">	String subString(int beginIndex);</span><br><span class="line">6、截取字符串，从beginIndex开始到endIndex结束（含头不含尾），返回新字符串</span><br><span class="line">	String subString(int beginIndex, int endIndex);</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240710222320914.png" alt="image-20240710222320914"></p>
<p>这个时候就可以遍历一下字符串了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;asdfghjkl&quot;;</span><br><span class="line">for (int i = 0; i &lt; s.length()-1; i++) &#123;</span><br><span class="line">	System.out.println(s.charAt(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="转换功能"><a href="#转换功能" class="headerlink" title="转换功能"></a>转换功能</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、char[] toCharArray() -&gt; 将字符串转为char数组</span><br><span class="line">2、byte[] getBytes() -&gt; 将字符串转成byte数组</span><br><span class="line">3、String replace(CharSequence c1, CharSequence c2) -&gt; 替换字符</span><br><span class="line">4、byte[] getBytes(String charsetName) -&gt; 按照指定的编码将字符串转成byte数组</span><br></pre></td></tr></table></figure>





<p><img src="/../%E5%9B%BE%E7%89%87/image-20240710223709233.png" alt="image-20240710223709233"></p>
<blockquote>
<p>CharSequence是String类的接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">实例代码：</span><br><span class="line">	        <span class="comment">// 转换</span></span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//1、char[] toCharArray() -&gt; 将字符串转为char数组</span></span><br><span class="line">        <span class="type">char</span>[] chars = s1.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            System.out.print(chars[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、byte[] getBytes() -&gt; 将字符串转成byte数组</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="type">byte</span>[] bytes = s1.getBytes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">            System.out.print(bytes[i]+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、String replace(CharSequence c1, CharSequence c2) -&gt; 替换字符</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.replace(<span class="string">&quot;asd&quot;</span>,<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">        System.out.println(s1+<span class="string">&quot;||&quot;</span>+s2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、byte[] getBytes(String charsetName) -&gt; 按照指定的编码将字符串转成byte数组</span></span><br><span class="line">        <span class="type">byte</span>[] byteGBK = <span class="string">&quot;你好&quot;</span>.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; byteGBK.length; i++) &#123;</span><br><span class="line">            System.out.print(byteGBK[i]);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240710224422591.png" alt="image-20240710224422591"></p>
<h5 id="分割功能"><a href="#分割功能" class="headerlink" title="分割功能"></a>分割功能</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] split(String regex) -&gt; 按照指定的规则分割字符串</span><br><span class="line"></span><br><span class="line">注意：regex写的是正则表达式 -&gt; .在正则表达式中代表任意字符，如果要以.来切割的话，使用转义符//</span><br></pre></td></tr></table></figure>



<h5 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、boolean contains(String s) -&gt; 判断老字符串内是否包含指定的字符串</span><br><span class="line">2、boolean endsWith(String s) -&gt; 判断老字符串是否以指定的字符串结尾</span><br><span class="line">3、boolean startsWith(String s) -&gt; 判断老字符串是否以指定的字符串开头</span><br><span class="line">4、String toLowerCase() -&gt; 将字母转成小写</span><br><span class="line">5、String toUpperCase() -&gt; 将字母转成大写</span><br><span class="line">6、String trim() -&gt; 去掉字符串两端空格</span><br></pre></td></tr></table></figure>



<h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><blockquote>
<p>概述：一个可变的字符序列，此类提供了一个与StringBuffer兼容的一套API，但是不保证同步(线程不安全，效率高)</p>
<p>作用：主要是字符串拼接</p>
<p>问题：</p>
<p>​	1、String也能做到字符串拼接，直接使用+拼接，那么为什么还要用StringBuilder拼接呢</p>
<p>​	2、原因：</p>
<p>​		String每拼接一次，就会产生新的字符串对象，就会在堆内存中开辟新空间，如果拼接过多，会占用内存，效率降低</p>
<p>​	3、StringBuilder，底层自带一个缓冲区（没有被final修饰的byte数组）拼接字符串之后都会在缓冲区中保存，在拼接过程中，不会随意产生新对象，节省内存</p>
<p>特点：</p>
<p>​	1、底层自带缓冲区，此缓冲区是备用被final修饰的byte数组，默认长度是16</p>
<p>​	2、如果超出了数组长度，数组会自动扩容</p>
<p>​		因为定长，所以创建一个新长度的数组，将老数组的元素复制到新数组中，然后将新数组的地址值重新赋值给老数组</p>
<p>​	3、默认每次扩容老数组的2倍+2</p>
<p>​		如果一次性添加的数据超出了默认的扩容数组长度(2倍+2)。但有例外，比如存了36个字符，超出了第一扩容的34，就按照实际数据个数为准，就是以36扩容</p>
</blockquote>
<h4 id="深入♂了解一下"><a href="#深入♂了解一下" class="headerlink" title="深入♂了解一下"></a>深入♂了解一下</h4><p>看一下StringBuilder的底层代码</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240710231951379.png" alt="image-20240710231951379"></p>
<p>创建出来的缓冲区</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240710232348458.png" alt="image-20240710232348458"></p>
<p>搞点事情，打个断点观察一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sb.append(&quot;1111111111111111111111111111111&quot;);</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240710233101853.png" alt="image-20240710233101853"></p>
<p>判断是否应该扩容</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240710233705340.png" alt="image-20240710233705340"></p>
<p>开始扩容</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240710233953734.png" alt="image-20240710233953734"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240710234511279.png" alt="image-20240710234511279"></p>
<p>返回34之后在copyOf内创建了新的长度为34的数组，赋值，更改地址等一系列操作</p>
<blockquote>
<p>补充：</p>
<p>​	如果len大于34的话，最后的扩容计算会正好等于length，然后返回这个值</p>
<p>​	值得注意的是，StringBuilder扩容时也会创建新的对象，也会占用内存，但是不可否认的是，完成同样的事，StringBuilder所占的内存更少</p>
</blockquote>
<h4 id="StringBuilter的使用"><a href="#StringBuilter的使用" class="headerlink" title="StringBuilter的使用"></a>StringBuilter的使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">构造：</span><br><span class="line">	StringBuilder()</span><br><span class="line">	StringBuilder(String str)</span><br><span class="line">	</span><br><span class="line">	两种构造方法，空参是空的缓冲区，传参是往缓冲区添加</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">常用方法：</span><br><span class="line">	StringBUilder append(任意类型数据) -&gt; 字符串拼接的效果，但是底层逻辑和字符串拼接不一样，返回值是StringBuilder自己</span><br><span class="line">	StringBuilder reverse() -&gt; 字符串翻转，返回的是StringBUilder自己</span><br><span class="line">	String toString() -&gt; 将StringBuilder转换成String。老朋友toString了</span><br><span class="line">		用StringBuilder拼接字符串是为了效率，为了不占内存，那么拼接完成之后处理字符串就需要调用String中的方法，所以需要将StringBuilder转换成String</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> sb.append(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        System.out.println(sb==s1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链式调用</span></span><br><span class="line">        sb.append(<span class="string">&quot;李四&quot;</span>).append(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 翻转</span></span><br><span class="line">        System.out.println(sb+<span class="string">&quot;---||---&quot;</span>+sb.reverse());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换成String</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> sb.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240711001057714.png" alt="image-20240711001057714"></p>
<p>小练习：判断键盘录入的内容是否回文</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 准备StringBuilder和键盘录入</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入要判断的内容：&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 录入字符串，添加到StringBuilder</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">oldster</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        sb.append(oldster);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 翻转比较</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">newS</span> <span class="operator">=</span> sb.reverse().toString();</span><br><span class="line">        <span class="keyword">if</span> (oldster.equals(newS)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;符合回文特征&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不符合回文特征&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<blockquote>
<p>总结一下：</p>
<p>String：拼接字符串效率低，每拼接一次，都会产生一个新的字符串对象，耗费内存资源</p>
<p>StringBuilder和StringBuffer区别：</p>
<p>1、相同点：</p>
<p>​	用法一样、作用一样</p>
<p>2、不同点</p>
<p>​	StringBuilder拼接效率比StringBuffer高，但是线程不安全</p>
<p>​	StringBuffer反之</p>
</blockquote>
<p>拼接效率比较：StringBuilder&gt;StringBuffer&gt;String</p>
<h3 id="数学相关类"><a href="#数学相关类" class="headerlink" title="数学相关类"></a>数学相关类</h3><h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">概述：数学工具类，主要用于数学运算</span><br><span class="line">特点：</span><br><span class="line">	1、构造方法私有，外界不能根据构造方法new对象</span><br><span class="line">	2、方法都是静态</span><br><span class="line">	</span><br><span class="line">使用：</span><br><span class="line">	类名直接调用</span><br></pre></td></tr></table></figure>



<h5 id="Math方法"><a href="#Math方法" class="headerlink" title="Math方法"></a>Math方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static int abs(int a) -&gt; 求参数的绝对值</span><br><span class="line">static double ceil(double a) -&gt; 向上取证</span><br><span class="line">static double floor(double a) -&gt; 向下取证</span><br><span class="line">static long round(double a) -&gt; 四舍五入</span><br><span class="line">static int max(int a, int b) -&gt; 求两个数之间的较大值</span><br><span class="line">static int min(int a, int b) -&gt; 求两个数之间的较小值</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">math</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//static int abs(int a)-&gt;求参数的绝对值</span></span><br><span class="line">        System.out.println(Math.abs(-<span class="number">10</span>));</span><br><span class="line">        <span class="comment">//static double ceil(double a)-&gt;向上取整</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">3.6</span>));</span><br><span class="line">        <span class="comment">// static double floor(double a) -&gt;向下取整</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">3.6</span>));</span><br><span class="line">        <span class="comment">// static long round(double a) -&gt;四舍五入</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">3.6</span>));</span><br><span class="line">        System.out.println(Math.round(-<span class="number">2.8</span>));</span><br><span class="line">        <span class="comment">// static int max(int a，int b) -&gt;求两个数之间的较大值</span></span><br><span class="line">        System.out.println(Math.max(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">        <span class="comment">// static int min(int a，int b) -&gt;求两个数之间的较小值</span></span><br><span class="line">        System.out.println(Math.min(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712140005159.png" alt="image-20240712140005159"></p>
<blockquote>
<p>Math类还包含用于执行基本数学运算的方法，如初等函数、对数、平方根和三角函数</p>
</blockquote>
<h4 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">将来可能操作特别大的数据，大到比long还大，这种数据我们称之为“对象”</span><br><span class="line"></span><br><span class="line">作用：</span><br><span class="line">	处理超大整数</span><br><span class="line">	</span><br><span class="line">构造：</span><br><span class="line">	BigInteger(String val) -&gt; 参数的格式必须是整数</span><br><span class="line">	</span><br><span class="line">方法：</span><br><span class="line">	BigInteger add(BigInteger val) -&gt; 加 返回其值为(this + val)的BigInteger</span><br><span class="line">	BigInteger subtract(BigInteger val) -&gt; 减 返回值为(this - val)的BigInteger</span><br><span class="line">	BigInteger multiply(BigInteger val) -&gt; 乘 返回其值为(this * val)的BigInteger</span><br><span class="line">	BigInteger divide(BigInteger val) -&gt; 除 返回其值为(this / val)的BigInteger</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712141206432.png" alt="image-20240712141206432"></p>
<blockquote>
<p>BigInteger主要是处理大数据，数据大到基本数据类型接受不了，传入字符串的形式，进行运算</p>
<p>int intValue()       将BigInteger转成int</p>
<p>long longValue()     将BigInteger转成long</p>
<p>BigInteger上限：42亿的21亿次方，这个大小的数一般内存遭不住，所以也可以认为BigInteger无上限</p>
</blockquote>
<h4 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">之前说过不能直接用floor或者double，因为会出现精度损失的问题</span><br><span class="line"></span><br><span class="line">这个BigDecimal 主要就是解决floor和double直接做运算时出现的精度损失问题</span><br><span class="line"></span><br><span class="line">构造：</span><br><span class="line">	BigDecimal(String val) -&gt; val必须说数字形式</span><br><span class="line">	// 构造方式有很多种，也可以直接传入double类型，但是结果具有不可预知性，不准确</span><br><span class="line">	// 如果死犟的话，可以使用静态方法 static valueOf(double)</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">常用方法：、</span><br><span class="line">	static BigDecimal valueOf(double) -&gt; 此方法初始化小数时可以传入double类型数据</span><br><span class="line">	BigDecimal add(BigDecimal val) -&gt; 加 返回其值为(this + val)的BigDecimal</span><br><span class="line">	BigDecimal subtract(BigDecimalval) -&gt; 减 返回值为(this - val)的BigDecimal</span><br><span class="line">	BigDecimal multiply(BigDecimal val) -&gt; 乘 返回其值为(this * val)的BigDecimal</span><br><span class="line">	BigDecimal divide(BigDecimal val) -&gt; 除 返回其值为(this / val)的BigDecimal</span><br><span class="line">	// 加减乘除的方法和BigInteger一样的</span><br><span class="line">	// 这个除法如果除不尽是会报一个运算错误的</span><br><span class="line">	</span><br><span class="line">	BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)</span><br><span class="line">		divisor:除数（除号后面的数）</span><br><span class="line">		scale:指定保留几位小数</span><br><span class="line">		roundingMode:取舍方式</span><br><span class="line">			static int ROUND_UP -&gt; 向上加一</span><br><span class="line">			static int ROUND_DOWN -&gt; 直接舍去</span><br><span class="line">			static int ROUND_HALF_UP -&gt; 四舍五入</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712143430357.png" alt="image-20240712143430357"></p>
<blockquote>
<p>double doubleValue()  将BigDecimal转换成doubleValue</p>
</blockquote>
<p>之前的几个取舍方式是过时的，表示已经被新的内容的替代了</p>
<p>文档上加了 <code>@Deprecated</code> 就代表是过时的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712143708424.png" alt="image-20240712143708424"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">新方法：</span><br><span class="line">	BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode)</span><br><span class="line">		divisor:除数（除号后面的数）</span><br><span class="line">		scale:指定保留几位小数</span><br><span class="line">		roundingMode(它的类型改变了):取舍方式 -&gt; RoundingMode是一个枚举，里面的成员可以直接调用</span><br><span class="line">			UP -&gt; 向上加一</span><br><span class="line">			DOWN -&gt; 直接舍去</span><br><span class="line">			HALF_UP -&gt; 四舍五入</span><br></pre></td></tr></table></figure>

<p>这个时候黄线就没了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712144355763.png" alt="image-20240712144355763"></p>
<h3 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h3><h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">表示特定时间，精确到毫秒</span><br><span class="line">常识：</span><br><span class="line">	1、1000毫秒 = 1秒</span><br><span class="line">	2、时间原点1970年1月1日 0时0分0秒(UNIX系统起始时间)，叫做格林威治时间，在0时区上</span><br><span class="line">	3、时区：北京位于东八区，一个时区经度差15度，时间相差一个小时，所以北京时间比时间原点时区时间相差八个小时</span><br><span class="line">	</span><br><span class="line">使用：</span><br><span class="line">	构造方法：</span><br><span class="line">	Date() -&gt; 获取系统时间</span><br><span class="line">	Date(long time) -&gt; 获取指定时间，传递毫秒值 -&gt; 从时间原点开始算</span><br></pre></td></tr></table></figure>



<p>因为东八区，所以时间原点+了八个小时</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712172206591.png" alt="image-20240712172206591"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Date date = new Date();</span><br><span class="line">// 设置时间，从时间原点开始计算</span><br><span class="line">date.setTime(1000L);</span><br><span class="line">// 获取设置的时间，返回毫秒值</span><br><span class="line">System.out.println(date.getTime());</span><br></pre></td></tr></table></figure>



<h4 id="Calendar日历类"><a href="#Calendar日历类" class="headerlink" title="Calendar日历类"></a>Calendar日历类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">概述：日历类，抽象类（abstract）</span><br><span class="line">获取方法：Calendar中的方法</span><br><span class="line">	static Calendar getInstance()</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">time</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">System.out.println(time);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">java.util.GregorianCalendar[time=<span class="number">1720776818898</span>,areFieldsSet=<span class="literal">true</span>,areAllFieldsSet=<span class="literal">true</span>,lenient=<span class="literal">true</span>,zone=sun.util.calendar.ZoneInfo[id=<span class="string">&quot;Asia/Shanghai&quot;</span>,offset=<span class="number">28800000</span>,dstSavings=<span class="number">0</span>,useDaylight=<span class="literal">false</span>,transitions=<span class="number">31</span>,lastRule=<span class="literal">null</span>],firstDayOfWeek=<span class="number">1</span>,minimalDaysInFirstWeek=<span class="number">1</span>,ERA=<span class="number">1</span>,YEAR=<span class="number">2024</span>,MONTH=<span class="number">6</span>,WEEK_OF_YEAR=<span class="number">28</span>,WEEK_OF_MONTH=<span class="number">2</span>,DAY_OF_MONTH=<span class="number">12</span>,DAY_OF_YEAR=<span class="number">194</span>,DAY_OF_WEEK=<span class="number">6</span>,DAY_OF_WEEK_IN_MONTH=<span class="number">2</span>,AM_PM=<span class="number">1</span>,HOUR=<span class="number">5</span>,HOUR_OF_DAY=<span class="number">17</span>,MINUTE=<span class="number">33</span>,SECOND=<span class="number">38</span>,MILLISECOND=<span class="number">898</span>,ZONE_OFFSET=<span class="number">28800000</span>,DST_OFFSET=<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">注意月份：</span><br><span class="line">    国外从<span class="number">0</span>开始，国内从<span class="number">1</span>开始，因此转换的时候月份要+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>java.util.GregorianCalendar[&#x3D;&#x3D;time&#x3D;&#x3D;&#x3D;1720776818898,areFieldsSet&#x3D;true,areAllFieldsSet&#x3D;true,lenient&#x3D;true,zone&#x3D;sun.util.calendar.ZoneInfo[id&#x3D;”Asia&#x2F;Shanghai”,offset&#x3D;28800000,dstSavings&#x3D;0,useDaylight&#x3D;false,transitions&#x3D;31,lastRule&#x3D;null],firstDayOfWeek&#x3D;1,minimalDaysInFirstWeek&#x3D;1,ERA&#x3D;1,&#x3D;&#x3D;YEAR&#x3D;&#x3D;&#x3D;2024,&#x3D;&#x3D;MONTH&#x3D;&#x3D;&#x3D;6,WEEK_OF_YEAR&#x3D;28,WEEK_OF_MONTH&#x3D;2,&#x3D;&#x3D;DAY_OF_MONTH&#x3D;&#x3D;&#x3D;12,DAY_OF_YEAR&#x3D;194,&#x3D;&#x3D;DAY_OF_WEEK&#x3D;&#x3D;&#x3D;6,DAY_OF_WEEK_IN_MONTH&#x3D;2,AM_PM&#x3D;1,&#x3D;&#x3D;HOUR&#x3D;&#x3D;&#x3D;5,&#x3D;&#x3D;HOUR_OF_DAY&#x3D;&#x3D;&#x3D;17,&#x3D;&#x3D;MINUTE&#x3D;&#x3D;&#x3D;33,&#x3D;&#x3D;SECOND&#x3D;&#x3D;&#x3D;38,MILLISECOND&#x3D;898,ZONE_OFFSET&#x3D;28800000,DST_OFFSET&#x3D;0]</p>
<table>
<thead>
<tr>
<th>字段值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR</td>
<td>年</td>
</tr>
<tr>
<td>MONTH</td>
<td>月</td>
</tr>
<tr>
<td>DAY_OF_DAY</td>
<td>日</td>
</tr>
<tr>
<td>HOUR<br/>AM_PM</td>
<td>时（12小时制）</td>
</tr>
<tr>
<td>HOUR_OF_DAY</td>
<td>时（24小时制）</td>
</tr>
<tr>
<td>MINUTE</td>
<td>分</td>
</tr>
<tr>
<td>SECOND</td>
<td>秒</td>
</tr>
<tr>
<td>DAY_OF_WEEK</td>
<td>周中的天（周日为1）</td>
</tr>
</tbody></table>
<p>最前面返回的是实现类的对象，因为不同时区不一样，因此实现类也不一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">常用方法:</span><br><span class="line">	int get(int field) -&gt; 返回给指定日历字段的值</span><br><span class="line">	void set(int field, int value) -&gt; 给定的日历字段设置为指定的值</span><br><span class="line">	void add(int field, int amount) -&gt; 根据日历的规则，为给定的日历字段添加或者减去指定的时间量</span><br><span class="line">	Date getTime() -&gt; 将Calendar转成Date对象</span><br><span class="line">	</span><br><span class="line">field：代表的是日历字段 -&gt; 年、月、日、星期等，都是静态的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">拓展方法：</span><br><span class="line">	void set(int year, int month, int date) -&gt; 直接设置年月日</span><br></pre></td></tr></table></figure>

<blockquote>
<p>比较无聊，也不演示了</p>
</blockquote>
<h4 id="SipleDateFormat日期格式化"><a href="#SipleDateFormat日期格式化" class="headerlink" title="SipleDateFormat日期格式化"></a>SipleDateFormat日期格式化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">概述：格式化日期，让获取到的日期看着舒服</span><br><span class="line">构造：</span><br><span class="line">	SipleDateFormat(String pattern)</span><br><span class="line">	pathhern代表的是我们自己指定的日期格式-字母不能改变，中间的连接符可以改变</span><br><span class="line">	yyyy-MM-dd HH:mm:ss</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>时间字母表示</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>y</td>
<td>年</td>
</tr>
<tr>
<td>M</td>
<td>月</td>
</tr>
<tr>
<td>d</td>
<td>日</td>
</tr>
<tr>
<td>H</td>
<td>时</td>
</tr>
<tr>
<td>m</td>
<td>分</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">两个方法：</span><br><span class="line">	String format(Date date) -&gt; 将Date对象按照指定的格式转成String</span><br><span class="line">	Date parse(String source) -&gt; 将符合日期格式的字符串转化成Date对象</span><br><span class="line">	</span><br><span class="line">	SipleDateFormat sdf = new SipleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">	String time = sdf.format(new Date());</span><br><span class="line">	</span><br><span class="line">	注意：Date parse(String source)这东西有异常是个，编译时期异常，引用时需要处理，如果格式正确返回正确结果，格式错误就飘红</span><br></pre></td></tr></table></figure>



<h4 id="jdk8新日期类"><a href="#jdk8新日期类" class="headerlink" title="jdk8新日期类"></a>jdk8新日期类</h4><h5 id="LocalDate本地日期"><a href="#LocalDate本地日期" class="headerlink" title="LocalDate本地日期"></a>LocalDate本地日期</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">概述：LocalDate是一个不可变的日期时间对象，表示日期，通常被视为年月日</span><br><span class="line">获取：</span><br><span class="line">	static LocalDate now() -&gt; 创建LocalDate对象</span><br><span class="line">	static LocalDate of(int year, int month, int datOfMonth) -&gt; 创建LocalDate对象，设置年月日</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        System.out.println(<span class="string">&quot;localDate = &quot;</span> + localDate);</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> LocalDate.of(<span class="number">2000</span>,<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;localDate1 = &quot;</span> + localDate1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712180450765.png" alt="image-20240712180450765"></p>
<h6 id="LocalDateTime对象"><a href="#LocalDateTime对象" class="headerlink" title="LocalDateTime对象"></a>LocalDateTime对象</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">概述：LocalDateTime是一个不可变的日期时间对象，通常被视为年-月-日-时-分-秒</span><br><span class="line"></span><br><span class="line">获取：</span><br><span class="line">	static LocalDateTime now() -&gt; 创建LocalDateTime对象</span><br><span class="line">	static LocalDateTime of(int year，Month month，int dayofMonth，int hour，int minute，int second) -&gt; 创建Loca1DateTime对象，设置年月日时分秒</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">System.out.println(&quot;localDateTime = &quot; + localDateTime);</span><br><span class="line"></span><br><span class="line">LocalDateTime localDateTime1 = LocalDateTime.of(2000,10,10,10,10,10);</span><br><span class="line">System.out.println(&quot;localDateTime1 = &quot; + localDateTime1);</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712180934217.png" alt="image-20240712180934217"></p>
<blockquote>
<p>还可以往下设置毫秒</p>
</blockquote>
<h6 id="获取对应字段get开头"><a href="#获取对应字段get开头" class="headerlink" title="获取对应字段get开头"></a>获取对应字段get开头</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法：</span><br><span class="line">	int getYear()  -&gt; 获取年份</span><br><span class="line">	int getMonthValue() -&gt; 获取月份</span><br><span class="line">	int getDayOfMonth() -&gt; 获取月中的第几天</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line">localDate.getYear() -&gt; 获取年份</span><br><span class="line">localDate.getMonthValue() -&gt; 获取月份</span><br><span class="line">localDate.getDayOfMonth() -&gt; 获取月中的第几天</span><br></pre></td></tr></table></figure>



<h6 id="设置日期字段with开头"><a href="#设置日期字段with开头" class="headerlink" title="设置日期字段with开头"></a>设置日期字段with开头</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate withYear(int year) -&gt; 设置年份</span><br><span class="line">LocalDate withMonth(int month) -&gt; 设置月份</span><br><span class="line">LocalDate withDayOfMonth(int day) -&gt; 设置月中的第几天（从0开始）</span><br></pre></td></tr></table></figure>

<blockquote>
<p>懒得写了，调用使用对象名.方法</p>
</blockquote>
<h6 id="日期字段偏移"><a href="#日期字段偏移" class="headerlink" title="日期字段偏移"></a>日期字段偏移</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">设置日期字段的偏移量，方法名以plus开头，向后偏移</span><br><span class="line">设置日期字段的偏移量，方法名以minus开头，向前偏移</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712182037010.png" alt="image-20240712182037010"></p>
<blockquote>
<p>这些方法顾名思义吧，都是点出来的</p>
</blockquote>
<h5 id="Period计算日期之间的偏差"><a href="#Period计算日期之间的偏差" class="headerlink" title="Period计算日期之间的偏差"></a>Period计算日期之间的偏差</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">方法：</span><br><span class="line">	static Period between(LocalDate d1,LocalDate d2) -&gt; 计算两个日期的差值</span><br><span class="line">	</span><br><span class="line">	使用Period对象接收这个差值后，使用下面方法获取对应的差值</span><br><span class="line">	</span><br><span class="line">	getYears()</span><br><span class="line">	getMonths()</span><br><span class="line">	getDays()</span><br></pre></td></tr></table></figure>



<h5 id="Duration计算时间之间的偏差"><a href="#Duration计算时间之间的偏差" class="headerlink" title="Duration计算时间之间的偏差"></a>Duration计算时间之间的偏差</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">方法：</span><br><span class="line">	static Duration between(Temporal startInclusive,Temporal endExclusive) -&gt; 精确计算两个日期的差值</span><br><span class="line">	</span><br><span class="line">Temporal:一个接口</span><br><span class="line">	它实现类包含：LocalDate LocalDateTime</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">注意：这两个方法不同点在于参数，Duration需要传递Temporal的实现类对象，注意要传递LocalDateTime，因为Duration计算精确时间偏差，所以需要传递能操作精确时间的LocalDateTime</span><br><span class="line"></span><br><span class="line">利用Duration获取相差的时分秒 -&gt; to开头</span><br><span class="line">	toDays()</span><br><span class="line">	toHours()</span><br><span class="line">	toMinutes()</span><br><span class="line">	toMillis() -&gt; 获取相差毫秒</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结一下两个计算时间差值的类</p>
<p>​	Period就是硬减2024-10-12减2023-9-11获取相差的年月日都是1，很离谱</p>
<p>​	Duration2024-10-12减2023-9-11获取相差的时分秒是根据实际情况来的</p>
</blockquote>
<h5 id="DateTimeFormatter日期格式化类（麻烦、难记、有替代）"><a href="#DateTimeFormatter日期格式化类（麻烦、难记、有替代）" class="headerlink" title="DateTimeFormatter日期格式化类（麻烦、难记、有替代）"></a>DateTimeFormatter日期格式化类（麻烦、难记、有替代）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">获取：</span><br><span class="line">	static DateTimeFormatter ofPattern(String pattern) -&gt; 获取对象，指定格式</span><br><span class="line">	</span><br><span class="line">方法：</span><br><span class="line">	String format(TemporalAccessor temporal) -&gt; 将日期对象按照指定的规则转成String</span><br><span class="line">	TemporalAccessor:接口，子接口包括Temporal</span><br><span class="line">	Temporal的实现类LocalDate LocalDateTime</span><br><span class="line">	</span><br><span class="line">	TemporalAccessor parse(CharSeqence text) -&gt; 将符合规则的字符串转成日期对象</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter dtf =DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">Stringtime =&quot;2000-10-1010:10:10&quot;;</span><br><span class="line">TemporalAccessor temporalAccessor = dtf.parse(time);</span><br><span class="line">System.out.println(temporalAccessor);</span><br><span class="line">LocalDateTime localDateTime=LocalDateTime.from(temporalAccessor);</span><br><span class="line">System.out.println(&quot;localDateTime =&quot;+localDateTime);</span><br></pre></td></tr></table></figure>



<h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><h4 id="System"><a href="#System" class="headerlink" title="System"></a>System</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">概述：系统相关类，是一个工具类</span><br><span class="line">特点：</span><br><span class="line">	1、构造私有化，不能new对象</span><br><span class="line">	2、方法都是静态的，类名直接调用</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>static long currentTimeMillis()</td>
<td>返回以毫秒为单位的当前时间，可以测试效率使用</td>
</tr>
<tr>
<td>static void exit(int status)</td>
<td>终止当前正在运行的Java虚拟机</td>
</tr>
<tr>
<td>static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</td>
<td>数组复制<br/>src:源数组<br/>srcPos:从源数组的哪个索引开始复制<br/>dest:目标数组<br/>destPos:从目标数组哪个索引开始粘贴<br/>length:复制多少个元素</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(System.currentTimeMillis());</span><br><span class="line">// 输出的是当前时间</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712185356217.png" alt="image-20240712185356217"></p>
<p>演示一下</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712190214070.png" alt="image-20240712190214070"></p>
<h4 id="Arrays数组工具类"><a href="#Arrays数组工具类" class="headerlink" title="&#x3D;&#x3D;Arrays数组工具类&#x3D;&#x3D;"></a>&#x3D;&#x3D;Arrays数组工具类&#x3D;&#x3D;</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">概述：数组工具类</span><br><span class="line">特点：</span><br><span class="line">	构造私有</span><br><span class="line">	方法静态（这是工具类的特点）</span><br><span class="line">使用：类名直接调用</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>static String toString(int[] a)</td>
<td>按照格式打印数组元素<br/>[元素1，元素2……]</td>
</tr>
<tr>
<td>static void sort(int[] a)</td>
<td>升序排序（底层原理并不是冒泡排序，效果相同）</td>
</tr>
<tr>
<td>static int binarySearch(int[] a, int key)</td>
<td>二分查找(前提是升序)</td>
</tr>
<tr>
<td>static int[] copyOf(int[] orginal, int newLength)</td>
<td>数组扩容</td>
</tr>
</tbody></table>
<blockquote>
<p>之前使用过的数组操作的方法都有封号好的类之间使用即可</p>
</blockquote>
<p>排序的底层方法和之前手写的toString很相似</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712195049760.png" alt="image-20240712195049760"></p>
<p>数组扩容的底层方法和之前手写也很相似</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712215725839.png" alt="image-20240712215725839"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712220101112.png" alt="image-20240712220101112"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(arr1,<span class="number">3</span>);</span><br><span class="line">        System.out.println(index);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        arr2 = Arrays.copyOf(arr2,<span class="number">10</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr2));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">概述：就是基本类型对应的类(包装类)，我们需要将基本类型转成包装类，从而让基本类型拥有类的特性（基本类型转成包装类之后，就可以使用包装类中的方法操作数据）</span><br><span class="line"></span><br><span class="line">为啥学包装类：</span><br><span class="line">	1、将来有一些特定场景，特定操作，比如调用方法传递包装类</span><br><span class="line">	  比如：ArrayList集合，里面有一个方法add(Integer i)，此时我们不能调用add方法之后直接传递基本类型，因为引用类型不能直接接收基本类型的值，就需要先将基本类型转成包装类，传递到add方法中</span><br><span class="line">	2、将来还可以将包装类转成基本类，因为包装类无法进行运算</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712222402317.png" alt="image-20240712222402317"></p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>Charactor</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<h4 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">概述：int的包装类</span><br><span class="line">构造：	不推荐使用</span><br><span class="line">	Integer(int value)</span><br><span class="line">	Integer(String s) s必须是数字</span><br><span class="line">	</span><br><span class="line">	这样的构造方法是过时了的，输入就飘红了，注意这个构造方法是八个类型都有的，但是有一个特殊</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Boolean bl = new Boolean(s:&quot;true&quot;);</span><br><span class="line">System.out.println(&quot;b1 = &quot; + b1);</span><br><span class="line">Boolean b2 = new Boolean(&quot;false&quot;);</span><br><span class="line">System.out.println(&quot;b2 =&quot;+ b2);</span><br><span class="line">Boolean b3 = new Boolean(&quot;True&quot;);</span><br><span class="line">System.out.println(&quot;b3 = &quot; + b3);</span><br></pre></td></tr></table></figure>

<p>b1、b2可以理解，但是b3这里是有说法的</p>
<p>输出还是 <code>true</code> </p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712223833312.png" alt="image-20240712223833312"></p>
<p>看一下底层</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712224332386.png" alt="image-20240712224332386"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">装箱：</span><br><span class="line">	将基本类型转成对应的包装类</span><br><span class="line"></span><br><span class="line">方法：</span><br><span class="line">	static Integer valueOf(int i)</span><br><span class="line">	static Integer valueOf(String s)</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;i1 = &quot;</span> + i1);</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;i2 = &quot;</span> + i2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">拆箱：将包装类转成基本类型</span><br><span class="line">方法：</span><br><span class="line">	int intValue()</span><br><span class="line">	其他类型的包装类的拆箱方法分别是类型名+Value()</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;i1 = &quot;</span> + i1);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> i1.intValue();</span><br><span class="line">        System.out.println(<span class="string">&quot;(i+10) = &quot;</span> + (i+<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="自动拆箱装箱"><a href="#自动拆箱装箱" class="headerlink" title="自动拆箱装箱"></a>自动拆箱装箱</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">拆箱和装箱多数时候都是自动完成，在idea内可以直接</span><br><span class="line">	Integer i = 10;</span><br><span class="line">	</span><br><span class="line">	这个时候就发生了自动装箱</span><br><span class="line">	</span><br><span class="line">	Integer sum = i+10;</span><br><span class="line">	</span><br><span class="line">	自动拆箱又装箱</span><br></pre></td></tr></table></figure>



<p>反编译可以看到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> Integer.valueOf(i.intValue() + <span class="number">10</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712225700354.png" alt="image-20240712225700354"></p>
<p>拓展一下：</p>
<p>很有意思的事情，同样Integer地址值不一样</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712230119350.png" alt="image-20240712230119350"></p>
<p>看一下Integer中的装箱代码</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712230514533.png" alt="image-20240712230514533"></p>
<p>往上一翻可以发现范围是[-128,127]</p>
<p>数组内是[-128,127]的Integer对象，如果传入的数在这个范围内，就会共享这个Integer对象</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712230801133.png" alt="image-20240712230801133"></p>
<h4 id="基本类型和String类之间的转换"><a href="#基本类型和String类之间的转换" class="headerlink" title="基本类型和String类之间的转换"></a>基本类型和String类之间的转换</h4><h5 id="基本类型转String"><a href="#基本类型转String" class="headerlink" title="基本类型转String"></a>基本类型转String</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方式一：</span><br><span class="line">	+&quot;&quot; 拼接</span><br><span class="line"></span><br><span class="line">方式二：String内的静态方法</span><br><span class="line">	static String valueOf(int i)</span><br></pre></td></tr></table></figure>



<h5 id="String转成基本数据类型"><a href="#String转成基本数据类型" class="headerlink" title="String转成基本数据类型"></a>String转成基本数据类型</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每一个类中都有一个类似的方法： parseXXX</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>位置</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Byte</td>
<td>static byte parseByte(String s)</td>
<td>将String转成byte类型</td>
</tr>
<tr>
<td>Short</td>
<td>static byte parseShort(String s)</td>
<td>将String转成short类型</td>
</tr>
<tr>
<td>Integer</td>
<td>static byte parseInteger(String s)</td>
<td>将String转成int类型</td>
</tr>
<tr>
<td>Long</td>
<td>static byte parseLong(String s)</td>
<td>将String转成long类型</td>
</tr>
<tr>
<td>Float</td>
<td>static byte parseFloat(String s)</td>
<td>将String转成float类型</td>
</tr>
<tr>
<td>Double</td>
<td>static byte parseDouble(String s)</td>
<td>将String转成double类型</td>
</tr>
<tr>
<td>Boolean</td>
<td>static byte parseBoolean(String s)</td>
<td>将String转成boolean类型</td>
</tr>
</tbody></table>
<p>注意没有char类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private staticvoid method02() &#123;</span><br><span class="line">	int number = Integer.parseInt(&quot;1111&quot;);</span><br><span class="line">	System.out.println(number+1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在实际开发过程中如何定义一个标准的javabean</span><br><span class="line">	之前说过一些，还要补充一个：</span><br><span class="line">	定义JavaBean的时候一般会将基本类型的属性定义成包装类</span><br><span class="line">	</span><br><span class="line">其实呢，就是在原有的基础上把基本数据类型改成包装类即可</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">javabeantest</span> &#123;</span><br><span class="line"><span class="comment">//    private int uid;</span></span><br><span class="line">    <span class="keyword">private</span> Integer uid;</span><br><span class="line">    <span class="comment">// 只更改这里即可</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">javabeantest</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">javabeantest</span><span class="params">(Integer uid, String age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.uid = uid;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(String age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getUid</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUid</span><span class="params">(Integer uid)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.uid = uid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>举例：如果uid为Integer型，默认值为null</p>
<p>1、将来JavaBean中的数据都是和数据库表联系起来的，我们可以将JavaBean中的数据添加到表中，如果表中的uid为主键自增，此时添加语句的uid中的数据不用我们单独进行赋值了</p>
<p>​	添加语句的sql语句就可以这样写：</p>
<p>​	insert into user(uid,name,age) value(NULL,”张三”,18)</p>
<p>2、到时候，我们需要将JavaBean中封装的数据获取出来放到sql语句中，如果uid为主键自增，而且JavaBean中的uid为包装类型，默认值为null，这样就不用单独维护uid的值了，也不用先给uid赋值再保存到数据库中了，就可以直接使用默认值，将默认值放到sql语句的uid列中</p>
<p>3、而且将JavaBean中的属性变为包装类，还可以使用包装类中的方法去操作此属性值</p>
</blockquote>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="了解多线程"><a href="#了解多线程" class="headerlink" title="了解多线程"></a>了解多线程</h3><h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">进程：在内存上执行的引用程序</span><br><span class="line">线程：是进程中的最小执行单元</span><br><span class="line">线程作用：负责当前进程中程序的运行，一个进程中至少有一个线程</span><br><span class="line"></span><br><span class="line">在CPU和内存之间为每一个功能开辟对应的通道，方便CPU去内存中提取代码做计算，这个通道称之为“线程”</span><br><span class="line"></span><br><span class="line">简单理解：一个功能就需要一条线程去执行</span><br></pre></td></tr></table></figure>



<blockquote>
<p>1、使用场景：软件耗时操作 -&gt; 拷贝大文件，加载大量资源，聊天软件，后台服务器</p>
<p>一个线程可以干一件事，我们就可以同时做多件事</p>
</blockquote>
<h4 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">并行：在同一时刻，有多个执行在多个CPU上同时执行（就好比是多个人做不同的事）</span><br><span class="line">	比如：多个厨师在炒多个菜</span><br><span class="line">	</span><br><span class="line">并发：在同一时刻，有多个指令在单个CPU上（交替）执行</span><br><span class="line">	比如：一个厨师炒多个菜</span><br><span class="line">	</span><br><span class="line">1、之前CPU是单核，但是在执行多个程序的时候好像是在同时执行，原因是CPU在多个线程之间做高速切换</span><br><span class="line">2、现在的CPU都是多核多线程了，比如2核4线程，那么CPU可以同时执行4个线程，但是如果多了，CPU就开始切换了，所以CPU在执行程序的时候并发和并行都存在</span><br></pre></td></tr></table></figure>



<h4 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">分时调度：指的是让所看的线程轮流获取CPU使用权，并且平均分配每个线程占用CPU的时间片</span><br><span class="line">2.抢占式调度：多个线程轮流抢占CPU使用权，哪个线程先抢到了，哪个线程先执行，一般都是优先级高的先抢到CPU使用权的几率大，Java程序就是抢占式调度</span><br></pre></td></tr></table></figure>



<blockquote>
<p>主线程的概念：</p>
<p>CPU和内存之间为main方法开辟的通道专门为main方法服务，这个通道叫做主线程”</p>
</blockquote>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="创建线程（重点）"><a href="#创建线程（重点）" class="headerlink" title="创建线程（重点）"></a>创建线程（重点）</h3><h4 id="继承Thread"><a href="#继承Thread" class="headerlink" title="继承Thread"></a>继承Thread</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、定义一个类，继承Thread</span><br><span class="line">2、重写run方法，在run方法中设置线程任务（所谓的线程任务指的是此线程要干的具体的事，具体执行的代码）</span><br><span class="line">3、创建自定义线程类的对象</span><br><span class="line">4、调用Thread的start方法，开启线程，jvm自动调用run方法</span><br></pre></td></tr></table></figure>



<p>重写的run方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mythread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;mythread....执行了&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>main</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">mythread</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mythread</span>();</span><br><span class="line">        <span class="comment">// 调用start方法，开启线程，jvm自动调用run方法</span></span><br><span class="line">        p1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main....执行了&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以清除的看到有抢占情况</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240713111557786.png" alt="image-20240713111557786"></p>
<blockquote>
<p>多线程在内存中的运行：</p>
<p>开启一个线程会开启一个栈空间，去运行对应的线程代码，死循环开线程，电脑直接卡死</p>
<p>同一个线程对象只能调用一个start，不能连续调用start，想再开一个线程，就new一个新的线程对象</p>
</blockquote>
<h5 id="Thread中的方法"><a href="#Thread中的方法" class="headerlink" title="Thread中的方法"></a>Thread中的方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void start() -&gt; 开启线程，jvm自动调用run方法</span><br><span class="line">void run() -&gt; 设置线程任务，这个run方法是Thread重写接口Runnable中的run方法</span><br><span class="line">String getName() -&gt; 获取线程名字 默认是Thread-i i从0递增</span><br><span class="line">String setName() -&gt; 设置线程名字</span><br><span class="line">static Thread currentThread() -&gt; 获取正在执行的线程对象</span><br><span class="line">static void sleep(long millis) -&gt; 线程休眠，单位是毫秒</span><br></pre></td></tr></table></figure>



<p>复习一下异常的知识，这里继承的Thread是不能抛异常的，原因是Thread中的run方法没有抛异常，这里也不能上抛，只能try……catch</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240713113958896.png" alt="image-20240713113958896"></p>
<blockquote>
<p>如果我想知道主线程的线程名称，我的main方法又没有继承Thread很显然不能getName，这个时候就需要currentThread()方法，获得当先运行的Thread对象，写一个链式调用即可</p>
<p>Thread.currentThread().getName()</p>
<p>返回结果是main</p>
</blockquote>
<h5 id="Thread中的其他方法"><a href="#Thread中的其他方法" class="headerlink" title="Thread中的其他方法"></a>Thread中的其他方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void setPriority(int newPriority) -&gt; 设置线程优先级，优先级越高的线程，抢到CPU使用权的几率越大，但是不是每次都能抢到</span><br><span class="line"></span><br><span class="line">int getPriority() -&gt; 获取线程优先级</span><br><span class="line"></span><br><span class="line">void setDaemon(boolean on) -&gt; 设置为守护线程 执行完非守护线程，守护线程就要结束，无论是否执行完毕</span><br><span class="line"></span><br><span class="line">static void yie1d() -&gt; 礼让线程，让当前线程让出CPU使用权</span><br><span class="line"></span><br><span class="line">void join() -&gt; 插入线程或者插队线程</span><br></pre></td></tr></table></figure>



<h6 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h6><p>可以看到优先级都为5</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240713115035035.png" alt="image-20240713115035035"></p>
<blockquote>
<p>看一下底层代码，最小为1，默认为5，最大为10</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240713115157530.png" alt="image-20240713115157530"></p>
<p>但是效果并不是特点明显，最高优先级也不是每次都能抢到</p>
</blockquote>
<h6 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h6><p>main</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">mythread</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mythread</span>();</span><br><span class="line">        <span class="type">mythread01</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mythread01</span>();</span><br><span class="line">        p1.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        p2.setDaemon(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用start方法，开启线程，jvm自动调用run方法</span></span><br><span class="line">        p1.start();</span><br><span class="line">        p2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>守护线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mythread01</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;李四....执行了&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>非守护线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mythread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;mythread....执行了&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到其他线程结束后，守护线程也结束了，并没有循环完100次</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240713115832529.png" alt="image-20240713115832529"></p>
<blockquote>
<p>守护线程也不是马上结束了，当非守护线程结束之后，系统会告诉守护线程，告知的过程中，守护线程仍在执行，我感觉使用场景很适合游戏反作弊</p>
</blockquote>
<h6 id="礼让线程"><a href="#礼让线程" class="headerlink" title="礼让线程"></a>礼让线程</h6><p>写在一个实现类内，理想型是p1、p2交叉执行，但是并不是绝对的，只是尽可能的平衡，即使礼让了仍然会有连续执行的情况</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240713121008607.png" alt="image-20240713121008607"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">核心语句：</span><br><span class="line">	Thread.yield();</span><br></pre></td></tr></table></figure>



<h6 id="插入线程"><a href="#插入线程" class="headerlink" title="插入线程"></a>插入线程</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">插入线程的效果不错，但是用的不是很多</span><br></pre></td></tr></table></figure>



<p>main</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">mythread</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mythread</span>();</span><br><span class="line">        p1.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用start方法，开启线程，jvm自动调用run方法</span></span><br><span class="line">        p1.start();</span><br><span class="line">        p1.join();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main执行了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread实现了Runnable接口，重写了run方法，Runnable接口中只要一个run方法</span><br><span class="line"></span><br><span class="line">1、创建类，实现Runnable接口</span><br><span class="line">2、重写run方法，设置线程任务</span><br><span class="line">3、利用Thread类的构造方法：Thread(Runnable target)，创建Thread对象(线程对象)，将自定义的类当参数传递到Thread构造中 -&gt; 这一步是让我们自己定义的类成为一个真正的线程类对象</span><br><span class="line">4、调用Thread中的start方法，开启线程，jvm自动调用run方法</span><br></pre></td></tr></table></figure>



<p>实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;...执行了&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>main</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">m1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Thread(Runnable target);</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(m1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用start方法开启线程</span></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;执行&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="两种创建方法的区别"><a href="#两种创建方法的区别" class="headerlink" title="两种创建方法的区别"></a>两种创建方法的区别</h4><blockquote>
<p>1、继承Thread：继承只支持单继承，有继承的局限性</p>
<p>2、实现Runnable：没有继承的局限性</p>
<p>MyRunnable extends Fu implements Runnable</p>
<p>总结就是：Runnable节省了一个继承卡槽</p>
</blockquote>
<h4 id="匿名内部类创建多线程"><a href="#匿名内部类创建多线程" class="headerlink" title="匿名内部类创建多线程"></a>匿名内部类创建多线程</h4><blockquote>
<p>严格意义来说，匿名内部类方式不属于创建多线程方式其中之一，因为匿名内部类形式建立在实现Runnable接口或者继承Thread的基础上完成的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">回顾：</span><br><span class="line">	new 接口/抽象类()&#123;</span><br><span class="line">		重写方法</span><br><span class="line">	&#125;.重写的方法()</span><br><span class="line">	</span><br><span class="line">	or</span><br><span class="line">	</span><br><span class="line">	接口名/类名 对象名 = new 接口/抽象类()&#123;</span><br><span class="line">		重写方法</span><br><span class="line">	&#125;</span><br><span class="line">	 对象名.重写的方法();</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 相当于继承Thread</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;张三&quot;</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 相当于实现Runnable</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;李四&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Thread也为匿名内部类提供了命名的方法：</p>
<p>继承Thread的时候，直接传入一个字符串，会给线程命名</p>
<p>实现Runnable的时候，传入一个Runnable对象的同时再传入一个字符串实现命名</p>
</blockquote>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><blockquote>
<p>什么时候发生：</p>
<p>​	多个线程访问同一个资源时，导致了数据出现问题</p>
</blockquote>
<p>可以看到三个人访问了同一个，甚至还买到了第0张</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240713152801971.png" alt="image-20240713152801971"></p>
<p>线程有问题的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">ticker</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ticker &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;买了第&quot;</span>+ticker+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                ticker--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">myRunnable</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">myRunnable</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(p1,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(p1,<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(p1,<span class="string">&quot;王五&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因：CPU在不同线程之间做高速切换导致的，在前一个人进入线程还没还得及ticket–的时候，下一个人也访问了进来，就造成了有3个第100的现象，0也是这样，前一个人还没–，就通过if判断进入，前者–，后者输出ticket就出现了0</p>
</blockquote>
<h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">问题抛出来了，肯定得解决</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">	synchronized(任意对象)&#123;</span><br><span class="line">		线程可能出现的不安全代码</span><br><span class="line">	&#125;</span><br><span class="line">1、任意对象：就是锁对象</span><br><span class="line">2、执行：</span><br><span class="line">	一个线程拿到锁之后，会进入到同步代码块中执行，在此期间，其他线程拿不到锁，就进不去同步代码块，需要在同步代码块外面等待排队，需要等着执行的线程执行完毕，出了同步代码块，相当于释放锁，等待的线程才能抢到锁，才能进入到同步代码块中执行</span><br><span class="line">3、默认锁：this</span><br></pre></td></tr></table></figure>



<p>解决问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">ticker</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                <span class="keyword">if</span> (ticker &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;买了第&quot;</span>+ticker+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    ticker--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样的方式既可以解决访问用一个对象，还加了一个sleep防止全被同一个人拿走</p>
<p>锁只能有一把，不能多把，联合实际也可以理解</p>
</blockquote>
<h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><h5 id="普通同步方法"><a href="#普通同步方法" class="headerlink" title="普通同步方法"></a>普通同步方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	修饰符 synchronized 返回值类型 方法名(参数)&#123;</span><br><span class="line">		方法体</span><br><span class="line">		return 结果</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">ticker</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//method();</span></span><br><span class="line">            testMethod();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ticker &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;买了第&quot;</span>+ticker+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            ticker--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ticker &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;买了第&quot;</span>+ticker+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                ticker--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上方代码块内method是普通同步方法，虽然没有指定锁，但是这个锁是this，也就是说，普通同步方法method和下方的同步代码块testMethod是一样的</p>
</blockquote>
<h5 id="静态同步方法"><a href="#静态同步方法" class="headerlink" title="静态同步方法"></a>静态同步方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	修饰符 static synchronized 返回值类型 方法名(参数)&#123;</span><br><span class="line">		方法体</span><br><span class="line">		return 结果</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">默认锁：class对象</span><br></pre></td></tr></table></figure>



<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticker</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//method01();</span></span><br><span class="line">            testMethod01();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ticker &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;买了第&quot;</span>+ticker+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            ticker--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testMethod01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (myRunnable.class)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ticker &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;买了第&quot;</span>+ticker+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                ticker--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为静态成员不能访问非静态成员，所以需要将ticket变为静态的，然后锁变为了class，其他的和普通同步方法很相似</p>
</blockquote>
<p>拓展一下：之前说过StringBuilder多线程时不安全，但是效率高，StringBuffer安全但是效率低</p>
<p>原因就是StringBuffer的方法都是带synchronized的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240713162603427.png" alt="image-20240713162603427"></p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁是指两个或者两个以上的线程在执行过程中由于竞争同步锁而产生的一种阻塞现象；如果没有外力的作用，他们将无法继续执行下去，这种情况称之为死锁</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240713162944893.png" alt="image-20240713162944893"></p>
<blockquote>
<p>如图所示：线程1正在持有锁1，但是线程1必须再拿到锁2，才能继续执行</p>
<p>而线程2正在持有锁2，但是线程2需要再拿到锁1，才能继续执行</p>
<p>此时两个线程处于互相等待的状态，就是死锁，在程序中的死锁将出现在同步代码块的嵌套中</p>
</blockquote>
<p>因此，我们应该&#x3D;&#x3D;避免同步代码的嵌套&#x3D;&#x3D;</p>
<p>实现一个死锁看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">LockA</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockA</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">LockB</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockB</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Run</span><span class="params">(<span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Run</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LockA.lockA)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;if...LockA&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (LockB.lockB)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;if...LockB&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LockB.lockB)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;else...LockA&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (LockA.lockA)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;else...LockB&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Run</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Run</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Run</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Run</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(p1).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(p2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种情况大概率死锁，但也有小概率手快，两个都拿了，执行完毕释放出来。</p>
<p>看个乐呵，还是要避免嵌套</p>
</blockquote>
<h3 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程被创建并启动后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程中生命周期中，有几种状态呢？在API中Java.lang.Thread.State这个枚举中给出了六种线程状态：</span><br><span class="line">	这里先列出各个线程状态发生的条件，下面将会每种状态进行详细解析。</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>线程状态</th>
<th>导致状态发生体哦阿健</th>
</tr>
</thead>
<tbody><tr>
<td>NEW(新建)</td>
<td>线程刚被创建，但是并未启动。还没调用start方法。</td>
</tr>
<tr>
<td>Runnable(可运行)</td>
<td>线程可以在Java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器</td>
</tr>
<tr>
<td>Blocked(锁阻塞)</td>
<td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁，该线程将变成Runnable状态</td>
</tr>
<tr>
<td>Waiting(无线等待)</td>
<td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒</td>
</tr>
<tr>
<td>Timed Waiting(计时等待)</td>
<td>同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这个状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep、Object.wait。</td>
</tr>
<tr>
<td>Terminated(被终止)</td>
<td>因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。或者调用过时方法stop()</td>
</tr>
</tbody></table>
<p>画图表示</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240713175148947.png" alt="image-20240713175148947"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">注意以下方法</span><br><span class="line"></span><br><span class="line">1、sleep(time)和wait(time)的区别</span><br><span class="line">	sleep(time):线程睡眠，在睡眠的过程中，线程不会释放锁，此时其他线程抢不到锁，设置时间一旦超时，自动醒来，继续执行</span><br><span class="line">	wait(time):线程等待，在等待的过程中会释放锁，其他线程就可能抢到锁，如果在等待的过程中被唤醒或者时间超时，会和其他的线程重新抢锁，如果抢到了继续执行，抢不到进入锁阻塞</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、wait()和notify()</span><br><span class="line">	wait():空参wait，线程进入无限等待状态，会释放锁，需要其他线程调用notify(一次唤醒一条等待的线程，唤醒的线程是随机的)或者notifyAll方法(将所有等待线程全唤醒)，被唤醒之后，会和其他的线程重新抢锁，如果抢到了继续执行，抢不到进入锁阻塞</span><br><span class="line">	notify():notify会唤醒正在等待的线程，一次只能唤醒一条等待的线程；如果多线程等待，随机唤醒一条 </span><br><span class="line">	notifyAll():唤醒所有等待的线程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3、wait和notify两个方法的用法：</span><br><span class="line">	两个方法都需要锁对象调用，所以两个方法需要用到同步代码块、同步方法中</span><br><span class="line">	俩个方法的调用必须是同一个锁对象调用，可以理解为用同一个锁对象，将多条线程分到了一组中，这样notify就知道唤醒的是自己本组的等待线程</span><br></pre></td></tr></table></figure>



<h3 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需求：一个线程生产，一个线程消费，不能连续生产，不能连续消费 -&gt; 等待唤醒机制（线程之间通信）</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void wait()</td>
<td>线程等待，等待的过程会释放锁，需要被其他线程调用notify方法将其唤醒，重新抢锁执行</td>
</tr>
<tr>
<td>void notify()</td>
<td>线程唤醒，一次唤醒一个等待线程，多条线程等待，随机唤醒一条线程</td>
</tr>
<tr>
<td>void notifyAll()</td>
<td>线程唤醒，唤醒所有等待线程</td>
</tr>
</tbody></table>
<blockquote>
<p>wait和notify方法需要锁对象调用，所以需要用到同步代码块中，而且必须是同一锁对象</p>
</blockquote>
<p>案例代码</p>
<blockquote>
<p>思路：</p>
<p>​	1、怎么生产和消费包子</p>
<p>​			count++,count–</p>
<p>​	2、怎么证明有没有包子</p>
<p>​			设置一个flag flag&#x3D;true表示有</p>
<p>​	3、如何防止生产到一半，CPU切换</p>
<p>​			加锁</p>
<p>​	4、如何保证生产一个消费一个，防止连续生产，连续消费</p>
<p>​			wait和notify方法</p>
</blockquote>
<p>生产流水线</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjjws.h_stop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">suo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Test test;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">suo</span><span class="params">(Test test)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.test = test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (test)&#123;</span><br><span class="line">                <span class="keyword">if</span> (test.isFlag()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        test.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    test.setCount();</span><br><span class="line">                    test.setFlag(<span class="literal">true</span>);</span><br><span class="line">                    test.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>消费流水线</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjjws.h_stop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">baoz</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Test test;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">baoz</span><span class="params">(Test test)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.test = test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (test)&#123;</span><br><span class="line">                <span class="keyword">if</span> (test.isFlag()==<span class="literal">false</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        test.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    test.getCount();</span><br><span class="line">                    test.setFlag(<span class="literal">false</span>);</span><br><span class="line">                    test.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>包子铺</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjjws.h_stop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFlag</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlag</span><span class="params">(<span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费第&quot;</span>+count+<span class="string">&quot;个包子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCount</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产第&quot;</span>+count+<span class="string">&quot;个包子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了方便查看，消费包子就不count--了</span></span><br></pre></td></tr></table></figure>



<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjjws.h_stop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">suo</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">suo</span>(test);</span><br><span class="line">        <span class="type">baoz</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">baoz</span>(test);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(p1);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(p2);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试这里很关键，在两个线程内添加了锁，但是应该如何保证是同一把锁呢，这个就需要将两个方法的对象设置成同一个，使用有参构造来更改对象地址值，确保是同一把锁。</span></span><br></pre></td></tr></table></figure>



<p>还可以使用同步方法来完成</p>
<p>生产</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjjws.h_stop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">suo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Test test;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">suo</span><span class="params">(Test test)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.test = test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            test.setCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>消费</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjjws.h_stop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">baoz</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Test test;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">baoz</span><span class="params">(Test test)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.test = test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            test.getCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>包子铺</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjjws.h_stop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFlag</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlag</span><span class="params">(<span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.flag==<span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.flag = <span class="literal">false</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费第&quot;</span>+count+<span class="string">&quot;个包子&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.flag) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产第&quot;</span>+count+<span class="string">&quot;个包子&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.notify();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后一次测试就不粘贴了。和上面一样，更改就在于将setcount和getcount更改为了同步方法，因为同步方法的锁默认是this，因此和上面的代码效果是相同的</span></span><br></pre></td></tr></table></figure>



<p><strong>多等待多唤醒案例</strong></p>
<blockquote>
<p>如果有多条线程的话，上面的方法还是有点问题的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"></span><br><span class="line">     <span class="type">suo</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">suo</span>(test);</span><br><span class="line">     <span class="type">baoz</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">baoz</span>(test);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(p1).start();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(p1).start();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(p1).start();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(p2).start();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(p2).start();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(p2).start();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>症结在于notify，因为是随机唤醒，这个机制面对6个对象抢锁的时候会出现问题，因此面对多线程的时候要使用notifyAll来防止没有线程来抢锁了</p>
</blockquote>
<p>因此只需要改变notify即可</p>
<blockquote>
<p>不改变：这个情况是全都wait了，卡死了，全休眠去了，没有活着的线程了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240717165337495.png" alt="image-20240717165337495"></p>
</blockquote>
<p>这里老师讲的很迷，连续消费，连续生产的问题，只需要加上应该else就可以解决，因为他的代码没有else出了if就还会继续执行下面的语句</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240717170023463.png" alt="image-20240717170023463"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240717170224882.png" alt="image-20240717170224882"></p>
<p>他之所以这样写，是为了铺垫下面的把if改成while，就是循环判断，防止唤醒之后，没有判断就继续执行代码，仔细想一下还是while比较安全、迅速一些</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.flag) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.flag = <span class="literal">false</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费。。。。。。。第&quot;</span>+count+<span class="string">&quot;个包子&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">this</span>.flag) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">    System.out.println(<span class="string">&quot;生产第&quot;</span>+count+<span class="string">&quot;个包子&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">this</span>.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">概述：</span><br><span class="line">	Lock是一个接口</span><br><span class="line">	</span><br><span class="line">实现类：</span><br><span class="line">	ReentrantLock</span><br><span class="line">	</span><br><span class="line">方法：</span><br><span class="line">	lock() -&gt; 获取锁</span><br><span class="line">	unlock() -&gt; 释放锁</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjjws.j_lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">ticker</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (ticker &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;买了第&quot;</span> + ticker + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                ticker--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以小小借用一下try</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">ticker</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span> (ticker &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;买了第&quot;</span> + ticker + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    ticker--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>synchronized：不管是同步代码块还是同步方法，都需要在结束一对{}之后，释放锁对象</p>
<p>Lock：是通过两个方法控制需要被同步的代码，形式上更加灵活</p>
</blockquote>
<h3 id="实现多线程方式3-Callable接口"><a href="#实现多线程方式3-Callable接口" class="headerlink" title="实现多线程方式3-Callable接口"></a>实现多线程方式3-Callable接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、继承Thread</span><br><span class="line">2、实现Runnable接口</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;V&gt;是一个接口，类似于Runnable</span><br><span class="line">方法：</span><br><span class="line">	V call() -&gt; 设置线程任务，类似于run方法</span><br><span class="line">	</span><br><span class="line">&lt;V&gt;：</span><br><span class="line">	泛型</span><br><span class="line">	用于指定我们操作什么类型的数据，&lt;&gt;内只能写引用数据类型，也就是说基本数据类型要转换成包装类，如果泛型不写，默认是Object类型数据</span><br><span class="line">	实现callable接口时，指定泛型是什么类型的，重写call方法返回值就是什么类型</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">获取call方法返回值：FutureTask&lt;V&gt;</span><br><span class="line">	1、FutureTask&lt;V&gt;实现了一个接口：Future&lt;V&gt;</span><br><span class="line">	2、FutureTask&lt;V&gt;中有一个方法：</span><br><span class="line">	// FutureTask是Future的实现类</span><br><span class="line">	</span><br><span class="line">		V get() -&gt; 获取call方法的返回值</span><br></pre></td></tr></table></figure>

<blockquote>
<p>run方法和call方法的区别：</p>
<p>​	相同点：</p>
<p>​		设置线程任务</p>
<p>​	不同点：</p>
<p>​		call方法有返回值，有异常可以throws</p>
<p>​		run方法没有返回值，有异常不能throws</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240717175339488.png" alt="image-20240717175339488"></p>
</blockquote>
<p>实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mycall</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;隔壁老王和金莲不得不说的故事&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">mycall</span> <span class="variable">call</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mycall</span>();</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(call);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程对象 -&gt; Thread(Runnable targer) </span></span><br><span class="line">        <span class="comment">// 可以看出FutureTask和Runnable还是有一些关系的</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// futureTask.get()是获取call方法返回值的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实现多线程方式4-线程池"><a href="#实现多线程方式4-线程池" class="headerlink" title="实现多线程方式4-线程池"></a>实现多线程方式4-线程池</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">之前来一个线程任务，就需要创建一个线程对象去执行，用完还需要销毁线程对象，如果线程任务多了，就需要频繁创建线程对象和线程对象，这样会耗费内存资源，所以我们就想到线程对象能不能循环利用，用的时候直接拿线程对象，用完还回去</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>线程池：</p>
<p>​	创建线程池对象，指定最多能有几个线程对象</p>
<p>​	未到达上限时，如果没有线程对象，创建线程对象，用还还回去</p>
<p>​	到达上限后，等其他线程任务执行完毕归还线程对象后，再使用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">创建线程池对象：</span><br><span class="line">	工具类：Executors</span><br><span class="line">	</span><br><span class="line">获取线程池对象：</span><br><span class="line">	Executors中的静态方法</span><br><span class="line">	static ExecutorService newFixedThreadPool(int nThreads)</span><br><span class="line">	1、参数：指定线程池中最多创建的线程对象条数</span><br><span class="line">	2、返回值ExecutorService是线程池，用来管理线程对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">执行线程任务：ExceutorService中的方法</span><br><span class="line">	Future&lt;?&gt; submit(Runnable task) -&gt; 提交一个Runnable任务，用于执行</span><br><span class="line">	Future&lt;T&gt; submit(Callable&lt;T&gt; task) -&gt; 提交一个Callable任务用于执行</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">submit方法的返回值：Future接口</span><br><span class="line">	用于接收run方法或者call方法返回值的，但是run方法没有返回值，所以不用Future接收，执行call方法需要用Future接收</span><br><span class="line">	Future中有一个方法：V get() -&gt; 获取call方法的返回值</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">ExecutorService中的方法：</span><br><span class="line">	void shutdown() -&gt; 启动有序关闭，其中先前提交的任务被执行，但不会接收新的任务（关闭线程池）</span><br></pre></td></tr></table></figure>


<p>定义线程任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjjws.k_call;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mycall</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;执行了&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>执行方法一——run方法使用较多</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">method</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">mycall</span>());</span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">mycall</span>());</span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">mycall</span>());</span><br><span class="line"></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>执行方法二——获取返回值（call）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">public class method01 &#123;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(2);</span><br><span class="line">        Future&lt;Integer&gt; future = es.submit(new mycall());</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="定时器-Timer"><a href="#定时器-Timer" class="headerlink" title="定时器 Timer"></a>定时器 Timer</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">不属于上面的内容，算作一个补充</span><br><span class="line">构造：</span><br><span class="line">	Timer()</span><br><span class="line">	</span><br><span class="line">方法：</span><br><span class="line">	void schedule(TimerTask task, Date firstTime, long period)</span><br><span class="line">		task:抽象类，是Runnable的实现类</span><br><span class="line">		firstTime：从什么时间开始执行，一般写new Date</span><br><span class="line">		period:每隔多长时间执行一次，设置的是毫秒值</span><br></pre></td></tr></table></figure>



<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="集合框架（单列集合）"><a href="#集合框架（单列集合）" class="headerlink" title="集合框架（单列集合）"></a>集合框架（单列集合）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">之前学了的保存数据的有：变量、数组、但是数组有一个很大的缺点——定长，如果增删改数据，数组并不好用，需要创建新数组</span><br><span class="line"></span><br><span class="line">集合是一个长度可变的容器</span><br><span class="line">特点：</span><br><span class="line">	1、只能存储引用数据类型数据</span><br><span class="line">	2、长度可变</span><br><span class="line">	3、集合中有大量的方法，方便操作</span><br><span class="line">	</span><br><span class="line">分类：</span><br><span class="line">	1、单列集合：一个元素就一个组成部分</span><br><span class="line">		list.add(&quot;张三&quot;)</span><br><span class="line">	2、双列集合：一个元素有两个组成部分（key value）键值对一一对应（字典）</span><br><span class="line">		map.put(&quot;李四&quot;,&quot;王五&quot;)</span><br></pre></td></tr></table></figure>



<h4 id="框架介绍："><a href="#框架介绍：" class="headerlink" title="框架介绍："></a>框架介绍：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">单列集合顶级接口：</span><br><span class="line">	Collection接口</span><br><span class="line">	</span><br><span class="line">Collection下有两个接口list和set</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list有三个实现类ArrayList、LinkedList、Vector</span><br><span class="line"></span><br><span class="line">ArrayList：</span><br><span class="line">	1、元素有序</span><br><span class="line">	2、元素可重复</span><br><span class="line">	3、有索引</span><br><span class="line">	4、线程不安全</span><br><span class="line">	5、底层数据结构是数组</span><br><span class="line">	</span><br><span class="line">LinkedLink：</span><br><span class="line">	1、元素有序</span><br><span class="line">	2、元素可重复</span><br><span class="line">	3、有索引</span><br><span class="line">	4、线程不安全</span><br><span class="line">	5、底层数据结构是双向链表</span><br><span class="line">	</span><br><span class="line">Vector：</span><br><span class="line">	1、元素有序</span><br><span class="line">	2、元素可重复</span><br><span class="line">	3、有索引</span><br><span class="line">	4、线程不安全</span><br><span class="line">	5、底层数据结构是数组</span><br><span class="line">	// 元老级别的了，因为安全所以慢，用的也少</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">set接口也有三个实现类HashSet、LinkedHashSet、TreeSet</span><br><span class="line"></span><br><span class="line">HashSet：</span><br><span class="line">	1、元素无序</span><br><span class="line">	2、元素唯一</span><br><span class="line">	3、无索引</span><br><span class="line">	4、线程不安全</span><br><span class="line">	5、底层数据结构是哈希表</span><br><span class="line">	</span><br><span class="line">LinkedHashSet：</span><br><span class="line">	还是HashSet的子类</span><br><span class="line">	1、元素有序</span><br><span class="line">	2、元素唯一</span><br><span class="line">	3、无索引</span><br><span class="line">	4、线程不安全</span><br><span class="line">	5、底层数据结构是哈希表+双向链表</span><br><span class="line">	LinkedList本质上无索引，但是Java为其提供了很多根据索引操作元素的方法</span><br><span class="line">	</span><br><span class="line">TreeSet：</span><br><span class="line">	1、可对元素进行排序</span><br><span class="line">	2、元素唯一</span><br><span class="line">	3、无索引</span><br><span class="line">	4、线程不安全</span><br><span class="line">	5、底层数据结构是红黑树</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240719200404369.png" alt="image-20240719200404369"></p>
<h4 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">概述：单列集合的顶级接口</span><br><span class="line">使用：</span><br><span class="line">	创建：</span><br><span class="line">		Collection&lt;E&gt; 对象名 = new 实现类对象&lt;E&gt;()</span><br><span class="line">	&lt;E&gt;泛型：</span><br><span class="line">		决定了集合中能存储什么类型的数据，可以统一元素类型</span><br><span class="line">		泛型中只能写引用数据类型，因此集合只能存储引用数据类型，如果不写，默认是Object类型，此时什么类型的数据都可以存储</span><br><span class="line">	细节：</span><br><span class="line">		我们等号前面的泛型必须写，等号后面的泛型可以不写，jvm可以根据前面的泛型推导出后面的泛型是啥</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">常用方法：</span><br><span class="line">	boolean add(E e)：将给定的元素添加到当前集合中（我们一般调add时，不用boolean接收，因为add一定会成功）</span><br><span class="line">	boolean addAll(collection&lt;？extendsE&gt;c):将另一个集合元素添加到当前集合中（集合合并）(把括号内的元素添加到后面)</span><br><span class="line">	void clear()：清除集合中所有的元素</span><br><span class="line">	boolean contains(object o)：判断当前集合中是否包含指定的元素</span><br><span class="line">	boolean isEmpty(）：判断当前集合中是否有元素-&gt;判断集合是否为空</span><br><span class="line">	boolean remove(object o)：将指定的元素从集合中删除</span><br><span class="line">	int size()：返回集合中的元素个数。</span><br><span class="line">	object[] toArray()：把集合中的元素，存储到数组中</span><br></pre></td></tr></table></figure>



<blockquote>
<p>为啥说add一定成功呢，因为如果传入的类型不正确，会出现编译时期异常</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240719203320666.png" alt="image-20240719203320666"></p>
</blockquote>
<p>实践一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01collection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;String&gt; c1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//boolean add(E e)：将给定的元素添加到当前集合中（我们一般调add时，不用boolean接收，因为add一定会成功）</span></span><br><span class="line">        c1.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        c1.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        c1.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        c1.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        c1.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        c1.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        System.out.println(c1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//boolean addAll(collection&lt;？extendsE&gt;c):将另一个集合元素添加到当前集合中（集合合并）(把括号内的元素添加到后面)</span></span><br><span class="line">        Collection&lt;String&gt; c2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        c2.add(<span class="string">&quot;王二麻子&quot;</span>);</span><br><span class="line">        c2.add(<span class="string">&quot;王二麻子&quot;</span>);</span><br><span class="line">        c2.add(<span class="string">&quot;王二麻子&quot;</span>);</span><br><span class="line">        c2.add(<span class="string">&quot;王二麻子&quot;</span>);</span><br><span class="line">        c2.add(<span class="string">&quot;王二麻子&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;c2 = &quot;</span> + c2);</span><br><span class="line">        c1.addAll(c2);</span><br><span class="line">        System.out.println(<span class="string">&quot;c1 = &quot;</span> + c1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//void clear()：清除集合中所有的元素</span></span><br><span class="line">        c2.clear();</span><br><span class="line">        System.out.println(<span class="string">&quot;c2 = &quot;</span> + c2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//boolean contains(object o)：判断当前集合中是否包含指定的元素</span></span><br><span class="line">        System.out.println(c1.contains(<span class="string">&quot;赵四&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//boolean isEmpty(）：判断当前集合中是否有元素-&gt;判断集合是否为空</span></span><br><span class="line">        System.out.println(<span class="string">&quot;c1中无元素&quot;</span>+c1.isEmpty());</span><br><span class="line">        System.out.println(<span class="string">&quot;c2中无元素&quot;</span>+c2.isEmpty());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//boolean remove(object o)：将指定的元素从集合中删除</span></span><br><span class="line">        System.out.println(<span class="string">&quot;c1 = &quot;</span> + c1);</span><br><span class="line">        c1.remove(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;c1 = &quot;</span> + c1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//int size()：返回集合中的元素个数。</span></span><br><span class="line">        System.out.println(c1.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//object[] toArray()：把集合中的元素，存储到数组中</span></span><br><span class="line">        Object[] arr = c1.toArray();</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240719211259568.png" alt="image-20240719211259568"></p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">概述：主要作用就是遍历集合</span><br><span class="line">需要用到一个接口：Iterator</span><br><span class="line">获取：</span><br><span class="line">	Inerator&lt;E&gt; iterator()</span><br><span class="line">	// 这是collection中的一个方法</span><br><span class="line">	</span><br><span class="line">方法：</span><br><span class="line">	boolean hasNext() -&gt; 判断集合中有没有下一个元素</span><br><span class="line">	E next() -&gt; 获取下一个元素</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240719213600905.png" alt="image-20240719213600905"></p>
<blockquote>
<p>注意：next方法在获取的时候不要连续使用多次</p>
<p>很好理解，告诉你下一个有，结果一次拿两个，第二个可能拿不到，报错&#x3D;&#x3D;NoSuchElementException&#x3D;&#x3D;：没有操作的元素异常</p>
</blockquote>
<p>说说我自己的看法，这个迭代器的作用就是用来遍历集合，通过for循环或者增强的for循环也可以解决</p>
<h4 id="迭代器的迭代过程"><a href="#迭代器的迭代过程" class="headerlink" title="迭代器的迭代过程"></a>迭代器的迭代过程</h4><p><img src="/../%E5%9B%BE%E7%89%87/image-20240719220403029.png" alt="image-20240719220403029"></p>
<p>这里定义了一个负一，这样查看下一个是否存在的方法就可以检验索引了，这样迭代的过程就很好理解了，和for循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int cursor;</span><br><span class="line">int lasRet = -1;</span><br></pre></td></tr></table></figure>



<h4 id="迭代器底层原理"><a href="#迭代器底层原理" class="headerlink" title="迭代器底层原理"></a>迭代器底层原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">获取Iterator的时候怎么获取</span><br><span class="line">	Iterator iterator = list.iterator()</span><br><span class="line">	我们知道Iterator是一个接口。等号右边一定是它的实现类对象</span><br><span class="line">	Iterator接收的是哪个实现类对象呢？ -&gt; ArrayList中的内部类Itr对象</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240721082927838.png" alt="image-20240721082927838"></p>
<blockquote>
<p>注意：</p>
<p>​	只要ArrayList使用迭代器的时候Iterator接口才会是Itr来实现，其他的集合使用迭代器，不是由Itr来实现的</p>
<p>例如：HashSet做迭代指向KeyIterator</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240721084358237.png" alt="image-20240721084358237"></p>
</blockquote>
<h4 id="并发修改异常"><a href="#并发修改异常" class="headerlink" title="并发修改异常"></a>并发修改异常</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需求：定义一个集合，存储 唐僧、悟空、猪八戒、沙和尚，要求遍历到猪八戒的时候在后面添加上白龙马</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02collection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;唐僧&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;悟空&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;猪八戒&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;沙和尚&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">em</span> <span class="operator">=</span> iterator.next().toString();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;猪八戒&quot;</span>.equals(em)) &#123;</span><br><span class="line">                list.add(<span class="string">&quot;白龙马&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候异常就来了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240721090259358.png" alt="image-20240721090259358"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	modCount：表示实际操作次数</span></span><br><span class="line"><span class="comment">    	expectedModCount：表示预计操作次数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    …………………………</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="comment">// 当实际操作次数和预计操作次数不等时，抛出并发修改异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkForComodification抛的异常就是并发修改异常</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>结论：</p>
<p>​	当预计操作次数和实际操作次数不相等时，抛出并发修改异常</p>
<p>异常原因：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line"> modCount++;</span><br><span class="line"> add(e, elementData, size);</span><br><span class="line"> return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>add方法上来就是一个modCount++，让实际操作次数+1，再次调用next方法的时候并没有重新把修改后的modCount赋值给expectedModCount，导致next方法底层判断实际操作次数和预期操作次数不相等</p>
</blockquote>
<p>也不是没有方法搞定 <code>ListIterator</code> 这个和ArrayList有关</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ListIterator&lt;String&gt; listIterator = list.listIterator();</span><br><span class="line">while(listIterator.hasNext())&#123;</span><br><span class="line">	String element = listIterator.next();</span><br><span class="line">	if(&quot;猪八戒&quot;.equals)element))&#123;</span><br><span class="line">		listIterator.add(&quot;白龙马&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

<p>因为ListIterator是有add这个方法的，所以可以正常添加</p>
<p>但是呢：<strong>使用迭代器、增强for，迭代集合的过程中，不要随意修改集合长度</strong></p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据结构是一种具有一定逻辑关系，在计算机中应用某种存储结构，并且封装了相应操作的数据元素集合，它包含三方面的内容，逻辑关系、存储关系以及操作。</span><br></pre></td></tr></table></figure>

<p><strong>为什么需要数据结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">随着应用程序变得越来越复杂和数据越来越丰富，几百万、几十亿甚至几百亿的数据就会出现，而面对这么大对数据进行搜素插入或者排序等的操作就越来越慢。数据结构就是来解决这个问题的</span><br><span class="line"></span><br><span class="line">数据结构非常复杂，这里只对数据结构进行简单的了解</span><br></pre></td></tr></table></figure>



<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">特点：</span><br><span class="line">	先进后出(就好比手枪压子弹)</span><br></pre></td></tr></table></figure>



<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">特点：</span><br><span class="line">	先进先出（就好比过安检）</span><br></pre></td></tr></table></figure>



<h4 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">特点：</span><br><span class="line">	查询快，增删慢</span><br><span class="line">	</span><br><span class="line">查询快：</span><br><span class="line">	因为有索引，我们可以直接通过索引操作元素</span><br><span class="line">增删慢：</span><br><span class="line">	数组定长</span><br><span class="line">	添加元素：创建新数组，将老数组中的元素复制到新数组中去，在最后添加元素；但是如果在中间添加元素就麻烦了，插入完新元素，后面的元素都要向后移动</span><br><span class="line">	删除元素：创建新数组，将老数组中的元素复制到新数组中去，要删除的元素不赋值；如果在中间删除元素，被删除元素后面的元素都要往前移动</span><br></pre></td></tr></table></figure>



<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">在集合中涉及了两种链表：单向链表、双向链表</span><br><span class="line">单向链表：</span><br><span class="line">	1、节点：一个节点分为两个部分</span><br><span class="line">		第一部分：数据域(存储数据)</span><br><span class="line">		第二部分：指针域(保存下一个节点地址值)</span><br><span class="line">	2、特点：前面节点保存后面节点的地址，但是后面节点地址不记录前面节点地址</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">双向链表：</span><br><span class="line">	1、节点：一个节点分为三部分</span><br><span class="line">		第一部分：指针域(保存上一个节点地址值)</span><br><span class="line">		第二部分：数据域(保存的数据)</span><br><span class="line">		第三部分：指针域(保存下一个节点地址值)</span><br><span class="line">	2、特点：前面节点记录后面节点地址，后面节点也记录前面节点地址</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">链表结构特点：查询慢，增删快</span><br></pre></td></tr></table></figure>



<h5 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h5><img src="../图片/image-20240721141112175.png" alt="image-20240721141112175" style="zoom:50%;" />



<h5 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h5><p><img src="/../%E5%9B%BE%E7%89%87/image-20240721141317663.png" alt="image-20240721141317663"></p>
<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><p>list接口是collection接口的子接口</p>
<p>常见的实现类：ArrayList、LinkedList、Vector</p>
<h4 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ArrayList是List接口的实现类</span><br><span class="line">特点：</span><br><span class="line">	1、元素有序</span><br><span class="line">	2、元素可重复</span><br><span class="line">	3、有索引</span><br><span class="line">	4、线程不安全</span><br><span class="line">	</span><br><span class="line">数据结构：数组</span><br><span class="line"></span><br><span class="line">常用方法：</span><br><span class="line">	boolean add(E e) -&gt; 将元素添加到集合中（尾部）（之前说过，这个一旦执行，一定成功，所以不需要接收返回值）</span><br><span class="line">	void add(int index, E element) -&gt; 在指定位置添加元素</span><br><span class="line">	boolean remove(Object o) -&gt; 删除指定元素，删除成功为true</span><br><span class="line">	E remove(int index) -&gt; 删除指定索引位置上的元素，返回值是被删除的哪个元素</span><br><span class="line">	E set(int index, E element) -&gt; 将指定索引位置上的元素，修改为后面的element元素</span><br><span class="line">	E get(int index) -&gt; 根据索引获取元素</span><br><span class="line">	int size() -&gt; 获取集合元素个数</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//boolean add(E e) -&gt; 将元素添加到集合中（尾部）（之前说过，这个一旦执行，一定成功，所以不需要接收返回值）</span></span><br><span class="line">        list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;赵四&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//void add(int index, E element) -&gt; 在指定位置添加元素</span></span><br><span class="line">        list.add(<span class="number">0</span>,<span class="string">&quot;二柱&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//boolean remove(Object o) -&gt; 删除指定元素，删除成功为true</span></span><br><span class="line">        list.remove(<span class="string">&quot;赵四&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//E remove(int index) -&gt; 删除指定索引位置上的元素，返回值是被删除的哪个元素</span></span><br><span class="line">        list.remove(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//E set(int index, E element) -&gt; 将指定索引位置上的元素，修改为后面的element元素</span></span><br><span class="line">        list.set(<span class="number">1</span>,<span class="string">&quot;法外狂徒张三&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//E get(int index) -&gt; 根据索引获取元素</span></span><br><span class="line">        list.get(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//int size() -&gt; 获取集合元素个数</span></span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240721142831844.png" alt="image-20240721142831844"></p>
<p>遍历集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01for</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;二柱&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;赵四&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------我是分割线------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 快捷键 集合名.fori</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增强for后面再说</span></span><br><span class="line"><span class="comment">// 增强for的快捷键是</span></span><br><span class="line"><span class="comment">//		集合名或者数组名.for</span></span><br></pre></td></tr></table></figure>



<h5 id="remove问题"><a href="#remove问题" class="headerlink" title="remove问题"></a>remove问题</h5><p><img src="/../%E5%9B%BE%E7%89%87/image-20240721144126690.png" alt="image-20240721144126690"></p>
<p>解决方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list.remove(Integer.valueOf(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 过时方法</span></span><br><span class="line">list.remove(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>



<h5 id="底层源码"><a href="#底层源码" class="headerlink" title="底层源码"></a>底层源码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">构造方法：</span><br><span class="line">	ArrayList() -&gt; 构造一个初始容量为10的空列表</span><br><span class="line">	ArrayList(int initialCapacity) -&gt; 构造具有指定初始容量的空列表</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">ArrayList问题总结：</span><br><span class="line">	容量为10并不是new出来之后容量就是10，而是第一次add方法执行之后，扩容到10</span><br><span class="line">	ArrayList底层为数组，为什么说容量可变呢，因为底层自动扩容 -&gt; Arrays.copyOf()</span><br><span class="line">	扩容1.5倍（原长度+原长度二进制数据右移一位）</span><br></pre></td></tr></table></figure>



<h6 id="无参构造-1"><a href="#无参构造-1" class="headerlink" title="无参构造"></a>无参构造</h6><p><img src="/../%E5%9B%BE%E7%89%87/image-20240721145328684.png" alt="image-20240721145328684"></p>
<blockquote>
<p>可以看到，并没有所谓的容量为10的空列表，长度为0 </p>
<p>注意：</p>
<p>​	说的容量为10是&#x3D;&#x3D;第一次执行add方法后&#x3D;&#x3D;</p>
</blockquote>
<p>那就看一下add方法吧</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240721150000075.png" alt="image-20240721150000075"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240721150616062.png" alt="image-20240721150616062"></p>
<p>超出容量之后，再次执行add时</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240721151802182.png" alt="image-20240721151802182"></p>
<p>SOFT_MAX_ARRAY_LENGTH是数组最大长度2147483639</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240721152244804.png" alt="image-20240721152244804"></p>
<p>返回新数组后执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> Arrays.copyOf(elementData, newCapacity);</span><br></pre></td></tr></table></figure>

<p>将原数组的数据赋值给新数组</p>
<h6 id="有参构造-1"><a href="#有参构造-1" class="headerlink" title="有参构造"></a>有参构造</h6><p><img src="/../%E5%9B%BE%E7%89%87/image-20240721153125484.png" alt="image-20240721153125484"></p>
<blockquote>
<p>ArrayList<String> list &#x3D; new Array&lt;&gt;();  -&gt;  现在都是想用就new</p>
<p>但是将来开发不会想用就new集合，而是调用一个方法，查询出很多数据来，此方法返回一个集合，自动将查询出来的数据放到集合中，我们再在页面上展示数据，遍历集合</p>
<p>而且将来调用方法，返回的集合类型，一般都是接口类型</p>
<p>List<E> list &#x3D; 对象.查询方法()</p>
</blockquote>
<h4 id="LinkedList集合"><a href="#LinkedList集合" class="headerlink" title="LinkedList集合"></a>LinkedList集合</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">概述：是List接口的实现类</span><br><span class="line">特点：</span><br><span class="line">	1、元素有序</span><br><span class="line">	2、元素可重复</span><br><span class="line">	3、有索引 -&gt; 这里说有索引指的是有操作索引的方法，不代表本质上有索引</span><br><span class="line">	4、线程不安全</span><br><span class="line">	</span><br><span class="line">数据结构：双向链表，索引是数组的东西</span><br><span class="line"></span><br><span class="line">方法：有大量操作首尾元素的方法</span><br><span class="line">	public void addFirst(E e) -&gt; 将指定元素插入到列表的开头</span><br><span class="line">	public void addLast(E e) -&gt; 将指定元素添加到列表的结尾</span><br><span class="line">	public E getFirst() -&gt; 返回列表的第一个元素</span><br><span class="line">	public E getLast() -&gt; 返回列表的最后一个元素</span><br><span class="line">	public E removeFirst() -&gt; 删除列表的第一个元素</span><br><span class="line">	public E removeLast() -&gt; 删除列表最后一个元素</span><br><span class="line">	public E pop() -&gt; 从此列表表示的堆栈处弹出一个元素</span><br><span class="line">	public void push(E e) -&gt; 将元素推入此列表所表示的堆栈</span><br><span class="line">	public boolean isEmpty() -&gt; 如果列表没有元素，则返回true</span><br></pre></td></tr></table></figure>



<p>虽然没有索引但是也可以使用get方法配合for循环遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        LinkedList&lt;String&gt; linkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        linkedList.add(<span class="string">&quot;大头儿子&quot;</span>);</span><br><span class="line">        linkedList.add(<span class="string">&quot;大头cs&quot;</span>);</span><br><span class="line">        linkedList.add(<span class="string">&quot;小头爸爸&quot;</span>);</span><br><span class="line">        linkedList.add(<span class="string">&quot;小头孙子&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; iterator = linkedList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; linkedList.size(); i++) &#123;</span><br><span class="line">            System.out.println(linkedList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240721155303756.png" alt="image-20240721155303756"></p>
<p>可以看到底层还是通过iterator来拿到的数据，并不是索引</p>
<p>这几个方法就pop和push稀罕一点，其他的就不演示了，但是其底层还是removeFirst和addFirst。瞬间索然无味</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240721155804211.png" alt="image-20240721155804211"></p>
<h5 id="LinkedList底层成员"><a href="#LinkedList底层成员" class="headerlink" title="LinkedList底层成员"></a>LinkedList底层成员</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 元素个数</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first; <span class="comment">// 第一个节点对象</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last; <span class="comment">// 最后一个节点对象</span></span><br><span class="line"></span><br><span class="line">Node代表的是节点对象</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E item; <span class="comment">// 节点上的元素</span></span><br><span class="line">        Node&lt;E&gt; next; <span class="comment">// 记录着下一个节点地址</span></span><br><span class="line">        Node&lt;E&gt; prev; <span class="comment">// 记录着上一个节点地址</span></span><br><span class="line">        </span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next)&#123;</span><br><span class="line">            <span class="built_in">this</span>.item = element;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h6 id="分析add方法"><a href="#分析add方法" class="headerlink" title="分析add方法"></a>分析add方法</h6><p>创建第一个</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240721161343003.png" alt="image-20240721161343003"></p>
<p>再来一个</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240721161821324.png" alt="image-20240721161821324"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240721161950990.png" alt="image-20240721161950990"></p>
<h6 id="分析get方法"><a href="#分析get方法" class="headerlink" title="分析get方法"></a>分析get方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the (non-null) Node at the specified element index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">    	Node&lt;E&gt; x = first;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">     	   x = x.next;</span><br><span class="line">  	  <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  	  Node&lt;E&gt; x = last;</span><br><span class="line">  	  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">    	    x = x.prev;</span><br><span class="line">  	  <span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>虽然说慢，但是给出了优化查找的方法</p>
<blockquote>
<p>index &lt; (size &gt;&gt; 1) 采用二分思想，先将index与长度size的一半比较，如果index &lt; size&#x2F;2，就从位置0往后遍历到位置index处，而如果index &gt; size&#x2F;2，就只从位置size往前遍历到位置index处，这样可以减少一部分不必要的遍历</p>
</blockquote>
<p>这并&#x3D;&#x3D;不是&#x3D;&#x3D;二分法查询，但是利用了二分思想</p>
<h3 id="增强for"><a href="#增强for" class="headerlink" title="增强for"></a>增强for</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">基本作用：遍历集合或者数组</span><br><span class="line">格式：</span><br><span class="line">	for(元素类型 变量名:要遍历的集合名或者数组名)&#123;</span><br><span class="line">		变量名代表每一个元素</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">快捷键：</span><br><span class="line">	集合名或者数组名.for</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05for</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;二柱&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;赵六&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s = &quot;</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意：</p>
<p>​	增强for遍历集合时，底层原理是迭代器（因此遍历时不能更改集合长度）</p>
<p>​	增强for遍历数组时，底层原理是普通for</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240722110050634.png" alt="image-20240722110050634"></p>
<p>因此在使用增强for的时候，还是要注意不要触发并发修改异常</p>
</blockquote>
<h3 id="Collections-集合工具类"><a href="#Collections-集合工具类" class="headerlink" title="&#x3D;&#x3D;Collections&#x3D;&#x3D;集合工具类"></a>&#x3D;&#x3D;Collections&#x3D;&#x3D;集合工具类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">概述：集合工具类</span><br><span class="line">特点：构造私有、方法静态</span><br><span class="line"></span><br><span class="line">方法：</span><br><span class="line">	static &lt;T&gt; boolean addAll(Collection&lt;? super Y=T&gt; c, T…… element) -&gt; 批量添加元素</span><br><span class="line">	static void shuffle(List&lt;?&gt; list) -&gt; 将集合的元素顺序打乱</span><br><span class="line">	static &lt;T&gt; void sort(List&lt;T&gt; list) -&gt; 将集合中的元素按照默认规则排序(ASCII码表)</span><br><span class="line">	static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) -&gt; 将集合中的元素按照指定规则排序</span><br></pre></td></tr></table></figure>



<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//static &lt;T&gt; boolean addAll(Collection&lt;? super Y=T&gt; c, T…… element) -&gt; 批量添加元素</span></span><br><span class="line">        Collections.addAll(list,<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;二柱&quot;</span>,<span class="string">&quot;赵六&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//static void shuffle(List&lt;?&gt; list) -&gt; 将集合的元素顺序打乱</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//static &lt;T&gt; void sort(List&lt;T&gt; list) -&gt; 将集合中的元素按照默认规则排序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) -&gt; 将集合中的元素按照指定规则排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>shuffle打乱顺序是随机打乱的，每次运行都不同</p>
<p>sort默认排序是按照ASCII码表排序的，将指定规则拉出来单独说一下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) -&gt; 将集合中的元素按照指定规则排序</span><br><span class="line"></span><br><span class="line">Comparator比较器</span><br><span class="line">	方法：</span><br><span class="line">		int compare(T o1, T o2)</span><br><span class="line">			o1-o2 -&gt; 升序</span><br><span class="line">			o2-o1 -&gt; 降序</span><br></pre></td></tr></table></figure>



<p>示例一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">99</span>,<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">39</span>,<span class="string">&quot;李四&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">29</span>,<span class="string">&quot;王五&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">69</span>,<span class="string">&quot;二柱&quot;</span>));</span><br><span class="line"></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge()- o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Person类是手动定义的，也不用看代码了，大部分是快捷键生成的</p>
<p>注意添加对象的时候不能直接添加，需要new，进行一个有参构造</p>
<p>这里的排序规则使用了匿名内部类，重写了compare方法，使用了年龄的升序排序</p>
<p>为啥，默认会是ASCII码排序呢，因为底层实现了一个Comparable接口</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">接口：Comparable接口</span><br><span class="line">方法：int compareTo(T o) -&gt; this-o(升序)  o-this(降序)</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonTest</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;PersonTest&gt;&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">	……………………………………</span><br><span class="line">    <span class="comment">// 省略构造方法getset，toString</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(PersonTest o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getAge()-o.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Comparable需要传入一个泛型，这里传入了PersonTset，所以下面重写方法comparaTo传入的也是PersonTset类型，这样在对象内提前重写好了排序方法，那么在前面使用PersonTset作为泛型的集合，也就可以使用默认排序方法了。这样也可以理解String默认排序方法是ASCII码表了</span></span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;Arrays中的静态方法</span><br><span class="line">static &lt;T&gt; List&lt;T&gt; asList(T……a) -&gt; 直接指定元素，转存到list集合中</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;List&lt;String&gt; list = Arrays.asList(&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">泛型：&lt;&gt;</span><br><span class="line">作用：</span><br><span class="line">	统一数据类型，防止将来的数据转换异常</span><br><span class="line">	</span><br><span class="line">注意：</span><br><span class="line">	1、泛型中的类型必须是引用数据类型</span><br><span class="line">	2、如果不写泛型，默认Object型</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从使用层面来说，防止数据类型转换异常</span><br><span class="line">从定义层面来说，定义带泛型的类，方法等，将来使用的时候给泛型确定什么类型，泛型就会变成什么类型，凡是涉及到泛型的都会变成确定的类型，代码更灵活</span><br></pre></td></tr></table></figure>



<h4 id="含有泛型的类"><a href="#含有泛型的类" class="headerlink" title="含有泛型的类"></a>含有泛型的类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	public class 类名&lt;E&gt;&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">含有泛型的类是new对象的时候确定类型的，参考ArrayList</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo001fx</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 定义size代表元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个数组，初始长度为10</span></span><br><span class="line">    <span class="keyword">private</span> Object[] obj = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 定义添加方法</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;</span><br><span class="line">        obj[size] = e;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 定义get方法，根据索引，获取元素</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (E) obj[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.toString(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简简单单自己复现一下类似于ArrayList的代码</span></span><br></pre></td></tr></table></figure>





<h4 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	修饰符 &lt;E&gt; 返回值类型 方法名(E e)&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">含有泛型的方法在调用的时候确定类型</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03addAll</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  &lt;E&gt; <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(ArrayList&lt;E&gt; list, E ... e)</span>&#123;</span><br><span class="line">        <span class="comment">// 注意这里的&lt;E&gt;只是一个声明，并不是返回值类型，不要忘了返回值类型</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (E element : list) &#123;</span><br><span class="line">            <span class="comment">// 这里传入的e是一个数组，不能直接添加，要遍历</span></span><br><span class="line">            list.add(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        Demo03addAll.addAll(list,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里的泛型是通过list这个对象传进去的，因为list是有类型的String，被后面代码ArrayList&lt;E&gt; 接收</span></span><br></pre></td></tr></table></figure>



<h4 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	public interface 接口名&lt;E&gt;&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">确定泛型类型：</span><br><span class="line">	1、在实现类的时候还没有确定类型，在new实现类的时候确定类型 -- ArrayList</span><br><span class="line">	2、在实现类的时候就直接确定类型了 -- Scanner</span><br></pre></td></tr></table></figure>



<p>定义接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">myList</span> &lt;E&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样就定义好了一个泛型接口，使用时需要现有实现类，重写方法，再new实现类传入泛型，这里就不演示了，和上面的操作有点类似</span></span><br></pre></td></tr></table></figure>



<p>ArrayList类型就不演示了，看一下在实现类确定类型的，Scnner</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240722140236041.png" alt="image-20240722140236041"></p>
<p>也不用演示了，这里就可以看到，在实现接口的时候确定了类型</p>
<h4 id="泛型的通配符"><a href="#泛型的通配符" class="headerlink" title="泛型的通配符"></a>泛型的通配符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list1= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list1.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list2.add(<span class="number">1</span>);list2.add(<span class="number">2</span>);</span><br><span class="line">        method(list1);</span><br><span class="line">        method(list2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(ArrayList&lt;?&gt; list)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Object o: list)&#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的method方法就用到了通配符 <code>？</code>  但是这种使用比较基础，不写&lt;?&gt;，直接写ArrayList也是可以运行的，整点狠活</p>
<h5 id="泛型的上限下限"><a href="#泛型的上限下限" class="headerlink" title="泛型的上限下限"></a>泛型的上限下限</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">作用：可以规定泛型的范围</span><br><span class="line">上限：</span><br><span class="line">	格式：&lt;? extends 类型&gt;</span><br><span class="line">	含义：？只能接收extends后面的本类型以及子类类型</span><br><span class="line">	</span><br><span class="line">下限：</span><br><span class="line">	格式：&lt;? super 类型&gt;</span><br><span class="line">	含义：？只能接收super后面的本类类型和父类类型</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p>使用这个需要搞清楚类型的子父类关系</p>
<blockquote>
<p>应用场景：</p>
<p>​	1、如果我们在定义类、方法、接口的时候，如果类型不确定，我们可以考虑定义含有泛型的类、方法、接口</p>
<p>​	2、如果类型不确定，但是能知道以后只能传递某个类的继承体系中的子类或者父类，就可以使用泛型通配符</p>
</blockquote>
<h3 id="学以致用"><a href="#学以致用" class="headerlink" title="学以致用"></a>学以致用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; color = Arrays.asList(<span class="string">&quot;♥&quot;</span>,<span class="string">&quot;♣&quot;</span>,<span class="string">&quot;♦&quot;</span>,<span class="string">&quot;♠&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; num = Arrays.asList(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;10&quot;</span>,<span class="string">&quot;J&quot;</span>,<span class="string">&quot;Q&quot;</span>,<span class="string">&quot;K&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; obj = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成牌面</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; color.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">0</span>; i1 &lt; num.size(); i1++) &#123;</span><br><span class="line">                obj.add(color.get(i)+num.get(i1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        obj.add(<span class="string">&quot;大王&quot;</span>);</span><br><span class="line">        obj.add(<span class="string">&quot;小王&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化牌堆</span></span><br><span class="line">        <span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        ArrayList&lt;String&gt; list = demo.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 洗牌</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义玩家</span></span><br><span class="line">        ArrayList&lt;String&gt; p1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; p2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; p3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;ArrayList&lt;String&gt;&gt; rom = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(List.of(p1,p2,p3));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取底牌</span></span><br><span class="line">        ArrayList&lt;String&gt; last = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        last.add(list.remove(<span class="number">53</span>));</span><br><span class="line">        last.add(list.remove(<span class="number">52</span>));</span><br><span class="line">        last.add(list.remove(<span class="number">51</span>));</span><br><span class="line">        System.out.println(last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发牌</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">3</span>==<span class="number">0</span> || i==<span class="number">0</span>)&#123;</span><br><span class="line">                p1.add(list.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">3</span>==<span class="number">1</span>) &#123;</span><br><span class="line">                p2.add(list.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">3</span>==<span class="number">2</span>)&#123;</span><br><span class="line">                p3.add(list.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机地主</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> num.nextInt(<span class="number">3</span>);</span><br><span class="line">        System.out.println(data);</span><br><span class="line">        System.out.println(<span class="string">&quot;请&quot;</span>+rom.get(data)+<span class="string">&quot;玩家选择是否当地主&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入Y或是F&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> sc.next();</span><br><span class="line">            <span class="keyword">if</span> (content.equals(<span class="string">&quot;Y&quot;</span>) || content.equals(<span class="string">&quot;y&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; last.size(); i++) &#123;</span><br><span class="line">                    rom.get(data).add(last.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (content.equals(<span class="string">&quot;F&quot;</span>) || content.equals(<span class="string">&quot;f&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (data&lt;<span class="number">3</span>)&#123;</span><br><span class="line">                    data++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    data = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;非法输入，请重新输入&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样实现了，斗地主的一个牌面生成，取出底牌，发牌以及获取底牌的过程，这只是对学的集合知识简单的应用，并没有要开发游戏，不过闲的没事可以试试看。</p>
<p>这个生成牌面的过程也可以使用数组来解决，都差不多</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] color = <span class="string">&quot;♠-♣-♦-♥&quot;</span>.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">String[] number = <span class="string">&quot;A-2-3-4-5-6-7-8-9-10-J-Q-K&quot;</span>.split(<span class="string">&quot;-&quot;</span>);</span><br></pre></td></tr></table></figure>





<h3 id="红黑树（了解）"><a href="#红黑树（了解）" class="headerlink" title="红黑树（了解）"></a>红黑树（了解）</h3><p><img src="/../%E5%9B%BE%E7%89%87/image-20240722162134895.png" alt="image-20240722162134895"></p>
<p>先说一下排列树：左子树小，右子树大</p>
<p>红黑树规则：</p>
<p>​	1、每个节点必须是红色或者黑色的</p>
<p>​	2、根节点必须是黑色</p>
<p>​	3、如果一个节点没有子节点或者父节点，则该节点相应的指针属性值为Nil，这些Nil视为叶节点，每个叶节点(Nil)是黑色的</p>
<p>​	4、如果某一个节点是红色，那么它的子节点必须是黑色（不能出现两个红色节点相连的情况）</p>
<p>​	5、对每一个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点</p>
<p>红黑树趋近于平衡树，而且数据存储时按照排序树规则存储，查询速度快</p>
<p><a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/RedBlack">https://www.cs.usfca.edu/~galles/visualization/RedBlack</a></p>
<p>一个演示红黑树的网站</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">集合加入红黑树的目的：提高查询效率</span><br><span class="line">HashSet集合：</span><br><span class="line">	数据结构：哈希表</span><br><span class="line">		jdk8之前：哈希表 = 数组+链表</span><br><span class="line">		jdk8之后：哈希表 = 数组+链表+红黑树 -&gt; 目的是提高查询效率</span><br></pre></td></tr></table></figure>



<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set接口并没有对collection接口进行功能上的扩充，而且所有的Set集合底层都是依靠Map实现</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240722233753304.png" alt="image-20240722233753304"></p>
<p>set的所有方法，点开都是map</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set和Map是密切相关的</span><br><span class="line">遍历Map需要先变成单列集合，只能变成set集合</span><br></pre></td></tr></table></figure>



<h4 id="HashSet集合"><a href="#HashSet集合" class="headerlink" title="HashSet集合"></a>HashSet集合</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">概述：是set的实现类</span><br><span class="line">特点：</span><br><span class="line">	1、元素唯一</span><br><span class="line">	2、元素无序</span><br><span class="line">	3、无索引</span><br><span class="line">	4、线程不安全</span><br><span class="line"></span><br><span class="line">数据结构：哈希表</span><br><span class="line">	jdk8之前：哈希表 = 数组+链表</span><br><span class="line">	jdk8之后：哈希表 = 数组+链表+红黑树</span><br><span class="line">	</span><br><span class="line">方法：和collection一模一样</span><br><span class="line"></span><br><span class="line">遍历：</span><br><span class="line">	1、增强for（没有普通for因为不能操作索引）</span><br><span class="line">	2、迭代器</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的无序只是和插入的顺序不同，HashSet是将数据插入之后，利用方法根据哈希表生成一个值，然后根据这个值的大小排序，以链表的方式存储</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashSet&lt;String&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        hashSet.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;赵六&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;二柱&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;赵四&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;刘能&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;我&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;他&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;hashSet = &quot;</span> + hashSet);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; iterator = hashSet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : hashSet) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s = &quot;</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="LinkedHahSet"><a href="#LinkedHahSet" class="headerlink" title="LinkedHahSet"></a>LinkedHahSet</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HashSet的子类</span><br><span class="line">特点：</span><br><span class="line">	1、元素唯一</span><br><span class="line">	2、元素有序</span><br><span class="line">	3、无索引</span><br><span class="line">	4、线程不安全</span><br><span class="line">	</span><br><span class="line">数据结构：哈希表+双向链表</span><br><span class="line">使用：和HashSet一样</span><br></pre></td></tr></table></figure>



<h4 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">概述：是由计算机算出来的一个十进制数，可以看做是对象的地址值</span><br><span class="line">获取对象的哈希值，使用的是Object中的方法</span><br><span class="line">	public native int hashCode()</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240723111733526.png" alt="image-20240723111733526"></p>
<blockquote>
<p>哈希值不一样，内容肯定不一样，但是哈希值一样，内容可能不一样哦</p>
<p>一个特殊案例，“通话”和“重地”哈希值是一样的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240723112136329.png" alt="image-20240723112136329"></p>
</blockquote>
<p>研究一下String重写的hashCode哈希计算源码，看一下 <code>abc</code> 的哈希值是怎么计算出来的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// abc在ASCII码表中分别对应97、98、99</span></span><br><span class="line"><span class="type">byte</span>[] value = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">	<span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; !hashIsZero) &#123;</span><br><span class="line">	    h = isLatin1() ? StringLatin1.hashCode(value)</span><br><span class="line">	                   : StringUTF16.hashCode(value);</span><br><span class="line">	    <span class="keyword">if</span> (h == <span class="number">0</span>) &#123;</span><br><span class="line">	        hashIsZero = <span class="literal">true</span>;</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	        hash = h;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line">==============================</span><br><span class="line">StringLatin1.hashCode(value)底层源码</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">(<span class="type">byte</span>[] value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">byte</span> v : value) &#123;</span><br><span class="line">        h = <span class="number">31</span> * h + (v &amp; <span class="number">0xff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>oxff</code> 是十六进制的255，任何数据和255做与运算都是原值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第一圈：</span><br><span class="line">	h = 31 * 0 + 97   (97)</span><br><span class="line">	</span><br><span class="line">第二圈：</span><br><span class="line">	h = 31 * 97(h) + 98  (3105)</span><br><span class="line">	</span><br><span class="line">第三圈：</span><br><span class="line">	h = 31 * 3105 + 99  (96354)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在计算哈希的时候，有一个定值31，为啥</p>
<p>​	31是一个质数，31可以尽量降低内容不同但是哈希值一样的情况（哈希冲突，哈希碰撞）</p>
<p>​	这是一个统计学问题</p>
</blockquote>
<h4 id="HashSet存储去重过程"><a href="#HashSet存储去重过程" class="headerlink" title="HashSet存储去重过程"></a>HashSet存储去重过程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">先计算元素的哈希值(重写hashCode方法)，再比较内容(重写equals方法)</span><br><span class="line"></span><br><span class="line">过程：</span><br><span class="line">	先比较哈希值，如果哈希值不一样，存储</span><br><span class="line">	如果哈希值一样，比较内容，内容不同存储，内容相同，去重</span><br></pre></td></tr></table></figure>



<p>如果hashSet存储自定义类型数据，就没有去重效果了，因为地址值一定不同，还想要有去重效果，就需要重写hashCode和equals</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(name, person.name) &amp;&amp; Objects.equals(age, person.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：</p>
<p>​	1、如果HashSet存储自定义数据类型，需要重写hashcode和equals方法，让HashSet比较属性的哈希值以及属性的内容</p>
<p>​	2、如果不重写hashCode和equals方法，默认调用的是Object中的方法，不同对象，哈希值一定不一样，就不能去重了</p>
</blockquote>
<h3 id="双列集合"><a href="#双列集合" class="headerlink" title="双列集合"></a>双列集合</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">map是双列集合的顶级接口</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">map的实现类HashMap：</span><br><span class="line">特点：</span><br><span class="line">	1、key唯一，value可重复</span><br><span class="line">	2、无序</span><br><span class="line">	3、无索引</span><br><span class="line">	4、线程不安全</span><br><span class="line">	5、可以存null键，null值</span><br><span class="line">数据结构：哈希表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HashMap的子类LinkedHashMap:</span><br><span class="line">特点：</span><br><span class="line">	1、key唯一，value可重复</span><br><span class="line">	2、有序</span><br><span class="line">	3、无索引</span><br><span class="line">	4、线程不安全</span><br><span class="line">	5、可以存null键，null值</span><br><span class="line">数据结构：哈希表+双向链表</span><br><span class="line"></span><br><span class="line">map的实现类Hashtable</span><br><span class="line">特点：</span><br><span class="line">	1、key唯一，value可重复</span><br><span class="line">	2、无序</span><br><span class="line">	3、无索引</span><br><span class="line">	4、线程安全</span><br><span class="line">	5、不可以存null键，null值</span><br><span class="line">数据结构：哈希表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Hashtable的子类Properties（主要和配置文件结合使用）</span><br><span class="line">特点：</span><br><span class="line">	1、key唯一，value可重复</span><br><span class="line">	2、无序</span><br><span class="line">	3、无索引</span><br><span class="line">	4、线程安全</span><br><span class="line">	5、可以存null键，null值</span><br><span class="line">	6、key和value都是String型的</span><br><span class="line">数据结构：哈希表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">map的实现类TreeMap:</span><br><span class="line">特点：</span><br><span class="line">	1、key唯一，value可重复</span><br><span class="line">	2、可以对key进行排序</span><br><span class="line">	3、无索引</span><br><span class="line">	4、线程不安全</span><br><span class="line">	5、不能存null键，null值</span><br><span class="line">数据结构：红黑树</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240723124842454.png" alt="image-20240723124842454"></p>
<h4 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">概述：双列集合的顶级接口</span><br><span class="line">元素特点：</span><br><span class="line">	元素由键值对组成(key-value)</span><br></pre></td></tr></table></figure>



<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">概述：Map的实现类</span><br><span class="line">特点：</span><br><span class="line">	1、key唯一，value可以重复 -&gt; 如果key重复，会发生value覆盖</span><br><span class="line">	2、无序（针对整数，不会随意打乱顺序）</span><br><span class="line">	3、无索引</span><br><span class="line">	4、线程不安全</span><br><span class="line">	5、可以存null键，null值</span><br><span class="line">数据结构：哈希表</span><br><span class="line"></span><br><span class="line">// PS：感觉像python里面的字典</span><br><span class="line"></span><br><span class="line">方法：</span><br><span class="line">	V put(K key, V value) -&gt; 添加元素，返回的是被覆盖的value</span><br><span class="line">	V remove(Object key) -&gt; 根据key删除键值对，返回的是被删除的键值对的值(value)</span><br><span class="line">	V get(Object key) -&gt; 根据key获取value</span><br><span class="line">	boolean containsKey(Object key) -&gt; 判断集合中是否包含指定的key</span><br><span class="line">	Collection&lt;V&gt; values() -&gt; 获取集合中所有的value，转存到Collection集合中</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	Set&lt;V&gt; keySet() -&gt; 将Map中的key获取出来，转存到Set集合中</span><br><span class="line">	Set&lt;Map, Entry&lt;K, V&gt;&gt; entrySet() -&gt; 获取Map集合中的键值对，转存到Set集合中</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">注意，因为是键值对，因此新建集合是要传入两个泛型，对应key - value</span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;String,String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// V put(K key, V value) -&gt; 添加元素，返回的是被覆盖的value</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> hashMap.put(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;18&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;s1 = &quot;</span> + s1);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> hashMap.put(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;28&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;s2 = &quot;</span> + s2);</span><br><span class="line"></span><br><span class="line">        hashMap.put(<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;38&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;48&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// V remove(Object key) -&gt; 根据key删除键值对，返回的是被删除的键值对的值(value)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> hashMap.remove(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;s3 = &quot;</span> + s3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// V get(Object key) -&gt; 根据key获取value</span></span><br><span class="line">        System.out.println(hashMap.get(<span class="string">&quot;李四&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// boolean containsKey(Object key) -&gt; 判断集合中是否包含指定的key</span></span><br><span class="line">        System.out.println(hashMap.containsKey(<span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Collection&lt;V&gt; values() -&gt; 获取集合中所有的value，转存到Collection集合中</span></span><br><span class="line">        Collection&lt;String&gt; c1 = hashMap.values();</span><br><span class="line">        System.out.println(c1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">概述：HashMap的子集</span><br><span class="line">特点：</span><br><span class="line">	1、key唯一，value可以重复 -&gt; 如果key重复，会发生value覆盖</span><br><span class="line">	2、有序</span><br><span class="line">	3、无索引</span><br><span class="line">	4、线程不安全</span><br><span class="line">	5、可以存null键，null值</span><br><span class="line"></span><br><span class="line">数据结构：哈希表+双向链表</span><br><span class="line">方法：和HashMap一样</span><br></pre></td></tr></table></figure>



<h5 id="遍历的两种方式"><a href="#遍历的两种方式" class="headerlink" title="遍历的两种方式"></a>遍历的两种方式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">遍历就需要用到没有演示的两个方法了</span><br><span class="line">	Set&lt;V&gt; keySet() -&gt; 将Map中的key获取出来，转存到Set集合中</span><br><span class="line">	Set&lt;Map, Entry&lt;K, V&gt;&gt; entrySet() -&gt; 获取Map集合中的键值对，转存到Set集合中</span><br><span class="line">	</span><br><span class="line">之前说过，Map是没法遍历的，需要转换成set</span><br></pre></td></tr></table></figure>



<p>第一种方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = hashMap.keySet();</span><br><span class="line"><span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">    System.out.println(s + <span class="string">&quot; = &quot;</span> + hashMap.get(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先获取所有的key，遍历key，再查找到对应的value</p>
</blockquote>
<p>第二种方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;String,String&gt;&gt; set1 = hashMap.entrySet();</span><br><span class="line">System.out.println(<span class="string">&quot;set1 = &quot;</span> + set1);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : set1) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    System.out.println(key+<span class="string">&quot;...&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取记录key和value的对象，Map接口中的静态内部接口：Map.Entry</p>
<p>调用Map.Entry中的两个方法</p>
<p>getKey()   getValue()</p>
<p>方法就顾名思义吧</p>
</blockquote>
<h5 id="Map去重"><a href="#Map去重" class="headerlink" title="Map去重"></a>Map去重</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set执行add的时候，首先就是map.put(e, PRESENT) 把要插入的值作为key，而进行对象类型去重时，则是需要重写hashCode和equals方法</span><br><span class="line"></span><br><span class="line">Map对象去重和set一样，都是重写两个方法，原因就是Set的值是保存在Map的key的位置的</span><br></pre></td></tr></table></figure>



<h5 id="Map练习"><a href="#Map练习" class="headerlink" title="Map练习"></a>Map练习</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">经典python二级，字典统计字词个数</span><br><span class="line"></span><br><span class="line">步骤：</span><br><span class="line">	1、创建HashMap</span><br><span class="line">	2、遍历字符串，取出每个字母</span><br><span class="line">	3、判断map中是否有该字母</span><br><span class="line">	4、如果没有，直接存储，如果有获取对应的value，然后加一</span><br><span class="line">	5、重新保存到集合</span><br></pre></td></tr></table></figure>



<p>统计输入的字母个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">fori</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> sc.next();</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] c1 = s1.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : c1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hashMap.containsKey(c)) &#123;</span><br><span class="line">                hashMap.put(<span class="string">&quot;c&quot;</span>,<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> hashMap.get(c);</span><br><span class="line">                value++;</span><br><span class="line">                hashMap.put(c+<span class="string">&quot;&quot;</span>,value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;hashMap = &quot;</span> + hashMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>这个东西让我想到了备考python二级时经常碰见的东西</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tem)):</span><br><span class="line">	d[tem[i]] = d.get([tem[i]] , <span class="number">0</span> ) + <span class="number">1</span></span><br><span class="line">//用于统计数据</span><br><span class="line"></span><br><span class="line">d.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>] , value=<span class="literal">True</span>)</span><br><span class="line">//按照升序排序</span><br></pre></td></tr></table></figure>



<p>所以我感觉应该有精简的方法，于是就问了一把AI</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> sc.next();</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] c1 = s1.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : c1) &#123;</span><br><span class="line">            hashMap.merge(c+<span class="string">&quot;&quot;</span>, <span class="number">1</span>, Integer::sum);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;hashMap = &quot;</span> + hashMap);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里使用了merge方法代替了if-else</p>
<p>merge()方法接受三个参数：键、需要合并的值、以及一个函数</p>
<p>​	c+“”  -&gt;  因为定义的是字符串，c是char类型，简单转换一下</p>
<p>​	1  -&gt;   这个是要操作的值，为1</p>
<p>​	Integer::sum  -&gt;  顾名思义了直接，就是数字求和</p>
<p>这行代码的作用和上面是一样的，如果键不存在，插入键值对，并将值设为1，如果存在+1</p>
</blockquote>
<p>继续操作一下之前的那个斗地主，之前是利用ArrayList集合来实现的，但是还没有排序，扑克牌是用一个符号和数字组成，如果说再拆开排序不是不行，感觉很笨。因为map的key数字是不会打乱的，我们就可以对这些字符串按照牌面的大小，由数字进行一个排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 利用key按牌面大小排序</span></span><br><span class="line">        HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>, <span class="string">&quot;大王&quot;</span>);</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;小王&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String[] color = <span class="string">&quot;♠-♣-♦-♥&quot;</span>.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        String[] number = <span class="string">&quot;2-A-K-Q-J-10-9-8-7-6-5-4-3&quot;</span>.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">0</span>; i1 &lt; number.length; i1++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; color.length; i++) &#123;</span><br><span class="line">                map.put(j, color[i] + number[i1]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;map = &quot;</span> + map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将key值添加到ArrayList集合中，因为有序，可以打乱</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">54</span>; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 洗牌</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义玩家</span></span><br><span class="line">        ArrayList&lt;Integer&gt; p1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; p2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; p3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取底牌</span></span><br><span class="line">        ArrayList&lt;Integer&gt; last = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        last.add(list.remove(<span class="number">53</span>));</span><br><span class="line">        last.add(list.remove(<span class="number">52</span>));</span><br><span class="line">        last.add(list.remove(<span class="number">51</span>));</span><br><span class="line">        System.out.println(last);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发牌</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                p1.add(list.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                p2.add(list.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">2</span>) &#123;</span><br><span class="line">                p3.add(list.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 整理手牌，获得手牌</span></span><br><span class="line">        Collections.sort(p1);</span><br><span class="line">        Collections.sort(p2);</span><br><span class="line">        Collections.sort(p3);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> lookPoker(p1,map);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> lookPoker(p2,map);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> lookPoker(p3,map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备随机玩家</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; rom = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(List.of(p1,p2,p3));</span><br><span class="line">        <span class="type">Random</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> num.nextInt(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;请&quot;</span> + rom.get(data) + <span class="string">&quot;玩家选择是否当地主&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机的玩家开始选择是否需要底牌</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入Y或是F&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> sc.next();</span><br><span class="line">            <span class="keyword">if</span> (content.equals(<span class="string">&quot;Y&quot;</span>) || content.equals(<span class="string">&quot;y&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; last.size(); i++) &#123;</span><br><span class="line">                    rom.get(data).add(last.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (content.equals(<span class="string">&quot;F&quot;</span>) || content.equals(<span class="string">&quot;f&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (data &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                    data++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    data = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;非法输入，请重新输入&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义整理手牌的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">lookPoker</span><span class="params">(ArrayList&lt;Integer&gt; list, HashMap&lt;Integer, String&gt; map)</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (Integer key : list) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            e.append(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> e.toString();</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个程序写的还是有瑕疵的，因为使用了字符串来返回手牌情况，考虑到后面获取底牌和出牌，字符串并不是很好操作</p>
<p>有时间继续优化</p>
</blockquote>
<h3 id="哈希表存储的过程"><a href="#哈希表存储的过程" class="headerlink" title="哈希表存储的过程"></a>哈希表存储的过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">哈希表存储数据去重复的过程</span><br><span class="line">	1、先比较元素的哈希值hashCode，再比较内容equals</span><br><span class="line">	2、如果哈希值不一样，存</span><br><span class="line">	3、如果内容不一样，存</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240723225734056.png" alt="image-20240723225734056"></p>
<p>计算出 <code>通话</code> 和 <code>重地</code> 的存储位置相同，这个时候两者之间产生了链表关系，jdk版本不同，jdk8之前数据关系是 <code>哈希表 = 数组+链表</code> ，jdk8之后是 <code>哈希表 = 数组+链表+红黑树</code> 了。</p>
<p>同一存储位置，数据过多时会变成红黑树。加快查询速度</p>
<blockquote>
<p>注意：</p>
<p>​	1、哈希表中的数组默认长度为&#x3D;&#x3D;16&#x3D;&#x3D;，但是是第一次put的时候数组才会被初始化为长度为16的数组（和ArrayList中的add一样）</p>
<p>​	2、哈希表中有一个加载因子：&#x3D;&#x3D;0.75F&#x3D;&#x3D;</p>
<p>​		含义是：数组存储达到百分之七十五的时候，扩容</p>
<p>​		&#x3D;&#x3D;扩容两倍&#x3D;&#x3D;</p>
<p>​	3、如果链表长度达到&#x3D;&#x3D;8&#x3D;&#x3D;，并且数组容量大于等于&#x3D;&#x3D;64&#x3D;&#x3D;的时候，链表自动转成红黑树</p>
<p>​	4、如果删除元素，元素个数小于等于&#x3D;&#x3D;6&#x3D;&#x3D;，红黑树自动转回链表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">default_initial_capacity:HashMap默认容量 16</span><br><span class="line">default_1oad_factor:HashMap默认加载因子 0.75F</span><br><span class="line">thresho1d:扩容的临界值  等于  容量*0.75=12  第一次扩容</span><br><span class="line">treeify_thresho1d:链表长度默认值，转为红黑树：8</span><br><span class="line">min_treeify_capacity:链表被树化时最小的数组容量：64</span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="哈希表底层源码"><a href="#哈希表底层源码" class="headerlink" title="哈希表底层源码"></a>哈希表底层源码</h3><p><img src="/../%E5%9B%BE%E7%89%87/image-20240723235751452.png" alt="image-20240723235751452"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240724000911543.png" alt="image-20240724000911543"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240724002151190.png" alt="image-20240724002151190"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240724002356860.png" alt="image-20240724002356860"></p>
<p>举的例子不是很经典，下面换成 <code>abc</code> <code>通话</code> <code>重地</code></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240724004012437.png" alt="image-20240724004012437"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240724004121059.png" alt="image-20240724004121059"></p>
<p>可以看到数组长度小于64的时候不进行树化，先对数组进行扩容。下面的else-if是树化的代码</p>
<p>从底层代码了解了一下数据存储的过程，我们也可以手动指定加载因子和容量，也就是有参构造</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(5,0.5F);</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240724010223543.png" alt="image-20240724010223543"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tableSizeFor方法，怎么说呢，就是你传入的数字，并不是按你的意愿创造这个大小的容量的，实测，容量大小为大于等于你传入数字的2的倍数</p>
<p>8 4 2 1 规则</p>
<p>目的是为了尽量减少哈希碰撞</p>
<h4 id="索引问题"><a href="#索引问题" class="headerlink" title="索引问题"></a>索引问题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">问题1：哈希表的组成明明有索引，但是为什么set和map中没有呢</span><br><span class="line"></span><br><span class="line">	哈希表中虽然有索引，但是set和map却没有索引，因为哈希表还有链表的存在，存数据的时候有可能在同一索引下形成链表，这个时候去去索引，就会出现问题，因为不是一一对应的，不知道该取出哪一个</span><br><span class="line">	</span><br><span class="line">问题2：为啥说HashMap是无序的，LinkedHashMap是有序的呢？</span><br><span class="line">	</span><br><span class="line">	HashMap底层哈希表为单向链表</span><br><span class="line">	LinkedHashMap底层在哈希表的基础上加了一条双向链表</span><br></pre></td></tr></table></figure>



<p>单向链表：&#x3D;&#x3D;从索引0开始往后一条链表一条链表的遍历&#x3D;&#x3D;</p>
<p>HashMap，数据存储时有存储位置，，而且存储位置可能是同一个，这样遍历的时候从0索引开始向后遍历，而不是按照存储的顺序遍历，如果遇到一个位置上有多个元素的情况，先把这条链表遍历完，再进入下一个位置，这样就导致了无序，但其实遍历出来的东西还有有一定的顺序的，并不是完全意义上的无序</p>
<p>双向链表：从第一个节点开始遍历，以此遍历后面的元素</p>
<p>这个和双向链表和for循环顺序有关系，因为双向链表是前后相连的。</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240724012739416.png" alt="image-20240724012739416"></p>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">概述：是set的实现类</span><br><span class="line">特点：</span><br><span class="line">	1、对元素进行排序</span><br><span class="line">	2、无索引</span><br><span class="line">	3、不能存null</span><br><span class="line">	4、线程不安全</span><br><span class="line">	5、元素唯一</span><br><span class="line">	</span><br><span class="line">数据结构：红黑树</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">构造方法:</span><br><span class="line">	TreeSet() -&gt; 构造一个新的空set，该set根据其元素的自然顺序进行排序 -&gt; ASCII</span><br><span class="line">	TreeSet(Comparator&lt;? super E&gt; comparator) -&gt; 构造一个空TreeSet，它根据比较器进行排序</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeSet&lt;String&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        treeSet.add(<span class="string">&quot;c.qwe&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;a.qwe&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;d.qwe&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;b.qwe&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;treeSet = &quot;</span> + treeSet);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;============================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        TreeSet&lt;person&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(person o1, person o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge()- o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;二柱&quot;</span>,<span class="number">27</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">72</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;张麻子&quot;</span>,<span class="number">19</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;set = &quot;</span> + set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">概述：map的实现类</span><br><span class="line">特点：</span><br><span class="line">	1、对key进行排序</span><br><span class="line">	2、无索引</span><br><span class="line">	3、key唯一</span><br><span class="line">	4、线程不安全</span><br><span class="line">	5、不能存null</span><br><span class="line">	</span><br><span class="line">数据结构：红黑树</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">构造方法：</span><br><span class="line">	TreeMap() -&gt; 使用键的自然顺序构造一个新的、空的树映射 -&gt; ASCII</span><br><span class="line">	TreeMap(Comparator&lt;? super E&gt; comparator) -&gt; 构造一个，新的、空的树映射，该映射根据给定比较器进行排序</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeMap&lt;String, String&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        treeMap.put(<span class="string">&quot;c&quot;</span>,<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;d&quot;</span>,<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;b&quot;</span>,<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;treeMap = &quot;</span> + treeMap);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;============================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        TreeMap&lt;person, String&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(person o1, person o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge()-o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>), <span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;二柱&quot;</span>,<span class="number">27</span>), <span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">72</span>), <span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;张麻子&quot;</span>,<span class="number">19</span>), <span class="string">&quot;北京&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;map = &quot;</span> + map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Hashtable和Vector-了解"><a href="#Hashtable和Vector-了解" class="headerlink" title="Hashtable和Vector(了解)"></a>Hashtable和Vector(了解)</h3><h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map的实现类</span><br><span class="line">特点：</span><br><span class="line">	1、key唯一，value可重复</span><br><span class="line">	2、无序</span><br><span class="line">	3、无索引</span><br><span class="line">	4、线程安全</span><br><span class="line">	5、不能存null键，null值</span><br><span class="line">	</span><br><span class="line">数据类型：哈希表</span><br></pre></td></tr></table></figure>

<blockquote>
<p>HashMap和Hashtable的区别：</p>
<p>​	相同点：元素无序，无索引，key唯一</p>
<p>​	不同点：HashMap线程不安全，Hashtable线程安全</p>
<p>​				   HashMap可以存储null键null值，Hashtable不能</p>
<p>Hashtable的一些具体方法和HashMap一样</p>
</blockquote>
<h4 id="Vector集合"><a href="#Vector集合" class="headerlink" title="Vector集合"></a>Vector集合</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">概述：list接口的实现类</span><br><span class="line">特点：</span><br><span class="line">	1、元素有序</span><br><span class="line">	2、有索引</span><br><span class="line">	3、元素可重复</span><br><span class="line">	4、线程安全</span><br><span class="line">	</span><br><span class="line">数据结构：数组</span><br><span class="line"></span><br><span class="line">如果用空参构造创建对象，数组初始容量为10，自动扩容2倍</span><br><span class="line">如果初始容量和容量增量，扩容就是现有容量+容量增量</span><br></pre></td></tr></table></figure>

<p>使用方式和ArrayList相似</p>
<blockquote>
<p>源码分析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector() 构造一个空向量，使其内部数据数组的大小为10，其标准容量增量为零</span><br><span class="line">Vector(int initialcapacity, int capacityIncrement) 使用指定的初始容量和容量增量构造一个空的向量</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">int</span> capacityIncrement)</span> &#123;</span><br><span class="line"> <span class="built_in">super</span>();</span><br><span class="line"> <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                        initialCapacity);</span><br><span class="line"> <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity]; <span class="comment">// 长度为10的数组</span></span><br><span class="line"> <span class="built_in">this</span>.capacityIncrement = capacityIncrement; <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一点就是和ArrayList不一样的点，ArrayList对象new出来长度为0，只要第一个add的时候才会扩容到10，而Vector新new出来的容量就是10</p>
<p>看一下扩容的具体代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line"> modCount++;</span><br><span class="line"> add(e, elementData, elementCount);</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add方法是同步方法，线程安全的表现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e, Object[] elementData, <span class="type">int</span> s)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">     elementData = grow();</span><br><span class="line"> elementData[s] = e;</span><br><span class="line"> elementCount = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要扩容，调用grow方法 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line"> <span class="keyword">return</span> grow(elementCount + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="type">int</span> minCapacity) &#123;</span><br><span class="line"> <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length; <span class="comment">// 10</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> ArraysSupport.newLength(oldCapacity,</span><br><span class="line">         minCapacity - oldCapacity, <span class="comment">/* minimum growth */</span></span><br><span class="line">         capacityIncrement &gt; <span class="number">0</span> ? capacityIncrement : oldCapacity</span><br><span class="line">                                    <span class="comment">/* preferred growth */</span>);</span><br><span class="line"><span class="comment">// 经过一个三元运算符运算，newCapacity为20</span></span><br><span class="line"> <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>再来看有参构造</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240724121834301.png" alt="image-20240724121834301"></p>
<p>指定容量增量为5之后，再次扩容就会扩容到15</p>
</blockquote>
<h3 id="Properties集合（属性集）"><a href="#Properties集合（属性集）" class="headerlink" title="Properties集合（属性集）"></a>Properties集合（属性集）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">概述：Hashtable的子类</span><br><span class="line">特点：</span><br><span class="line">	1、key唯一，value可重复</span><br><span class="line">	2、无序</span><br><span class="line">	3、无索引</span><br><span class="line">	4、线程安全</span><br><span class="line">	5、不能存null键，null值</span><br><span class="line">	6、Properties的key和value类型默认为String</span><br><span class="line">	</span><br><span class="line">数据结构：哈希表</span><br><span class="line"></span><br><span class="line">特有方法：</span><br><span class="line">	Properties的一套方法和Map很相近，但也有特有方法</span><br><span class="line">	Object setProperty(String key, String value) -&gt; 存键值对</span><br><span class="line">	String getProperty(String key) -&gt; 根据key获取value值</span><br><span class="line">	Set&lt;String&gt; stringPropertyNames() -&gt; 获取所有的key，保存到set集合中，相当于keySet方法</span><br><span class="line">	void load(InputStream inStream) -&gt; 将流中的数据加载到Properties集合中(IO流使用，现在不说)</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">        properties.setProperty(<span class="string">&quot;root&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;123456&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;root&quot;</span>));</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set = properties.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">            System.out.println(properties.getProperty(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="集合嵌套"><a href="#集合嵌套" class="headerlink" title="集合嵌套"></a>集合嵌套</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">之前写斗地主的时候，问AI就用到这个嵌套了</span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; p1 = new ArrayList&lt;&gt;();</span><br><span class="line">ArrayList&lt;String&gt; p2 = new ArrayList&lt;&gt;();</span><br><span class="line">ArrayList&lt;String&gt; p3 = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">ArrayList&lt;ArrayList&lt;String&gt;&gt; rom = new ArrayList&lt;&gt;(List.of(p1,p2,p3));</span><br></pre></td></tr></table></figure>

<p>这东西就这么存进去了，如果要遍历的话，可以遍历大集合，再遍历小集合取出元素</p>
<p>集合嵌套的样式有点多，但是主要的就是泛型传的对，遍历拿得出就可以了，没啥特别要说的</p>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">计算机常识：</span><br><span class="line">	1、以.jpg结尾的一定是图片吗？</span><br><span class="line">		也可能是文件夹</span><br><span class="line">		</span><br><span class="line">	2、什么是文本文档</span><br><span class="line">		用记事本打开，人能看懂的东西（word打开就看不懂）</span><br><span class="line">		</span><br><span class="line">	3、E:\Idea\io\1.jpg 中的1.jpg的父路径是谁？</span><br><span class="line">		E:\Idea\io 这个是父路径 io 是父级文件夹</span><br><span class="line">		</span><br><span class="line">	4、分隔符</span><br><span class="line">		a.路径名称分隔符</span><br><span class="line">			Windows: \</span><br><span class="line">			Linux： /</span><br><span class="line">		b.路径分隔符：一个路径和其他路径之间的分隔符</span><br><span class="line">			;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">概述：文件和目录路径名的抽象表示</span><br><span class="line">简单理解：</span><br><span class="line">	在创建File对象的时候，需要传入一个路径，这个路径定位到哪个文件夹或者文件上，我们的File就代表哪个对象</span><br></pre></td></tr></table></figure>



<h4 id="File使用"><a href="#File使用" class="headerlink" title="File使用"></a>File使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">File的静态成员：</span><br><span class="line">	static String pathSeparator:与系统有关的路径分隔符，为了方便，它被表示为一个字符串</span><br><span class="line">	static String separator:与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">这俩东西的作用就是为了实现一次编写，导出运行，可以在不同操作系统中运行</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">File的构造方法</span><br><span class="line"></span><br><span class="line">File(String parent, String child) 根据所填写的路径创建File对象</span><br><span class="line">	parent：父路径</span><br><span class="line">	child：子路径</span><br><span class="line">	</span><br><span class="line">File(File parent, String child) 根据所填写的路径创建File对象</span><br><span class="line">	parent：父路径，是一个File对象</span><br><span class="line">	child：子路径</span><br><span class="line">	</span><br><span class="line">File(String pathname)  根据所填写的路径创建File对象</span><br><span class="line">	pathname：直接指定路径</span><br></pre></td></tr></table></figure>

<blockquote>
<p>细节，传递的路径可以是不存在的，但是传递不存在的路径，没有什么意义</p>
</blockquote>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><h5 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String getAbsolutePath() -&gt; 获取File的绝对路径-&gt;带盘符的路径</span><br><span class="line">StringgetPath() -&gt; 获取的是封装路径-&gt;newFile对象的时候写的啥路径，获取的就是啥路径</span><br><span class="line">String getName() -&gt; 获取的是文件或者文件夹名称</span><br><span class="line">long length() -&gt; 获取的是文件的长度-&gt;文件的字节数</span><br></pre></td></tr></table></figure>



<h5 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">boolean createNewFile() -&gt; 创建文件</span><br><span class="line">	如果要创建的文件之前有，创建失败，返回false</span><br><span class="line">	如果要创建的文件之前没有，创建成功，返回true</span><br><span class="line"></span><br><span class="line">boolean mkdirs() -&gt; 创建文件夹（目录）既可以创建多级文件夹，还可以创建单级文件夹</span><br><span class="line">	如果要创建的文件夹之前有，创建失败，返回false</span><br><span class="line">	如果要创建的文件夹之前没有，创建成功，返回true</span><br></pre></td></tr></table></figure>



<h5 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boolean delete -&gt; 删除文件或者文件夹</span><br><span class="line">    1、不会移到回收站，直接删除</span><br><span class="line">    2、只能删除空文件夹</span><br></pre></td></tr></table></figure>



<h5 id="判断方法-1"><a href="#判断方法-1" class="headerlink" title="判断方法"></a>判断方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boolean isDirectory() -&gt; 判断是否为文件夹</span><br><span class="line">boolean isFile() -&gt; 判断是否为文件</span><br><span class="line">boolean exists() -&gt; 判断文件或者文件夹是否存在</span><br></pre></td></tr></table></figure>



<h5 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String[] 1ist() -&gt; 遍历指定的文件夹，返回的是string数组</span><br><span class="line">File[] listFiles() -&gt; 追历指定的文件夹，返回的是File数组 -&gt; 这个推荐使用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">listFiles方法底层还是list方法</span><br><span class="line">	调用list方法，遍历文件夹，返回一个String数组，遍历数组，将数组中的内容一个一个封装到File对象中，然后再将File对象放到File数组中</span><br><span class="line">	</span><br><span class="line">注意：</span><br><span class="line">	遍历文件夹，只会遍历文件夹内的文件，如果还有子级文件夹不会遍历，但是会遍历出文件夹名</span><br></pre></td></tr></table></figure>



<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 三种构造方法</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\新桌面&quot;</span>,<span class="string">&quot;IO&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\新桌面&quot;</span>),<span class="string">&quot;IO&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\新桌面\\IO\\1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取方法</span></span><br><span class="line">        System.out.println(f1.getAbsoluteFile()); <span class="comment">// 获取绝对路径</span></span><br><span class="line">        System.out.println(f2.getPath()); <span class="comment">// 获取封装路径</span></span><br><span class="line">        System.out.println(f1.getName()); <span class="comment">// 获取文件或者文件夹名称</span></span><br><span class="line">        System.out.println(f3.length()); <span class="comment">// 获取文件长度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建方法</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\新桌面\\IO\\10.txt&quot;</span>);</span><br><span class="line">        System.out.println(f4.createNewFile());</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\新桌面\\IO\\bb&quot;</span>);</span><br><span class="line">        System.out.println(f5.mkdirs());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除方法</span></span><br><span class="line">        System.out.println(f4.delete());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断方法</span></span><br><span class="line">        System.out.println(f5.isDirectory());</span><br><span class="line">        System.out.println(f5.isFile());</span><br><span class="line">        System.out.println(f4.exists());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        String[] s1 = f1.list();</span><br><span class="line">        <span class="keyword">for</span> (String s : s1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s = &quot;</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        File[] s2 = f1.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : s2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;file = &quot;</span> + file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>小练习，遍历目录下的所有txt文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 指定文件夹</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\新桌面\\IO&quot;</span>);</span><br><span class="line">        method(f1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(File f1)</span>&#123;</span><br><span class="line">        File[] f2 = f1.listFiles();</span><br><span class="line">        <span class="comment">// 遍历文件夹</span></span><br><span class="line">        <span class="keyword">for</span> (File file : f2) &#123;</span><br><span class="line">            <span class="comment">// 判断是否是文件，是文件判断是否是txt文件</span></span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> file.getName();</span><br><span class="line">                <span class="keyword">if</span> (name.endsWith(<span class="string">&quot;.txt&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不是文件，即使文件夹，重新调用方法，遍历文件夹</span></span><br><span class="line">                method(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说一下相对路径的写法，要从项目的根目录下面开始写，因为如果直接就创建一个1.txt这个时候文件是生成在项目的根目录下的和out目录同级。</p>
</blockquote>
<h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><h4 id="IO流介绍"><a href="#IO流介绍" class="headerlink" title="IO流介绍"></a>IO流介绍</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">单词：</span><br><span class="line">	Output：输出</span><br><span class="line">	Input：输入</span><br><span class="line">	</span><br><span class="line">	write：写入</span><br><span class="line">	read：读取</span><br><span class="line">	</span><br><span class="line">IO流：</span><br><span class="line">	将一个设备上的数据传输到另一个设备上，称为IO流技术</span><br><span class="line">	</span><br><span class="line">学IO流的目的：</span><br><span class="line">	集合和数组都能存储数据，但是这两个都是临时存储（代码运行完毕，集合和数组就从内存中释放了，数据也就不存在了），所以集合和数组不能永久保存数据。这个时候就需要IO流，将数据保存到文件里</span><br></pre></td></tr></table></figure>



<h4 id="IO流的流向"><a href="#IO流的流向" class="headerlink" title="IO流的流向"></a>IO流的流向</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">针对于se阶段的IO</span><br><span class="line">输入流：将数据从硬盘上读到内存中  Input</span><br><span class="line">输出流：从内存出发，将数据写到硬盘上 Output</span><br><span class="line"></span><br><span class="line">要是从电脑和电脑之间做数据传输，就是相对的</span><br><span class="line">	发数据的一方：输出</span><br><span class="line">	收数据的一方：输入</span><br></pre></td></tr></table></figure>



<h4 id="IO流分类"><a href="#IO流分类" class="headerlink" title="IO流分类"></a>IO流分类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">字节流：万能流，一切皆字节</span><br><span class="line">	字节输出流： OutputStream 抽象类</span><br><span class="line">	字节输入流： InputStream 抽象类</span><br><span class="line">字符流：专门操作文本文档</span><br><span class="line">	字符输出流： Writer 抽象类</span><br><span class="line">	字符输入流： Reader 抽象类</span><br></pre></td></tr></table></figure>



<h4 id="字节输出流"><a href="#字节输出流" class="headerlink" title="字节输出流"></a>字节输出流</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">概述：OutputStream 抽象类</span><br><span class="line">	子类：FileOutputStream</span><br><span class="line">	</span><br><span class="line">作用：往硬盘上写数据</span><br><span class="line"></span><br><span class="line">构造：</span><br><span class="line">	FileOutputStream(File file);</span><br><span class="line">	FileOutputStream(String name)</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">特点：</span><br><span class="line">	1、指定的文件如果没有，会自动创建</span><br><span class="line">	2、如果有这个文件，会覆盖掉</span><br><span class="line">	</span><br><span class="line">	// python的open(&quot;w&quot;)模式</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">方法：</span><br><span class="line">	void write(int b)  一次写一个字节</span><br><span class="line">	void write(byte[] b)  一次写一个字节数组</span><br><span class="line">	void write(byte[] b,int off，int len) 一次写一个字节数组一部分</span><br><span class="line">			b：写的数组</span><br><span class="line">			off：从数组的哪个索引开始写</span><br><span class="line">			len：写多少个</span><br><span class="line">	void close() -&gt; 手动关闭</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">注意：写是按照字节写的，保存到文件中，用记事本打开，写的数字就会按照ASCII码表翻译</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        method01();</span><br><span class="line">        method02();</span><br><span class="line">        method03();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method01</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;mondeule01\\1.txt&quot;</span>);</span><br><span class="line">        fos.write(<span class="number">97</span>);</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method02</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;mondeule01\\1.txt&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] by = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>,<span class="number">101</span>&#125;;</span><br><span class="line">        fos.write(by);</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method03</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;mondeule01\\1.txt&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] by = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>,<span class="number">101</span>&#125;;</span><br><span class="line">        fos.write(by,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240724223841431.png" alt="image-20240724223841431"></p>
<blockquote>
<p>这样的方法多少有点原始人了，想点流弊的，字符串有一个方法，可以转成byte类型，用它就行了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fos.write(<span class="string">&quot;abcde&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>


</blockquote>
<h5 id="追加模式"><a href="#追加模式" class="headerlink" title="追加模式"></a>追加模式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FileoutputStream(String name，boolean append)</span><br><span class="line">	append等于true -&gt; 实现续写追加</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">换行：</span><br><span class="line">	1、windows：\r\n 或者 \n  -&gt; 占两个字节</span><br><span class="line">	2、Linux：\n</span><br><span class="line">	3、mac os：\r</span><br></pre></td></tr></table></figure>



<h4 id="字节输入流（只读模式）"><a href="#字节输入流（只读模式）" class="headerlink" title="字节输入流（只读模式）"></a>字节输入流（只读模式）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">概述：InputStream 抽象类</span><br><span class="line">	子类：FileInputStream</span><br><span class="line">	</span><br><span class="line">作用：读数据，将数据从硬盘上读到内存中来</span><br><span class="line"></span><br><span class="line">构造：</span><br><span class="line">	FileInputStream(File file)</span><br><span class="line">	FileInputStream(String path)</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">方法：</span><br><span class="line">	int read()  一次读一个字节，返回的是读取的字节</span><br><span class="line">	int read(byte[] b)  一次读取一个字节数组，返回的是读取的字节个数</span><br><span class="line">	int read(byte[] b, int off, int len)  一次读取一个字节数组的一部分，返回的是读取的字节个数</span><br><span class="line">	void close() 关闭资源文件</span><br></pre></td></tr></table></figure>



<h5 id="一次只读一个"><a href="#一次只读一个" class="headerlink" title="一次只读一个"></a>一次只读一个</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read01</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;mondeule01\\1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*int data1 = fis.read();</span></span><br><span class="line"><span class="comment">    System.out.println(data1);</span></span><br><span class="line"><span class="comment">    int data2 = fis.read();</span></span><br><span class="line"><span class="comment">    System.out.println(data2);</span></span><br><span class="line"><span class="comment">    int data3 = fis.read();</span></span><br><span class="line"><span class="comment">    System.out.println(data3);*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 太慢了，来个循环</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> ((len = fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;len = &quot;</span> + len);</span><br><span class="line">        System.out.println((<span class="type">char</span>) len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有一个点就是，超出字节长度时再次读取也可以读取到，但是读出的数是 <code>-1</code> ，这个时候就利用while来读取内容了，如果遇到-1就停止，因为读出来的是ASCII码的形态，可以强转成char数组，显示字母</p>
<p>注意：</p>
<p>​	1、一个流对象，读完只会就不能再读了；除非再new一个新对象</p>
<p>​	2、流关闭之后，流对象不能继续使用了</p>
</blockquote>
<h5 id="读出-1问题"><a href="#读出-1问题" class="headerlink" title="读出-1问题"></a>读出-1问题</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每个文件末尾都会有一个“结束标记”，这个“结束标记”看不见，摸不着</span><br><span class="line">而read()方法规定，如果读取到了文件的结束标记，方法返回-1</span><br><span class="line">如果文本中本来有-1，也会拆开出现，先是-再是1</span><br></pre></td></tr></table></figure>



<h5 id="一次读一个数组"><a href="#一次读一个数组" class="headerlink" title="一次读一个数组"></a>一次读一个数组</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;mondeule01\\1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 创建一个数组：byte[]</span></span><br><span class="line"><span class="comment">        *   1.创建的数组相当于一个临时存储区域，我们要读取的内容会临时保存</span></span><br><span class="line"><span class="comment">        *     到数组中然后我们再从数组中将数据获取</span></span><br><span class="line"><span class="comment">        *   2.数组长度定为多少，每次读取多少个，一般情况下数组长度定为1024</span></span><br><span class="line"><span class="comment">        *     或者1024的倍数如果剩下的字节不够数组长度了，那么就最后有多少</span></span><br><span class="line"><span class="comment">        *     读多少</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        byte[] bytes = new byte[2];</span></span><br><span class="line"><span class="comment">//        int len1 = fis.read(bytes);</span></span><br><span class="line"><span class="comment">//        System.out.println(len1);</span></span><br><span class="line"><span class="comment">//        System.out.println(new String(bytes, 0 ,len1));</span></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span> ,len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意这里之所以使用长度为2的数组是想说明一个问题，读取完时候输出成字符串形式的时候</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(new String(bytes, 0 ,len));</span><br></pre></td></tr></table></figure>

<p>一定要使用len来限制长度，因为如果上一个读出cd，这一从读取两个，只拿到了e，这个时候e将c覆盖掉，但是d还在哪里，这个时候输出整个数组的话，就会出现问题，也是一个小细节</p>
</blockquote>
<h4 id="实现文件复制"><a href="#实现文件复制" class="headerlink" title="实现文件复制"></a>实现文件复制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">复制一个图片吧</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\新桌面\\IO\\1.jpg&quot;</span>);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\新桌面\\IO\\1plus版.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这种形式是边读边写</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(bytes);  <span class="comment">// 读多少，写多少</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 习惯是先开后管</span></span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">上面学习字节流的时候并没有用中文，因为涉及中文编码占字节数问题，一个中午在utf-8内占3个字节，如果还是上面的读取俩字节输出一下子，指定乱码，需要读取3个字节，虽然是没问题，因为字节流是万能流，但是有点麻烦，字节流更偏向于文件复制，因此不要边度边看</span><br><span class="line"></span><br><span class="line">但是呢，使用字符操作编码也要保持一致，否则仍然会乱码</span><br><span class="line">字符流在编码一致的情况下边读边看是没啥问题的</span><br><span class="line">字节流即使在编码一致的情况下，边读边看仍然可能出现问题</span><br></pre></td></tr></table></figure>



<h4 id="FileReader（字符输入流）"><a href="#FileReader（字符输入流）" class="headerlink" title="FileReader（字符输入流）"></a>FileReader（字符输入流）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">字符流是专门用来操作文本文档的，但是进行复制操作的，还是要用字节流</span><br><span class="line"></span><br><span class="line">概述：字符出入流 -&gt; Reader -&gt; 是一个抽象类</span><br><span class="line">作用：将文本文档中的内容读取到内存中来</span><br><span class="line">构造：</span><br><span class="line">	FileReader(File file)</span><br><span class="line">	FileReader(String path)</span><br><span class="line">	</span><br><span class="line">方法：</span><br><span class="line">	int read() -&gt; 一次读取一个字符，返回的是读取字符对应的int值</span><br><span class="line">	int read(char[] cbuf) -&gt; 一次读取一个字符数组，返回的是读取个数</span><br><span class="line">	int read(char[] cbuf, int off, int len) -&gt; 一次读取一个字符数组一部分，返回的是读取个数</span><br><span class="line">	close() -&gt; 关闭资源</span><br></pre></td></tr></table></figure>



<h4 id="FileWriter（字符输出流）"><a href="#FileWriter（字符输出流）" class="headerlink" title="FileWriter（字符输出流）"></a>FileWriter（字符输出流）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">概述：Writer 抽象类</span><br><span class="line">	子类：FileWriter</span><br><span class="line"></span><br><span class="line">作用：将数据写到文件中</span><br><span class="line">构造：</span><br><span class="line">	FileWriter(File file)</span><br><span class="line">	FileWriter(String fileName)</span><br><span class="line">	FileWriter(String fileName, boolean addenp) -&gt; 追加续写</span><br><span class="line">	</span><br><span class="line">方法：</span><br><span class="line">	void writer(int c)</span><br><span class="line">	void writer(char[] cbuf)</span><br><span class="line">	void writer(char[] cbuf, int off, int len) </span><br><span class="line">	void writer(String str) -&gt; 直接写一个字符串</span><br><span class="line">	void close() -&gt; 关闭资源</span><br></pre></td></tr></table></figure>



<p>字符输出流，字符输入流，这俩东西和字节输出流，字节输入流方法是很相近的，就懒得演示了</p>
<blockquote>
<p>有一个细节：</p>
<p>​	FileWriter底层自带一个缓冲区，我们写入的数据会先保存在缓冲区内，所以我们需要将缓冲区的数据刷到文件中。这一点和字节输出流不一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fw.flush()</span><br><span class="line"></span><br><span class="line">// 当然直接关闭资源，也可以刷入</span><br><span class="line">fw.close()</span><br></pre></td></tr></table></figure>

<p>但是呢，flush只是单纯刷新，如果使用close就关闭流了，后续无法继续使用流对象了</p>
</blockquote>
<h3 id="IO流异常处理方式"><a href="#IO流异常处理方式" class="headerlink" title="IO流异常处理方式"></a>IO流异常处理方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IO操作的时候是有异常的，之前都是直接上抛，但其实Io异常处理应该try……catch</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;mondeule01\\1.txt&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fr != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fr.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>处理异常还有专门办法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	try(IO对象)&#123;</span><br><span class="line">		可能出现的异常代码</span><br><span class="line">	&#125; catch (异常类型 对象名)&#123;</span><br><span class="line">		处理异常</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">注意这个格式处理IO异常，是自动关流的</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;mondeule\\2.txt&quot;</span>)) &#123;</span><br><span class="line">            fw.write(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为FileWriter不刷新，不关流是不会将缓存区内容添加到文本文档内的，因此可以测试是否自动关闭</span></span><br></pre></td></tr></table></figure>





<h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><h4 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">为啥要学字节缓冲流</span><br><span class="line">	之前学的FileOutputStream，FileInputStream，FileReader，Filewriter这都叫做基本类，其中FileInputStream和FileOutputStream的读写方法都是本地方法（方法声明上带native），本地方法是和系统以及硬盘打交道的，也就是说这两个对象的读和写都是在硬盘之间进行读写的，效率不高；缓冲流中底层带一个长度为8192的数组(缓冲区)，此时读和写都是在内存中完成的（在缓冲区完成），内存中的读写效率非常高</span><br><span class="line">	</span><br><span class="line">	使用之前需要将基本流包装成缓冲流，其实就new对象时，传递基本流</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">字节缓冲流：</span><br><span class="line">	1、BufferedOutputStream：字节缓冲输出流</span><br><span class="line">		构造：BufferedOutputStream(OutputStream out)</span><br><span class="line">		使用：和FileOutputStream一样</span><br><span class="line">		</span><br><span class="line">	2、BufferedInputStream：字节缓冲输入流</span><br><span class="line">		构造：BufferedInputStream(FileInputStream in)</span><br><span class="line">		使用：和FileInputStream一样</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用缓冲流复制文件。效率比较高</p>
<p>细节：</p>
<p>​	问题1：使用缓冲流的时候为什么只需要关闭缓冲流，而不需要关闭基本流？</p>
<p>​			原因：缓冲流的close方法底层自动关闭基本流</p>
<p>​	问题2：缓冲流底层有数组（缓冲区），都是在内存之间进行读写，那么缓冲流读写的过程是怎么样的？</p>
<p>​			先依靠基本流将数据读出来，然后交给缓冲流，由于缓冲流缓冲区是8192，所以每次读取8192个字节放到缓冲区中，然后再将输入流缓冲区中的数据交给输出流缓冲区，然后利用基本流将数据写到硬盘上</p>
<p>​			那么在操作代码时len的作用是什么呢？len的主要作用时在两个缓冲区之间倒腾数据，将输入流缓冲区中的数据读到，然后写到输出流缓冲区中，等待输出流缓冲区满了，再依靠基本流写到硬盘上；如果输入流缓冲区中的数据读不到了，重新从硬盘读取8192个字节，进入到输出流缓冲区中，继续利用len在两个缓冲区之间倒腾数据。</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240725152609092.png" alt="image-20240725152609092"></p>
</blockquote>
<p>​	</p>
<h4 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">字符流的基本流底层是有缓冲区的，所以在效率这一层面不是特别明显，主要学习字符缓冲流的两个特有方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">缓冲输出流</span><br><span class="line">	构造：</span><br><span class="line">		BufferedWriter(Writer w)</span><br><span class="line">	</span><br><span class="line">	方法：</span><br><span class="line">		和FileWriter一样</span><br><span class="line">	</span><br><span class="line">	特有方法：</span><br><span class="line">		newLine()  -&gt;  换行</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">缓冲输入流</span><br><span class="line">	构造：</span><br><span class="line">		BufferedReader(Reader r)</span><br><span class="line">		</span><br><span class="line">	方法：和FileReader一样</span><br><span class="line">	</span><br><span class="line">	特有方法：</span><br><span class="line">		String readLine()  -&gt;  一次读一行，如果读到结束标记，返回null</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;mondeule01\\2.txt&quot;</span>));</span><br><span class="line">        bw.write(<span class="string">&quot;但使龙城飞将在&quot;</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(<span class="string">&quot;不教胡马度阴山&quot;</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(<span class="string">&quot;杨花落尽子规啼&quot;</span>);</span><br><span class="line">        bw.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;mondeule01\\2.txt&quot;</span>));</span><br><span class="line">        <span class="comment">/*System.out.println(br.readLine());</span></span><br><span class="line"><span class="comment">        System.out.println(br.readLine());</span></span><br><span class="line"><span class="comment">        System.out.println(br.readLine());</span></span><br><span class="line"><span class="comment">        System.out.println(br.readLine());</span></span><br><span class="line"><span class="comment">        System.out.println(br.readLine());*/</span></span><br><span class="line"></span><br><span class="line">        String len;</span><br><span class="line">        <span class="keyword">while</span> ((len = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(len);</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.字节流读取中文在编码一致的情况，也不要边读边看，因为如果字节读不准，读不全，输出的内容有可能会出现乱码</span><br><span class="line">2.所以，我们学了字符流，字符流读取文本文档中的内容如果编码一致，就不会出现乱码问题了</span><br><span class="line">3.但是如果编码不一致，即使用字符流读取，仍然会出现乱码</span><br></pre></td></tr></table></figure>



<h4 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">概述：是字节流通向字符流的桥梁 -&gt; 读数据</span><br><span class="line">构造：</span><br><span class="line">	InputStreamReader(InputStream in, String charsetName)</span><br><span class="line">		charsetName:指定编码，不区分大小写</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作用：</span><br><span class="line">	直接指定编码，按照指定编码去读取内容</span><br><span class="line">	</span><br><span class="line">用法：</span><br><span class="line">	基本用法和FileReader一样，因为FileReader继承InputStreamReader</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个东西相当于python中open方法的第三个参数的作用，指定编码集</p>
</blockquote>
<h4 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">字符流通向字节流的桥梁</span><br><span class="line">构造：</span><br><span class="line">	OutputStreamWriter(OutputStream out, String charsetName)</span><br><span class="line">	</span><br><span class="line">方法和FileWriter一样，因为FileWriter继承了OutputStreamWirter</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;1.txt&quot;</span>),<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">        osw.write(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        osw.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;1.txt&quot;</span>),<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> isr.read();</span><br><span class="line">        System.out.println((<span class="type">char</span>)data);</span><br><span class="line">        isr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="序列化流和反序列化流"><a href="#序列化流和反序列化流" class="headerlink" title="序列化流和反序列化流"></a>序列化流和反序列化流</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">作用：读写对象</span><br><span class="line">两个对象：</span><br><span class="line">	1、ObjectOutputStream（序列化流） -&gt; 写对象</span><br><span class="line">	2、ObjectInputStream（反序列化流） -&gt; 读对象</span><br><span class="line">	</span><br><span class="line">注意：</span><br><span class="line">	我们将对象序列化到对象中，打开文件，指定看不懂，这就对了，防止数据被随意改动，只需要能读回来即可</span><br><span class="line">	</span><br><span class="line">	</span><br></pre></td></tr></table></figure>



<h4 id="ObjectOutputStream"><a href="#ObjectOutputStream" class="headerlink" title="ObjectOutputStream"></a>ObjectOutputStream</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">作用：写对象</span><br><span class="line">构造：</span><br><span class="line">	ObjectOutputStream(OutputStream out)</span><br><span class="line">	</span><br><span class="line">方法：</span><br><span class="line">	writeObject(Object obj) -&gt; 写对象</span><br></pre></td></tr></table></figure>



<h4 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">作用：读对象</span><br><span class="line">构造：</span><br><span class="line">	ObjectInputStream(InputStream in)</span><br><span class="line">	</span><br><span class="line">方法：</span><br><span class="line">	Object readObject()  -&gt;  读对象</span><br></pre></td></tr></table></figure>



<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;mondeule01\\person.txt&quot;</span>));</span><br><span class="line">        <span class="type">person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">19</span>);</span><br><span class="line">        oos.writeObject(p1);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;mondeule01\\person.txt&quot;</span>));</span><br><span class="line">        <span class="type">person</span> <span class="variable">p2</span> <span class="operator">=</span> (person) ois.readObject();</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>定义对象的时候需要实现Serializable才能进行序列化。</p>
<p>问题：如果我有一个值，不想没序列化怎么办？</p>
<p>​		transient关键字，在不想被序列化的数据类型前面加上这个关键字即可</p>
</blockquote>
<h4 id="反序列化时出现的问题"><a href="#反序列化时出现的问题" class="headerlink" title="反序列化时出现的问题"></a>反序列化时出现的问题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">问题描述：</span><br><span class="line">	序列化之后，修改源码，修改完之后没有重新序列化，直接反序列化了，就会出现序列号冲突问题；</span><br><span class="line">	InvalidClassException</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240725215058436.png" alt="image-20240725215058436"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解决：将序列号定死，后面不管怎么修改代码，序列号都是这一个</span><br><span class="line">	在被序列化的对象中加上一个public static final long 的变量，并为其赋值</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">42L</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>加上这一个就可以固定序列号，这时再更改变量的修饰符，不会影响反序列化</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">42L</span>;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将一个对象实现一个序列化接口，将来才能让这个对象变为二进制，在网络上传输</p>
</blockquote>
<p>反序列化的时候，面对多个对象肯定要使用for循环，但是注意：循环读取的次数和存储对象的个数要对应，否则会出现EOFException异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解决方法有很多，只说一个：</span><br><span class="line">	创建一个ArrayList对象，将要序列化的对象全部传入集合中，然后，只需要反序列化一个集合即可，出来再for循环，集合的长度可以使用方法确定。</span><br></pre></td></tr></table></figure>





<h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">构造：</span><br><span class="line">	PrintStream(String fileName)</span><br><span class="line">	</span><br><span class="line">方法：</span><br><span class="line">	1、println()：原样输出，自带换行效果</span><br><span class="line">	2、print()：原样输出，不换行</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;mondeule01\\1.txt&quot;</span>);</span><br><span class="line">        ps.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="改变流向"><a href="#改变流向" class="headerlink" title="改变流向"></a>改变流向</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">改变流向：</span><br><span class="line">	什么叫做改变流向：</span><br><span class="line">	比如：System.out.println() -&gt; 语法本身是将语句输出到控制台</span><br><span class="line">	改变流向：可以让输出语句从控制台上输出改变成往指定文件中输出</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">方法：System中的方法：</span><br><span class="line">	static void setOut(PrintStream out) -&gt; 改变流向 -&gt; 让输出语句从控制台输出转移到指定文件中</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;mondeule01\\1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.setOut(ps);</span><br><span class="line">        System.out.println(<span class="string">&quot;床前明月光&quot;</span>);</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个时候，本该输出到控制台的语句就转存到PrintStream对象指定的文件中了，主要使用场景就是保存日志文件</p>
</blockquote>
<h4 id="打印流续写"><a href="#打印流续写" class="headerlink" title="打印流续写"></a>打印流续写</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PrintStream(OutputStream out)  -&gt;  可以依靠OutputStream的续写功能完成打印流续写</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;mondeule01\\1.txt&quot;</span>,<span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">        System.setOut(ps);</span><br><span class="line">        System.out.println(<span class="string">&quot;床前明月光&quot;</span>);</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Properties集合"><a href="#Properties集合" class="headerlink" title="Properties集合"></a>Properties集合</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">这个集合之前说过，可以配合IO流</span><br><span class="line"></span><br><span class="line">回顾一下：</span><br><span class="line">	概述：Hashtable的子类</span><br><span class="line">	特点：</span><br><span class="line">		1、无序、无索引</span><br><span class="line">		2、key唯一，value可重复</span><br><span class="line">		3、线程安全</span><br><span class="line">		4、key和value的默认值都是String</span><br><span class="line">		</span><br><span class="line">	特有方法：</span><br><span class="line">		map里的方法都能使用</span><br><span class="line">		setProperty(String key, String value) -&gt; 存键值对</span><br><span class="line">		getProperty(String key) -&gt; 根据key获取value</span><br><span class="line">		stringPropertyNames() -&gt; 获取所有的key存放到set集合中</span><br><span class="line">		load(InputStream in) -&gt; 将流中的数据加载到Properties集合中</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用场景：配合配置文件使用</p>
<p>注意：</p>
<p>​	将来我们不能将很多的硬数据放到源码中，比如用户名和密码这些数据，因为将来我们有可能换用户名或者密码，如果一换，我们就需要去源码中修改，将来我们的类和类之间都有联系，有可能牵一发动全身，所以我们需要将这些数据提取出来，放到文件中，改的时候直接去文件中该，源码不需要改动</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">创建配置文件</span><br><span class="line">	新建文本文档 xxx.properties</span><br><span class="line">	注意事项：</span><br><span class="line">		1、key和value都是key=valie形式</span><br><span class="line">		2、key和value都是String的，但是不要加双引号</span><br><span class="line">		3、每个键值对写完之后，换行写下一个</span><br><span class="line">		4、键值对之间最好不要有空格(可以有，但是不建议)</span><br><span class="line">		5、键值对中建议不要用中文(读取可能乱码，需要用转换流转码)</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">pis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;mondeule01\\student.properties&quot;</span>);</span><br><span class="line">        p.load(pis);</span><br><span class="line">        <span class="comment">// 将数据添加到集合中去，然后转成set集合来遍历</span></span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set = p.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">            System.out.println(s+<span class="string">&quot;...&quot;</span>+p.getProperty(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="IO流工具类-Commons-io"><a href="#IO流工具类-Commons-io" class="headerlink" title="IO流工具类-Commons-io"></a>IO流工具类-Commons-io</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IO开发中，代码量很大，代码重复率高。对应遍历目录，拷贝目录中递归调用，程序就变得复杂</span><br></pre></td></tr></table></figure>



<h4 id="添加第三方jar包"><a href="#添加第三方jar包" class="headerlink" title="添加第三方jar包"></a>添加第三方jar包</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Commons-io工具类属于第三方，需要添加jar包</span><br><span class="line"></span><br><span class="line">jar包：本身是一个压缩包，里面转的都是class文件，我们想使用jar包中的工具类，就需要将相应的jar包解压到当前目录下</span><br><span class="line"></span><br><span class="line">引入jar包：</span><br><span class="line">	1、在当前模块下创建文件夹，取名为lib或者libs</span><br><span class="line">	2、将准备好的jar包放到此文件夹下</span><br><span class="line">	3、右键，添加到库</span><br></pre></td></tr></table></figure>



<h4 id="使用工具包"><a href="#使用工具包" class="headerlink" title="使用工具包"></a>使用工具包</h4><h5 id="IoUtils类"><a href="#IoUtils类" class="headerlink" title="IoUtils类"></a>IoUtils类</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IoUtils类</span><br><span class="line">	静态方法：</span><br><span class="line">		IOUtils.copy(InputStream in, OutputStream out)  -&gt;  传递字节流，实现文件复制</span><br><span class="line">		IOUtils.closeQuietly(任意流对象)悄悄的释放资源，自动处理close()方法抛出的异常</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        IOUtils.copy(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;mondule01\\1.txt&quot;</span>),<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;mondule01\\11.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;mondule01\\1.txt&quot;</span>);</span><br><span class="line">            fw.write(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fw != <span class="literal">null</span>) &#123;</span><br><span class="line">                IOUtils.closeQuietly(fw);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使用closeQuietly方法，就不需要在对close进行try……catch处理了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="FileUtils类"><a href="#FileUtils类" class="headerlink" title="FileUtils类"></a>FileUtils类</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FileUtils类</span><br><span class="line">静态方法：</span><br><span class="line">	FileUtiles.copyDirectoryToDirectory(File src, File dest)</span><br><span class="line">		传递File类型的目录，进行整个目录的复制，自动进行递归遍历</span><br><span class="line">		</span><br><span class="line">		参数：</span><br><span class="line">			src:要复制的文件夹路径</span><br><span class="line">			dest:要将文件夹粘贴到哪里去</span><br><span class="line">			</span><br><span class="line">	writeStringToFile(File file, String str) -&gt; 写字符串到文本文件中</span><br><span class="line">	String readFileToString(File file)  读取文本文件，返回字符串</span><br></pre></td></tr></table></figure>



<blockquote>
<p>IO流总结：</p>
<p>​	写的类名：FileOutputStream、FileWriter、BufferedOutputStream、BufferedWriter、ObjectOutputStream、OutputStreamWriter</p>
<p>​	写的方法：writer、BufferedWriter的特有方法newLine()、ObjectOutputStream -&gt; writerObject、OutputStreamWriter -&gt; new对象时指定编码</p>
<p>​	读的类名：FilelnputStream、FileReader、BufferedlnputStream、BufferedReader、ObjectlnputStream、InputStreamReader</p>
<p>​	读的方法：read()、BufferedReader 特有方法 readLine()、ObjectlnputStream -&gt; readObject()、InputStreamReader new对象的时候指定编码</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240726002053215.png" alt="image-20240726002053215"></p>
</blockquote>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">概述：在网络通信协议下，不同计算机上运行的程序，进行数据传输</span><br><span class="line">	比如：通信，视频通话，网游，邮件等</span><br><span class="line">	只要是计算机之间通过网络进行数据传输，就存在网络编程</span><br></pre></td></tr></table></figure>



<h3 id="软件结构"><a href="#软件结构" class="headerlink" title="软件结构"></a>软件结构</h3><ul>
<li>C&#x2F;S结构：全称为Client&#x2F;Server结构，是指客户端和服务端结构。常见程序有QQ</li>
<li>B&#x2F;S结构：全称为Browser&#x2F;Server结构，是指浏览器和服务器结构。之间通过浏览器访问</li>
</ul>
<p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。网络编程，就是在一定的协议下，实现两台计算机的通信的程序</p>
<h4 id="服务器概念"><a href="#服务器概念" class="headerlink" title="服务器概念"></a>服务器概念</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">概述：安装了服务器软件的计算机</span><br><span class="line">	如：tomcat</span><br></pre></td></tr></table></figure>

<blockquote>
<p>网络通信协议：两台计算机在做数据交互时要遵守的规则，协议会对数据的格式，速率等进行规定，只要遵守了这个协议，才能完成数据交互</p>
</blockquote>
<h4 id="通信三要素"><a href="#通信三要素" class="headerlink" title="通信三要素"></a>通信三要素</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[IP地址]：计算机的唯一标识，用于两台计算机之间的连接</span><br><span class="line">	这东西很熟悉了，也不多说了</span><br><span class="line">	IPV4,IPV6</span><br><span class="line">	ipconfig、ifconfig</span><br><span class="line">	ping</span><br><span class="line"></span><br><span class="line">[协议]：</span><br><span class="line">	TCP：面向连接协议</span><br><span class="line">		需要先确认连接，才能进行数据交互</span><br><span class="line">		三次握手：</span><br><span class="line">			- 第一次握手，客户端向服务器发出连接请求，等待服务器确认</span><br><span class="line">			- 第二次握手，服务端向客户端回送一个响应，通知客户端收到了连接请求</span><br><span class="line">			- 第三次握手，客户端再次向服务器端发送确认信息，确认连接</span><br><span class="line">			</span><br><span class="line">		好处：数据安全，能给数据的传输提供一个安全的传输环境</span><br><span class="line">		坏处：效率低</span><br><span class="line">		</span><br><span class="line">	UDP：面向无连接协议</span><br><span class="line">		好处：效率高</span><br><span class="line">		坏处：传输的数据不安全，容易丢失数据包</span><br><span class="line">		</span><br><span class="line">[端口号]</span><br><span class="line">	每一个应用程序的唯一标识</span><br><span class="line">	</span><br><span class="line">	用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>TCP协议的四次挥手</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">四次挥手，客户端和服务端断开连接的时候进行</span><br><span class="line"></span><br><span class="line">- 第一次挥手：客户端向服务端提出结束连接，让服务端做最后的准备工作，此时，客户端处于半关闭状态，即表示不再向服务器发送数据了。但是还可以接收数据。</span><br><span class="line"></span><br><span class="line">- 第二次挥手：服务器接收到客户端释放连接的请求后，会将最后的数据发送给客户端，并告知上层的应用进程不再接收数据。</span><br><span class="line"></span><br><span class="line">- 第三次挥手：服务器发送完数据后，会给客户端发送一个释放连接的报文。那么客户端接收后就知道可以正式释放连接了。</span><br><span class="line"></span><br><span class="line">- 第四次挥手：客户端接收到服务器最后的释放连接报文后，要回复一个彻底断开的报文。这样服务器收到后才会彻底释放连接。这里客户端，发送完最后的报文后，会等待2MSL，因为有可能服务器没有收到最后的报文，那么服务器迟迟没收到，就会再次给客户端发送释放连接的报文，此时客户端在等待时间范围内接收到，会重新发送最后的报文，并重新计时。如果等待2MSL后，没有收到，那么彻底断开。</span><br></pre></td></tr></table></figure>


</blockquote>
<h4 id="UDP协议编程"><a href="#UDP协议编程" class="headerlink" title="UDP协议编程"></a>UDP协议编程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket -&gt; 好比寄快递找的快递公司</span><br><span class="line">DatagramPacket -&gt; 好比快递公司打包</span><br></pre></td></tr></table></figure>



<h5 id="客户端（发送端）"><a href="#客户端（发送端）" class="headerlink" title="客户端（发送端）"></a>客户端（发送端）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">创建DatagramSocket对象</span><br><span class="line">	1、空参：端口号从可用的端口号随机一个使用</span><br><span class="line">	2、有参：使用指定的端口号</span><br><span class="line">	</span><br><span class="line">创建DatagramPacket对象，将数据进行打包</span><br><span class="line">	1、要发送的数据 -&gt; byte[]</span><br><span class="line">	2、指定接收端的IP</span><br><span class="line">	3、指定接收端的端口号</span><br><span class="line">	</span><br><span class="line">发送数据</span><br><span class="line"></span><br><span class="line">释放资源</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Send</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建DatagramSocket对象</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        创建DatagramPacket对象，将数据进行打包</span></span><br><span class="line"><span class="comment">	        1、要发送的数据 -&gt; byte[]</span></span><br><span class="line"><span class="comment">	        2、指定接收端的IP</span></span><br><span class="line"><span class="comment">	        3、指定接收端的端口号</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="string">&quot;hello,world&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">ip</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">6666</span>;</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length, ip, port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        socket.send(dp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接执行不会报错，UDP协议是面向无连接协议，不管有没有服务端，客户端照发不误</span></span><br></pre></td></tr></table></figure>



<h5 id="服务端（接收端）"><a href="#服务端（接收端）" class="headerlink" title="服务端（接收端）"></a>服务端（接收端）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、创建DatagramSocket对象，指定服务端的端口号</span><br><span class="line">2、接收数据包</span><br><span class="line">3、解析数据包</span><br><span class="line">4、释放资源</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Send</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建DatagramSocket对象</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        创建DatagramPacket对象，将数据进行打包</span></span><br><span class="line"><span class="comment">	        1、要发送的数据 -&gt; byte[]</span></span><br><span class="line"><span class="comment">	        2、指定接收端的IP</span></span><br><span class="line"><span class="comment">	        3、指定接收端的端口号</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="string">&quot;hello,world&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">ip</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">6666</span>;</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length, ip, port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        socket.send(dp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先打开服务端（接收端），然后再运行客户端，即可接收到发送的信息</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240726155347084.png" alt="image-20240726155347084"></p>
</blockquote>
<h4 id="TCP协议编程"><a href="#TCP协议编程" class="headerlink" title="TCP协议编程"></a>TCP协议编程</h4><p><img src="/../%E5%9B%BE%E7%89%87/image-20240726160303827.png" alt="image-20240726160303827"></p>
<h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、创建Socket对象，指明服务端的ip以及端口号</span><br><span class="line">2、调用Socket树象中的getOutputStream,获取输出流发送请求</span><br><span class="line">3、调用Socket中的getinputStream,获取输入流读取响应结果</span><br><span class="line">4、关流</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1、创建Socket对象，指明服务端的ip以及端口号</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、调用Socket树象中的getOutputStream,获取输出流发送请求</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        os.write(<span class="string">&quot;我想打视频&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、调用Socket中的getinputStream,获取输入流读取响应结果</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(bytes);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、关流</span></span><br><span class="line">        is.close();</span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.创建ServerSocket对象，设置端口号</span><br><span class="line">2.调用ServerSocket中的accept方法，等待客户端连接（该方法返回的是连接服务端的socket对象）</span><br><span class="line">3.调用socket中的getInputStream，用于读取请求</span><br><span class="line">4.调用socket中的getOutputStream，用于给客户端写响应</span><br><span class="line">5.关流</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.创建ServerSocket对象，设置端口号</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.调用ServerSocket中的accept方法，等待客户端连接（该方法返回的是连接服务端的socket对象）</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">s1</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.调用socket中的getInputStream，用于读取请求</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> s1.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(bytes);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.调用socket中的getOutputStream，用于给客户端写响应</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> s1.getOutputStream();</span><br><span class="line">        os.write(<span class="string">&quot;打个锤子你打&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.关流</span></span><br><span class="line">        os.close();</span><br><span class="line">        is.close();</span><br><span class="line">        s1.close();</span><br><span class="line">        ss.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="练习：文件上传"><a href="#练习：文件上传" class="headerlink" title="练习：文件上传"></a>练习：文件上传</h4><p>问题代码：可恶本本分分按照思路敲的代码有bug</p>
<h5 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\新桌面\\IO\\服务端复制.jpg&quot;</span>);</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            outputStream.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;以下是给客户端的响应结果&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        os.write(<span class="string">&quot;上传成功&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        os.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        is.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        ss.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送到服务端一张图片，边读边写</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\新桌面\\IO\\1.jpg&quot;</span>);</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            os.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;以下是服务端的响应结果&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收服务端提示</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bytes1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        len = is.read(bytes1);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes1, <span class="number">0</span>, len));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关流</span></span><br><span class="line">        is.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h5><p>图片因为我已经反复执行过了，所以显示上次的字节，如果是第一次执行，应该是显示0 字节</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240726165131748.png" alt="image-20240726165131748"></p>
<p>这个时候就可以推断出，问题出在服务端</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240726165512521.png" alt="image-20240726165512521"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240726170227837.png" alt="image-20240726170227837"></p>
<h6 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">缺少结束标记，给他一个结束标记进行了</span><br><span class="line"></span><br><span class="line">// 给服务端写一个结束标记</span><br><span class="line">socket.shutdownOutput();</span><br></pre></td></tr></table></figure>



<p>只需要在客户端上更改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送到服务端一张图片，边读边写</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\新桌面\\IO\\1.jpg&quot;</span>);</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            os.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给服务端写一个结束标记</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;以下是服务端的响应结果&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收服务端提示</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bytes1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        len = is.read(bytes1);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes1, <span class="number">0</span>, len));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关流</span></span><br><span class="line">        is.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个时候其实还有一个问题，复制的图片位置固定了，那么下一次上传就会覆盖掉，在服务端用一个随机方法，随机一个名字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = UUID.randomUUID().toString();</span><br><span class="line">// 生成一个十六进制的随机数</span><br></pre></td></tr></table></figure>



<p>服务端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成一个随机id并加上当前时间的毫秒值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span>s + System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 边读边写</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\新桌面\\IO\\&quot;</span>+name+<span class="string">&quot;.jpg&quot;</span>);</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            outputStream.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;以下是给客户端的响应结果&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给客户端的响应</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        os.write(<span class="string">&quot;上传成功&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关流</span></span><br><span class="line">        os.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        is.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        ss.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="多线程处理"><a href="#多线程处理" class="headerlink" title="多线程处理"></a>多线程处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">serverTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 生成一个随机id并加上当前时间的毫秒值</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">                        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> s + System.currentTimeMillis();</span><br><span class="line">                        outputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\新桌面\\IO\\&quot;</span> + name + <span class="string">&quot;.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 边读边写</span></span><br><span class="line">                        <span class="type">int</span> len;</span><br><span class="line">                        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                        <span class="keyword">while</span> ((len = is.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                            outputStream.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;以下是给客户端的响应结果&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 给客户端的响应</span></span><br><span class="line">                        os = socket.getOutputStream();</span><br><span class="line">                        os.write(<span class="string">&quot;上传成功&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 关流</span></span><br><span class="line">                        <span class="keyword">if</span> (os != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                os.close();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (outputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                outputStream.close();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (is != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                is.close();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (socket != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                socket.close();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>考虑到实际情况，ss对象就不关闭了，保持服务器一直开启，这个close的处理过于恶心，可以封装一个工具类。</p>
</blockquote>
<p>思考题，使用线程池</p>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">概述：具有特殊规则的字符串</span><br><span class="line">作用：检验</span><br><span class="line">	比如：手机号，身份证号，密码，用户名，邮箱等</span><br><span class="line">	</span><br><span class="line">String中有一个校验正则的方法：</span><br><span class="line">	boolean mathes(String regex)  校验字符串是否指定的regex的规则</span><br></pre></td></tr></table></figure>



<p>正则这东西省代码，用着简单，写起来抽象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res01</span> <span class="operator">=</span> method01(data);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res02</span> <span class="operator">=</span> method02(data);</span><br><span class="line">        System.out.println(<span class="string">&quot;res01 = &quot;</span> + res01);</span><br><span class="line">        System.out.println(<span class="string">&quot;res02 = &quot;</span> + res02);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">method02</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data.matches(<span class="string">&quot;[1-9][0-9]&#123;4,14&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">method01</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.startsWith(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] chars = data.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> aChar : chars) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aChar &lt; <span class="string">&#x27;0&#x27;</span> || aChar &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data.length() &lt; <span class="number">5</span> || data.length() &gt; <span class="number">15</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">字符类</span><br><span class="line">1.[abc]：代表a或者b，或者c字符中的一个。</span><br><span class="line">2.[^abc]：代表除a，b，c以外的任何字符。</span><br><span class="line">3.[a-z]：代表a-z的所有小写字符中的一个。</span><br><span class="line">4.[A-Z]：代表A-Z的所有大写字符中的一个</span><br><span class="line">5.[0-9]：代表0-9之间的某一个数字字符。</span><br><span class="line">6.[a-zA-Z0-9]：代表a-z或者A-Z或者0-9之间的任意一个字符。</span><br><span class="line">7.[a-dm-p]：a到d或m到p之间的任意一个字符</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">逻辑符</span><br><span class="line">1、&amp;&amp;：并且</span><br><span class="line">2、|：或者</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">预定义字符</span><br><span class="line">1、&quot;.&quot;：匹配任何字符。（重点）不能加[]</span><br><span class="line">2、&quot;\\d&quot;：任何数字[0-9]的简写；（重点）</span><br><span class="line">3、&quot;\\D&quot;：任何非数字[^0-9]的简写；</span><br><span class="line">4、&quot;\\s&quot;：空白字符：[\t\n\xOB\f\r]的简写</span><br><span class="line">5、&quot;\\S&quot;：非空白字符：[^\s]的简写</span><br><span class="line">6、&quot;\\w”：单词字符：[a-zA-Z_0-9]的简写（重点）</span><br><span class="line">7、&quot;\\W”：非单词字符：[^\w]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">数量词</span><br><span class="line">1、X? ：X出现的数量为0次或1次</span><br><span class="line">2、X* ：X出现的数量为0次到多次  任意次</span><br><span class="line">3、X+ ：x出现的数量为1次或多次  X&gt;=1次</span><br><span class="line">4、X&#123;n&#125; ：x出现的数量为恰好n次  X=n次</span><br><span class="line">5、X&#123;n,&#125; ：x出现的数量为至少n次  X&gt;=n次  x&#123;3,&#125;</span><br><span class="line">6、x&#123;n,m&#125; ：x出现的数量为n到m次（n和m都是包含的）  n=&lt;x&lt;=m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">分组括号</span><br><span class="line">(abc) -&gt; 表示abc为一组，出现</span><br></pre></td></tr></table></figure>



<h5 id="String中和正则表达式相关的方法"><a href="#String中和正则表达式相关的方法" class="headerlink" title="String中和正则表达式相关的方法"></a>String中和正则表达式相关的方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean matches(String regex)  判断字符串是否匹配给定的正则表达式。</span><br><span class="line"></span><br><span class="line">String[] split(String regex)  根据给定正则表达式的匹配拆分此字符串。</span><br><span class="line"></span><br><span class="line">String replaceAll(String regex, String rep1acement)  把满足正则表达式的字符串，替换为新的字符</span><br></pre></td></tr></table></figure>



<p>放一个生成正则的网址</p>
<p><a target="_blank" rel="noopener" href="https://www.sojson.com/regex/generate">https://www.sojson.com/regex/generate</a></p>
<h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">设计模式（Designpattern），是一套被反复使用、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、保证代码可靠性、程序的重用性，稳定性。</span><br><span class="line"></span><br><span class="line">1995年，GoF（GangofFour，四人组）合作出版了《设计模式：可复用面向对象软件的基础》一书，共收录了23种设计模式。&lt;大话设计模式&gt;</span><br><span class="line"></span><br><span class="line">总体来说设计模式分为三大类：</span><br><span class="line"></span><br><span class="line">创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。--&gt;  创建对象</span><br><span class="line"></span><br><span class="line">结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。--&gt;  对功能进行增强</span><br><span class="line"></span><br><span class="line">行为型模式，共十一种：策略模式、模板方法模式、观察者模式、选代子模式、贵任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</span><br></pre></td></tr></table></figure>



<h5 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模板方法（Temp1ateMethod）模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。明确了一部分功能，而另一部分功能不明确。需要延伸到子类中实现</span><br></pre></td></tr></table></figure>

<blockquote>
<p>主要思想是一样的写父类里面，不一样的继承到子类中，然后重写方法，使用时，直接子类点父类中的方法</p>
</blockquote>
<h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">目的：单（一个）例（实例，对象）</span><br><span class="line">	让一个类只产生一个对象，供外界使用</span><br><span class="line"></span><br><span class="line">分类：</span><br><span class="line">	1、饿汉式：迅速new对象</span><br><span class="line">	2、懒汉式：不着急new对象的</span><br></pre></td></tr></table></figure>



<h6 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">e</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *   防止外界随意使用构造方法，先将构造方法私有化</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">e</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *   为了赶紧new对象，我们new对象的时候变成静态的，让其随着类的加载而加载</span></span><br><span class="line"><span class="comment">    *   为了不让外界随便使用类名调用此静态对象，将其变为private</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">e</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">e</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *   还需要将new出来的对象给出去</span></span><br><span class="line"><span class="comment">    *   定义一个方法，让对象作为返回值给出去</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> e <span class="title function_">getE</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">singleton</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *   防止外界随意使用构造方法，先将构造方法私有化</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">singleton</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *   不着急new对象</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">singleton</span> <span class="variable">e</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *   还需要将new出来的对象给出去</span></span><br><span class="line"><span class="comment">    *   定义一个方法，让对象作为返回值给出去</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> singleton <span class="title function_">getE</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 直接进行if判断是有线程安全问题的，加上一个锁，但是呢，老是去抢锁，影响速率，再外面套一个判断，看需不需要去抢锁</span></span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                    e = <span class="keyword">new</span> <span class="title class_">singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Lombok使用"><a href="#Lombok使用" class="headerlink" title="Lombok使用"></a>Lombok使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">作用：简化javabean开发</span><br><span class="line">使用：</span><br><span class="line">	下载插件idea中下载即可</span><br><span class="line">	导jar包</span><br><span class="line">	设置</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240726204949047.png" alt="image-20240726204949047"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240726205010962.png" alt="image-20240726205010962"></p>
<h5 id="Getter和-Setter"><a href="#Getter和-Setter" class="headerlink" title="@Getter和@Setter"></a>@Getter和@Setter</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240726210940683.png" alt="image-20240726210940683"></p>
<h5 id="ToString"><a href="#ToString" class="headerlink" title="@ToString"></a>@ToString</h5><p>作用：生成toString()方法。</p>
<h5 id="NoArgsConstructor和-AllArgsConstructor"><a href="#NoArgsConstructor和-AllArgsConstructor" class="headerlink" title="@NoArgsConstructor和@AllArgsConstructor"></a>@NoArgsConstructor和@AllArgsConstructor</h5><ul>
<li>@NoArgsConstructor：无参数构造方法。</li>
<li>@AllArgsConstructor：满参数构造方法。</li>
</ul>
<h5 id="EgualsAndHashCode"><a href="#EgualsAndHashCode" class="headerlink" title="@EgualsAndHashCode"></a>@EgualsAndHashCode</h5><p>生成hashCode()和equals()方法。</p>
<h5 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h5><p>作用：生成get&#x2F;set，toString，hashcode，equals，无参构造方法</p>
<p>注解只能写在类上。</p>
<p>不包含有参构造</p>
<h2 id="jdk新特性"><a href="#jdk新特性" class="headerlink" title="jdk新特性"></a>jdk新特性</h2><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="&#x3D;&#x3D;Lambda表达式&#x3D;&#x3D;"></a>&#x3D;&#x3D;Lambda表达式&#x3D;&#x3D;</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">面向对象思想是Java的核心编程思想</span><br><span class="line">	强调的是对象，然后使用对象中实现好的功能</span><br><span class="line">	比如：去北京，强调的是怎么去</span><br><span class="line">	</span><br><span class="line">jdk8开始，出现了新的思想：函数式编程思想：</span><br><span class="line">	强调的是结果，不强调过程</span><br><span class="line">	比如：去北京，强调去了还是没去</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">Lambda表达式</span><br><span class="line">	格式：</span><br><span class="line">		()-&gt;&#123;&#125;</span><br><span class="line">		</span><br><span class="line">	解释：</span><br><span class="line">		() ：参数位</span><br><span class="line">		-&gt; ：将参数传递到方法体中</span><br><span class="line">		&#123;&#125; ：重写方法的方法体</span><br></pre></td></tr></table></figure>



<p>lambda表达式在js中很常见啊，在Java中的一个示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;执行了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行了&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; System.out.println(<span class="string">&quot;执行了&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>主要是利用了jvm虚拟机的反推能力，让代码更加简洁、高级，可读性也变差了</p>
</blockquote>
<h4 id="使用前提"><a href="#使用前提" class="headerlink" title="使用前提"></a>使用前提</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">必须是函数式接口做方法传递</span><br><span class="line">函数式接口：</span><br><span class="line">	有且只有一个抽象方法的接口，用@FuncitionalInterface去检测</span><br><span class="line">	</span><br><span class="line">比如：Runnable接口，只要一个run抽象方法，就可以使用lambda表达式</span><br></pre></td></tr></table></figure>



<h4 id="省略规则"><a href="#省略规则" class="headerlink" title="省略规则"></a>省略规则</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">先观察，后改造</span><br><span class="line">1、观察是否是函数式接口做方法参数传递</span><br><span class="line">2、如果是，考虑使用Lambda表达式</span><br><span class="line">3、调用方法，以匿名内部类的形式传递实参</span><br><span class="line">4、从new接口开始到重写方法的方法名结束，选择，删除</span><br><span class="line">5、在重写方法的参数后面，后面大括号前面加上 -&gt;</span><br><span class="line">（过于新手了）</span><br><span class="line"></span><br><span class="line">省略规则：</span><br><span class="line">	1、重写方法的参数结果可以干掉</span><br><span class="line">	2、如果重写方法只要一个参数，所在小括号可以干掉</span><br><span class="line">	3、如果方法体只有一句话，那么所在的大括号以及分号可以干掉</span><br><span class="line">	4、如果方法体中只有一句话并且带return的，那么所在的大括号，分号以及return可以干掉</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">19</span>);</span><br><span class="line">        <span class="type">person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">9</span>);</span><br><span class="line">        <span class="type">person</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(person o1, person o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge()- o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Collections.sort(list, (person o1, person o2) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge()- o2.getAge();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Collections.sort(list, (o1, o2) -&gt; o1.getAge()- o2.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">概述：有且仅有一个抽象方法的接口</span><br><span class="line">检测方法：</span><br><span class="line">	@FunctionalInterface</span><br></pre></td></tr></table></figure>



<p>介绍四个函数式接口</p>
<h4 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;T&gt; 它意味着“供给” -&gt; 想要什么，就返回什么</span><br><span class="line">方法：</span><br><span class="line">	T get()</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method01(<span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">int</span>[] ints = &#123;<span class="number">4</span>,<span class="number">65</span>,<span class="number">21</span>,<span class="number">84</span>,<span class="number">25</span>&#125;;</span><br><span class="line">                Arrays.sort(ints);</span><br><span class="line">                <span class="keyword">return</span> ints[ints.length-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        method01(() -&gt; &#123;</span><br><span class="line">                <span class="type">int</span>[] ints = &#123;<span class="number">4</span>,<span class="number">65</span>,<span class="number">21</span>,<span class="number">84</span>,<span class="number">25</span>&#125;;</span><br><span class="line">                Arrays.sort(ints);</span><br><span class="line">                <span class="keyword">return</span> ints[ints.length-<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method01</span><span class="params">(Supplier&lt;Integer&gt; supplier)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> supplier.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240726224857001.png" alt="image-20240726224857001"></p>
<h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;T&gt;  -&gt;  消费性接口 -&gt; 操作</span><br><span class="line">方法：</span><br><span class="line">	void accept(T t)  意为消费一个指定泛型的数据</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                System.out.println(s.length());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;asdfghjkl&quot;</span>);</span><br><span class="line"></span><br><span class="line">        method(s-&gt; System.out.println(s.length()),<span class="string">&quot;asdfghjkl&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Consumer&lt;String&gt; consumer, String s)</span> &#123;</span><br><span class="line">        consumer.accept(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240726230110401.png" alt="image-20240726230110401"></p>
<h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;T,R&gt; 接口用来根据一个类型数据得到另一个类型数据</span><br><span class="line">方法：</span><br><span class="line">	R apply(T t)  根据类型T参数获取类型R的结果</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        method(integer -&gt; integer+<span class="string">&quot;&quot;</span>,<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Function&lt;Integer, String&gt; function, Integer number)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> function.apply(number);</span><br><span class="line">        System.out.println(s+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240726230547130.png" alt="image-20240726230547130"></p>
<h4 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">判断型接口 Predicate&lt;T&gt;</span><br><span class="line">	boolean test(T t) -&gt; 用于判断方法，返回布尔型</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method(s -&gt; s.length()==<span class="number">7</span>,<span class="string">&quot;qwertyu&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Predicate&lt;String&gt; predicate, String s)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">test</span> <span class="operator">=</span> predicate.test(s);</span><br><span class="line">        System.out.println(<span class="string">&quot;test = &quot;</span> + test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>但是这个四个函数式接口，毫无用处，绕了一圈使用Lambda表达式解决问题罢了。但其实，这四个函数式接口主要配合Stream流使用的</p>
</blockquote>
<h3 id="Stream流"><a href="#Stream流" class="headerlink" title="&#x3D;&#x3D;Stream流&#x3D;&#x3D;"></a>&#x3D;&#x3D;Stream流&#x3D;&#x3D;</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">流不是指IO流，是一种编程方式--“流式编程”，可以看作流水线</span><br></pre></td></tr></table></figure>



<p>演示一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demobig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;翠花&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;翠花&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;赵正&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;潘金莲&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;武大郎&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张辽&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张八百&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求1，筛选出张姓</span></span><br><span class="line">        ArrayList&lt;String&gt; list1Zhang = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.startsWith(<span class="string">&quot;张&quot;</span>)) &#123;</span><br><span class="line">                list1Zhang.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求2，筛选出张姓，三字的人</span></span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : list1Zhang) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.length() == <span class="number">3</span>) &#123;</span><br><span class="line">                list1.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求3，遍历</span></span><br><span class="line">        <span class="keyword">for</span> (String s : list1) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;使用Stream流&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stream = list.stream();</span><br><span class="line">        <span class="comment">/*stream.filter(new Predicate&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public boolean test(String s) &#123;</span></span><br><span class="line"><span class="comment">                return s.startsWith(&quot;张&quot;);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;).filter(new Predicate&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public boolean test(String s) &#123;</span></span><br><span class="line"><span class="comment">                return s.length()==3;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;).forEach(new Consumer&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void accept(String s) &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(s);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;使用Lambda表达式&quot;</span>);</span><br><span class="line"></span><br><span class="line">        stream.filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).filter(s -&gt; s.length()==<span class="number">3</span>).forEach(s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Stream流的获取"><a href="#Stream流的获取" class="headerlink" title="Stream流的获取"></a>Stream流的获取</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">针对集合：Collection中的方法</span><br><span class="line">	Stream&lt;E&gt; stream()</span><br><span class="line">	</span><br><span class="line">针对集合：Stream接口中的静态方法</span><br><span class="line">	static &lt;T&gt; Stream&lt;T&gt; of(T...values)</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">steam</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stream = list.stream();</span><br><span class="line">        System.out.println(stream);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stream1 = Stream.of(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        System.out.println(stream1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Stream方法"><a href="#Stream方法" class="headerlink" title="Stream方法"></a>Stream方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">forEach：逐一处理 -&gt; 遍历</span><br><span class="line">	void forEach(Consumer&lt;? super T&gt; action);</span><br><span class="line">	</span><br><span class="line">	注意：forEach方法是一个[终结方法]，使用完之后，Stream流不能用了</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">count：统计元素个数</span><br><span class="line">	long count();</span><br><span class="line">	注意：count方法也是终结方法</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">filter：根据某个条件进行元素过滤</span><br><span class="line">	Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</span><br><span class="line">	返回一个新的stream流对象</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">limit：获取前n个元素</span><br><span class="line">	Stream&lt;T&gt; 1imit(long maxSize)</span><br><span class="line">	获取Stream流对象中的前n个元素，返回一个新的stream流对象</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">skip：跳过Stream流中的前n个元素</span><br><span class="line">	Stream&lt;T&gt; skip(long n)</span><br><span class="line">	跳过stream流对象中的前n个元素，返回一个新的stream流对象</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">concat：流合并</span><br><span class="line">	static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;?extends T&gt;b)</span><br><span class="line">	两个流合成一个流</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">collect：Stream流转换成集合</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">dinstinct：元素去重，依赖hashCode和equals方法</span><br><span class="line">	如果是自定义对象类型，需要重写两个方法</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">map：转化流中的数据类型</span><br><span class="line">	Stream&lt;R&gt; map(Function&lt;T，R&gt; mapper)</span><br></pre></td></tr></table></figure>



<p>小练习</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.第一个队伍只要名字为3个字的成员姓名</span><br><span class="line"></span><br><span class="line">2.第一个队伍筛选之后只要前3个人；</span><br><span class="line"></span><br><span class="line">3.第二个队伍只要姓张的成员姓名；</span><br><span class="line"></span><br><span class="line">4.第二个队伍筛选之后不要前2个人；</span><br><span class="line"></span><br><span class="line">5.将两个队伍合并为一个队伍；</span><br><span class="line"></span><br><span class="line">6.打印整个队伍的姓名信息。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; one = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        one.add(<span class="string">&quot;迪丽热巴&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;宋远桥&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;苏星河&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;老子&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;庄子&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;孙子&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;洪七公&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; two = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        two.add(<span class="string">&quot;古力娜扎&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;赵丽颖&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张二狗&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张天爱&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stream = one.stream();</span><br><span class="line">        Stream&lt;String&gt; s1 = stream.filter(s -&gt; s.length()==<span class="number">3</span>).limit(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stream1 = two.stream();</span><br><span class="line">        Stream&lt;String&gt; s2 = stream1.filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).skip(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Stream.concat(s1,s2).forEach(s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>代码还可以更恶心</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = one.stream();</span><br><span class="line">Stream&lt;String&gt; stream1 = two.stream();</span><br><span class="line"></span><br><span class="line">Stream.concat(stream.filter(s -&gt; s.length()==3).limit(3),stream1.filter(s -&gt; s.startsWith(&quot;张&quot;)).skip(2)).forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>



<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">概述：引用方法</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line">	1、被引用的方法要写在重写方法内</span><br><span class="line">	2、被引用的方法从参数上，返回值上要和所在重写方法一致，而且引用的方法最好是操作重写方法的参数值的</span><br><span class="line">	3、干掉重写方法的参数： 干掉-&gt;、干掉被引用方法的参数、被引用方法的.改成::</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;三上&quot;</span>,<span class="string">&quot;八下&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Lambda表达式&quot;</span>);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        stream.forEach(s -&gt; System.out.println(s));</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;方法引用&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="对象名引用成员方法"><a href="#对象名引用成员方法" class="headerlink" title="对象名引用成员方法"></a>对象名引用成员方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	对象::成员方法名</span><br><span class="line">	</span><br><span class="line">需求：</span><br><span class="line">	Supplier&lt;T&gt; 接口</span><br><span class="line">	</span><br><span class="line">方法：</span><br><span class="line">	T get()</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Lambda</span></span><br><span class="line">        method(()-&gt; <span class="string">&quot;  abc  &quot;</span>.trim());</span><br><span class="line">        <span class="comment">// 引用方法</span></span><br><span class="line">        method(<span class="string">&quot;  abc  &quot;</span>::trim);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Supplier&lt;String&gt; supplier)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> supplier.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;s = &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="类名引用静态方法"><a href="#类名引用静态方法" class="headerlink" title="类名引用静态方法"></a>类名引用静态方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	类名::静态方法名</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method(()-&gt;Math.random());</span><br><span class="line">        method(Math::random);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Supplier&lt;Double&gt; supplier)</span> &#123;</span><br><span class="line">        <span class="type">Double</span> <span class="variable">aDouble</span> <span class="operator">=</span> supplier.get();</span><br><span class="line">        System.out.println(aDouble);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="类-构造引用"><a href="#类-构造引用" class="headerlink" title="类-构造引用"></a>类-构造引用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	构造方法名::new</span><br><span class="line">	</span><br><span class="line">Function&lt;T, R&gt;接口</span><br><span class="line">	R apply(T t)  用于数据类型转换</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method(s -&gt; <span class="keyword">new</span> <span class="title class_">person</span>(s),<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        method(person::<span class="keyword">new</span>,<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Function&lt;String,person&gt; function, String name )</span> &#123;</span><br><span class="line">        <span class="type">person</span> <span class="variable">person</span> <span class="operator">=</span> function.apply(name);</span><br><span class="line">        System.out.println(<span class="string">&quot;person = &quot;</span> + person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">	数组的数据类型[]::new</span><br><span class="line">	int[]::new -&gt; 创建一个int型数组</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, <span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span>[] apply(Integer integer) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[integer];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        method(integer -&gt; <span class="keyword">new</span> <span class="title class_">int</span>[integer],<span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        method(<span class="type">int</span>[]::<span class="keyword">new</span>,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Function&lt;Integer, <span class="type">int</span>[]&gt; function, Integer len)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = function.apply(len);</span><br><span class="line">        System.out.println(<span class="string">&quot;arr = &quot;</span> + arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>jdk10更新了局部变量类型推断，可以想前端一样写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 变量名 = 值</span><br></pre></td></tr></table></figure>





<p>文本块 jdk15</p>
<p>三引号“”“ ”“” 自动给文本保持格式，不需要手动的&#x2F;n</p>
<p>jdk16  instanceof匹配</p>
<p>instanceof这个关键字是强转时使用的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void method(Animal animal) &#123;</span><br><span class="line"> /*if (animal instanceof Dog)&#123;</span><br><span class="line">     Dog dog =(Dog) animal;</span><br><span class="line">     dog.eat();</span><br><span class="line">     dog.1ookDoor;</span><br><span class="line">     &#125;*/</span><br><span class="line"></span><br><span class="line"> if (animal instanceof Dog dog) &#123;</span><br><span class="line">     dog.eat();</span><br><span class="line">     dog.lookDoor();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需要多给一个变量名，就省略了强转的过程</p>
<p>Record类</p>
<p>是一种全新的类型，本质上是一个final类，同时所有的类型都是final修饰，它会自动编译出get,set,hashCode,toString,以及比较所有属性值的equals。</p>
<p>注意：</p>
<ul>
<li>Record只会有一个全参构造</li>
<li>重写的equals方法比较所以的属性值</li>
<li>可以在Record声明的类中定义静态字段、静态方法或实例方法(非静态成员方法)</li>
<li>不能在Record声明的类中定义实例字段(非静态成员变量)</li>
<li>类不能声明为abstract</li>
<li>不能显式的声明父类，默认父类是java.lang.Record类</li>
<li>因为Record是final类，所以没有子类</li>
</ul>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240727125831744.png" alt="image-20240727125831744"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Test</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="comment">// 不能声明实例变量</span></span><br><span class="line">    <span class="comment">//int i;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 可以声明静态变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* // 不能声明空参构造</span></span><br><span class="line"><span class="comment">    public Test()&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以声明静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以声明非静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method01</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>密封类</p>
<p>密封的类和接口限制其他可能继承或实现它们的其他类或接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 sealed class 密封类 【extends父类】 【implements父接口】 permits 子类&#123;</span><br><span class="line">&#125;</span><br><span class="line">【修饰符】 sealed interface 接口 【extends父接口们】 permits 实现类&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>密封类使用sealed修饰符</li>
<li>使用permits关键字来指定可以继承或实现该类的类型</li>
<li>一个类继承密封类或实现密封接口，该类必须是sealed、non-sealed、final修饰的</li>
<li>sealed修饰的类或接口必须有子类或实现类</li>
</ul>
</blockquote>
<h3 id="Junit单元测试"><a href="#Junit单元测试" class="headerlink" title="Junit单元测试"></a>Junit单元测试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Junit是单元测试框架，可以替代main方法去执行其他方法</span><br><span class="line">作用：可以单独执行一个方法，测试该方法是否能抛通</span><br><span class="line">注意：Junit是第三方工具</span><br></pre></td></tr></table></figure>



<blockquote>
<p>jar包下载地址</p>
<p><a target="_blank" rel="noopener" href="https://github.com/junit-team/junit4/wiki/Download-and-Install">https://github.com/junit-team/junit4/wiki/Download-and-Install</a></p>
<p>配置下载地址</p>
<p><a target="_blank" rel="noopener" href="https://repo1.maven.org/maven2/org/hamcrest/hamcrest-core/1.3/">https://repo1.maven.org/maven2/org/hamcrest/hamcrest-core/1.3/</a></p>
</blockquote>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240727212633731.png" alt="image-20240727212633731"></p>
<h4 id="JUnit的注意事项"><a href="#JUnit的注意事项" class="headerlink" title="JUnit的注意事项"></a>JUnit的注意事项</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、@Test不能修饰static方法</span><br><span class="line">2、@Test不能修饰带参数的方法</span><br><span class="line">3、@Test不能修饰带返回值的方法</span><br><span class="line"></span><br><span class="line">这个很好理解测试方法，只测试一个方法，带参数，带返回值就需要进行传参和返回了，就超出了这个方法的范围</span><br></pre></td></tr></table></figure>



<h4 id="相关注解"><a href="#相关注解" class="headerlink" title="相关注解"></a>相关注解</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Before：在@Test之前执行，有多少个@Test执行，@Before就执行多少次 -&gt; 都是用作初始化一些数据</span><br><span class="line"></span><br><span class="line">@After：在@Test之前执行，有多少个@Test执行，@After就执行多少次 -&gt; 用作释放资源</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">还有两个注解</span><br><span class="line">@Beforecass：在@Test之前执行，只执行一次，只能修饰静态方法</span><br><span class="line">@Afterclass：在@Test之后执行，只执行一次，只能修饰静态方法</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240727215416205.png" alt="image-20240727215416205"></p>
<blockquote>
<p>@Test主要是用来测试的，用来代替main方法，分来测试模块的功能。</p>
</blockquote>
<h3 id="类的加载机制"><a href="#类的加载机制" class="headerlink" title="类的加载机制"></a>类的加载机制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、new对象</span><br><span class="line">2、new子类对象（new子类对象先初始化父类）</span><br><span class="line">3、执行main方法</span><br><span class="line">4、调用静态成员</span><br><span class="line">5、反射，创建class对象</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240727221033472.png" alt="image-20240727221033472"></p>
<h4 id="类加载器（了解）ClassLoader"><a href="#类加载器（了解）ClassLoader" class="headerlink" title="类加载器（了解）ClassLoader"></a>类加载器（了解）ClassLoader</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基于jdk8</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">1.概述：</span><br><span class="line">	在jvm中，负责将本地上的c1ass文件加载到内存的对象ClassLoader</span><br><span class="line"></span><br><span class="line">2.分类：</span><br><span class="line">	BootstrapclasLoader：根类加教器 -&gt; C语言写的，我们是获取不到的</span><br><span class="line">			也称之为引导类加载器，负责Java的核心类加载的</span><br><span class="line">			比如：System，String等</span><br><span class="line">			jre/lib/rt.jar下的类都是核心类</span><br><span class="line">			</span><br><span class="line">	ExtclassLoader：扩展类加载器</span><br><span class="line">			负责jre的扩展目录中的jar包的加载</span><br><span class="line">			在jdk中jre的lib目录下的ext目录</span><br><span class="line">			</span><br><span class="line">	AppclassLoader：系统类加载器</span><br><span class="line">			负责在jvm启动时加载来自java命令的c1ass文件（自定义类），以及classPath环境变量所指定的jar包（第三方jar包）</span><br><span class="line">			</span><br><span class="line">	不同的类加载器负责加载不同的类</span><br><span class="line">	</span><br><span class="line">3.三者的关系（从类加载机制层面）：</span><br><span class="line">	Appc1assLoader的父类加载器是ExtClassLoader</span><br><span class="line">	ExtclassLoader的父类加载器是BootStrapclassLoader</span><br><span class="line">	</span><br><span class="line">	但是：他们从代码级别上来看，没有子父类继承关系-&gt;他们都有一个共同的父类-&gt;ClassLoader</span><br><span class="line">	</span><br><span class="line">4.获取类加载器对象：getclassLoaderQ是class对象中的方法</span><br><span class="line">	类名.class.getclassLoader()</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">5.获取类加教器对象对应的父类加教器</span><br><span class="line">	ClassLoader类中的方法：classLoader</span><br><span class="line">	getParent（）-&gt; 没啥用</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">6.双亲委派（全盘负责委托机制）</span><br><span class="line"></span><br><span class="line">	a.Person类中有一个string</span><br><span class="line">	  Person本身是AppclassLoader加载</span><br><span class="line">	  String是BootStrapclassLoader加较</span><br><span class="line">	  </span><br><span class="line">	b.加载顺序：</span><br><span class="line">	  Person本身是App加载，按道理来说string也是App加载</span><br><span class="line">	  但是App加载String的时候，先问一问Ext，说：Ext你加载这个string吗？</span><br><span class="line">	  Ext说：我不加载，我负贵加载的是扩展类，但是app你别着急，我问问我爹去-&gt;boot</span><br><span class="line">	  Ext说：boot，你加载string吗？</span><br><span class="line">	  boot说：正好我加载核心类，行吧，我加载吧！</span><br><span class="line">	  </span><br><span class="line">	  </span><br><span class="line">7.类加载器的cache（缓存）机制（扩展）：一个类加载到内存之后，缓存中也会保存一份儿，后面如果再使用此类，如果缓存中保存了这个类，就直接返回他，如果没有才加载这个类，下一次如果有其他类在使用的时候就不会重新加载了，直接去缓存中拿，保证了类在内存中的唯一性</span><br><span class="line"></span><br><span class="line">8.所以：类加载器的双亲委派和缓存机制共同造就了加载类的特点：保证了类在内存中的唯一性</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240727222521344.png" alt="image-20240727222521344"></p>
<blockquote>
<p>缓存内有就开始加载，如果没有向上询问，直到boot，如果也没有去规定的目录内寻找，如果没有再向下查找</p>
</blockquote>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.反射概述：解剖c1ass对象的一个技术</span><br><span class="line">2.问题：能解剖c1ass对象的啥呢？</span><br><span class="line">	a.解剖出成员变量：赋值</span><br><span class="line">	b.解剖出成员方法：调用</span><br><span class="line">	c.解剖出构造方法：new对象</span><br><span class="line">	</span><br><span class="line">3.用反射的好处：让代码变的更通用，更灵活</span><br><span class="line"></span><br><span class="line">4.怎么学反射：</span><br><span class="line">	a.将反射看成是一套API来学</span><br><span class="line">	b.通过案例，体会反射的好处</span><br><span class="line">	</span><br><span class="line">5.问题：玩儿反射，最开始的一步是干啥？</span><br><span class="line">	获取class对象</span><br><span class="line">	</span><br><span class="line">6.c1ass对象：c1ass文件对应的对象</span><br><span class="line">	c1ass类：描述class对象的类</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240727223441205.png" alt="image-20240727223441205"></p>
<h4 id="获取class对象"><a href="#获取class对象" class="headerlink" title="获取class对象"></a>获取class对象</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">方式一：调用Object中的getClass方法：</span><br><span class="line">	class&lt;?&gt; getClass()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方式二：不管是基本类型还是引用类型，jvm都为其提供了一个静态成员：c1ass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方式三：C1ass类中的静态方法：</span><br><span class="line">	static Class&lt;?&gt; forName(String className)</span><br><span class="line">			className：传递的是类的全限定名（说的很高级，其实就是 包名.类名 ）</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 方式一</span></span><br><span class="line">        <span class="type">person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">person</span>();</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">person</span>&gt; class1 = person.getClass();</span><br><span class="line">        System.out.println(class1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式二</span></span><br><span class="line">        Class&lt;person&gt; class2 = person.class;</span><br><span class="line">        System.out.println(class2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式三</span></span><br><span class="line">        Class&lt;?&gt; class3 = Class.forName(<span class="string">&quot;com.sjjws.h_001.person&quot;</span>);</span><br><span class="line">        System.out.println(class3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240727225026712.png" alt="image-20240727225026712"></p>
<blockquote>
<p>forName是最通用的，因为参数是String，可以和properties文件，通过IO流的一番操作，就可以获取到class对象</p>
<p>类名.class是最常用的，因为方便</p>
</blockquote>
<h4 id="获取构造方法"><a href="#获取构造方法" class="headerlink" title="获取构造方法"></a>获取构造方法</h4><h5 id="获取所有public的构造方法"><a href="#获取所有public的构造方法" class="headerlink" title="获取所有public的构造方法"></a>获取所有public的构造方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class类中的方法：</span><br><span class="line">	Constructor&lt;?&gt;[] getConstructors() -&gt; 获取所有public的构造</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;person&gt; aClass = person.class;</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : aClass.getConstructors()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;constructor = &quot;</span> + constructor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="获取空参构造"><a href="#获取空参构造" class="headerlink" title="获取空参构造"></a>获取空参构造</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">获取：</span><br><span class="line">Class类中的方法：</span><br><span class="line">	Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) -&gt; 获取指定的public的构造</span><br><span class="line">			parameterTypes：可变参数，可以传递0-多个参数</span><br><span class="line">			</span><br><span class="line">	1、如果获取空参构造，参数不用写</span><br><span class="line">	2、如果获取有参构造：参数写参数类型的class对象</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">调用：</span><br><span class="line">Constructor类中的方法：</span><br><span class="line">	T newInstance(Object...initargs) -&gt; 创建对象</span><br><span class="line">		initargs:传递的是构造方法的实参</span><br><span class="line">		</span><br><span class="line">	a.如果根据无参构造new对象，initargs不写了</span><br><span class="line">	b.如果根据有参构造new对象，initargs传递实参</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        Class&lt;person&gt; aClass =  person.class;</span><br><span class="line">        Constructor&lt;person&gt; constructor = aClass.getConstructor();</span><br><span class="line">        System.out.println(<span class="string">&quot;constructor = &quot;</span> + constructor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        就好比 person person = new person();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">person</span> <span class="variable">person</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;person = &quot;</span> + person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的代码是先获取空参构造的方法，然后再用这个方法来new对象</p>
<p>利用空参new对象，有更简单的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class类中的方法：</span><br><span class="line">	T newInstance() -&gt; 根据空参构造创建对象</span><br><span class="line"></span><br><span class="line">前提：被反射的类中必须有public修饰的空参构造。</span><br><span class="line"></span><br><span class="line">注意：这个方法以及过时了</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="获取有参构造"><a href="#获取有参构造" class="headerlink" title="获取有参构造"></a>获取有参构造</h5><p>和无参构造相差无几</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        Class&lt;person&gt; aClass =  person.class;</span><br><span class="line">        Constructor&lt;person&gt; constructor = aClass.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;constructor = &quot;</span> + constructor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        就好比 person person = new person(&quot;张三&quot;,19);</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">person</span> <span class="variable">person</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;张三&quot;</span>,<span class="number">19</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;person = &quot;</span> + person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="获取私有构造"><a href="#获取私有构造" class="headerlink" title="获取私有构造"></a>获取私有构造</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">constructor&lt;?&gt;[] getDeclaredconstructors() -&gt; 获取所有构造方法，包括private</span><br><span class="line"></span><br><span class="line">onstructor&lt;T&gt; getDeclaredconstructor(类&lt;?&gt;...parameterTypes) -&gt; 获取指定构造，包括private</span><br><span class="line">	parameterTypes：参数类型的class对象</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">获取到的私有构造方法是不能直接使用的，但是反射是流氓啊</span><br><span class="line">Constructor的父类AccessibleObject内有一个方法</span><br><span class="line">	void setAccessible(boolean flag) -&gt; 修改访问权限</span><br><span class="line">			flag为true：解除私有权限</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Class&lt;person&gt; aClass = person.class;</span><br><span class="line">        Constructor&lt;person&gt; constructor = aClass.getDeclaredConstructor(String.class);</span><br><span class="line"></span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">person</span> <span class="variable">person</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="反射成员方法"><a href="#反射成员方法" class="headerlink" title="反射成员方法"></a>反射成员方法</h4><h5 id="获取所有public的成员方法"><a href="#获取所有public的成员方法" class="headerlink" title="获取所有public的成员方法"></a>获取所有public的成员方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class类中的方法：</span><br><span class="line">	Method[] getMethods() -&gt; 获取所有public方法，包括父类中的public方法</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;person&gt; aClass = person.class;</span><br><span class="line">        Method[] methods = aClass.getMethods();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="../图片/image-20240728000014776.png" alt="image-20240728000014776" style="zoom:67%;" />



<h5 id="获取public方法（有参、无参）"><a href="#获取public方法（有参、无参）" class="headerlink" title="获取public方法（有参、无参）"></a>获取public方法（有参、无参）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class类中的方法：</span><br><span class="line">	Method getMethod(String name,Class&lt;?&gt;...parameterTypes) -&gt; 获取指定的public的成员方法</span><br><span class="line">		name:传递方法名</span><br><span class="line">		parameterTypes:方法参数类型的class对象（因为是存在重载方法这个东西的）</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">调用方法：</span><br><span class="line">Method对象中的方法：</span><br><span class="line">	Object invoke(Object obj, Object... arges)  -&gt; 执行方法</span><br><span class="line">			obj:根据构造new出来的对象</span><br><span class="line">			arges:方法实参 -&gt; 如果有参数直接传</span><br><span class="line">			返回值：Object -&gt; 接收被执行方法的返回值，如果方法没有返回值，不接受</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        <span class="comment">// 获取class对象</span></span><br><span class="line">        Class&lt;person&gt; aClass = person.class;</span><br><span class="line">        <span class="comment">// 迅速new一个对象出来</span></span><br><span class="line">        <span class="type">person</span> <span class="variable">person</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 传递参数，无返回值</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> aClass.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line">        method.invoke(person, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 带返回值</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">get</span> <span class="operator">=</span> aClass.getMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> get.invoke(person);</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="获取私有方法"><a href="#获取私有方法" class="headerlink" title="获取私有方法"></a>获取私有方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Method[] getDeclaredMethods()  -&gt;  获取所有的成员方法，包括private的</span><br><span class="line"></span><br><span class="line">Method getDeclaredMethod(String name, class&lt;?&gt;... parameterTypes) -&gt; 获取执行成员方法，包括private</span><br><span class="line">		name:传递方法名</span><br><span class="line">		parameterTypes：方法参数类型的class对象</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">解除私有权限：void setAccessible(boolean flag)</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        Class&lt;person&gt; aClass = person.class;</span><br><span class="line">        <span class="type">person</span> <span class="variable">person</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> aClass.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">        method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        method.invoke(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="反射成员变量"><a href="#反射成员变量" class="headerlink" title="反射成员变量"></a>反射成员变量</h4><h5 id="获取所有属性"><a href="#获取所有属性" class="headerlink" title="获取所有属性"></a>获取所有属性</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class类中的方法：</span><br><span class="line">	Field[] getFileds() -&gt; 获取所有public的属性</span><br><span class="line">	</span><br><span class="line">	Field[] getDeclaredFields()  -&gt;  获取所有属性，包括priavte的</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;person&gt; aClass = person.class;</span><br><span class="line">        Field[] fields = aClass.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;field = &quot;</span> + field);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Field[] fields1 = aClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;field = &quot;</span> + field);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="获取指定属性"><a href="#获取指定属性" class="headerlink" title="获取指定属性"></a>获取指定属性</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class类中的方法：</span><br><span class="line">	Field getFiled(String name) -&gt; 获取指定public的属性</span><br><span class="line">	</span><br><span class="line">	Field getDeclaredField(String name)  -&gt;  获取指定属性，包括priavte的</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">Field类中的方法：</span><br><span class="line">	void set(Object obj, Object value) -&gt; 为属性赋值，相当于JavaBean中的set方法</span><br><span class="line">			obj:对象</span><br><span class="line">			value:赋予的值</span><br><span class="line">			</span><br><span class="line">	Object get(Object obj)  -&gt;  获取属性值</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取public成员</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        Class&lt;person&gt; aClass = person.class;</span><br><span class="line">        <span class="type">person</span> <span class="variable">person</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">fields</span> <span class="operator">=</span> aClass.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">        fields.set(person, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> fields.get(person);</span><br><span class="line">        System.out.println(<span class="string">&quot;o = &quot;</span> + o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取、操作私有成员</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo09</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        Class&lt;person&gt; aClass = person.class;</span><br><span class="line">        <span class="type">person</span> <span class="variable">person</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">fields</span> <span class="operator">=</span> aClass.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line">        fields.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        fields.set(person, <span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> fields.get(person);</span><br><span class="line">        System.out.println(<span class="string">&quot;o = &quot;</span> + o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="反射练习"><a href="#反射练习" class="headerlink" title="反射练习"></a>反射练习</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可以看到反射操作class对象的方法都不是很简单（相比直接new对象来说），反射的主要作用是编写框架</span><br><span class="line"></span><br><span class="line">public interface 接口名&#123;</span><br><span class="line">	public Employee find()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;find&quot; resultType=&quot;Employee的全限定名&quot;&gt;</span><br><span class="line">	select 列名 from 表名 where 条件</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">根据接口的class对象，创建一个实现类对象，然后通过配置文件中的方法名反射这个方法，invoke执行这个方法</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">练习需求：在配置文件中。配置类的全限定名，以及配置一个方法名，通过解析配置文件，让配置好的方法执行起来</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">步骤：</span><br><span class="line">	1.创建properties配置文件，配置信息</span><br><span class="line">		问题一：配置文件放在那里</span><br><span class="line">			开发完给用户的是out路径下的class文件，将class文件打包，如果配置文件在模块下，out路径下是不会生成这个配置文件的</span><br><span class="line">		解决：将配置文件放到src目录下	</span><br><span class="line">		</span><br><span class="line">		问题二：将配置文件放到src下，out路径下会自动生成配置文件，但是如果我们将来将所有的配置文件都放到src下，那么src下面会显得特别乱</span><br><span class="line">		解决：我们可以单独创建一个文件夹，将所有的配置文件放到此文件夹下，将此文件夹改成资源目录，取名为resources</span><br><span class="line">		</span><br><span class="line">	2.读取配置文件，解析配置文件</span><br><span class="line">		问题一：如果将配置文件放到resources资源目录下，我们怎么读取</span><br><span class="line">			new FileInputstream(&quot;模块名\\resources\\properties文件名&quot;) -&gt; 这样不行，因为out路径下没有resources-&gt;相当于写死了</span><br><span class="line">		</span><br><span class="line">		问题解决：用类加载器</span><br><span class="line">		classLoader  classLoader = 当前类.class.getclassLoader()</span><br><span class="line">		Inputstream in = classLoader.getResourceAsStream(&quot;文件名&quot;)//自动扫描resources下的文件-&gt;可以简单理解为扫描out路径下的配置文件</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	3.根据解析出来的c1assName，创建c1ass对象</span><br><span class="line">	4.根据解析出来的methodName，获取对应的方法</span><br><span class="line">	5.执行方法</span><br></pre></td></tr></table></figure>



<p>配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">className=com.sjjws.aa_kj.Person</span><br><span class="line">methodName=eat</span><br></pre></td></tr></table></figure>



<p>定义方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狠狠干饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.创建properties集合</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.读取配置文件，解析配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Demo.class.getClassLoader().getResourceAsStream(<span class="string">&quot;student.properties&quot;</span>);</span><br><span class="line">        properties.load(in);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.根据解析出来的c1assName，创建c1ass对象</span></span><br><span class="line">        <span class="comment">//4.根据解析出来的methodName，获取对应的方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取创建class对象</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(className);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取相应方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> aClass.getMethod(methodName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.执行方法</span></span><br><span class="line">        method.invoke(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种方法看似很麻烦，但是体现了框架架构思想</p>
</blockquote>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">引用数据类型：</span><br><span class="line">	类 数组 接口 枚举 注解</span><br><span class="line">	</span><br><span class="line">作用：</span><br><span class="line">	说明：对代码进行说明，生成doc文档（API文档）</span><br><span class="line">	检查：老朋友 @Override 检查是否为重写方法、 @FunctionalInterface 检查是否为函数式接口</span><br><span class="line">	分析：对代码进行分析，起到配置文件的作用</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240728104917624.png" alt="image-20240728104917624"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JDK中的注解：</span><br><span class="line">	@override -&gt; 检测此方法是否为重写方法</span><br><span class="line">	@Deprecated -&gt; 提示方法已经过时，不推荐使用调用方法的时候，方法上会有横线，但是能用</span><br><span class="line">	@suppresswarnings -&gt; 消除警告@Suppresswarnings(&quot;a11&quot;)</span><br></pre></td></tr></table></figure>



<h4 id="注解的定义以及属性的定义格式"><a href="#注解的定义以及属性的定义格式" class="headerlink" title="注解的定义以及属性的定义格式"></a>注解的定义以及属性的定义格式</h4><p>注意，这里说的注解属性，其实本质上是抽象方法，但是我们按照属性来理解，好理解，因为到时候使用注解的时候，需要用&#x3D;为其赋值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">定义：</span><br><span class="line">	public @interface 接口名&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">定义属性（抽象方法）：</span><br><span class="line">	数据类型 属性名() -&gt; 在使用注解的时候为其赋值</span><br><span class="line">	数据类型 属性名() default 值 -&gt;  有默认值，如果需要可以二次赋值</span><br><span class="line">	</span><br><span class="line">注解可以定义的类型：</span><br><span class="line">	1、8种基本数据类型</span><br><span class="line">	2、String类型、class类型、枚举类型、注解类型</span><br><span class="line">	3、以及以上类型的一维数组</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Book &#123;</span><br><span class="line">    String <span class="title function_">bookName</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    String[] author();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">price</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">使用：</span><br><span class="line">	本质上就是为注解中的属性赋值</span><br><span class="line">	</span><br><span class="line">使用位置：</span><br><span class="line">	在类上使用、在方法上使用、成员变量上使用、局部变量上使用、参数位置使用等</span><br><span class="line">	</span><br><span class="line">使用格式：</span><br><span class="line">	1、@注解名(属性名 = 值...)</span><br><span class="line">	2、如果属性中有数组：</span><br><span class="line">		@注解名(属性名 = &#123;元素1,元素2...&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意事项：</p>
<p>​	1、空注解可以直接使用 -&gt; 空注解就是注解中没有任何的属性</p>
<p>​	2、不同的位置可以使用一样的注解，同一位置不可以</p>
<p>​	3、使用注解时，如果此注解中有属性，注解中的属性一定要赋值，如果有多个属性，用,隔开，如果有数组使用{}</p>
<p>​	4、如果注解中的属性有默认值，那么我们不必要写，也不要重新赋值，反之必须写</p>
<p>​	5、如果注解中只有一个属性，并且属性名为value，那么使用的时候可以不写属性名，只写值</p>
</blockquote>
<h4 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">概述：获取注解中的属性值</span><br><span class="line"></span><br><span class="line">AnnotatedElement接口</span><br><span class="line">	实现类：Accessibleobject，Class，Constructor，Executable，Field，Method，Package，Parameter</span><br><span class="line">	（可以看出这些实现类和反射密切相关）</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">先判断位置上有没有使用指定的注解，如果有，获取指定的注解，获取注解中的属性值</span><br><span class="line">	boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) -&gt; 判断指定位置上有没有指定的注解</span><br><span class="line">	  比如：判断BookShe1f上有没有Book注解</span><br><span class="line">	  	Class bookshelf = Bookshelf.class</span><br><span class="line">	  	bookShelf.isAnnotationPresent(Book.class)</span><br><span class="line">	</span><br><span class="line">	getAnnotation(Class&lt;T&gt; annotationClass) -&gt; 获取指定是注解</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取BookShelf的class对象</span></span><br><span class="line">        Class&lt;BookShelf&gt; bookShelfClass = BookShelf.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断bookShelf上有没有book注解</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> bookShelfClass.isAnnotationPresent(Book.class);</span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断，如果是true，就获取属性值</span></span><br><span class="line">        <span class="keyword">if</span> (b)&#123;</span><br><span class="line">            <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> bookShelfClass.getAnnotation(Book.class);</span><br><span class="line">            System.out.println(book.bookName());</span><br><span class="line">            System.out.println(Arrays.toString(book.author()));</span><br><span class="line">            System.out.println(book.price());</span><br><span class="line">            System.out.println(book.count());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是这个代码并没有获取到，输出 b 输出结果为false</p>
<p>原因是Book注解没有被加载到内存</p>
</blockquote>
<h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">概述：元注解就是管理注解的注解</span><br><span class="line"></span><br><span class="line">管理：</span><br><span class="line">	1、控制注解的使用位置</span><br><span class="line">		控制注解是否能在类上使用</span><br><span class="line">		控制注解是否能在方法上使用</span><br><span class="line">		控制注解是否能在构造上使用等</span><br><span class="line">		</span><br><span class="line">	2、控制注解的生命周期（加载位置）</span><br><span class="line">		控制注解是否能在源码中出现</span><br><span class="line">		控制注解能否在class文件中出现</span><br><span class="line">		控制注解能否在内存中出现</span><br><span class="line">		</span><br><span class="line">	3、怎么使用：</span><br><span class="line">		a.@Target：控制注解的使用位置</span><br><span class="line">			属性：ElementType[] value()</span><br><span class="line">				ElementType是一个枚举，里面的成员可以类名直接调用</span><br><span class="line">			ElementType中的成员：</span><br><span class="line">				TYPE：控制注解能使用在类上</span><br><span class="line">				FIELD：控制注解能使用在属性上</span><br><span class="line">				METHOD：控制注解能使用在方法上</span><br><span class="line">				PARAMETER：控制注解能使用在参数上</span><br><span class="line">				CONSTRUCTOR：控制注解能使用在构造上</span><br><span class="line">				LOCAL_VARIABLE：控制注解能使用在局部变量上</span><br><span class="line">				</span><br><span class="line">		不写@Target的情况下哪都能写，如果写了@Target那么就只能按照控制的位置写</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		b.@Retention：控制注解的生命周期（加载位置）</span><br><span class="line">			属性：RetentionPolicy value();</span><br><span class="line">				RetentionPolicy也是枚举</span><br><span class="line">				</span><br><span class="line">			RetentionPolicy中的成员：</span><br><span class="line">				SOURCE：控制注解能在源码中出现-&gt;默认</span><br><span class="line">				CLASS：控制注解能在c1ass文件中出现</span><br><span class="line">				RUNTIME：控制注解能在内存中出现</span><br></pre></td></tr></table></figure>



<p>将Book加载到内存，再次运行就出现了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Book &#123;</span><br><span class="line">    String <span class="title function_">bookName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String[] author();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">price</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240728172518571.png" alt="image-20240728172518571"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1、概述：五大引用数据类型</span><br><span class="line">	类 数组 接口 注解 枚举</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">2、定义：</span><br><span class="line">	public enum 枚举类名&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	所有的枚举类都有一个共同的父类Enum</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">3、定义枚举值：</span><br><span class="line">	特点：</span><br><span class="line">		都是static final，但是定义的时候不要写出来，写出来会报错</span><br><span class="line">		写完所有的枚举值之后，最后加个;</span><br><span class="line">		枚举值的名字大写 -&gt; 开发习惯</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	使用：类名直接调用</span><br><span class="line">	</span><br><span class="line">	注意：每一个枚举值都是当前枚举类的对象</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">4、问题：枚举类中的枚举值都是什么类型？</span><br><span class="line">	本类型</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">5、枚举类中的其他成员：构造</span><br><span class="line">	在枚举类中定义的构造，默认都是private的</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">6、枚举的使用场景：</span><br><span class="line">	表示对象的状态</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240728175705980.png" alt="image-20240728175705980"></p>
<blockquote>
<p>枚举还可以设置值，设置了值的枚举值，相当于进行了一个有参构造</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">state</span> &#123;</span><br><span class="line"> <span class="comment">//static WEIFUKUAN = new state();</span></span><br><span class="line"> WEIFUKUAN(<span class="string">&quot;未付款&quot;</span>),</span><br><span class="line"></span><br><span class="line"> <span class="comment">//static YIFUKUAN = new state();</span></span><br><span class="line"> YIFUKUAN,</span><br><span class="line"></span><br><span class="line"> <span class="comment">//static WEIFAHUO = new state();</span></span><br><span class="line"> WEIFAHUO,</span><br><span class="line"></span><br><span class="line"> <span class="comment">//static YIFAHUO = new state();</span></span><br><span class="line"> YIFAHUO;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"> state(String name)&#123;</span><br><span class="line">     <span class="built_in">this</span>.name = name;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> state()&#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> name;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240728180710086.png" alt="image-20240728180710086"></p>
<p>在后面传入参数，还方便调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">state</span> <span class="variable">state0</span> <span class="operator">=</span> com.sjjws.aa_kj.state.WEIFAHUO;</span><br><span class="line">     System.out.println(state0);</span><br><span class="line">     System.out.println(state0.getName());</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="枚举的方法"><a href="#枚举的方法" class="headerlink" title="枚举的方法"></a>枚举的方法</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String toString()</td>
<td>返回枚举值的名字</td>
</tr>
<tr>
<td>values()</td>
<td>返回所有与的枚举值</td>
</tr>
<tr>
<td>valueof(String str)</td>
<td>将一个字符串转成枚举类型</td>
</tr>
</tbody></table>
<p>注意，valueOf内的字符串必须和定义好的枚举值一模一样，包括大小写，感觉很多此一举啊</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> state.WEIFUKUAN.toString();</span><br><span class="line">        System.out.println(<span class="string">&quot;s = &quot;</span> + s);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        state[] states = state.values();</span><br><span class="line">        <span class="keyword">for</span> (state state : states) &#123;</span><br><span class="line">            System.out.println(state);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">state</span> <span class="variable">s2</span> <span class="operator">=</span> state.valueOf(<span class="string">&quot;YIFAHUO&quot;</span>);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/09/27/%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%80/" rel="prev" title="安卓基础">
      <i class="fa fa-chevron-left"></i> 安卓基础
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/10/09/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-0x01%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%80/" rel="next" title="逆向学习 0x01安卓基础">
      逆向学习 0x01安卓基础 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E4%B8%8A"><span class="nav-number">1.</span> <span class="nav-text">Java上</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%99%E4%B8%80%E4%B8%AAhelloword"><span class="nav-number">1.0.0.0.1.</span> <span class="nav-text">写一个helloword</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E4%B9%8B%E5%89%8D%E7%9A%84%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.0.0.0.2.</span> <span class="nav-text">解释一下之前的入门程序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98"><span class="nav-number">1.0.0.0.3.</span> <span class="nav-text">字符编码问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%BA%90%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%8E%E7%B1%BB%E7%9B%AE%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98"><span class="nav-number">1.0.0.0.4.</span> <span class="nav-text">源文件名与类目一致问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#println%E5%92%8Cprint%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.0.0.5.</span> <span class="nav-text">println和print的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96"><span class="nav-number">1.0.1.</span> <span class="nav-text">常量、变量、类型转化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-number">1.0.1.1.</span> <span class="nav-text">常量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%B8%80%E4%B8%8B%E5%B8%B8%E9%87%8F%E7%9A%84%E8%BF%90%E7%AE%97"><span class="nav-number">1.0.1.2.</span> <span class="nav-text">注意一下常量的运算</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.0.2.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">1.0.3.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="nav-number">1.0.3.1.</span> <span class="nav-text">转义字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-number">1.0.3.2.</span> <span class="nav-text">标识符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.0.4.</span> <span class="nav-text">数据类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.0.4.1.</span> <span class="nav-text">自动类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.0.4.2.</span> <span class="nav-text">强制类型转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.0.5.</span> <span class="nav-text">位运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%B3%E7%A7%BB"><span class="nav-number">1.0.5.1.</span> <span class="nav-text">右移</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%8F%B3%E7%A7%BB"><span class="nav-number">1.0.5.2.</span> <span class="nav-text">无符号右移</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6-1"><span class="nav-number">1.0.5.3.</span> <span class="nav-text">位运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8E"><span class="nav-number">1.0.5.3.1.</span> <span class="nav-text">与&amp;</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%88%96"><span class="nav-number">1.0.5.3.2.</span> <span class="nav-text">或|</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%82%E6%88%96"><span class="nav-number">1.0.5.3.3.</span> <span class="nav-text">异或^</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%89%E4%BD%8D%E5%8F%96%E5%8F%8D"><span class="nav-number">1.0.5.3.4.</span> <span class="nav-text">按位取反</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">1.0.5.4.</span> <span class="nav-text">运算符的优先级</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7idea"><span class="nav-number">1.0.6.</span> <span class="nav-text">使用开发工具idea</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="nav-number">1.0.6.1.</span> <span class="nav-text">快捷键</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.0.7.</span> <span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.0.7.1.</span> <span class="nav-text">自增自减运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.0.7.2.</span> <span class="nav-text">逻辑运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.0.7.3.</span> <span class="nav-text">三元运算符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="nav-number">1.1.</span> <span class="nav-text">流程控制语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Scanner%E9%94%AE%E7%9B%98%E5%BD%95%E5%85%A5"><span class="nav-number">1.1.1.</span> <span class="nav-text">Scanner键盘录入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Random%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="nav-number">1.1.2.</span> <span class="nav-text">Random随机数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5-1"><span class="nav-number">1.1.3.</span> <span class="nav-text">流程控制语句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#switch"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">switch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#if"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">if</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#switch%E5%92%8Cif%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">switch和if的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#for%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">for循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#do%E2%80%A6%E2%80%A6while%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.1.3.5.</span> <span class="nav-text">do……while循环</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.1.</span> <span class="nav-text">数组操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">获取数组长度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">获取元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E7%9A%84%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">数组操作的常见异常</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E5%BC%82%E5%B8%B8-ArrayIndexOutOfBoundsException"><span class="nav-number">1.2.1.3.1.</span> <span class="nav-text">数组索引越界异常_ArrayIndexOutOfBoundsException</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8-NullPinterException"><span class="nav-number">1.2.1.3.2.</span> <span class="nav-text">空指针异常_NullPinterException</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%89%A9%E5%AE%B9"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">数组扩容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%9B%BE"><span class="nav-number">1.2.1.5.</span> <span class="nav-text">内存图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.1.6.</span> <span class="nav-text">二维数组</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.1.</span> <span class="nav-text">定义方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">形参和实参</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E6%80%9D%E6%83%B3"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">三层架构思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">数组作为参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">重载方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.4.</span> <span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.4.1.</span> <span class="nav-text">类和对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.4.2.</span> <span class="nav-text">匿名对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8%E6%97%B6%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">一个对象调用时的内存图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%EF%BC%88%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%89%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">全局变量（成员变量）和局部变量的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%E6%80%9D%E6%83%B3"><span class="nav-number">1.4.3.</span> <span class="nav-text">封装思想</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#private%E9%9A%90%E8%97%8F"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">private隐藏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#this%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">this的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">构造方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0"><span class="nav-number">1.4.3.3.1.</span> <span class="nav-text">无参构造</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0"><span class="nav-number">1.4.3.3.2.</span> <span class="nav-text">有参构造</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JavaBean"><span class="nav-number">1.4.3.3.3.</span> <span class="nav-text">JavaBean</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">1.4.4.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">static关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#static%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="nav-number">1.4.4.1.1.</span> <span class="nav-text">static修饰成员的访问特点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">定义可变参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%BF%BB%E8%BD%AC"><span class="nav-number">1.4.4.4.</span> <span class="nav-text">数组翻转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">1.4.4.5.</span> <span class="nav-text">&#x3D;&#x3D;冒泡排序&#x3D;&#x3D;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">1.4.4.6.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="nav-number">1.4.4.7.</span> <span class="nav-text">对象数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0"><span class="nav-number">1.4.4.8.</span> <span class="nav-text">方法参数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.4.4.8.1.</span> <span class="nav-text">基本数据类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.4.4.8.2.</span> <span class="nav-text">引用数据类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="nav-number">1.4.4.8.3.</span> <span class="nav-text">命令行参数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#debug%E8%B0%83%E8%AF%95"><span class="nav-number">1.4.4.9.</span> <span class="nav-text">debug调试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E4%B8%8B"><span class="nav-number">1.5.</span> <span class="nav-text">Java下</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF-1"><span class="nav-number">1.5.1.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">继承的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">继承中成员访问特点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-number">1.5.1.2.1.</span> <span class="nav-text">成员变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="nav-number">1.5.1.2.2.</span> <span class="nav-text">成员方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">方法的重写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#super%E5%92%8Cthis"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">super和this</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.5.1.5.</span> <span class="nav-text">继承的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1"><span class="nav-number">1.5.1.6.</span> <span class="nav-text">抽象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="nav-number">1.5.1.6.1.</span> <span class="nav-text">注意事项：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.6.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98"><span class="nav-number">1.6.1.</span> <span class="nav-text">接口中的成员</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">抽象方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">默认方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">静态方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-1"><span class="nav-number">1.6.1.4.</span> <span class="nav-text">成员变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.6.2.</span> <span class="nav-text">接口的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.6.3.</span> <span class="nav-text">接口和抽象类的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">1.7.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E4%B8%8B%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.7.1.</span> <span class="nav-text">多态下成员访问的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">1.7.2.</span> <span class="nav-text">多态的好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E4%B8%AD%E7%9A%84%E8%BD%AC%E5%9E%8B"><span class="nav-number">1.7.3.</span> <span class="nav-text">多态中的转型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">向上转型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="nav-number">1.7.3.2.</span> <span class="nav-text">向下转型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%E9%97%AE%E9%A2%98"><span class="nav-number">1.7.3.3.</span> <span class="nav-text">向下转型问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%82%E9%A1%B9"><span class="nav-number">1.8.</span> <span class="nav-text">杂项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">1.8.1.</span> <span class="nav-text">权限修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.8.2.</span> <span class="nav-text">final关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E7%B1%BB"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">修饰类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">修饰方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">1.8.2.3.</span> <span class="nav-text">修饰局部变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.8.2.4.</span> <span class="nav-text">修饰对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-number">1.8.2.5.</span> <span class="nav-text">修饰成员变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">1.8.3.</span> <span class="nav-text">代码块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">1.8.3.1.</span> <span class="nav-text">构造代码块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">1.8.3.2.</span> <span class="nav-text">静态代码块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.8.3.3.</span> <span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.8.3.3.1.</span> <span class="nav-text">静态成员内部类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.8.3.3.2.</span> <span class="nav-text">非静态成员内部类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.8.3.3.3.</span> <span class="nav-text">局部内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">1.8.3.3.3.1.</span> <span class="nav-text">局部内部类基本操作</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E5%AE%9E%E9%99%85%E6%93%8D%E4%BD%9C"><span class="nav-number">1.8.3.3.3.2.</span> <span class="nav-text">局部内部类实际操作</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="nav-number">1.8.3.3.4.</span> <span class="nav-text">匿名内部类（重点）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%A4%8D%E6%9D%82%E4%BD%BF%E7%94%A8"><span class="nav-number">1.8.3.3.4.1.</span> <span class="nav-text">匿名内部类的复杂使用</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">1.8.4.</span> <span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">1.8.4.1.</span> <span class="nav-text">创建异常对象（了解）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">1.8.4.2.</span> <span class="nav-text">异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#throws"><span class="nav-number">1.8.4.2.1.</span> <span class="nav-text">throws</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#try%E2%80%A6%E2%80%A6catch"><span class="nav-number">1.8.4.2.2.</span> <span class="nav-text">try……catch</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E5%BC%82%E5%B8%B8"><span class="nav-number">1.8.4.2.2.1.</span> <span class="nav-text">处理多个异常</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#finally%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.8.4.3.</span> <span class="nav-text">finally关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#finally%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.8.4.3.1.</span> <span class="nav-text">finally的使用场景</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.8.4.4.</span> <span class="nav-text">抛异常的注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="nav-number">1.8.4.5.</span> <span class="nav-text">自定义异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%8D%B0%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E7%9A%84%E4%B8%89%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="nav-number">1.8.4.6.</span> <span class="nav-text">打印错误信息的三个方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object%E7%B1%BB"><span class="nav-number">1.8.5.</span> <span class="nav-text">Object类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#toString-NaN"><span class="nav-number">1.8.5.1.</span> <span class="nav-text">toString()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#equals"><span class="nav-number">1.8.5.2.</span> <span class="nav-text">equals</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#clone%E6%96%B9%E6%B3%95-%E5%85%8B%E9%9A%86"><span class="nav-number">1.8.5.3.</span> <span class="nav-text">clone方法(克隆)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.8.6.</span> <span class="nav-text">经典接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#java-lang-Comparable"><span class="nav-number">1.8.6.1.</span> <span class="nav-text">java.lang.Comparable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java-util-Comparator"><span class="nav-number">1.8.6.2.</span> <span class="nav-text">java.util.Comparator</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#API%E9%83%A8%E5%88%86"><span class="nav-number">1.9.</span> <span class="nav-text">API部分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String"><span class="nav-number">1.9.1.</span> <span class="nav-text">String</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3string"><span class="nav-number">1.9.1.1.</span> <span class="nav-text">了解string</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.9.1.2.</span> <span class="nav-text">String的实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">1.9.1.3.</span> <span class="nav-text">String的创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.9.1.4.</span> <span class="nav-text">String常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95"><span class="nav-number">1.9.1.4.1.</span> <span class="nav-text">判断方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%8A%9F%E8%83%BD"><span class="nav-number">1.9.1.4.2.</span> <span class="nav-text">获取功能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E5%8A%9F%E8%83%BD"><span class="nav-number">1.9.1.4.3.</span> <span class="nav-text">转换功能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%89%B2%E5%8A%9F%E8%83%BD"><span class="nav-number">1.9.1.4.4.</span> <span class="nav-text">分割功能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="nav-number">1.9.1.4.5.</span> <span class="nav-text">其他方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StringBuilder"><span class="nav-number">1.9.2.</span> <span class="nav-text">StringBuilder</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E2%99%82%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">深入♂了解一下</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#StringBuilter%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.9.2.2.</span> <span class="nav-text">StringBuilter的使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3%E7%B1%BB"><span class="nav-number">1.9.3.</span> <span class="nav-text">数学相关类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Math"><span class="nav-number">1.9.3.1.</span> <span class="nav-text">Math</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Math%E6%96%B9%E6%B3%95"><span class="nav-number">1.9.3.1.1.</span> <span class="nav-text">Math方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BigInteger"><span class="nav-number">1.9.3.2.</span> <span class="nav-text">BigInteger</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BigDecimal"><span class="nav-number">1.9.3.3.</span> <span class="nav-text">BigDecimal</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="nav-number">1.9.4.</span> <span class="nav-text">日期类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Date"><span class="nav-number">1.9.4.1.</span> <span class="nav-text">Date</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Calendar%E6%97%A5%E5%8E%86%E7%B1%BB"><span class="nav-number">1.9.4.2.</span> <span class="nav-text">Calendar日历类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SipleDateFormat%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="nav-number">1.9.4.3.</span> <span class="nav-text">SipleDateFormat日期格式化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jdk8%E6%96%B0%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="nav-number">1.9.4.4.</span> <span class="nav-text">jdk8新日期类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#LocalDate%E6%9C%AC%E5%9C%B0%E6%97%A5%E6%9C%9F"><span class="nav-number">1.9.4.4.1.</span> <span class="nav-text">LocalDate本地日期</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#LocalDateTime%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.9.4.4.1.1.</span> <span class="nav-text">LocalDateTime对象</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94%E5%AD%97%E6%AE%B5get%E5%BC%80%E5%A4%B4"><span class="nav-number">1.9.4.4.1.2.</span> <span class="nav-text">获取对应字段get开头</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E6%97%A5%E6%9C%9F%E5%AD%97%E6%AE%B5with%E5%BC%80%E5%A4%B4"><span class="nav-number">1.9.4.4.1.3.</span> <span class="nav-text">设置日期字段with开头</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E5%AD%97%E6%AE%B5%E5%81%8F%E7%A7%BB"><span class="nav-number">1.9.4.4.1.4.</span> <span class="nav-text">日期字段偏移</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Period%E8%AE%A1%E7%AE%97%E6%97%A5%E6%9C%9F%E4%B9%8B%E9%97%B4%E7%9A%84%E5%81%8F%E5%B7%AE"><span class="nav-number">1.9.4.4.2.</span> <span class="nav-text">Period计算日期之间的偏差</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Duration%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E4%B9%8B%E9%97%B4%E7%9A%84%E5%81%8F%E5%B7%AE"><span class="nav-number">1.9.4.4.3.</span> <span class="nav-text">Duration计算时间之间的偏差</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DateTimeFormatter%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%B1%BB%EF%BC%88%E9%BA%BB%E7%83%A6%E3%80%81%E9%9A%BE%E8%AE%B0%E3%80%81%E6%9C%89%E6%9B%BF%E4%BB%A3%EF%BC%89"><span class="nav-number">1.9.4.4.4.</span> <span class="nav-text">DateTimeFormatter日期格式化类（麻烦、难记、有替代）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">1.9.5.</span> <span class="nav-text">工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#System"><span class="nav-number">1.9.5.1.</span> <span class="nav-text">System</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Arrays%E6%95%B0%E7%BB%84%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">1.9.5.2.</span> <span class="nav-text">&#x3D;&#x3D;Arrays数组工具类&#x3D;&#x3D;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-number">1.9.6.</span> <span class="nav-text">包装类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Integer"><span class="nav-number">1.9.6.1.</span> <span class="nav-text">Integer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E8%A3%85%E7%AE%B1"><span class="nav-number">1.9.6.2.</span> <span class="nav-text">自动拆箱装箱</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8CString%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.9.6.3.</span> <span class="nav-text">基本类型和String类之间的转换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E8%BD%ACString"><span class="nav-number">1.9.6.3.1.</span> <span class="nav-text">基本类型转String</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#String%E8%BD%AC%E6%88%90%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.9.6.3.2.</span> <span class="nav-text">String转成基本数据类型</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.10.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.10.1.</span> <span class="nav-text">了解多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.10.1.1.</span> <span class="nav-text">进程与线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="nav-number">1.10.1.2.</span> <span class="nav-text">并发与并行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU%E8%B0%83%E5%BA%A6"><span class="nav-number">1.10.1.3.</span> <span class="nav-text">CPU调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.10.1.4.</span> <span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="nav-number">1.10.2.</span> <span class="nav-text">创建线程（重点）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BFThread"><span class="nav-number">1.10.2.1.</span> <span class="nav-text">继承Thread</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Thread%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.10.2.1.1.</span> <span class="nav-text">Thread中的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Thread%E4%B8%AD%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="nav-number">1.10.2.1.2.</span> <span class="nav-text">Thread中的其他方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">1.10.2.1.2.1.</span> <span class="nav-text">优先级</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.10.2.1.2.2.</span> <span class="nav-text">守护线程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%A4%BC%E8%AE%A9%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.10.2.1.2.3.</span> <span class="nav-text">礼让线程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.10.2.1.2.4.</span> <span class="nav-text">插入线程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.10.2.2.</span> <span class="nav-text">实现Runnable接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.10.2.3.</span> <span class="nav-text">两种创建方法的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.10.2.4.</span> <span class="nav-text">匿名内部类创建多线程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">1.10.3.</span> <span class="nav-text">线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">1.10.3.1.</span> <span class="nav-text">同步代码块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="nav-number">1.10.3.2.</span> <span class="nav-text">同步方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="nav-number">1.10.3.2.1.</span> <span class="nav-text">普通同步方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="nav-number">1.10.3.2.2.</span> <span class="nav-text">静态同步方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">1.10.3.3.</span> <span class="nav-text">死锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.10.4.</span> <span class="nav-text">线程生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6"><span class="nav-number">1.10.5.</span> <span class="nav-text">等待唤醒机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lock%E9%94%81"><span class="nav-number">1.10.6.</span> <span class="nav-text">Lock锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%B9%E5%BC%8F3-Callable%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.10.7.</span> <span class="nav-text">实现多线程方式3-Callable接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%B9%E5%BC%8F4-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.10.8.</span> <span class="nav-text">实现多线程方式4-线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8-Timer"><span class="nav-number">1.10.8.0.1.</span> <span class="nav-text">定时器 Timer</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">1.11.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%88%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88%EF%BC%89"><span class="nav-number">1.11.1.</span> <span class="nav-text">集合框架（单列集合）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D%EF%BC%9A"><span class="nav-number">1.11.1.1.</span> <span class="nav-text">框架介绍：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Collection%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.11.1.2.</span> <span class="nav-text">Collection接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">1.11.2.</span> <span class="nav-text">迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E8%BF%AD%E4%BB%A3%E8%BF%87%E7%A8%8B"><span class="nav-number">1.11.2.1.</span> <span class="nav-text">迭代器的迭代过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">1.11.2.2.</span> <span class="nav-text">迭代器底层原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E5%BC%82%E5%B8%B8"><span class="nav-number">1.11.2.3.</span> <span class="nav-text">并发修改异常</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.11.3.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">1.11.3.1.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">1.11.3.2.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84-1"><span class="nav-number">1.11.3.3.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">1.11.3.4.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">1.11.3.4.1.</span> <span class="nav-text">单向链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">1.11.3.4.2.</span> <span class="nav-text">双向链表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.11.4.</span> <span class="nav-text">List接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayList%E9%9B%86%E5%90%88"><span class="nav-number">1.11.4.1.</span> <span class="nav-text">ArrayList集合</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#remove%E9%97%AE%E9%A2%98"><span class="nav-number">1.11.4.1.1.</span> <span class="nav-text">remove问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81"><span class="nav-number">1.11.4.1.2.</span> <span class="nav-text">底层源码</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0-1"><span class="nav-number">1.11.4.1.2.1.</span> <span class="nav-text">无参构造</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0-1"><span class="nav-number">1.11.4.1.2.2.</span> <span class="nav-text">有参构造</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedList%E9%9B%86%E5%90%88"><span class="nav-number">1.11.4.2.</span> <span class="nav-text">LinkedList集合</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#LinkedList%E5%BA%95%E5%B1%82%E6%88%90%E5%91%98"><span class="nav-number">1.11.4.2.1.</span> <span class="nav-text">LinkedList底层成员</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%86%E6%9E%90add%E6%96%B9%E6%B3%95"><span class="nav-number">1.11.4.2.1.1.</span> <span class="nav-text">分析add方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%86%E6%9E%90get%E6%96%B9%E6%B3%95"><span class="nav-number">1.11.4.2.1.2.</span> <span class="nav-text">分析get方法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A2%9E%E5%BC%BAfor"><span class="nav-number">1.11.5.</span> <span class="nav-text">增强for</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Collections-%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">1.11.6.</span> <span class="nav-text">&#x3D;&#x3D;Collections&#x3D;&#x3D;集合工具类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">1.11.7.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AB%E6%9C%89%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%B1%BB"><span class="nav-number">1.11.7.1.</span> <span class="nav-text">含有泛型的类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AB%E6%9C%89%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.11.7.2.</span> <span class="nav-text">含有泛型的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AB%E6%9C%89%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.11.7.3.</span> <span class="nav-text">含有泛型的接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-number">1.11.7.4.</span> <span class="nav-text">泛型的通配符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%8A%E9%99%90%E4%B8%8B%E9%99%90"><span class="nav-number">1.11.7.4.1.</span> <span class="nav-text">泛型的上限下限</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%A6%E4%BB%A5%E8%87%B4%E7%94%A8"><span class="nav-number">1.11.8.</span> <span class="nav-text">学以致用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">1.11.9.</span> <span class="nav-text">红黑树（了解）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.11.10.</span> <span class="nav-text">Set接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HashSet%E9%9B%86%E5%90%88"><span class="nav-number">1.11.10.1.</span> <span class="nav-text">HashSet集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedHahSet"><span class="nav-number">1.11.10.2.</span> <span class="nav-text">LinkedHahSet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E5%80%BC"><span class="nav-number">1.11.10.3.</span> <span class="nav-text">哈希值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashSet%E5%AD%98%E5%82%A8%E5%8E%BB%E9%87%8D%E8%BF%87%E7%A8%8B"><span class="nav-number">1.11.10.4.</span> <span class="nav-text">HashSet存储去重过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%88"><span class="nav-number">1.11.11.</span> <span class="nav-text">双列集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Map%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.11.11.1.</span> <span class="nav-text">Map接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap"><span class="nav-number">1.11.11.2.</span> <span class="nav-text">HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#LinkedHashMap"><span class="nav-number">1.11.11.2.1.</span> <span class="nav-text">LinkedHashMap</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">1.11.11.2.2.</span> <span class="nav-text">遍历的两种方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Map%E5%8E%BB%E9%87%8D"><span class="nav-number">1.11.11.2.3.</span> <span class="nav-text">Map去重</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Map%E7%BB%83%E4%B9%A0"><span class="nav-number">1.11.11.2.4.</span> <span class="nav-text">Map练习</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AD%98%E5%82%A8%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">1.11.12.</span> <span class="nav-text">哈希表存储的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81"><span class="nav-number">1.11.13.</span> <span class="nav-text">哈希表底层源码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E9%97%AE%E9%A2%98"><span class="nav-number">1.11.13.1.</span> <span class="nav-text">索引问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeSet"><span class="nav-number">1.11.14.</span> <span class="nav-text">TreeSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeMap"><span class="nav-number">1.11.15.</span> <span class="nav-text">TreeMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hashtable%E5%92%8CVector-%E4%BA%86%E8%A7%A3"><span class="nav-number">1.11.16.</span> <span class="nav-text">Hashtable和Vector(了解)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Hashtable"><span class="nav-number">1.11.16.1.</span> <span class="nav-text">Hashtable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Vector%E9%9B%86%E5%90%88"><span class="nav-number">1.11.16.2.</span> <span class="nav-text">Vector集合</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Properties%E9%9B%86%E5%90%88%EF%BC%88%E5%B1%9E%E6%80%A7%E9%9B%86%EF%BC%89"><span class="nav-number">1.11.17.</span> <span class="nav-text">Properties集合（属性集）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E5%B5%8C%E5%A5%97"><span class="nav-number">1.11.18.</span> <span class="nav-text">集合嵌套</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO%E6%B5%81"><span class="nav-number">1.12.</span> <span class="nav-text">IO流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#File%E7%B1%BB"><span class="nav-number">1.12.1.</span> <span class="nav-text">File类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#File%E4%BD%BF%E7%94%A8"><span class="nav-number">1.12.1.1.</span> <span class="nav-text">File使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95-1"><span class="nav-number">1.12.1.2.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95"><span class="nav-number">1.12.1.2.1.</span> <span class="nav-text">获取方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95"><span class="nav-number">1.12.1.2.2.</span> <span class="nav-text">创建方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%96%B9%E6%B3%95"><span class="nav-number">1.12.1.2.3.</span> <span class="nav-text">删除方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95-1"><span class="nav-number">1.12.1.2.4.</span> <span class="nav-text">判断方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="nav-number">1.12.1.2.5.</span> <span class="nav-text">遍历方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81"><span class="nav-number">1.12.2.</span> <span class="nav-text">字节流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IO%E6%B5%81%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.12.2.1.</span> <span class="nav-text">IO流介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IO%E6%B5%81%E7%9A%84%E6%B5%81%E5%90%91"><span class="nav-number">1.12.2.2.</span> <span class="nav-text">IO流的流向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IO%E6%B5%81%E5%88%86%E7%B1%BB"><span class="nav-number">1.12.2.3.</span> <span class="nav-text">IO流分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">1.12.2.4.</span> <span class="nav-text">字节输出流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%BD%E5%8A%A0%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.12.2.4.1.</span> <span class="nav-text">追加模式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81%EF%BC%88%E5%8F%AA%E8%AF%BB%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">1.12.2.5.</span> <span class="nav-text">字节输入流（只读模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E6%AC%A1%E5%8F%AA%E8%AF%BB%E4%B8%80%E4%B8%AA"><span class="nav-number">1.12.2.5.1.</span> <span class="nav-text">一次只读一个</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E5%87%BA-1%E9%97%AE%E9%A2%98"><span class="nav-number">1.12.2.5.2.</span> <span class="nav-text">读出-1问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E6%AC%A1%E8%AF%BB%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84"><span class="nav-number">1.12.2.5.3.</span> <span class="nav-text">一次读一个数组</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6"><span class="nav-number">1.12.2.6.</span> <span class="nav-text">实现文件复制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="nav-number">1.12.3.</span> <span class="nav-text">字符流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FileReader%EF%BC%88%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81%EF%BC%89"><span class="nav-number">1.12.3.1.</span> <span class="nav-text">FileReader（字符输入流）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FileWriter%EF%BC%88%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%89"><span class="nav-number">1.12.3.2.</span> <span class="nav-text">FileWriter（字符输出流）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E6%B5%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">1.12.4.</span> <span class="nav-text">IO流异常处理方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E6%B5%81"><span class="nav-number">1.12.5.</span> <span class="nav-text">缓冲流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81"><span class="nav-number">1.12.5.1.</span> <span class="nav-text">字节缓冲流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81"><span class="nav-number">1.12.5.2.</span> <span class="nav-text">字符缓冲流</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="nav-number">1.12.6.</span> <span class="nav-text">转换流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#InputStreamReader"><span class="nav-number">1.12.6.1.</span> <span class="nav-text">InputStreamReader</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OutputStreamWriter"><span class="nav-number">1.12.6.2.</span> <span class="nav-text">OutputStreamWriter</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81"><span class="nav-number">1.12.7.</span> <span class="nav-text">序列化流和反序列化流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ObjectOutputStream"><span class="nav-number">1.12.7.1.</span> <span class="nav-text">ObjectOutputStream</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ObjectInputStream"><span class="nav-number">1.12.7.2.</span> <span class="nav-text">ObjectInputStream</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.12.7.3.</span> <span class="nav-text">反序列化时出现的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E5%8D%B0%E6%B5%81"><span class="nav-number">1.12.8.</span> <span class="nav-text">打印流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B9%E5%8F%98%E6%B5%81%E5%90%91"><span class="nav-number">1.12.8.1.</span> <span class="nav-text">改变流向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%8D%B0%E6%B5%81%E7%BB%AD%E5%86%99"><span class="nav-number">1.12.8.2.</span> <span class="nav-text">打印流续写</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Properties%E9%9B%86%E5%90%88"><span class="nav-number">1.12.9.</span> <span class="nav-text">Properties集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E6%B5%81%E5%B7%A5%E5%85%B7%E7%B1%BB-Commons-io"><span class="nav-number">1.12.10.</span> <span class="nav-text">IO流工具类-Commons-io</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E7%AC%AC%E4%B8%89%E6%96%B9jar%E5%8C%85"><span class="nav-number">1.12.10.1.</span> <span class="nav-text">添加第三方jar包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8C%85"><span class="nav-number">1.12.10.2.</span> <span class="nav-text">使用工具包</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#IoUtils%E7%B1%BB"><span class="nav-number">1.12.10.2.1.</span> <span class="nav-text">IoUtils类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FileUtils%E7%B1%BB"><span class="nav-number">1.12.10.2.2.</span> <span class="nav-text">FileUtils类</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">1.13.</span> <span class="nav-text">网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-number">1.13.1.</span> <span class="nav-text">软件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A6%82%E5%BF%B5"><span class="nav-number">1.13.1.1.</span> <span class="nav-text">服务器概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="nav-number">1.13.1.2.</span> <span class="nav-text">通信三要素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A8%8B"><span class="nav-number">1.13.1.3.</span> <span class="nav-text">UDP协议编程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%88%E5%8F%91%E9%80%81%E7%AB%AF%EF%BC%89"><span class="nav-number">1.13.1.3.1.</span> <span class="nav-text">客户端（发送端）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%88%E6%8E%A5%E6%94%B6%E7%AB%AF%EF%BC%89"><span class="nav-number">1.13.1.3.2.</span> <span class="nav-text">服务端（接收端）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A8%8B"><span class="nav-number">1.13.1.4.</span> <span class="nav-text">TCP协议编程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">1.13.1.4.1.</span> <span class="nav-text">客户端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="nav-number">1.13.1.4.2.</span> <span class="nav-text">服务端</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="nav-number">1.13.1.5.</span> <span class="nav-text">练习：文件上传</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF-1"><span class="nav-number">1.13.1.5.1.</span> <span class="nav-text">服务端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-1"><span class="nav-number">1.13.1.5.2.</span> <span class="nav-text">客户端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bug"><span class="nav-number">1.13.1.5.3.</span> <span class="nav-text">bug</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">1.13.1.5.3.1.</span> <span class="nav-text">解决方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86"><span class="nav-number">1.13.1.6.</span> <span class="nav-text">多线程处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.13.1.7.</span> <span class="nav-text">正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8"><span class="nav-number">1.13.1.7.1.</span> <span class="nav-text">具体使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#String%E4%B8%AD%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.13.1.7.2.</span> <span class="nav-text">String中和正则表达式相关的方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.13.1.8.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.13.1.8.1.</span> <span class="nav-text">模板方法设计模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.13.1.8.2.</span> <span class="nav-text">单例模式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="nav-number">1.13.1.8.2.1.</span> <span class="nav-text">饿汉式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F"><span class="nav-number">1.13.1.8.2.2.</span> <span class="nav-text">懒汉式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lombok%E4%BD%BF%E7%94%A8"><span class="nav-number">1.13.1.9.</span> <span class="nav-text">Lombok使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Getter%E5%92%8C-Setter"><span class="nav-number">1.13.1.9.1.</span> <span class="nav-text">@Getter和@Setter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ToString"><span class="nav-number">1.13.1.9.2.</span> <span class="nav-text">@ToString</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#NoArgsConstructor%E5%92%8C-AllArgsConstructor"><span class="nav-number">1.13.1.9.3.</span> <span class="nav-text">@NoArgsConstructor和@AllArgsConstructor</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#EgualsAndHashCode"><span class="nav-number">1.13.1.9.4.</span> <span class="nav-text">@EgualsAndHashCode</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Data"><span class="nav-number">1.13.1.9.5.</span> <span class="nav-text">@Data</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jdk%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.14.</span> <span class="nav-text">jdk新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.14.1.</span> <span class="nav-text">&#x3D;&#x3D;Lambda表达式&#x3D;&#x3D;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%89%8D%E6%8F%90"><span class="nav-number">1.14.1.1.</span> <span class="nav-text">使用前提</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9C%81%E7%95%A5%E8%A7%84%E5%88%99"><span class="nav-number">1.14.1.2.</span> <span class="nav-text">省略规则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.14.2.</span> <span class="nav-text">函数式接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Supplier"><span class="nav-number">1.14.2.1.</span> <span class="nav-text">Supplier</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Consumer"><span class="nav-number">1.14.2.2.</span> <span class="nav-text">Consumer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Function"><span class="nav-number">1.14.2.3.</span> <span class="nav-text">Function</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Predicate"><span class="nav-number">1.14.2.4.</span> <span class="nav-text">Predicate</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stream%E6%B5%81"><span class="nav-number">1.14.3.</span> <span class="nav-text">&#x3D;&#x3D;Stream流&#x3D;&#x3D;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Stream%E6%B5%81%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="nav-number">1.14.3.1.</span> <span class="nav-text">Stream流的获取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Stream%E6%96%B9%E6%B3%95"><span class="nav-number">1.14.3.2.</span> <span class="nav-text">Stream方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="nav-number">1.14.4.</span> <span class="nav-text">方法引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%90%8D%E5%BC%95%E7%94%A8%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="nav-number">1.14.4.1.</span> <span class="nav-text">对象名引用成员方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%90%8D%E5%BC%95%E7%94%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">1.14.4.2.</span> <span class="nav-text">类名引用静态方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB-%E6%9E%84%E9%80%A0%E5%BC%95%E7%94%A8"><span class="nav-number">1.14.4.3.</span> <span class="nav-text">类-构造引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8"><span class="nav-number">1.14.4.4.</span> <span class="nav-text">数组引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-number">1.14.5.</span> <span class="nav-text">Junit单元测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JUnit%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.14.5.1.</span> <span class="nav-text">JUnit的注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.14.5.2.</span> <span class="nav-text">相关注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-number">1.14.6.</span> <span class="nav-text">类的加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89ClassLoader"><span class="nav-number">1.14.6.1.</span> <span class="nav-text">类加载器（了解）ClassLoader</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">1.14.7.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96class%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.14.7.1.</span> <span class="nav-text">获取class对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">1.14.7.2.</span> <span class="nav-text">获取构造方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89public%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">1.14.7.2.1.</span> <span class="nav-text">获取所有public的构造方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%A9%BA%E5%8F%82%E6%9E%84%E9%80%A0"><span class="nav-number">1.14.7.2.2.</span> <span class="nav-text">获取空参构造</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0"><span class="nav-number">1.14.7.2.3.</span> <span class="nav-text">获取有参构造</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0"><span class="nav-number">1.14.7.2.4.</span> <span class="nav-text">获取私有构造</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="nav-number">1.14.7.3.</span> <span class="nav-text">反射成员方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89public%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="nav-number">1.14.7.3.1.</span> <span class="nav-text">获取所有public的成员方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96public%E6%96%B9%E6%B3%95%EF%BC%88%E6%9C%89%E5%8F%82%E3%80%81%E6%97%A0%E5%8F%82%EF%BC%89"><span class="nav-number">1.14.7.3.2.</span> <span class="nav-text">获取public方法（有参、无参）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="nav-number">1.14.7.3.3.</span> <span class="nav-text">获取私有方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-number">1.14.7.4.</span> <span class="nav-text">反射成员变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E5%B1%9E%E6%80%A7"><span class="nav-number">1.14.7.4.1.</span> <span class="nav-text">获取所有属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E5%B1%9E%E6%80%A7"><span class="nav-number">1.14.7.4.2.</span> <span class="nav-text">获取指定属性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%BB%83%E4%B9%A0"><span class="nav-number">1.14.7.5.</span> <span class="nav-text">反射练习</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.14.8.</span> <span class="nav-text">注解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%9A%E4%B9%89%E4%BB%A5%E5%8F%8A%E5%B1%9E%E6%80%A7%E7%9A%84%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.14.8.1.</span> <span class="nav-text">注解的定义以及属性的定义格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.14.8.2.</span> <span class="nav-text">注解的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90"><span class="nav-number">1.14.8.3.</span> <span class="nav-text">注解解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.14.8.4.</span> <span class="nav-text">元注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE"><span class="nav-number">1.14.9.</span> <span class="nav-text">枚举</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.14.9.1.</span> <span class="nav-text">枚举的方法</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="没事数命的猫"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">没事数命的猫</p>
  <div class="site-description" itemprop="description">学而不思则罔</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">没事数命的猫</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
