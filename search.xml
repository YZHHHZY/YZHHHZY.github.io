<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>form表单验证</title>
    <url>/2024/07/03/form%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<h1 id="form表单验证"><a href="#form表单验证" class="headerlink" title="form表单验证"></a>form表单验证</h1><p>前言：做获奖申报时，我想把一些输入框设置为必填，原生小程序中没有表单验证，如果在后端将输入框内的变量挨个使用 <code>if ……else</code> 似乎过于麻烦，结构太复杂，我想用vant组件的表单验证解决，但是遇到点问题：vant-form组件无法引入</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240401203626963.png" alt="image-20240401203626963"></p>
<p>改变思路，尝试引入vue组件，经过一些操作，成功报错</p>
<p>发生错误SyntaxError: parse js file (D:\微信小程序开发\微信小程序练习\miniprogram-18&#x2F;miniprogram&#x2F;node_modules&#x2F;@vue&#x2F;compiler-sfc&#x2F;dist&#x2F;compiler-sfc.cjs.js) failed: Unexpected token (333:15)</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240401200131194.png" alt="image-20240401200131194"></p>
<p>解决方法：</p>
<p>清除npm缓存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm cache clean --force</span><br></pre></td></tr></table></figure>



<h2 id="柳暗花明又一村"><a href="#柳暗花明又一村" class="headerlink" title="柳暗花明又一村"></a>柳暗花明又一村</h2><p><img src="/../%E5%9B%BE%E7%89%87/image-20240401202139114.png" alt="image-20240401202139114"></p>
<h2 id="uni-app"><a href="#uni-app" class="headerlink" title="uni-app"></a>uni-app</h2><p>然后我选择了uni-app组件</p>
<p>组件官方文档：<a href="https://uniapp.dcloud.io/">https://uniapp.dcloud.io/</a></p>
<p>uni-app 推荐使用 Hbuilderx 开发工具来开发项目</p>
<p>下载地址：<a href="https://www.dcloud.io/hbuilderx.html">https://www.dcloud.io/hbuilderx.html</a></p>
<h3 id="Hbuilder-X"><a href="#Hbuilder-X" class="headerlink" title="Hbuilder X"></a>Hbuilder X</h3><h4 id="使用HbuilderX打开微信开发者工具"><a href="#使用HbuilderX打开微信开发者工具" class="headerlink" title="使用HbuilderX打开微信开发者工具"></a>使用HbuilderX打开微信开发者工具</h4><p>1、安装 sass 插件</p>
<p>点击 <strong>工具 &#x3D;&gt; 插件安装 &#x3D;&gt; 安装新插件 &#x3D;&gt; 前往插件市场安装</strong> ，找到需要的插件之后点击下载 &#x3D;&gt; 使用Hbuilderx 导入插件，这里需要登录 sass 的网站，如果登录成功则会打开 Hbuilderx 编译器，然后点击确定就可以安装了；</p>
<p>2、新建uni-app项目</p>
<p>Hbuilderx 点击 <strong>文件&#x3D;&gt;新增&#x3D;&gt;项目</strong> ，本文新建一个小程序项目：uni-app &#x3D;&gt; 填写项目名称、选择项目存放路径 &#x3D;&gt; 模板 uni-ui 项目&#x3D;&gt;创建，然后就可以生成一个小程序项目；</p>
<p>3、配置 appid</p>
<p>在 <strong>manifest.json 文件 &#x3D;&gt; 微信小程序配置</strong> 填写微信小程序 appID；（在微信开放平台上找）</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240401212830280.png" alt="image-20240401212830280"></p>
<p>4、在 Hbuilderx 配置微信开发者工具的安装路径：这样可以在 Hbuilderx 里面运行的时候自动打开微信开发者工具查看项目</p>
<p><strong>工具 &#x3D;&gt; 设置 &#x3D;&gt; 运行配置 &#x3D;&gt; 小程序运行配置</strong> 配置微信开发者工具的安装路径，如：D:\微信小程序开发\微信web开发者工具</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240401212737689.png" alt="image-20240401212737689"></p>
<p>5、在<strong>微信开发者工具</strong>开启服务端口</p>
<p><strong>设置 &#x3D;&gt; 安全设置 &#x3D;&gt; 安全</strong>  开启服务端口</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240401212706282.png" alt="image-20240401212706282"></p>
<p>6、运行</p>
<p>Hbuilderx 点击 <strong>运行&#x3D;&gt;运行到小程序模拟器</strong> 点击第一个就可以在 Hbuilderx 自动编译，成功之后会<strong>自动打开</strong>微信开发者工具；</p>
<p>注意：这个时候我们想修改项目里面的内容，需要在 Hbuilderx 里面修改，例如修改配置：manifest.json 文件 &#x3D;&gt; 源码视图</p>
<p>成功：</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240401212623601.png" alt="image-20240401212623601"></p>
<h4 id="浅尝Hbuilder-X"><a href="#浅尝Hbuilder-X" class="headerlink" title="浅尝Hbuilder X"></a>浅尝Hbuilder X</h4><h5 id="创建新页面"><a href="#创建新页面" class="headerlink" title="创建新页面"></a>创建新页面</h5><p>打开pages文件夹，右键创建新页面</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240401214421029.png" alt="image-20240401214421029"></p>
<p>创建成功之后，pages.json中出现一下内容</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240401215210866.png" alt="image-20240401215210866"></p>
<h5 id="尝试创建tabbar"><a href="#尝试创建tabbar" class="headerlink" title="尝试创建tabbar"></a>尝试创建tabbar</h5><p>在pages.json中写入，同app.json中写法相同</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240401215544190.png" alt="image-20240401215544190"></p>
<p>通过<code>ctrl</code> + <code>s</code> 快捷键保存自动运行，微信开发者工具上即可显示</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240401215625920.png" alt="image-20240401215625920"></p>
<h5 id="尝试表单"><a href="#尝试表单" class="headerlink" title="尝试表单"></a>尝试表单</h5><p>HbuilderX页面中只有一个index.vue文件，因此要将前后端写在一起</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240402104926882.png" alt="image-20240402104926882"></p>
<p>template前端（wxml）</p>
<p>script后端（js）</p>
<p>style样式（wxss）</p>
<p>后端代码中，小程序中的 <code>data:&#123;&#125;</code> 中的变量相当于这里的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">       变量</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">methods: &#123;</span><br><span class="line">    这里写事件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240402105103849.png" alt="image-20240402105103849"></p>
<p>经过官方文档发现，这里改变赋值不需要</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.setData(&#123;</span><br><span class="line">    inputvalue: e.detail.value</span><br><span class="line">&#125;)</span><br><span class="line">而是以一种简单的方法</span><br><span class="line">this.inputvalue = e.detail.value</span><br></pre></td></tr></table></figure>



<p>再来看前端代码</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240402105612322.png" alt="image-20240402105612322"></p>
<p>这里的<code>@submit</code> 相当于微信小程序中的 <code>bindsubmit</code>  <code>@input</code> 相当于 <code>bindinput</code> 大胆推测在vue中 <code>@</code> 的作用相当于小程序中的 <code>bind</code></p>
<p>这样似乎就写好了一个表单，但是我们的目的是做表单验证，让输入框为必填项</p>
<h3 id="开始表单验证"><a href="#开始表单验证" class="headerlink" title="开始表单验证"></a>开始表单验证</h3><p>这里需要引入 <code>uni-forms</code> 组件进入 <code>Hbuilder X</code> ：</p>
<p>官方文档提供的组件下载地址：<a href="https://ext.dcloud.net.cn/plugin?id=2773">https://ext.dcloud.net.cn/plugin?id=2773</a></p>
<p>在vue文件中<strong>引入组件</strong>，注意文件夹位置为实际文件夹位置，不要复制粘贴</p>
<p>一定要引入组件！！！找了好多文章，完全没有提引入的事情</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    </span><br><span class="line">import uniForms from &#x27;@/uni_modules/uni-forms/components/uni-forms/uni-forms.vue&#x27;;</span><br><span class="line">import uniFormsItem from &#x27;@/uni_modules/uni-forms/components/uni-forms-item/uni-forms-item.vue&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    uniForms,</span><br><span class="line">    uniFormsItem</span><br><span class="line">    // 可以在这里注册其他在本页面使用的组件</span><br><span class="line">  &#125;</span><br><span class="line">  // 其他数据和方法...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>引入之后，我的小程序依旧报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Component is not found in path &quot;uni_modules/uni-forms/components/uni-forms/uni-forms&quot; (using by &quot;pages/index/index&quot;)(env: Windows,mp,1.06.2402021; lib: 3.3.4)</span><br><span class="line">Component is not found in path &quot;uni_modules/uni-forms/components/uni-forms-item/uni-forms-item&quot; (using by &quot;pages/index/index&quot;)(env: Windows,mp,1.06.2402021; lib: 3.3.4)</span><br></pre></td></tr></table></figure>

<p>如果路径没有问题的话，就可以尝试清除缓存，重新启动</p>
<p> <code>&lt;uni-forms&gt; </code>  提供了 rules属性来描述校验规则、 <code>&lt;uni-forms-item&gt;</code> 子组件来包裹具体的表单项，以及给原生或三方组件提供了 <code>onFieldChange()</code> 来校验表单值。</p>
<p>每个要校验的表单项，不管input还是checkbox，都必须放在 <code>&lt;uni-forms-item&gt;</code> 组件中，且一个 <code>&lt;uni-forms-item&gt;</code> 组件只能放置一个表单项。</p>
<p> <code>&lt;uni-forms-item&gt;</code> 组件内部预留了显示error message的区域，默认是在表单项的底部。</p>
<p>另外， <code>&lt;uni-forms&gt;</code> 组件下面的各个表单项，可以通过 <code>&lt;uni-group&gt;</code> 包裹为不同的分组。同一 <code> &lt;uni-group&gt;</code> 下的不同表单项目将聚拢在一起，同其他group保持垂直间距。 <code>&lt;uni-group&gt;</code> 仅影响视觉效果。</p>
<h4 id="来写一个简单的表单吧"><a href="#来写一个简单的表单吧" class="headerlink" title="来写一个简单的表单吧"></a>来写一个简单的表单吧</h4><h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><p><img src="/../%E5%9B%BE%E7%89%87/image-20240402195909896.png" alt="image-20240402195909896"></p>
<h6 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;view class=&quot;content&quot;&gt;</span><br><span class="line">		&lt;uni-forms ref=&quot;form&quot; :model=&quot;formData&quot; :rules=&quot;rules&quot;&gt;</span><br><span class="line">			&lt;uni-forms-item label=&quot;姓名&quot; required=true name=&quot;name&quot;&gt;</span><br><span class="line">				&lt;input type=&quot;text&quot; v-model=&quot;formData.name&quot; @input=&quot;event =&gt; binddata(&#x27;name&#x27;,event.detail.value,&#x27;form&#x27;)&quot;/&gt;</span><br><span class="line">			&lt;/uni-forms-item&gt;</span><br><span class="line">			</span><br><span class="line">			&lt;uni-forms-item label=&quot;年龄&quot; required=true name=&quot;age&quot;&gt;</span><br><span class="line">				&lt;input type=&quot;text&quot; v-model=&quot;formData.age&quot; @input=&quot;event =&gt; binddata(&#x27;age&#x27;,event.detail.value,&#x27;form&#x27;)&quot;/&gt;</span><br><span class="line">			&lt;/uni-forms-item&gt;</span><br><span class="line">			&lt;button @click=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class="line">		&lt;/uni-forms&gt;</span><br><span class="line">	&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>



<p>这里要用到了两个之前引入的组件</p>
<p><code>ref</code> 是这个表单的名字   </p>
<p><code>:model</code> 定义的是该表单储存数据的字典，内的元素以key&#x2F;value这种键值对的形式存在</p>
<p><code>:rules</code> 定义的是验证规则</p>
<p>实现表单验证主要依靠这个组件</p>
<p>之前提到过，uni-forms中要实现表单验证需要搭配uni-forms-item组件使用，一个组件内只能放一个input，因此可以get到这个组件类似于view且将表单中的name元素写在这个位置</p>
<p>一些属性：</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240402200724302.png" alt="image-20240402200724302"></p>
<p>还要注意的是这里的input内几个用法</p>
<ol>
<li><p><code>v-model=&quot;formData.name&quot;</code> </p>
<p>我的理解是这个相当于微信小程序input组件的value元素，这里的 <code>v-model </code> 指向的是之前<code>:model</code> 定义过的字典，对应的是name的value</p>
</li>
<li><p><code>@input=&quot;event =&gt; binddata(&#39;name&#39;,event.detail.value,&#39;form&#39;)&quot;</code> </p>
<p>之前提到过@相当于bind所有这个解释bindinput输入事件，作用是输入时改变字典内相对于的值</p>
<p>‘name’，就是指向字典内的key值；</p>
<p>‘event.detail.value’，是输入的内容；</p>
<p>‘form’，是指表单名称，由之前的ref定义的</p>
</li>
</ol>
<h5 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	import uniForms from &#x27;@/uni_modules/uni-forms/components/uni-forms/uni-forms.vue&#x27;;</span><br><span class="line">	import uniFormsItem from &#x27;@/uni_modules/uni-forms/components/uni-forms-item/uni-forms-item.vue&#x27;;</span><br><span class="line">	</span><br><span class="line">	export default &#123;</span><br><span class="line">		components: &#123;</span><br><span class="line">		  uniForms,</span><br><span class="line">		  uniFormsItem</span><br><span class="line">		  // 可以在这里注册其他在本页面使用的组件</span><br><span class="line">		&#125;,</span><br><span class="line">		data() &#123;</span><br><span class="line">			return &#123;</span><br><span class="line">				formData: &#123;</span><br><span class="line">					name: &#x27;&#x27;,</span><br><span class="line">					age: &#x27;&#x27;</span><br><span class="line">				&#125;,</span><br><span class="line">				rules: &#123;</span><br><span class="line">					name: &#123;</span><br><span class="line">						rules: [&#123;</span><br><span class="line">							required: true,</span><br><span class="line">							errorMessage: &#x27;姓名不能为空&#x27;</span><br><span class="line">						&#125;]</span><br><span class="line">					&#125;,</span><br><span class="line">					age: &#123;</span><br><span class="line">						rules: [&#123;</span><br><span class="line">							required: true,</span><br><span class="line">							errorMessage: &#x27;年龄不能为空&#x27;</span><br><span class="line">						&#125;, &#123;</span><br><span class="line">							format: &#x27;number&#x27;,</span><br><span class="line">							errorMessage: &#x27;年龄只能输入数字&#x27;</span><br><span class="line">						&#125;]</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		onLoad() &#123;</span><br><span class="line"></span><br><span class="line">		&#125;,</span><br><span class="line">		methods: &#123;</span><br><span class="line">			submit() &#123;</span><br><span class="line">						this.$refs.form.validate().then(res=&gt;&#123;</span><br><span class="line">							console.log(&#x27;表单数据信息：&#x27;, res);</span><br><span class="line">						&#125;).catch(err =&gt;&#123;</span><br><span class="line">							console.log(&#x27;表单错误信息：&#x27;, err);</span><br><span class="line">						&#125;)</span><br><span class="line">					&#125;,</span><br><span class="line">			binddata(fieldName, value, form) &#123;</span><br><span class="line">			      // 这里实现 binddata 方法的逻辑</span><br><span class="line">			      // 例如，更新 formData 对象中对应字段的值</span><br><span class="line">			      this.formData[fieldName] = value;</span><br><span class="line">			      console.log(this.formData[fieldName])</span><br><span class="line">			      // 如果有额外的逻辑需要根据表单名处理，也可以在这里添加</span><br><span class="line">			    &#125;,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>后端相比于小程序的变化前面已经说过了，直接看代码，因为之前定义了一个 <code>formData</code> 的变量，因此需要在后端进行补充，这里定义了需要用到的键值对</p>
<p>然后定义表单验证规则，毕竟红点只是前端，只是看，这里的结构为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的rules是前端用 `:rules` 命名的无特殊含义</span></span><br><span class="line"><span class="attr">rules</span>: &#123;</span><br><span class="line">   变量: &#123;</span><br><span class="line">       <span class="attr">rules</span>: [&#123;</span><br><span class="line">           <span class="attr">required</span>: <span class="literal">true</span>, </span><br><span class="line">           <span class="comment">// 确定元素是否为必填项</span></span><br><span class="line"></span><br><span class="line">		   <span class="attr">errorMessage</span>: <span class="string">&#x27;姓名不能为空&#x27;</span></span><br><span class="line">           <span class="comment">// 元素未填时的提示信息</span></span><br><span class="line">       &#125;]</span><br><span class="line">   &#125;,</span><br><span class="line">   变量: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>rules的一些属性</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240403082244110.png" alt="image-20240403082244110"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240403082415300.png" alt="image-20240403082415300"></p>
<h6 id="这里学到了一个知识点，对代码简化很有帮助"><a href="#这里学到了一个知识点，对代码简化很有帮助" class="headerlink" title="这里学到了一个知识点，对代码简化很有帮助"></a>这里学到了一个知识点，对代码简化很有帮助</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">binddata</span>(<span class="params">fieldName, value, form</span>) &#123;</span><br><span class="line">	<span class="comment">// 这里实现 binddata 方法的逻辑</span></span><br><span class="line">	<span class="comment">// 例如，更新 formData 对象中对应字段的值</span></span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">formData</span>[fieldName] = value;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">formData</span>[fieldName])</span><br><span class="line">	<span class="comment">// 如果有额外的逻辑需要根据表单名处理，也可以在这里添加</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>这里的<code>fieldName</code> 是一个动态参数，而且<code>fieldName</code> 并不固定可以由自己随意改变</p>
<p>这个函数为多输入框的单一函数提供了简单方法，去掉了一些机械重复的代码，爽了</p>
<p>注意官网上并没有用到这个方法，是直接通过<code>v-model</code> 绑定的，一些不支持绑定的组件才会使用<code>@input</code>事件</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240403081929654.png" alt="image-20240403081929654"></p>
<h6 id="提交-验证事件"><a href="#提交-验证事件" class="headerlink" title="提交&#x2F;验证事件"></a>提交&#x2F;验证事件</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">submit() &#123;</span><br><span class="line">			this.$refs.form.validate().then(res=&gt;&#123;</span><br><span class="line">				console.log(&#x27;表单数据信息：&#x27;, res);</span><br><span class="line">			&#125;).catch(err =&gt;&#123;</span><br><span class="line">				console.log(&#x27;表单错误信息：&#x27;, err);</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;,</span><br></pre></td></tr></table></figure>

<p>这里的<code>$refs</code>  是一个对象</p>
<p><code>$refs.form</code> 指向的就是命名为<code>form</code> 的表单</p>
<p><code>validate()</code> 是组件内自带的一个方法，作用就是验证表单，比较有了规则，还有有执行规则的</p>
<ul>
<li><code>validate</code>方法返回一个<code>Promise</code>，它在校验成功时会被解析，校验失败时会被拒绝。</li>
</ul>
<p>这样一个简陋的表单验证就完成了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240403081629036.png" alt="image-20240403081629036"></p>
]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>python、java多环境</title>
    <url>/2024/07/07/python%E3%80%81java%E5%A4%9A%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h3 id="python虚拟环境"><a href="#python虚拟环境" class="headerlink" title="python虚拟环境"></a>python虚拟环境</h3><h4 id="venv"><a href="#venv" class="headerlink" title="venv"></a>venv</h4><p>创建虚拟环境需要用到venv，python3.6以上默认安装的</p>
<h4 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h4><p>可以在任意文件夹下创建虚拟环境，注意的是，创建出来的虚拟环境是和当前python版本是一样的，主要作用是下载脚本相适配的库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyhton -m venv [要创建环境的名称]</span><br></pre></td></tr></table></figure>

<p>执行成功后生成一个和名称相同的文件夹，文件夹内的Scripts文件夹内是启动虚拟环境的脚本，lin文件夹内是环境依赖</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240707162341789.png" alt="image-20240707162341789"></p>
<h4 id="启动虚拟环境"><a href="#启动虚拟环境" class="headerlink" title="启动虚拟环境"></a>启动虚拟环境</h4><p>启动脚本来启动虚拟环境，脚本需要在Windows PowerShell中允许，默认的命令行，只能打开这个记事本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[虚拟环境的名称]\Scripts\Activate.ps1</span><br></pre></td></tr></table></figure>



<h4 id="启动问题——Windows-PowerShell执行策略"><a href="#启动问题——Windows-PowerShell执行策略" class="headerlink" title="启动问题——Windows PowerShell执行策略"></a>启动问题——Windows PowerShell执行策略</h4><p>我这就是没用过Windows PowerShell的提示，因为Windows PowerShell默认是只能执行本地的脚本，不能执行下载的脚本，是一种安全模式(Restricted)</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240707163923274.png" alt="image-20240707163923274"></p>
<p>在Windows PowerShell中查看当前的执行策略</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-ExecutionPolicy</span><br></pre></td></tr></table></figure>

<p>管理员运行Windows PowerShell更改策略</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-ExecutionPolicy RemoteSigned</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240707164700351.png" alt="image-20240707164700351"></p>
<p>再次执行脚本，出现绿框内容表示成功进入虚拟环境，通过pip list可以发现环境十分干净，没有其他的库</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240707164918878.png" alt="image-20240707164918878"></p>
<h4 id="退出环境"><a href="#退出环境" class="headerlink" title="退出环境"></a>退出环境</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<p>python的虚拟环境不算很复杂，可以根据脚本的要求下载对象版本的库</p>
<h3 id="python多环境管理"><a href="#python多环境管理" class="headerlink" title="python多环境管理"></a>python多环境管理</h3><h4 id="下载安装pyenv"><a href="#下载安装pyenv" class="headerlink" title="下载安装pyenv"></a>下载安装pyenv</h4><p>从gitup上下载pyenv-win <a href="https://github.com/pyenv-win/pyenv-win#readme">https://github.com/pyenv-win/pyenv-win#readme</a> </p>
<p>解压下来，找到pyenv-win的bin目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xxx\pyenv-win-master\pyenv-win-master\pyenv-win</span><br></pre></td></tr></table></figure>



<p>也可以使用pip安装，但是会安装到C盘，我就没有弄</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install pyenv-win</span><br></pre></td></tr></table></figure>



<h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><p>新建一个系统变量 <code>PYENV</code></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240707203445362.png" alt="image-20240707203445362"></p>
<p>新增两行环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%PYENV%\bin</span><br><span class="line">%PYENV%\shims</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240707203537895.png" alt="image-20240707203537895"></p>
<p>配置完成后，命令行输入pyenv验证一下</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240707203657370.png" alt="image-20240707203657370"></p>
<h4 id="切换python版本"><a href="#切换python版本" class="headerlink" title="切换python版本"></a>切换python版本</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyenv global [切换到的版本]</span><br></pre></td></tr></table></figure>



<p>pyenv的方法输入pyenv都可以看到，install下载版本什么的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240707205346137.png" alt="image-20240707205346137"></p>
<h4 id="下载问题"><a href="#下载问题" class="headerlink" title="下载问题"></a>下载问题</h4><p>补档：</p>
<p>当时下载第一个成功下载了，后面再下载一直提示失败</p>
<p>可以尝试更改国内源，添加环境变量，地址有很多，随便选一个就行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://jedore.netlify.app/tools/python-mirrors/</span><br><span class="line">https://jedore.vercel.app/tools/python-mirrors/</span><br><span class="line">https://mirrors.huaweicloud.com/python/</span><br></pre></td></tr></table></figure>

<img src="../图片/image-20240810001647296.png" alt="image-20240810001647296" style="zoom: 67%;" />



<p>如果还是提示失败，可以直接将对应的python版本下载下来，放到这个目录下，install_cache</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\pyenv-win-master\pyenv-win-master\pyenv-win\install_cache</span><br></pre></td></tr></table></figure>

<p>再执行下载命令，这个时候就不会下载了，而是直接进行安装操作</p>
<h4 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h4><p>输入pyenv versions是看不到本地下载的python版本的，只能看到通过pyenv install下载的python版本</p>
<p>我认为呢，问题不大，可以再将本地再重新下载一个，因为库是不变的，更该python版本，系统上的库不会变化，如何有需要，可以再创建虚拟环境</p>
<p>pyenv下载的python版本在pyenv的目录下的versions目录下</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240707211345538.png" alt="image-20240707211345538"></p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>在Linux系统下，需要用到update-alternatives来管理多系统</p>
<p>使用update-alternatives的前提是Linux里已经装好了不同版本的python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update-alternatives --install [链接] [名称] [路径] [优先级]</span><br><span class="line">链接/usr/bin/python</span><br><span class="line">名称一般为python，也可以自定义</span><br><span class="line">路径为python的版本路径</span><br></pre></td></tr></table></figure>



<p>配置好链接后，切换版本时，只需要</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update-alternatives --config python</span><br></pre></td></tr></table></figure>

<p>然后输入要切换的编号即可</p>
<p>Linux中Java的多环境和python一样，也是通过update-alternatives来实现</p>
<p>我也没配置jdk8的环境，直接切换就可以使用</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240707230355226.png" alt="image-20240707230355226"></p>
<p>注意还要配置javac</p>
]]></content>
      <tags>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue实践</title>
    <url>/2024/07/13/Vue%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>小敲一下</p>
<p>想写一个与之前微信小程序中相似的实时时间更新</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个方法获取时间</span></span><br><span class="line">    <span class="attr">updateDateTime</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="keyword">var</span> year = date.<span class="title function_">getFullYear</span>();</span><br><span class="line">        <span class="keyword">var</span> month = date.<span class="title function_">getMonth</span>() + <span class="number">1</span>; <span class="comment">// 月份从0开始，所以需要加1</span></span><br><span class="line">        <span class="comment">// 这个月份从0开始，转化到我们这边需要加一</span></span><br><span class="line">        <span class="keyword">var</span> day = date.<span class="title function_">getDate</span>();</span><br><span class="line">        <span class="keyword">var</span> hours = date.<span class="title function_">getHours</span>();</span><br><span class="line">        <span class="keyword">var</span> minutes = date.<span class="title function_">getMinutes</span>();</span><br><span class="line">        <span class="keyword">var</span> seconds = date.<span class="title function_">getSeconds</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这里是将时间变为自己想要的样子，如果都行无所谓的话也可以直接</span></span><br><span class="line">        <span class="keyword">var</span> newdate = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toLocaleString</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 格式化日期和时间</span></span><br><span class="line">        <span class="keyword">var</span> formattedDateTime = <span class="string">`<span class="subst">$&#123;year&#125;</span>-<span class="subst">$&#123;month.toString().padStart(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)&#125;</span>-<span class="subst">$&#123;day.toString().padStart(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)&#125;</span> <span class="subst">$&#123;hours.toString().padStart(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)&#125;</span>:<span class="subst">$&#123;minutes.toString().padStart(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)&#125;</span>:<span class="subst">$&#123;seconds.toString().padStart(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)&#125;</span>`</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">            <span class="attr">currentDateTime</span>: formattedDateTime</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">        </span><br><span class="line">    <span class="title function_">onLoad</span>(<span class="params">options</span>) &#123;</span><br><span class="line">         <span class="comment">// 页面加载时开始更新时间</span></span><br><span class="line">         <span class="variable language_">this</span>.<span class="title function_">updateDateTime</span>();</span><br><span class="line">         <span class="comment">// 设置定时器，每秒更新一次时间</span></span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">timer</span> = <span class="built_in">setInterval</span>(<span class="variable language_">this</span>.<span class="property">updateDateTime</span>, <span class="number">1000</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">onUnload</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">timer</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">//Vue3中的写法与之类似，但是有个问题，因为Vue3 我使用的是Vue3语法糖就有一些问题</span></span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    //我的想法捏</span><br><span class="line">    import &#123; ref,onMounted &#125; from &#x27;vue&#x27;</span><br><span class="line">    </span><br><span class="line">    let date = ref(new Date().toLocaleString())</span><br><span class="line">    </span><br><span class="line">    function updateTime() &#123;</span><br><span class="line">        date = ref(new Date().toLocaleString())</span><br><span class="line">    &#125;</span><br><span class="line">    onMounted() &#123;</span><br><span class="line">        updateTime()</span><br><span class="line">        setInterval(updateTime, 1000);</span><br><span class="line">    &#125;</span><br><span class="line">    // 但是，不刷新数据是不会自动更新的，也就是说setInterval(updateTime, 1000);并没有起作用</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>其实，这里有两个问题，第一个onMounted这个钩子的用法不对，这里写的用法是类似于微信小程序中钩子的写法在Vue3中应该为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">onMounted(()=&gt;&#123;</span><br><span class="line">     updateTime()</span><br><span class="line">     setInterval(updateTime, 1000);    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>第二个问题，这里的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240530202913984.png" alt="image-20240530202913984"></p>
<p>需要改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date.value = new Date().toLocaleString()</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    //我的想法捏</span><br><span class="line">    import &#123; ref,onMounted,onUnmounted &#125; from &#x27;vue&#x27;</span><br><span class="line">    </span><br><span class="line">    let date = ref(new Date().toLocaleString())</span><br><span class="line">    let timer:any</span><br><span class="line">    </span><br><span class="line">    function updateTime() &#123;</span><br><span class="line">        date.value = new Date().toLocaleString()</span><br><span class="line">    &#125;</span><br><span class="line">    onMounted() &#123;</span><br><span class="line">        updateTime()</span><br><span class="line">        timer = setInterval(updateTime, 1000);</span><br><span class="line">    &#125;</span><br><span class="line">    onUnmounted(()=&gt;&#123;</span><br><span class="line">		clearInterval(timer)</span><br><span class="line">	&#125;)</span><br><span class="line">    // 卸载计时器，因为即使是组件卸载掉了，计时器仍然会继续date依然更新，浪费性能没必要</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>但是通过对比发现两者的写法差别是不大的</p>
<h2 id="组件模仿页面切换"><a href="#组件模仿页面切换" class="headerlink" title="组件模仿页面切换"></a>组件模仿页面切换</h2><p>但是微信小程序和Vue3 我感觉主要的区别在于，Vue3所有的活动都是在App.vue这个根上的，而微信小程序可以创建很多新的页面，这个时候我准备给Vue3写一个类似于小程序的东西</p>
<p>先搞一个路由</p>
<p>因为只有一个根组件，那么我可以只用路由来达到目的，App.vue中先写一个占位，更换路由占位更换，这就相当于页面更换，这样的话，我感觉就实现了微信小程序页面更换的问题</p>
<p>看一下App.vue</p>
<p>App.vue相当简洁，写了 一个路由占位符，准备渲染组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;app&quot;&gt;</span><br><span class="line">	</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>



<p>写一下路由组件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="comment">// 引入组件和路由器，设置一个history传参</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Index</span> <span class="keyword">from</span> <span class="string">&quot;./index.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Demo</span> <span class="keyword">from</span> <span class="string">&quot;./demo.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Demolist</span> <span class="keyword">from</span> <span class="string">&quot;./demolist.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Get</span> <span class="keyword">from</span> <span class="string">&quot;./get.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Text</span> <span class="keyword">from</span> <span class="string">&quot;./text.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Mess</span> <span class="keyword">from</span> <span class="string">&quot;./mess.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">	<span class="attr">history</span>: <span class="title function_">createWebHistory</span>(),</span><br><span class="line">	<span class="attr">routes</span>: [&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 封装路由，将/设置为index组件，默认展示index组件，然后在index路由下封装四个组件准备展示在index组件</span></span><br><span class="line">		<span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">		<span class="attr">component</span>: <span class="title class_">Index</span>,</span><br><span class="line">		<span class="attr">children</span>: [</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">name</span>: <span class="string">&#x27;demo&#x27;</span>,</span><br><span class="line">				<span class="attr">path</span>: <span class="string">&#x27;demo&#x27;</span>,</span><br><span class="line">				<span class="attr">component</span>: <span class="title class_">Demo</span></span><br><span class="line">			&#125;, &#123;</span><br><span class="line">				<span class="attr">name</span>: <span class="string">&#x27;demolist&#x27;</span>,</span><br><span class="line">				<span class="attr">path</span>: <span class="string">&#x27;demolist&#x27;</span>,</span><br><span class="line">				<span class="attr">component</span>: <span class="title class_">Demolist</span></span><br><span class="line">			&#125;, &#123;</span><br><span class="line">				<span class="attr">name</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">				<span class="attr">path</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">				<span class="attr">component</span>: <span class="title class_">Get</span></span><br><span class="line">			&#125;, &#123;</span><br><span class="line">				<span class="attr">name</span>:<span class="string">&#x27;mess&#x27;</span>,</span><br><span class="line">				<span class="attr">path</span>: <span class="string">&#x27;mess&#x27;</span>,</span><br><span class="line">				<span class="attr">component</span>: <span class="title class_">Mess</span></span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;,&#123;</span><br><span class="line">        <span class="comment">// 再写一个text组件，脱离index，我打算以点击事件的方式将这个组件渲染到App.vue 来实现类似微信小程序的页面跳转</span></span><br><span class="line">		<span class="attr">path</span>: <span class="string">&#x27;/text&#x27;</span>,</span><br><span class="line">		<span class="attr">component</span>: <span class="title class_">Text</span></span><br><span class="line">	&#125;,&#123;</span><br><span class="line">		<span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">		<span class="attr">redirect</span>:<span class="string">&#x27;/home&#x27;</span></span><br><span class="line">	&#125;]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>

<p>这样呢是形成了两个页面的效果，一个是&#x2F;home首页，另一个是&#x2F;text 因为index.vue内是写了一些样式，是一个路由，所以只能算一个页面，而这个text组件，确实是独立的一个页面效果，他是再index组件卸载后，渲染上去的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// text.vue</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;h2&gt;text&lt;/h2&gt;</span><br><span class="line">	&lt;button @click=&quot;showHome()&quot;&gt;点我&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">	import &#123; useRouter &#125; from &#x27;vue-router&#x27;;</span><br><span class="line">	</span><br><span class="line">	let router = useRouter()</span><br><span class="line">	</span><br><span class="line">	function showHome() &#123;</span><br><span class="line">		router.push(&#123;</span><br><span class="line">			path:&#x27;/&#x27;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240530222305593.png" alt="image-20240530222305593"></p>
<p>这样这个效果基本实现，但是是这个跳转方法是不太好复现的，因为无论是history还是hash跳转都是卸载掉当前组件，然后再挂载新的组件的，毕竟一直在那里的只有app.vue，但是还是有点相像的毕竟history可以有浏览器提供的返回键来返回，就相当于wx.navigateTo这种跳转，hash不能由浏览器提供的返回键返回，是属于覆盖性的，就相当于wx.redirectTo跳转了</p>
<h2 id="引入Vant组件库"><a href="#引入Vant组件库" class="headerlink" title="引入Vant组件库"></a>引入Vant组件库</h2><p>之前在微信小程序中使用的 vant4 组件库也支持Vue版本，这边搞一下</p>
<p>先在Vue3项目中下载Vant</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i vant</span><br></pre></td></tr></table></figure>

<p>官方文档：<a href="https://vant-ui.github.io/vant/#/zh-CN/quickstart">https://vant-ui.github.io/vant/#/zh-CN/quickstart</a></p>
<h3 id="全局引用"><a href="#全局引用" class="headerlink" title="全局引用"></a>全局引用</h3><p>因为 我的Vue3是使用vite 来构建的，因此，会有一个vite.comfig.js文件</p>
<p>更改这个文件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 看变量名也可以猜出来，自动引入组件API</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AutoImport</span> <span class="keyword">from</span> <span class="string">&#x27;unplugin-auto-import/vite&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个会在使用组件后，自动解析并注册组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Components</span> <span class="keyword">from</span> <span class="string">&#x27;unplugin-vue-components/vite&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个从vant中拿到相应的样式</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">VantResolver</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@vant/auto-import-resolver&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="title function_">vue</span>(),</span><br><span class="line">        <span class="title class_">AutoImport</span>(&#123;</span><br><span class="line">            <span class="attr">resolvers</span>: [<span class="title class_">VantResolver</span>()],</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="title class_">Components</span>(&#123;</span><br><span class="line">            <span class="attr">resolvers</span>: [<span class="title class_">VantResolver</span>()],</span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>如果报错的话，依次下载三个引入的地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i unplugin-auto-import -D</span><br><span class="line">npm i unplugin-vue-components -D</span><br><span class="line">npm i @vant/auto-import-resolver -D</span><br></pre></td></tr></table></figure>



<p>这个时候就可以直接在页面中使用vant组件了，不再需要任何的引用</p>
<p>  <img src="/../%E5%9B%BE%E7%89%87/image-20240531115246422.png" alt="image-20240531115246422"></p>
<h3 id="按需引用"><a href="#按需引用" class="headerlink" title="按需引用"></a>按需引用</h3><p>按需引用比较麻烦，需要再 main.js 的入口文件中引入</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个代码的意思是将Button这个组件中拿出来，如果我还需要 cell,calendae 等等，这里就会写很长</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Button</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vant&#x27;</span></span><br><span class="line"><span class="comment">// 引入组件样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;vant/lib/index.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里要使用app.use使用组件，感觉这种方式有点麻烦，不如全局引入，一劳永逸</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title class_">Button</span>)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>剩下的就用就完了，没啥好说的。</p>
<h2 id="引入three-js"><a href="#引入three-js" class="headerlink" title="引入three.js"></a>引入three.js</h2><p>官方文档：<a href="https://threejs.org/docs/index.html#manual/en/introduction/Creating-a-scene">https://threejs.org/docs/index.html#manual/en/introduction/Creating-a-scene</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i three</span><br></pre></td></tr></table></figure>



<p>安装版本号</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240531135049372.png" alt="image-20240531135049372"></p>
<p>这个时候新建一个组件开始敲</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div ref=&quot;threeContainer&quot; class=&quot;three-container&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;ThreeComponent&quot;&gt;</span><br><span class="line">	import * as THREE from &#x27;three&#x27;</span><br><span class="line">	import &#123; ref,onMounted &#125; from &#x27;vue&#x27;;</span><br><span class="line">	</span><br><span class="line">	const threeContainer = ref(null)</span><br><span class="line">	</span><br><span class="line">	onMounted (()=&gt;&#123;</span><br><span class="line">		// 初始化Three，获取容器信息</span><br><span class="line">		const container = threeContainer.value</span><br><span class="line">        </span><br><span class="line">		</span><br><span class="line">		// 创建场景，创建一个新的 Three.js 场景</span><br><span class="line">		const scene = new THREE.Scene();</span><br><span class="line">        </span><br><span class="line">		</span><br><span class="line">		// 创建相机，创建一个透明相机，并设置其位置</span><br><span class="line">	 	const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1 ,1000 );</span><br><span class="line">        // 这个postion.z 是设置相机高度</span><br><span class="line">		camera.position.z = 5</span><br><span class="line">        </span><br><span class="line">		</span><br><span class="line">		// 创建渲染器，将其大小设置为容器的宽度和高度，然后将渲染器的 DOM 元素添加到容器中</span><br><span class="line">		const renderer = new THREE.WebGLRenderer();</span><br><span class="line">		renderer.setSize( window.innerWidth, window.innerHeight );</span><br><span class="line">		container.appendChild( renderer.domElement )</span><br><span class="line">        </span><br><span class="line">		</span><br><span class="line">		// 创建一个立方体，并将其组合成一个网格对象，然后将该网络对象添加到场景中</span><br><span class="line">		const geometry = new THREE.BoxGeometry();</span><br><span class="line">		const material = new THREE.MeshBasicMaterial(&#123; color:0x00ff00 &#125;)</span><br><span class="line">        // 设置立方体颜色，color</span><br><span class="line">		const cube = new THREE.Mesh(geometry,material)</span><br><span class="line">		scene.add(cube)</span><br><span class="line">        // 将这个cude添加到 Three.js 中</span><br><span class="line">        </span><br><span class="line">		</span><br><span class="line">		// 渲染循环，创建一个动画循环，在每一帧中，旋转立方体，渲染场景</span><br><span class="line">		const animate = () =&gt; &#123;</span><br><span class="line">			requestAnimationFrame(animate);</span><br><span class="line">			</span><br><span class="line">			cube.rotation.x += 0.01</span><br><span class="line">			cube.rotation.y += 0.01</span><br><span class="line">			// x,y 分别为x,y方向旋转的速度</span><br><span class="line">			renderer.render(scene,camera)</span><br><span class="line">		&#125;</span><br><span class="line">		animate()</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .three-container &#123;</span><br><span class="line">		width: 100%;</span><br><span class="line">		height: 100%;</span><br><span class="line">		overflow: hidden;</span><br><span class="line">	&#125;</span><br><span class="line">    // 设置div样式，使其覆盖整个视口并隐藏溢出内容</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240531143824887.png" alt="image-20240531143824887"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save-dev @types/three</span><br></pre></td></tr></table></figure>



<p>这样就写出来了一个自动旋转的绿色正方体</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240531150142785.png" alt="image-20240531150142785"></p>
<p>注意这里是有循环的，要使用卸载钩子将组件不引用时卸载掉three场景，释放资源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 引入监听页面卸载的钩子，小改一下代码，懒得写注释了</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;ThreeComponent&quot;&gt;</span><br><span class="line">	import * as THREE from &#x27;three&#x27;</span><br><span class="line">	import &#123; ref,onMounted,onUnmounted &#125; from &#x27;vue&#x27;;</span><br><span class="line">	</span><br><span class="line">	const threeContainer = ref&lt;HTMLDivElement | null&gt;(null)</span><br><span class="line">	const cube = new THREE.Mesh</span><br><span class="line">	const renderer = new THREE.WebGLRenderer();</span><br><span class="line">	let animationId:number</span><br><span class="line">	</span><br><span class="line">	onMounted (()=&gt;&#123;</span><br><span class="line">		if (!threeContainer.value) return;</span><br><span class="line">		</span><br><span class="line">		// 初始化Three</span><br><span class="line">		const container = threeContainer.value</span><br><span class="line">		</span><br><span class="line">		// 创建场景</span><br><span class="line">		const scene = new THREE.Scene();</span><br><span class="line">		</span><br><span class="line">		// 创建相机</span><br><span class="line">	 	const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1 ,1000 );</span><br><span class="line">		camera.position.z = 3</span><br><span class="line">		</span><br><span class="line">		// 创建渲染器</span><br><span class="line">		renderer.setSize( window.innerWidth, window.innerHeight );</span><br><span class="line">		container.appendChild( renderer.domElement )</span><br><span class="line">		</span><br><span class="line">		// 创建一个立方体</span><br><span class="line">		const geometry = new THREE.BoxGeometry();</span><br><span class="line">		const material = new THREE.MeshBasicMaterial(&#123; color:0x00ff00 &#125;)</span><br><span class="line">		const cube = new THREE.Mesh(geometry,material)</span><br><span class="line">		scene.add(cube)</span><br><span class="line">		</span><br><span class="line">		// 渲染循环</span><br><span class="line">		const animate = () =&gt; &#123;</span><br><span class="line">			animationId = requestAnimationFrame(animate);</span><br><span class="line">			</span><br><span class="line">			cube.rotation.x += 0.01</span><br><span class="line">			cube.rotation.y += 0.01</span><br><span class="line">			console.log(&#x27;1&#x27;)</span><br><span class="line">			renderer.render(scene,camera)</span><br><span class="line">		&#125;</span><br><span class="line">		animate()</span><br><span class="line">	&#125;),</span><br><span class="line">	onUnmounted (()=&gt;&#123;</span><br><span class="line">        // 停止动画循环</span><br><span class="line">		cancelAnimationFrame(animationId)</span><br><span class="line">        </span><br><span class="line">        // 清除几何体材质</span><br><span class="line">		cube.geometry.dispose();</span><br><span class="line">		(cube.material as THREE.Material).dispose()</span><br><span class="line">        </span><br><span class="line">        // 移除渲染器的 DOM 元素</span><br><span class="line">		if (renderer &amp;&amp; renderer.domElement &amp;&amp; renderer.domElement.parentNode) &#123;</span><br><span class="line">			renderer.domElement.parentNode.removeChild(renderer.domElement);</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        // 清理渲染器</span><br><span class="line">		renderer.dispose();</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>这里写了一个打印1的地方，通过编程式导航来进行跳转发现，返回后，1停止打印，说明已经释放资源  </p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240531160347088.png" alt="  "></p>
<h2 id="防止父容器的点击态"><a href="#防止父容器的点击态" class="headerlink" title="防止父容器的点击态"></a>防止父容器的点击态</h2><p>想写一个俄罗斯方块，写到暂停键的时候，遇到了问题，先看一下能不能看出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div class=&quot;box-right&quot;&gt;</span><br><span class="line">		&lt;div style=&quot;margin-top: 80px;&quot;&gt;&#123;&#123;forTime&#125;&#125;&lt;/div&gt;</span><br><span class="line">			&lt;div class=&quot;box-right-icon&quot; @click=&quot;stop&quot;&gt;</span><br><span class="line">				&lt;div @click=&quot;stop&quot; :class=&quot;status?&#x27;icon-content&#x27;:&#x27;icon-stop&#x27;&quot; &gt;&lt;/div&gt;</span><br><span class="line">    	&lt;/div&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">	import &#123; ref,watch,onMounted,onUnmounted &#125; from &#x27;vue&#x27;;</span><br><span class="line">	</span><br><span class="line">	let num = 200</span><br><span class="line">	let hour = ref(0)</span><br><span class="line">	let minute = ref(0)</span><br><span class="line">	let second = ref(0)</span><br><span class="line">	let timer:any</span><br><span class="line">	let forTime = ref(&#x27;&#x27;)</span><br><span class="line">	let status = ref(true)</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	function updatatime() &#123;</span><br><span class="line">		if (status.value=true) &#123;</span><br><span class="line">			if (second.value == 59) &#123;</span><br><span class="line">				second.value = 0</span><br><span class="line">				minute.value += 1</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				second.value += 1</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	function stop() &#123;</span><br><span class="line">		console.log(&#x27;stop triggered&#x27;)</span><br><span class="line">		status.value = !status.value</span><br><span class="line">		if (status.value) &#123;</span><br><span class="line">		    timer = setInterval(updatatime, 1000); // 继续计时</span><br><span class="line">		  &#125; else &#123;</span><br><span class="line">		    clearInterval(timer)</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	onMounted(()=&gt;&#123;</span><br><span class="line">		updatatime()</span><br><span class="line">		timer = setInterval(updatatime,1000)</span><br><span class="line">	&#125;)</span><br><span class="line">	onUnmounted(()=&gt;&#123;</span><br><span class="line">		clearInterval(timer)</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">	const time = watch(second,(value)=&gt;&#123;</span><br><span class="line">		if (minute.value&lt;10 &amp;&amp; second.value&lt;10) &#123;</span><br><span class="line">			forTime.value =	hour.value+&#x27;:0&#x27;+minute.value+&#x27;:0&#x27;+second.value</span><br><span class="line">		&#125; else if(second.value&lt;10) &#123;</span><br><span class="line">			forTime.value =	hour.value+&#x27;:&#x27;+minute.value+&#x27;:0&#x27;+second.value</span><br><span class="line">		&#125; else if(minute.value&lt;10) &#123;</span><br><span class="line">			forTime.value =	hour.value+&#x27;:0&#x27;+minute.value+&#x27;:&#x27;+second.value</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			forTime.value =	hour.value+&#x27;:&#x27;+minute.value+&#x27;:&#x27;+second.value</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>我是通过打印事件，排查出来的，点击样式内的div后，会触发两次点击事件，true变为false又变为false，以此，导致了视觉上的子容器的点击事件不好使的情况</p>
<p>解决方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	function stop(event: Event) &#123;</span><br><span class="line">		event.stopPropagation()</span><br><span class="line">		status.value = !status.value</span><br><span class="line">		if (status.value) &#123;</span><br><span class="line">		    timer = setInterval(updatatime, 1000); // 继续计时</span><br><span class="line">		  &#125; else &#123;</span><br><span class="line">		    clearInterval(timer)</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">// 给他来一个event.stopPropagation()阻止冒泡即可，之前从未遇到过这样需求，长知识了</span><br></pre></td></tr></table></figure>





<h2 id="获取非普通标签的DOM元素"><a href="#获取非普通标签的DOM元素" class="headerlink" title="获取非普通标签的DOM元素"></a>获取非普通标签的DOM元素</h2><p>写俄罗斯方块的时候，我将方块封装为不同的组件</p>
<p>封装组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div class=&quot;lang&quot; ref=&quot;rootElement&quot;&gt;</span><br><span class="line">		&lt;div v-for=&quot;x in 4&quot; class=&quot;lang-bor&quot;&gt;&lt;/div&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">	import &#123; ref &#125; from &#x27;vue&#x27;;</span><br><span class="line">	</span><br><span class="line">	const rootElement =ref&lt;HTMLElement | null&gt;(null)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>想要获取组件的DOM元素，只需要给最外层一个ref即可</p>
<p>然后再调用组件的页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;long-vue ref=&quot;movableDiv&quot;&gt;&lt;/long-vue&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">	import &#123; ref,watch,onMounted,onUnmounted,nextTick &#125; from &#x27;vue&#x27;;</span><br><span class="line">    import longVue from &#x27;../components/long.vue&#x27;;</span><br><span class="line">    </span><br><span class="line">    onMounted(async ()=&gt;&#123;</span><br><span class="line">		await nextTick()</span><br><span class="line">		if (movableDiv.value) &#123;</span><br><span class="line">			const movawidth = movableDiv.value.$el.offsetWidth</span><br><span class="line">			const movaheight = movableDiv.value.$el.offsetHeight</span><br><span class="line">			console.log(movawidth,movaheight)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>比直接获取HTML标签的DOM元素中多了一个 <code>$el</code> 加上就可以直接拿到组件的DOM 元素</p>
<h2 id="导出微信语音"><a href="#导出微信语音" class="headerlink" title="导出微信语音"></a>导出微信语音</h2><p>首先将微信呢语音收藏，然后呢在手机版中，将语音转化为笔记</p>
<p>再在..\FileStorage\Fav\Temp\xxxxx\res中 找到一个拓展名为silk的文件</p>
<p>利用一个小工具silk2mp3，我是不敢在真机中使用，所以扔虚拟机了</p>
<p>直接解码为mp3即可导出微信语音</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>autoplay</td>
<td>autoplay</td>
<td>如果出现该属性，则音频在就绪后马上播放。</td>
</tr>
<tr>
<td>controls</td>
<td>controls</td>
<td>如果出现该属性，则向用户显示音频控件（比如播放&#x2F;暂停按钮）。</td>
</tr>
<tr>
<td>loop</td>
<td>loop</td>
<td>如果出现该属性，则每当音频结束时重新开始播放。</td>
</tr>
<tr>
<td>muted</td>
<td>muted</td>
<td>如果出现该属性，则音频输出为静音。</td>
</tr>
<tr>
<td>preload</td>
<td>auto<br/>metadata<br/>none</td>
<td>规定当网页加载时，音频是否默认被加载以及如何被加载。</td>
</tr>
<tr>
<td>src</td>
<td>URL</td>
<td>规定音频文件的 URL。</td>
</tr>
</tbody></table>
<h3 id="audio属性"><a href="#audio属性" class="headerlink" title="audio属性"></a>audio属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>audioTracks</td>
<td>返回表示可用音频轨道的 AudioTrackList 对象</td>
</tr>
<tr>
<td>autoplay</td>
<td>设置或返回是否在加载完成后随即播放音频</td>
</tr>
<tr>
<td>buffered</td>
<td>返回表示音频已缓冲部分的 TimeRanges 对象</td>
</tr>
<tr>
<td>controller</td>
<td>返回表示音频当前媒体控制器的 MediaController 对象</td>
</tr>
<tr>
<td>controls</td>
<td>设置或返回音频是否显示控件（比如播放&#x2F;暂停等）</td>
</tr>
<tr>
<td>crossOrigin</td>
<td>设置或返回音频的 CORS 设置</td>
</tr>
<tr>
<td>currentSrc</td>
<td>回当前音频的 URL</td>
</tr>
<tr>
<td>currentTime</td>
<td>设置或返回音频中的当前播放位置（以秒计）</td>
</tr>
<tr>
<td>defaultMuted</td>
<td>设置或返回音频默认是否静音</td>
</tr>
<tr>
<td>defaultPlaybackRate</td>
<td>设置或返回音频的默认播放速度</td>
</tr>
<tr>
<td>duration</td>
<td>返回当前音频的长度（以秒计）</td>
</tr>
<tr>
<td>ended</td>
<td>返回音频的播放是否已结束</td>
</tr>
<tr>
<td>error</td>
<td>返回表示音频错误状态的 MediaError 对象</td>
</tr>
<tr>
<td>loop</td>
<td>设置或返回音频是否应在结束时重新播放</td>
</tr>
<tr>
<td>mediaGroup</td>
<td>设置或返回音频所属的组合（用于连接多个音频元素）</td>
</tr>
<tr>
<td>muted</td>
<td>设置或返回音频是否静音</td>
</tr>
<tr>
<td>networkState</td>
<td>返回音频的当前网络状态</td>
</tr>
<tr>
<td>paused</td>
<td>设置或返回音频是否暂停</td>
</tr>
<tr>
<td>playbackRate</td>
<td>设置或返回音频播放的速度</td>
</tr>
<tr>
<td>played</td>
<td>返回表示音频已播放部分的 TimeRanges 对象</td>
</tr>
<tr>
<td>preload</td>
<td>设置或返回音频是否应该在页面加载后进行加载</td>
</tr>
<tr>
<td>readyState</td>
<td>返回音频当前的就绪状态</td>
</tr>
<tr>
<td>seekable</td>
<td>返回表示音频可寻址部分的 TimeRanges 对象</td>
</tr>
<tr>
<td>seeking</td>
<td>返回用户是否正在音频中进行查找</td>
</tr>
<tr>
<td>src</td>
<td>设置或返回音频元素的当前来源</td>
</tr>
<tr>
<td>textTracks</td>
<td>返回表示可用文本轨道的 TextTrackList 对象</td>
</tr>
<tr>
<td>volume</td>
<td>设置或返回音频的音量</td>
</tr>
</tbody></table>
<h3 id="audio方法"><a href="#audio方法" class="headerlink" title="audio方法"></a>audio方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>addTextTrack()</td>
<td>在音频中添加一个新的文本轨道</td>
</tr>
<tr>
<td>canPlayType()</td>
<td>检查浏览器是否可以播放指定的音频类型</td>
</tr>
<tr>
<td>fastSeek()</td>
<td>在音频播放器中指定播放时间。</td>
</tr>
<tr>
<td>getStartDate()</td>
<td>返回一个新的Date对象，表示当前时间轴偏移量</td>
</tr>
<tr>
<td>load()</td>
<td>重新加载音频元素</td>
</tr>
<tr>
<td>play()</td>
<td>开始播放音频</td>
</tr>
<tr>
<td>pause()</td>
<td>暂停当前播放的音频</td>
</tr>
</tbody></table>
<h2 id="封装图片验证码"><a href="#封装图片验证码" class="headerlink" title="封装图片验证码"></a>封装图片验证码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div class=&quot;img-verify&quot;&gt;</span><br><span class="line">		&lt;canvas ref=&quot;verify&quot; :width=&quot;state.width&quot; :height=&quot;state.height&quot; @click=&quot;handleDraw&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">	import &#123; ref,onMounted,reactive &#125; from &#x27;vue&#x27;;</span><br><span class="line">	</span><br><span class="line">	const verify = ref(null)</span><br><span class="line">	const emit = defineEmits([&quot;get-code&quot;])</span><br><span class="line">	const state = reactive(&#123;</span><br><span class="line">		pool:&quot;qwertyuiopasdfghjklzxcvbnm1234567890&quot;,</span><br><span class="line">		width:120,</span><br><span class="line">		height:40,</span><br><span class="line">		imgCode:&#x27;&#x27;,</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">	// 随机数字</span><br><span class="line">	const randomNum = (min,max) =&gt; &#123;</span><br><span class="line">		return parseInt(Math.random() * (max - min) + min)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 随机颜色</span><br><span class="line">	const randomColor = (min,max) =&gt; &#123;</span><br><span class="line">		const r = randomNum(min,max)</span><br><span class="line">		const g = randomNum(min,max)</span><br><span class="line">		const b = randomNum(min,max)</span><br><span class="line">		return `rgb($&#123;r&#125;,$&#123;g&#125;,$&#123;b&#125;)`</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 绘制图片</span><br><span class="line">	const draw = () =&gt; &#123;</span><br><span class="line">		// 填充背景颜色</span><br><span class="line">		const ctx = verify.value.getContext(&quot;2d&quot;)</span><br><span class="line">		// 填充颜色</span><br><span class="line">		ctx.fillStyle = randomColor(180,230)</span><br><span class="line">		// 填充位置</span><br><span class="line">		ctx.fillRect(0,0,state.width,state.width)</span><br><span class="line">		</span><br><span class="line">		// 定义paramText</span><br><span class="line">		let imgCode = &#x27;&#x27;;</span><br><span class="line">		</span><br><span class="line">		// 产生随机数字，并且随即旋转</span><br><span class="line">		for (let i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">			// 产生随机数字</span><br><span class="line">			const text = state.pool[randomNum(0,state.pool.length)]</span><br><span class="line">			imgCode += text</span><br><span class="line">			</span><br><span class="line">			// 随机大小字体</span><br><span class="line">			const fontSize = randomNum(18,40);</span><br><span class="line">			</span><br><span class="line">			// 随机字体角度</span><br><span class="line">			const deg = randomNum(-30,30)</span><br><span class="line">			</span><br><span class="line">			ctx.font = fontSize + &#x27;px Simhei&#x27;;</span><br><span class="line">			ctx.textBaseline = &quot;top&quot;;</span><br><span class="line">			ctx.fillStyle = randomColor(80,150)</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			ctx.save()</span><br><span class="line">			ctx.translate(30 * i + 15,15);</span><br><span class="line">			ctx.rotate((deg * Math.PI) / 180)</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			ctx.fillText(text, -15 + 5, -15)</span><br><span class="line">			ctx.restore()</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		// 随机5条干扰线</span><br><span class="line">		for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">			ctx.beginPath();</span><br><span class="line">			ctx.moveTo(randomNum(0,state.width),randomNum(0,state.height))</span><br><span class="line">			ctx.lineTo(randomNum(0,state.width),randomNum(0,state.height))</span><br><span class="line">			ctx.strokeStyle = randomColor(180,230);</span><br><span class="line">			ctx.closePath()</span><br><span class="line">			ctx.stroke()</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		// 产生40个干扰点</span><br><span class="line">		for (var i = 0; i &lt; 40; i++) &#123;</span><br><span class="line">			ctx.beginPath();</span><br><span class="line">			ctx.acr(</span><br><span class="line">				randomNum(0,state.width),</span><br><span class="line">				randomNum(0,state.height),</span><br><span class="line">				1,</span><br><span class="line">				0,</span><br><span class="line">				2 * Math.PI</span><br><span class="line">			);</span><br><span class="line">			ctx.closePath();</span><br><span class="line">			ctx.fillStyle = randomColor(150,200);</span><br><span class="line">			ctx.fill();</span><br><span class="line">		&#125;</span><br><span class="line">		return imgCode</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 点击切换图片</span><br><span class="line">	const handleDraw = () =&gt; &#123;</span><br><span class="line">		state.imgCode = draw();</span><br><span class="line">		emit(&quot;get-code&quot;,state.imgCode)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 初始化</span><br><span class="line">	onMounted(()=&gt;&#123;</span><br><span class="line">		state.imgCode = draw();</span><br><span class="line">		emit(&quot;get-code&quot;,state.imgCode)</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">	.img-verify &#123;</span><br><span class="line">		height: 40px;</span><br><span class="line">		margin: 0 0.1rem;</span><br><span class="line">	&#125;</span><br><span class="line">	.img-verify canvas &#123;</span><br><span class="line">		cursor: pointer;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>微信小程序对称加密</title>
    <url>/2024/07/13/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<h1 id="crypto-js"><a href="#crypto-js" class="headerlink" title="crypto-js"></a>crypto-js</h1><p>利用crypto-js这个Java包来实现数据的加密解密</p>
<p>引入Java包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install crypto-js</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240519204321372.png" alt="image-20240519204321372"></p>
<p>然后小程序中就有这么一个文件夹</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240519204355653.png" alt="image-20240519204355653"></p>
<p>将文件夹内的crypto-js.js复制到需要用到加密的页面下，如：</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240519204449695.png" alt="image-20240519204449695"></p>
<h2 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h2><p>先引用crypto-js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const CryptoJs = require(&#x27;crypto-js&#x27;);</span><br></pre></td></tr></table></figure>



<p>AES加密存在一个key值和一个iv值</p>
<p>定义密钥和初始化向量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var key = CryptoJS.enc.Utf8.parse(&#x27;0123456789abcdef&#x27;); // 定义密钥</span><br><span class="line">var iv = CryptoJS.enc.Utf8.parse（&#x27;abcdef0123456789&#x27;)；// 定义初始化向量</span><br></pre></td></tr></table></figure>



<p>进行加密</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var encrypted = CryptoJs.AEs.encrypt(&#x27;hello world&#x27;, key, &#123; iv: iv );</span><br><span class="line">var date = encrypted.tostring()</span><br><span class="line">//date就是加密后的数据</span><br></pre></td></tr></table></figure>



<p>数据拿回来的时候同样需要解密</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var decrypted = CryptoJs.AES.decrypt(date, key, &#123; iv: iv &#125;);</span><br><span class="line">console.log(decrypted.toString(CryptoJs.enc.Utf8))； // 输出解密后的数据</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240713213602201.png" alt="image-20240713213602201"></p>
]]></content>
  </entry>
  <entry>
    <title>wxss实践</title>
    <url>/2024/07/13/wxss%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><p>肝（抄）了一周wxss，有了点心得，分享一下</p>
<h4 id="居中三板斧"><a href="#居中三板斧" class="headerlink" title="居中三板斧"></a>居中三板斧</h4><p>设置容器为弹性盒</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">display:flex;</span><br><span class="line">justify-content: center;</span><br><span class="line">//如果主轴是水平的，那么Flex项目将在容器内水平居中。</span><br><span class="line">align-items: center;</span><br><span class="line">//如果主轴是水平的，那么交叉轴就是垂直的，Flex项目将在容器内垂直居中。</span><br></pre></td></tr></table></figure>





<h4 id="极限微操"><a href="#极限微操" class="headerlink" title="极限微操"></a>极限微操</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">position: absolute;</span><br><span class="line">//position: absolute;设置为绝对位置，可以和其他元素重合（因为z-index不同，不在同一图层），这样就有一个好处就是不会牵一发而动全身，可以肆意调整容器位置</span><br><span class="line"></span><br><span class="line">z-index: 1;</span><br><span class="line">//设置图层，设置背景的时候经常用，z-index越小，图层越靠下</span><br><span class="line"></span><br><span class="line">margin: 0 0 0 0;</span><br><span class="line">//分别为距离上，右，下，左，的边距</span><br><span class="line">//只写两个的话，调整上下，左右的边距</span><br><span class="line">//只写一个，调整上下左右的边距</span><br></pre></td></tr></table></figure>



<p>margin和padding，个人感觉比padding好用，上图</p>
<p>初始状态</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240518110607965.png" alt="image-20240518110607965"></p>
<p>使用padding调整边距</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240518110644254.png" alt="image-20240518110644254"></p>
<p>使用margin调整边距</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240518110704801.png" alt="image-20240518110704801"></p>
<h4 id="模块美化一：圆角-阴影"><a href="#模块美化一：圆角-阴影" class="headerlink" title="模块美化一：圆角+阴影"></a>模块美化一：圆角+阴影</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">border-radius: 30px;</span><br><span class="line">//设置圆角</span><br><span class="line"></span><br><span class="line">box-shadow: 1px 1px 1px rgb(88, 88, 88);</span><br><span class="line">//设置阴影，属性分别为，水平偏移量，垂直偏移量，模糊半径，阴影颜色，可以根据自己的喜好将阴影放到想要的位置</span><br><span class="line"></span><br><span class="line">//text-shadow是设置字体阴影的也很不错，可以自己创建艺术字效果</span><br></pre></td></tr></table></figure>



<p>无阴影</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240518105315289.png" alt="image-20240518105315289"></p>
<p>有阴影</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240518105332800.png" alt="image-20240518105332800"></p>
<p>有阴影无圆角</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240518105414374.png" alt="image-20240518105414374"></p>
<p>总之阴影可以给容器增加一种层次感，很好的美化效果</p>
<h4 id="模块美化二：渐变"><a href="#模块美化二：渐变" class="headerlink" title="模块美化二：渐变"></a>模块美化二：渐变</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">background: linear-gradient(to right, #c528d3 , #2033df);</span><br><span class="line">//渐变可以背景渐变，字体渐变一会再说</span><br></pre></td></tr></table></figure>





<p>渐变没啥好说的都见过渐变色，整个花活吧</p>
<p>写一个容器外层限制大小，内层实现一个鼠标移动过去出现一个从左向右的下弧线，鼠标移开，下划线从左向右消失</p>
<p>主要利用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">box-min-title view&#123;</span><br><span class="line">    background: linear-gradient(to right, #7e2f3b, #146420) no-repeat right bottom;</span><br><span class="line">    //设置背景为渐变，to right 从左向右渐变 ，no-repeat 背景图像只显示一次（不设置重复的背景会铺满容器） ， right bottom 设置背景在右下方</span><br><span class="line">    background-size: 0 2px;</span><br><span class="line">    //设置背景大小，宽度为0，高度为2px，将背景设置为线性，达到下划线的效果</span><br><span class="line">    transition: background-size 1s;</span><br><span class="line">    //给代码增加一个过渡效果，是得background-size（背景大小）变化在1s内完成，算是一个动画效果了</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box-min-title view:hover&#123;</span><br><span class="line">    background-position: left bottom;</span><br><span class="line">    //添加鼠标放置动画，鼠标放上去之后，背景从左下开始，增加至100%</span><br><span class="line">    background-size: 100% 2px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//鼠标移开时背景右在右下，背景宽度减少至0，动画效果就是从左向右消失</span><br></pre></td></tr></table></figure>



<p>不设置no-repeat</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240518113322383.png" alt="image-20240518113322383"></p>
<p>源码加成品</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box-min-title&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    width: 47%;</span><br><span class="line">    margin:  20px 0 0 50%;</span><br><span class="line">    height: auto;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">&#125;</span><br><span class="line">.box-min-title view&#123;</span><br><span class="line">    background: linear-gradient(to right, #7e2f3b, #146420) no-repeat right bottom;</span><br><span class="line">    background-size: 0 2px;</span><br><span class="line">    transition: background-size 1s;</span><br><span class="line">    position: absolute;</span><br><span class="line">    margin: 30px 0 0 0;</span><br><span class="line">    font-size: 30px;</span><br><span class="line">&#125;</span><br><span class="line">.box-min-title view:hover&#123;</span><br><span class="line">    background-position: left bottom;</span><br><span class="line">    background-size: 100% 2px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240518113648360.png" alt="image-20240518113648360"></p>
<h4 id="艺术字"><a href="#艺术字" class="headerlink" title="艺术字"></a>艺术字</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">line-height: 50px;</span><br><span class="line">//行间距</span><br><span class="line">letter-spacing: 35rpx;</span><br><span class="line">//字间距</span><br><span class="line">font-style: italic;</span><br><span class="line">//倾斜</span><br><span class="line"></span><br><span class="line">background: linear-gradient(to bottom,rgb(93, 68, 233) ,rgb(116, 147, 177));</span><br><span class="line">-webkit-background-clip: text;</span><br><span class="line">background-clip: text;</span><br><span class="line">color: transparent;</span><br><span class="line">//渐变字体组合拳</span><br></pre></td></tr></table></figure>



<p>效果：艺术细菌和审美实在有限</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240518115344814.png" alt="image-20240518115344814"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box-text&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">    height: 100px;</span><br><span class="line">    width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">//整个居中弹性盒没啥好说的</span><br><span class="line"></span><br><span class="line">.box-text text&#123;</span><br><span class="line">    background: linear-gradient(to bottom,rgb(93, 68, 233) ,rgb(116, 147, 177));</span><br><span class="line">    -webkit-background-clip: text;</span><br><span class="line">    background-clip: text;</span><br><span class="line">    color: transparent;</span><br><span class="line">    </span><br><span class="line">/*</span><br><span class="line">整个渐变字体，color: transparent;将文本设置为透明，为了显示出来渐变的背景颜色，利用 -webkit-background-clip: text; 将背景限制在文本的位置，-webkit-background-clip: text;需要 background-clip: text; 才不会有黄色问题标识，实测，只有-webkit-background-clip: text; 就可以实现功能，但是只有background-clip: text; 不行</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">    font-size: 30px;</span><br><span class="line">    font-style: italic;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    //分别为设置字体大小，字体倾斜，字体加粗</span><br><span class="line">    </span><br><span class="line">    letter-spacing: 20px;</span><br><span class="line">    //设置字间距为20px</span><br><span class="line">    text-shadow: 1px 1px 30px rgb(226, 143, 143);</span><br><span class="line">    opacity:0.8;</span><br><span class="line">    //设置字体透明度0-1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>没有找到小程序内实现文本透视效果的方法，欢迎大佬斧正</p>
<h4 id="展示成品"><a href="#展示成品" class="headerlink" title="展示成品"></a>展示成品</h4><p>说了那么多，应该能看懂下面的源码……了吧？</p>
<img src="../图片/image-20240518125039100.png" alt="image-20240518125039100" style="zoom:50%;" />



<p>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;view class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;view class=&quot;content&quot;&gt;</span><br><span class="line">        &lt;form bindsubmit=&quot;onform&quot;&gt;</span><br><span class="line">            &lt;view class=&quot;okk&quot;&gt;</span><br><span class="line">                &lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; class=&quot;ok&quot;/&gt;</span><br><span class="line">            &lt;/view&gt;</span><br><span class="line">            &lt;view class=&quot;okk&quot;&gt;</span><br><span class="line">                &lt;input type=&quot;text&quot; placeholder=&quot;请输入密码&quot; class=&quot;ok&quot;/&gt;</span><br><span class="line">            &lt;/view&gt;</span><br><span class="line">            &lt;view class=&quot;container&quot; style=&quot;padding: 5px 0;&quot;&gt;</span><br><span class="line">                &lt;view class=&quot;bt&quot; form-type=&quot;submit&quot;&gt;</span><br><span class="line">                &lt;text class=&quot;container&quot; bind:tap=&quot;denglu&quot;&gt;登录&lt;/text&gt;</span><br><span class="line">                &lt;/view&gt;</span><br><span class="line">                &lt;view style=&quot;height: 20px;&quot;&gt;&lt;/view&gt;</span><br><span class="line">                &lt;view class=&quot;bt&quot; style=&quot;background: #c61dff;&quot;&gt;</span><br><span class="line">                &lt;text class=&quot;container&quot;&gt;注册&lt;/text&gt;</span><br><span class="line">                &lt;/view&gt;</span><br><span class="line">            &lt;/view&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">page,</span><br><span class="line">.box,</span><br><span class="line">.content &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">&#125;</span><br><span class="line">page &#123;</span><br><span class="line">    background: #eff0f4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: space-between;</span><br><span class="line">    margin: 130px auto;</span><br><span class="line">    width: 470px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box .content &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">    justify-content: space-around;</span><br><span class="line">    align-items: center;</span><br><span class="line">    width: 350px;</span><br><span class="line">    height: 350px;</span><br><span class="line">    padding: 60px 20px;</span><br><span class="line">    box-shadow: </span><br><span class="line">        20px 20px 20px rgba(0, 0, 0, 0.3),</span><br><span class="line">        25px 35px 20px rgba(0, 0, 0, 0.3),</span><br><span class="line">        25px 30px 30px rgba(0, 0, 0, 0.3);</span><br><span class="line">    transition: .5s;</span><br><span class="line">    border-radius: 52% 48% 33% 67% / 38% 45% 55% 62%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box .content:hover &#123;</span><br><span class="line">    border-radius: 50%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box .content::before &#123;</span><br><span class="line">    content: &quot;&quot;;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50px;</span><br><span class="line">    left: 85px;</span><br><span class="line">    width: 35px;</span><br><span class="line">    height: 35px;</span><br><span class="line">    border-radius: 50%;</span><br><span class="line">    background: #fff;</span><br><span class="line">    opacity: 0.9;</span><br><span class="line">&#125;</span><br><span class="line">.ok&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    border-radius: 25px;</span><br><span class="line">    box-shadow: 2px 5px 10px rgb(204, 193, 193);</span><br><span class="line">    padding: 0 30rpx;</span><br><span class="line">    font-size: 16px;</span><br><span class="line">    outline: none;</span><br><span class="line">&#125;</span><br><span class="line">.okk&#123;</span><br><span class="line">    padding: 30rpx 0;</span><br><span class="line">&#125;</span><br><span class="line">.bt&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    transition: 0.5s;</span><br><span class="line">    background: #ff0f5b;</span><br><span class="line">    border-radius: 25px;</span><br><span class="line">    padding: 7rpx 3rpx;</span><br><span class="line">    box-shadow: 2px 5px 10px rgba(0, 0, 0, 0.5);</span><br><span class="line">&#125;</span><br><span class="line">.box .content .container .bt:hover&#123;</span><br><span class="line">    width: 150px;</span><br><span class="line">&#125;</span><br><span class="line">.page&#123;</span><br><span class="line">    height:100%;</span><br><span class="line">  &#125;</span><br><span class="line">.background &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">    position:fixed; </span><br><span class="line">    background-size:100% 100%;</span><br><span class="line">    z-index: -1;</span><br><span class="line">    filter: blur(6rpx);</span><br><span class="line">    filter: brightness(0.9);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240518125106524.png" alt="image-20240518125106524"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240518125112348.png" alt="image-20240518125112348"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;view class=&quot;searchBar&#123;&#123;expand ? &#x27;change-width&#x27;: &#x27;&#x27;&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;view class=&quot;icons&quot;&gt;</span><br><span class="line">        &lt;image src=&quot;../../image/搜索.png&quot; bind:tap=&quot;show&quot;/&gt; </span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">    &lt;view class=&quot;textinput&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; placeholder=&quot;请输入搜索关键字&quot; value=&quot;&#123;&#123;myinput&#125;&#125;&quot; bindinput=&quot;valueinput&quot;/&gt;</span><br><span class="line">        &lt;image src=&quot;../../image/删除.png&quot; class=&quot;clear&quot; bind:tap=&quot;clear&quot;/&gt;</span><br><span class="line">        &lt;view class=&quot;bt&quot;&gt;</span><br><span class="line">            &lt;text class=&quot;goBtn&quot;&gt;搜索&lt;/text&gt;</span><br><span class="line">        &lt;/view&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">page&#123;</span><br><span class="line">    width: 100vm;</span><br><span class="line">    height: 100vh;</span><br><span class="line">    background: linear-gradient(</span><br><span class="line">        to bottom skyblue #003462</span><br><span class="line">    );</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">&#125;</span><br><span class="line">.searchBar&#123;</span><br><span class="line">    width: 400px;</span><br><span class="line">    height: 60px;</span><br><span class="line">    background-color: #fff;</span><br><span class="line">    box-shadow: 0 0 10px rgba(0, 0, 0, 0.4);</span><br><span class="line">    border-radius: 60px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    transition: 0.5s;</span><br><span class="line">    z-index: 1;</span><br><span class="line">&#125;</span><br><span class="line">.icons&#123;</span><br><span class="line">    width: 60px;</span><br><span class="line">    height: 60px;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">    cursor: pointer;</span><br><span class="line">&#125;</span><br><span class="line">.icons image&#123;</span><br><span class="line">    width: 30px;</span><br><span class="line">    height: 30px;</span><br><span class="line">    font-size: 30px;</span><br><span class="line">&#125;</span><br><span class="line">.textinput&#123;</span><br><span class="line">    width: 320px;</span><br><span class="line">    height: 60px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 60px;</span><br><span class="line">    right: 50px;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">    background-color: rgb(255, 255, 255);</span><br><span class="line">&#125;</span><br><span class="line">.textinput input&#123;</span><br><span class="line">    width: 270px;</span><br><span class="line">    height: 100%;</span><br><span class="line">    border: none;</span><br><span class="line">    outline: none;</span><br><span class="line">    font-size: 18px;</span><br><span class="line">    padding: 0 90px 0 0;</span><br><span class="line">&#125;</span><br><span class="line">.clear&#123;</span><br><span class="line">    width: 20px;</span><br><span class="line">    height: 20px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    right: 18%;</span><br><span class="line">    top: 50%;</span><br><span class="line">    transform: translateY(-50%);</span><br><span class="line">    cursor: pointer;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">&#125;</span><br><span class="line">.clear image&#123;</span><br><span class="line">    width: 20px;</span><br><span class="line">    height: 20px;</span><br><span class="line">    color: #999;</span><br><span class="line">&#125;</span><br><span class="line">.goBtn&#123;</span><br><span class="line">    width: 14%;</span><br><span class="line">    height: 60%;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 20%;</span><br><span class="line">    right: 0;</span><br><span class="line">    border-radius: 8px;</span><br><span class="line">    outline: none;</span><br><span class="line">    border: none;</span><br><span class="line">    color: rgb(80, 0, 0);</span><br><span class="line">    box-shadow: 0 0 2px rgba(0, 0, 0, 0.4);</span><br><span class="line">    background: linear-gradient(</span><br><span class="line">        skblue,deepskyblue</span><br><span class="line">    );</span><br><span class="line">    cursor: pointer;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.searchBarchange-width&#123;</span><br><span class="line">    width: 60px;</span><br><span class="line">    height: 60px;</span><br><span class="line">    background-color: #fff;</span><br><span class="line">    box-shadow: 0 0 10px rgba(0, 0, 0, 0.4);</span><br><span class="line">    border-radius: 60px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    transition: 0.5s;</span><br><span class="line">    margin: -500px 0 0 0;</span><br><span class="line">    z-index: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>认识Vue3</title>
    <url>/2024/07/13/%E8%AE%A4%E8%AF%86Vue3/</url>
    <content><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p>在vue中</p>
<p>编程语言：JS、TS                           主要是TS</p>
<p>代码风格：组合式API 、 选项式API        官方推荐组合式</p>
<p>生态系统逐渐向Vue3倾斜，主流库和擦火箭都在向Vue3迁移</p>
<p>这边建议直接下载一个 <code>Hbuilder X</code> ，可以直接创建vue项目，不用准备脚手架，和输入命令</p>
<p>默认使用Vite，是直接准备完成，看哪部分渲染哪部分，更加快捷</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240520204027444.png" alt="image-20240520204027444"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240520204544002.png" alt="image-20240520204544002"></p>
<p>这里的creaApp相当于一个花盆，APP相当于根，第四行相当于把根放进花盆里</p>
<p>index.html内</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240520210332091.png" alt="image-20240520210332091"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240520210551468.png" alt="image-20240520210551468"></p>
<p>总结</p>
<ul>
<li>Vite项目中，index.html 是项目入口文件，在项目最外层</li>
<li>加载 <code>index.html</code> 后，vite解析 <code>&lt;script type=&quot;module&quot; src=&quot;xxx&quot;&gt; </code> 指向 <code>JavaScript</code> </li>
<li>Vue3中是通过 <code>createApp</code> 函数创建一个应用实例</li>
</ul>
<h2 id="引入组件"><a href="#引入组件" class="headerlink" title="引入组件"></a>引入组件</h2><p>如果想要封装组件，可以在components目录下新建一个Vue文件，然后引入使用</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521152100322.png" alt="image-20240521152100322"></p>
<p>三步走</p>
<p>一、import引入</p>
<p>引入组件的路径</p>
<p>二、component引入</p>
<p>将组件名称放入export default中</p>
<p>三、使用方法</p>
<p>如下图：组件名称为 <code>Person</code> 使用是则为 <code>person</code> </p>
<p>如组件名称为 <code>MyComponents</code> 使用时写作 <code>my-components</code></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521152203856.png" alt="image-20240521152203856"></p>
<h2 id="Vue3核心"><a href="#Vue3核心" class="headerlink" title="Vue3核心"></a>Vue3核心</h2><ul>
<li><p>vue2 的 API 设计是 Options（配置）风格的</p>
</li>
<li><p>vue3 的 API 设计是 Composition（组合）风格的</p>
</li>
</ul>
<p>这些框住的都是配置，选项式</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521153927852.png" alt="image-20240521153927852"></p>
<h3 id="Options-API-的弊端"><a href="#Options-API-的弊端" class="headerlink" title="Options API 的弊端"></a>Options API 的弊端</h3><p>Options 类型的 API ，数据、方法、计算属性等，是分散在 <code>data</code>  <code>methods</code>  <code>computed</code> 中的，若想更改需求，需要分别修改 <code>data</code>  <code>methods</code>  <code>computed</code> ，不便于维护和复用</p>
<p>查看效果动画</p>
<p><a href="https://www.bilibili.com/read/cv10685553/?spm_id_from=333.999.0.0">https://www.bilibili.com/read/cv10685553/?spm_id_from=333.999.0.0</a></p>
<img src="../图片/image-20240521160504513.png" alt="image-20240521160504513" style="zoom:50%;" />

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521160547233.png" alt="image-20240521160547233"></p>
<h3 id="Composition-API-的优势"><a href="#Composition-API-的优势" class="headerlink" title="Composition API 的优势"></a>Composition API 的优势</h3><p>用函数的方式，更加优雅的组织代码，让相关功能的代码更加有序的组织在一起。将数据、方法、监视等组合在一起</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521160616293.png" alt="image-20240521160616293"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521160637568.png" alt="image-20240521160637568"></p>
<h3 id="拉开序幕的setup"><a href="#拉开序幕的setup" class="headerlink" title="拉开序幕的setup"></a>拉开序幕的setup</h3><h4 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h4><p>setup中的this是undefined，不要尝试在setup中写this.xxx，Vue3在尝试弱化this</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521162756473.png" alt="image-20240521162756473"></p>
<p><strong>注意看注释</strong></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521162917455.png" alt="image-20240521162917455"></p>
<h4 id="setup返回值"><a href="#setup返回值" class="headerlink" title="setup返回值"></a>setup返回值</h4><p>上图的return就是一个返回值</p>
<p>setup的返回值也可以是一个渲染函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return () =&gt; 是一个箭头函数，百度一下即可</span><br></pre></td></tr></table></figure>

<p>通过这个渲染函数，将哈哈渲染到页面中去了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521163256642.png" alt="image-20240521163256642"></p>
<h4 id="setup与Opyions-API-的关系"><a href="#setup与Opyions-API-的关系" class="headerlink" title="setup与Opyions API 的关系"></a>setup与Opyions API 的关系</h4><p>setup可以和data、methods共存，注意一下细节，setup是先执行的，也就是说，data是可以读取到setup的数据的</p>
<p>原写法可以读取到新写法的数据，新写法读取不到旧写法（data）的数据</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521165113768.png" alt="image-20240521165113768"></p>
<h4 id="setup语法糖"><a href="#setup语法糖" class="headerlink" title="setup语法糖"></a>setup语法糖</h4><p><img src="/../%E5%9B%BE%E7%89%87/image-20240521171120014.png" alt="image-20240521171120014"></p>
<p>这两个script同时存在很正常，第一个script仍然有存在的必要，因为需要export名称，如果文件名和组件名相同的话也可以不写</p>
<p>用以下方法可以只写一个script但是仍然可以定义组件名</p>
<p>终端下载插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i vite-plugin-vue-setup-extend -D</span><br></pre></td></tr></table></figure>



<p>vite.config.js中引入</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521172728045.png" alt="image-20240521172728045"></p>
<p>在文件中的script中输入name</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521172651664.png" alt="image-20240521172651664"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521172430585.png" alt="image-20240521172430585"></p>
<h3 id="响应式数据"><a href="#响应式数据" class="headerlink" title="响应式数据"></a>响应式数据</h3><p>Vue2的数据在data中就是响应式数据，但是Vue3没有data，他的响应式需要通过其他的方式</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521200546270.png" alt="image-20240521200546270"></p>
<h4 id="ref创建基本类型的响应式"><a href="#ref创建基本类型的响应式" class="headerlink" title="ref创建基本类型的响应式"></a>ref创建基本类型的响应式</h4><p><img src="/../%E5%9B%BE%E7%89%87/image-20240521201837488.png" alt="image-20240521201837488"></p>
<p>这个实例对象是可以改变的，内的数据只看无下划线部分的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521201324842.png" alt="image-20240521201324842"></p>
<p>这里需要更改一下方法为name.value但是前端仍为不需要更改，其自动选定value</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521201438804.png" alt="image-20240521201438804"></p>
<h4 id="reactive创建对象类型的响应式"><a href="#reactive创建对象类型的响应式" class="headerlink" title="reactive创建对象类型的响应式"></a>reactive创建对象类型的响应式</h4><p>打印出来的数据，数据在target中</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521203519086.png" alt="image-20240521203519086"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521212701383.png" alt="image-20240521212701383"></p>
<h4 id="ref创建对象类型响应式数据"><a href="#ref创建对象类型响应式数据" class="headerlink" title="ref创建对象类型响应式数据"></a>ref创建对象类型响应式数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ref &gt;&gt;&gt;  可以定义基本类型、对象类型的响应式数据</span><br><span class="line">reactive &gt;&gt;&gt; 只能定义对象类型的响应式数据</span><br></pre></td></tr></table></figure>



<p>ref定义响应式数据，只需要在调用对象的时候加一个value即可正常调用</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521213448544.png" alt="image-20240521213448544"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521213820263.png" alt="image-20240521213820263"></p>
<h4 id="ref对比reactive"><a href="#ref对比reactive" class="headerlink" title="ref对比reactive"></a>ref对比reactive</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">////从宏观角度来看</span><br><span class="line">1、ref用来定义：基本类型数据、对象类型数据</span><br><span class="line">2、reactive用来定义：对象类型数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">////区别</span><br><span class="line">1、ref创建变量必须使用 .value （可以使用 volar 插件自动添加 .value ）</span><br><span class="line">2、reactive重新分配一个新对象，会失去响应式 （可以使用 Object.assign 去整体替换）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">////使用原则</span><br><span class="line">1、若需要一个基本类型的响应式数据，必须使用ref</span><br><span class="line">2、若需要一个响应式对象，层级不深，ref、reactive 都可以</span><br><span class="line">3、若需要一个响应式对象，且层级很深，推荐使用reactive</span><br></pre></td></tr></table></figure>



<p>volar插件在Hbuilder X中没有找到，VSCode中有</p>
<p>reactive有一个局限性，无法被整体替代</p>
<p>解决方法</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240522152618838.png" alt="image-20240522152618838"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">car = &#123;brand:&#x27;雅迪&#x27;,price:&#x27;1&#x27;&#125;</span><br><span class="line">car = reactive(&#123;brand:&#x27;雅迪&#x27;,price:&#x27;1&#x27;&#125;)</span><br><span class="line">//这么写页面是不会更新的</span><br></pre></td></tr></table></figure>



<p>如果是定义的ref对象数据，就可以直接整体替换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">car.value = &#123;brand:&#x27;雅迪&#x27;,price:&#x27;1&#x27;&#125;</span><br><span class="line">//页面会更新渲染</span><br></pre></td></tr></table></figure>



<p>我的理解在于，ref定义的一个对象，数据在value中，更改整个value，仍然是在响应式数据内更改，而reactive定义的对象，如果要整体替换的话就不再是响应式的数据，虽然数据成功更改了，但是无法在页面显示，使用Object.assgin()算是巧妙的保留了reactive的响应式，在更新数据之后更新到页面。</p>
<p>简单来说捏，ref整体替换相当于换了个女朋友，reactive的替换相当于女朋友换了身衣服</p>
<h4 id="toRefs和toRef"><a href="#toRefs和toRef" class="headerlink" title="toRefs和toRef"></a>toRefs和toRef</h4><p>举个例子</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240522162105083.png" alt="image-20240522162105083"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240522162339468.png" alt="image-20240522162339468"></p>
<p>通过toRefs可以将reactive解构的数据变为响应式数据，通过输出可以发现，更改数据的时候，<strong>content.name的内容也发生了改变</strong></p>
<p>说明这里解构出来的name是和content.name相关联的，所以前端渲染写name或者conten.name都是可以的。非常nb。</p>
<p><strong>toRefs接收一个有reactive定义的响应式对象，将响应式对象的每一组key value都拿出来，形成一个新的对象，对象中有值，但是这个值是和原响应式相关联的，非常有作用</strong></p>
<p>toRef看名字知道和toRefs的关系，toRef是将响应式数据内的一个变量拿出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let name =toRef(content,&#x27;name&#x27;)</span><br></pre></td></tr></table></figure>

<p>作用和toRefs相同</p>
<h4 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性"></a>computed计算属性</h4><p>写一个输入框</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240522164255754.png" alt="image-20240522164255754"></p>
<p>使用v-model:value可以实现双向绑定，value可以省略</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240522164545945.png" alt="image-20240522164545945"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240522164457116.png" alt="image-20240522164457116"></p>
<p>虽然，可以直接把数据拿过来用，但是如果有别的需求的话，代码将变得复杂</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240522164839272.png" alt="image-20240522164839272"></p>
<p>如：姓名为英文，我需要首字母大写</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240522165326461.png" alt="image-20240522165326461"></p>
<p>很不优雅，把他移到后端</p>
<p>这个时候需要一个computer计算属性，computer有一个属性，只要计算所依赖的数据发生变化就重新计算</p>
<p>Vue2中使用computer是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        computer : &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">//computer在Vue2中是一个配置项，在Vue3则发生改变</span><br></pre></td></tr></table></figure>



<p>Vue3</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240522170439226.png" alt="image-20240522170439226"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240522171227394.png" alt="image-20240522171227394"></p>
<p>上图定义的fullName是一个计算属性，且是<strong>只读</strong>的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240522171917700.png" alt="image-20240522171917700"></p>
<p>修改一下试试</p>
<p>可以看到这是一个响应式数据</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240522172322486.png" alt="image-20240522172322486"></p>
<p>点击后页面也没有什么变化，这里有个bug，懒得换截图了，fullName.value 点击后数据不会更改</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240522172550613.png" alt="image-20240522172550613"></p>
<p>写一个可以改变的computer，get() get 到的是自己输入的只读，set() set是通过点击事件出发更改，然后将数据解构，再去 get 计算的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240522173705139.png" alt="image-20240522173705139"></p>
<h4 id="如何应用到微信小程序"><a href="#如何应用到微信小程序" class="headerlink" title="如何应用到微信小程序"></a>如何应用到微信小程序</h4><p>我的思考：</p>
<p>我认为上面的set方法严格来说也不算是改变了计算结果，而是通过改变计算的两个数据，引起computed重新计算而已，这个功能在微信小程序中也可以复现</p>
<p><strong>简单说一下原理：微信小程序中并没有直接的API写法，需要npm一个组件，然后再自己封装一个component页面组件，然后调用</strong></p>
<h5 id="首先：引入组件"><a href="#首先：引入组件" class="headerlink" title="首先：引入组件"></a>首先：引入组件</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install mobx-miniprogram mobx-miniprogram-bindings</span><br><span class="line">//使用npm引入mobx-miniprogram和mobx-miniprogram-bindings两个组件到微信小程序，然后构建npm（我成功的时候是引入到了page的同级目录下）</span><br></pre></td></tr></table></figure>



<p>简单介绍一下组件</p>
<ul>
<li><code>mobx-miniprogram</code> 的作用：创建 <code>Store</code> 对象，用于存储应用的数据</li>
<li><code>mobx-miniprogram-bindings</code> 的作用：将状态和组件、页面进行绑定关联，从而在组件和页面中操作数据</li>
</ul>
<h5 id="其次：封装组件"><a href="#其次：封装组件" class="headerlink" title="其次：封装组件"></a>其次：封装组件</h5><p>这一步需要在page的同级目录下创建一个component文件夹，因为是.js文件内不是 <code>page(&#123;&#125;)</code> 而是 <code>Compontent(&#123;&#125;)</code> </p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240523212900937.png" alt="image-20240523212900937"></p>
<p>注意检查一下json文件中是否有 <code>&quot;component&quot;: true,</code></p>
<p>然后</p>
<p>在 <code>numstore/numstore.js</code> 中创建一个 Store 对象，来储存数据，函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* compontents/numstore/numstore.js */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; observable, action, set &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-miniprogram&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 observable 创建一个被监测的对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> numStore = <span class="title function_">observable</span>(&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建应用状态</span></span><br><span class="line">  <span class="attr">numA</span>: <span class="string">&#x27;zhang&#x27;</span>,</span><br><span class="line">  <span class="attr">numB</span>: <span class="string">&#x27;san&#x27;</span>,</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 使用 action 更新 numA 以及 numB</span></span><br><span class="line">  <span class="attr">update</span>: <span class="title function_">action</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">numA</span>+=<span class="number">1</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">numB</span>+=<span class="number">1</span></span><br><span class="line">  &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="attr">changesum</span>: <span class="title function_">action</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">sum</span> = <span class="string">&#x27;li-si&#x27;</span></span><br><span class="line">  &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算属性，使用 get 修饰符，</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">sum</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">numA</span> + <span class="variable language_">this</span>.<span class="property">numB</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">sum</span>(<span class="params">VaL</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> [val1,val2] = <span class="title class_">VaL</span>.<span class="title function_">split</span>(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(set,val2,val1)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">numA</span> = val1</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">numB</span> = val2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240523214058666.png" alt="image-20240523214058666"></p>
<p>注意蓝字是问号，我并没有真的去尝试，因为感觉很麻烦，封装着用呗，蛮好的</p>
<h5 id="然后：使用组件"><a href="#然后：使用组件" class="headerlink" title="然后：使用组件"></a>然后：使用组件</h5><p>在要引用组件的页面引用 <code>mobx-miniprogram-bindings</code> </p>
<p>如果需要 Page 或者 Component 中对共享的数据进行读取、更新操作，需要使用 mobx-miniprogram-bindings </p>
<p>mobx-miniprogram-bindings 的作用就是将 Store 和 页面或组件进行绑定关联</p>
<p>如果需要在组件中使用状态，需要 mobx-miniprogram-bindings 库中导入 ComponentWithstore 方法</p>
<p>在使用时：需要将 &#x3D;&#x3D;component 方法替换成 Componentwithstore 方法&#x3D;&#x3D;，原本组件配置项也需要写到该方法中,在替换以后，就会新增一个&#x3D;&#x3D;storeBindings&#x3D;&#x3D; 配置项，配置项常用的属性有以下三个：</p>
<ul>
<li>store：指定要绑定的store对象，这里是绑定的封装组件的位置</li>
<li>fields：指定要绑定的data字段，这里的字段，是封装组件内的字段，而且绑定后，不需要在index中的data再进行定义，直接再前端就可以使用拿到数据</li>
<li>actions：指定需要映射的 action 方法，之前封装组件时，引用了action方法，而且在定义函数时也写到了action，这里只需要写需要用到的方法名，即可从封装的组件内获取到对应方法，直接在前端使用即可</li>
</ul>
<p>以为大部分组件被封装起来了，在index页面也就没什么好说的了，只需要注意一下storeBindings这个配置项获取方法即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* pages/index/index.js */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ComponentWithStore</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-miniprogram-bindings&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; numStore &#125; <span class="keyword">from</span> <span class="string">&#x27;../../components/store/numstore&#x27;</span></span><br><span class="line"><span class="comment">//两行import分别引入mobx-miniprogram-bindings组件和刚刚封装的numstore组件</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">ComponentWithStore</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">someData</span>: <span class="string">&#x27;...&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">storeBindings</span>: &#123;</span><br><span class="line">    <span class="attr">store</span>: numStore,</span><br><span class="line">    <span class="attr">fields</span>: [<span class="string">&#x27;numA&#x27;</span>, <span class="string">&#x27;numB&#x27;</span>, <span class="string">&#x27;sum&#x27;</span>],</span><br><span class="line">    <span class="attr">actions</span>: [<span class="string">&#x27;update&#x27;</span>,<span class="string">&#x27;changesum&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果原页面有需要新定义的方法，只需要在methods中定义，参考vue2</p>
<h5 id="最后：前端渲染"><a href="#最后：前端渲染" class="headerlink" title="最后：前端渲染"></a>最后：前端渲染</h5><p>写个丑陋的前端渲染一下</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240523215936991.png" alt="image-20240523215936991"></p>
<p>掌握了这些东西，可以尝试一下弄计算属性了</p>
<p>引入组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install miniprogram-computed</span><br></pre></td></tr></table></figure>



<p>开始使用组件复现计算属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// component.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入 miniprogram-computed</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ComponentWithComputed</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;miniprogram-computed&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">ComponentWithComputed</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="title function_">total</span>(<span class="params">data</span>) &#123;</span><br><span class="line">      <span class="comment">// 注意： </span></span><br><span class="line">      <span class="comment">// computed 函数中不能访问 this ，只有 data 对象可供访问</span></span><br><span class="line">      <span class="comment">// 这个函数的返回值会被设置到 this.data.sum 字段中</span></span><br><span class="line">      <span class="comment">// 计算属性具有缓存，计算属性使用多次，但是计算属性方法只会执行一次</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;~~~~~&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> data.<span class="property">a</span> + data.<span class="property">b</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">     <span class="attr">change</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">         <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">             numA : <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">numA</span> + <span class="number">1</span></span><br><span class="line">         &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>前端吓唬写一下，达到计算属性目的</p>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>监视，谁谁谁变了，我要怎样怎样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue3中的watch只能监视以下四种数据：</span><br><span class="line"></span><br><span class="line">1、ref 定义的数据</span><br><span class="line">2、reactive 定义的数据</span><br><span class="line">3、函数返回一个值（ getter函数 ）</span><br><span class="line">4、一个包含上述内容的数组</span><br></pre></td></tr></table></figure>



<h4 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h4><p>监听 ref 定义的数据</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240522210655285.png" alt="image-20240522210655285"></p>
<p>在Vue3中，watch函数返回一个停止监听器的函数，因此定义的stopWatch实际上是一个函数，当呢调用他是，他会停止对sum响应式数据的监听</p>
<h4 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h4><p>监听ref定义的【对象类型】数据：直接写数据名，监听的是对象的【地址值】，若想监视对象内部的数据，要开启深度监视。</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240524105415300.png" alt="image-20240524105415300"></p>
<p>deep开启深度监视</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240524111542504.png" alt="image-20240524111542504"></p>
<p>为了帮助理解可以当个比方</p>
<p>更改地址值相当于搬家，可以找到newValue和oldValue，更改属性相当于家里换家具，console时已经更换完了，获取到的地址值是同一个，看到的数据也是一样的</p>
<h4 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h4><p>监视reactive定义的【对象类型】数据，且默认开启了深度监视</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240524143721719.png" alt="image-20240524143721719"></p>
<h4 id="情况四"><a href="#情况四" class="headerlink" title="情况四"></a>情况四</h4><p>监视ref或者reactive定义的【对象类型】数据中的某个属性</p>
<p>注意点如下</p>
<ul>
<li>若该属性不是【对象类型】，需要写成函数形式</li>
<li>若该属性仍然是【对象类型】，可以直接编，也可以写成函数，不过建议写成函数</li>
</ul>
<p>监视对象类型中的某个基本类型数据，写成函数式</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240524153323683.png" alt="image-20240524153323683"></p>
<p>蓝字错误，写为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">()=&gt;person.name</span><br></pre></td></tr></table></figure>





<p>监视对象类型中的某个对象类型数据，可以直接写（但是有问题），建议写成函数式</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240524154850969.png" alt="image-20240524154850969"></p>
<p>函数式</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240524155233716.png" alt="image-20240524155233716"></p>
<p>总结，如果要侦听对象内的某个属性，无脑函数，对象类型数据在加上一个deep</p>
<h4 id="情况五"><a href="#情况五" class="headerlink" title="情况五"></a>情况五</h4><p>监视上述的多个数据</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240524160732396.png" alt="image-20240524160732396"></p>
<h4 id="如何应用到微信小程序-1"><a href="#如何应用到微信小程序-1" class="headerlink" title="如何应用到微信小程序"></a>如何应用到微信小程序</h4><p>自己的话：</p>
<p>使用和computed同一个组件引入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ComponentWithComputed</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;miniprogram-computed&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">ComponentWithComputed</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="attr">b</span>:<span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">computed</span>: &#123;</span><br><span class="line">        <span class="title function_">total</span>(<span class="params">data</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> data.<span class="property">a</span> + data.<span class="property">b</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">watch</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;a,b&#x27;</span>:<span class="keyword">function</span> (<span class="params">a,b</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">                <span class="attr">total</span>: a + b</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="title function_">updateDate</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">                <span class="attr">a</span>:<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">a</span> + <span class="number">1</span>,</span><br><span class="line">                <span class="attr">b</span>:<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">b</span> + <span class="number">1</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>





<h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h3><p>官网描述：立即运行一个函数，同时响应式地追踪其依赖，并在依赖更新时重新执行该函数</p>
<p><code>watch</code> 对比 <code>watchEffect</code> </p>
<ul>
<li>都能监听响应式数据的变化，不同的是监听数据变化的方式不同</li>
<li><code>watch</code> ：要明确指出监视的数据</li>
<li><code>watchEffect</code> ：不用明确指出监视的数据（函数中用到哪些属性，就监视哪些属性）</li>
</ul>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240525102510968.png" alt="image-20240525102510968"></p>
<h3 id="标签的ref属性"><a href="#标签的ref属性" class="headerlink" title="标签的ref属性"></a>标签的ref属性</h3><p><img src="/../%E5%9B%BE%E7%89%87/image-20240525105645472.png" alt="image-20240525105645472"></p>
<p>这种查询id的方法不建议使用，因为id是不可重复的，id取名难，一旦重复了不好找错</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240525114656049.png" alt="image-20240525114656049"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240525115912353.png" alt="image-20240525115912353"></p>
<p>上方这些东西是在HTML的标签上写的ref，如果在组件标签上写ref就有事了</p>
<p>&#x3D;&#x3D;二编&#x3D;&#x3D;：这里的截图有点含糊，在App.vue中给person逐渐添加了一个ref标签，然后点击打印标签的value，但是发现可以打印出来，但是看不到数据，如果想要看到数据，需要在person组件中添加defineExpose，指定可以获取到的变量名称。而且这个defineExpose可以不引入，因为其是宏函数，宏函数在Vue3内不引用也可以使用</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240525121116370.png" alt="image-20240525121116370"></p>
<p>总结：ref用在普通的DOM标签上，获取的是DOM节点；用在组件标签上，获取的是实例对象</p>
<p>尝试在小程序中实现，发现小程序中虽然有这种写法的提示词，但是并不支持这种查询，因为这是web的API</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wx.<span class="title function_">createSelectorQuery</span>().<span class="title function_">select</span>(<span class="string">&#x27;.title&#x27;</span>).<span class="title function_">boundingClientRect</span>(<span class="keyword">function</span>(<span class="params">rect</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(rect)</span><br><span class="line">        &#125;).<span class="title function_">exec</span>()</span><br></pre></td></tr></table></figure>





<h3 id="TS中的接口、泛型、自定义类型"><a href="#TS中的接口、泛型、自定义类型" class="headerlink" title="TS中的接口、泛型、自定义类型"></a>TS中的接口、泛型、自定义类型</h3><p>先看一下TS文件</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240525195139100.png" alt="image-20240525195139100"></p>
<p>结合看一下</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240525194601451.png" alt="image-20240525194601451"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240525200151911.png" alt="image-20240525200151911"></p>
<p>定义接口时 <code>？</code> 表示可选</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240525200436120.png" alt="image-20240525200436120"></p>
<h3 id="props的使用"><a href="#props的使用" class="headerlink" title="props的使用"></a>props的使用</h3><p>接受父页面的传参</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240525201909744.png" alt="image-20240525201909744"></p>
<p>简单介绍一下Vue中的属性问题</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240525203322432.png" alt="image-20240525203322432"></p>
<p>简单看一下for循环吧，和小程序有点不一样</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240525204531540.png" alt="image-20240525204531540"></p>
<p>限制类型+限制必要性</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240525210047384.png" alt="image-20240525210047384"></p>
<p>指定默认值</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240525211104015.png" alt="image-20240525211104015"></p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Vue组件实例在创建时要经历一系列的初始化步骤，在此过程中Vue在合适时机，调用特定的函数，从而让开发者有机会在特定的时期运行自己的代码。</p>
<p>生命周期、生命周期函数、生命周期钩子</p>
<p>组件的一生：&#x3D;&#x3D;创建、挂载、更新、销毁&#x3D;&#x3D;</p>
<ul>
<li>创建————调用特定的函数（created）</li>
<li>挂载————调用特定的函数（mounted）</li>
<li>更新</li>
<li>销毁</li>
</ul>
<h4 id="Vue2的生命周期"><a href="#Vue2的生命周期" class="headerlink" title="Vue2的生命周期"></a>Vue2的生命周期</h4><p>不包括路由的话是有八个生命周期钩子，但是真实情况是大于八个的</p>
<ul>
<li>创建——（创建前 beforeCreate，创建完毕 Created）</li>
<li>挂载——（挂载前 beforeMount，挂载完毕 Mounted）</li>
<li>更新——（更新前 beforeUpdate，更新完毕 Updated）</li>
<li>销毁——（销毁前 beforeUnmount，销毁完毕 Unmounted）</li>
</ul>
<p>因为我的Hbuilder X没有成功运行Vue2，这里不做图片演示，只有文字说明，创建和挂载组件是只能执行一次的，但是可以更新很多次，如果想要看销毁的话，可以在App.vue中使用</p>
<p>这里解释了一下v-if和v-show的区别</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240525222800323.png" alt="image-20240525222800323"></p>
<h4 id="Vue3的生命周期"><a href="#Vue3的生命周期" class="headerlink" title="Vue3的生命周期"></a>Vue3的生命周期</h4><ul>
<li>创建——（创建 setup）</li>
<li>挂载——（挂载前 onBeforeMount，挂载完毕 onMounted）</li>
<li>更新——（更新前 onBeforeUpdate，更新完毕 onUpdated）</li>
<li>销毁——（销毁前 onBeforeUnmount，销毁完毕 onUnmounted）</li>
</ul>
<p>Vue3常用的钩子挂在完毕、更新完毕、卸载之前</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240526093208019.png" alt="image-20240526093208019"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240526093444459.png" alt="image-20240526093444459"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240526094106548.png" alt="image-20240526094106548"></p>
<p>App.vue的挂载要在person组件的创建之前，很好理解吧</p>
<h4 id="补课微信小程序生命周期"><a href="#补课微信小程序生命周期" class="headerlink" title="补课微信小程序生命周期"></a>补课微信小程序生命周期</h4><p>小程序从启动到销毁的过程</p>
<p>一个小程序完整的生命周期由 &#x3D;&#x3D;应用生命周期&#x3D;&#x3D;、&#x3D;&#x3D;页面生命周期&#x3D;&#x3D; 和 &#x3D;&#x3D;组件生命周期&#x3D;&#x3D; 三部分组成的</p>
<h5 id="应用生命周期"><a href="#应用生命周期" class="headerlink" title="应用生命周期"></a>应用生命周期</h5><p>应用生命周期函数需要在app.js文件的App()方法中进行定义，App()方法必须在app.js中进行调用，主要用来注册小程序</p>
<p>应用生命周期函数由 <code>onLaunch</code> <code>onShow</code> <code>onHide</code> 三个函数组成</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240526102014503.png" alt="image-20240526102014503"></p>
<h5 id="页面生命周期"><a href="#页面生命周期" class="headerlink" title="页面生命周期"></a>页面生命周期</h5><p>访问页面——onLoad（监听页面加载）——onShow（监听初次渲染完成）——onUnload（监听页面卸载）</p>
<p>注意跳转到其他页面是是否关闭本页面，不同的路由，再次返会后，触发的生命周期函数不同，自己get一下</p>
<p>补充一个细节</p>
<ul>
<li>tabber页面之间的跳转并不会销毁页面</li>
<li>如果是左上角的返回键，返回上一个页面，会销毁当前页面</li>
</ul>
<p>之所以补课微信小程序的生命周期是因为，当时看课没有这个，其实也不是很难，平时开发的时候多少也都了解了一下</p>
<h5 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h5><p>组件的生命周期函数需要在 <code>lifetimes</code> 字段内进行声明</p>
<p>组件的生命周期函数有五个：<code>created</code> <code>attached</code> <code>ready</code> <code>moved</code> <code>detached</code></p>
<ul>
<li>组件创建完毕——created</li>
<li>组件解析完成，挂载到页面后——attached</li>
<li>组件被销毁——detached</li>
</ul>
<p>组件的生命周期主要用于component自定义组件，因为component自定义组件不太了解，先按下不表</p>
<p>但是一下原生组件，如view是没有生命周期的，如果view在组件内，其生命周期会受到外在组件的影响</p>
<h3 id="自定义Hooks"><a href="#自定义Hooks" class="headerlink" title="自定义Hooks"></a>自定义Hooks</h3><p>hooks的命名规范 <code>useXxxx</code></p>
<p>先写一个获取狗图片的功能，这个网站，每次打开获取到的狗都不同，利用这个来写</p>
<p><a href="https://dog.ceo/api/breed/pembroke/images/random">https://dog.ceo/api/breed/pembroke/images/random</a></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240526153051669.png" alt="image-20240526153051669"></p>
<p>现在解决蓝字问题，真正扣题了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240526154703753.png" alt="image-20240526154703753"></p>
<h2 id="路由（route）"><a href="#路由（route）" class="headerlink" title="路由（route）"></a>路由（route）</h2><ul>
<li>路由就是一组 &#x3D;&#x3D;key、value&#x3D;&#x3D; 的对应关系</li>
<li>多个路由，需要经过 &#x3D;&#x3D;路由器&#x3D;&#x3D; 的管理</li>
</ul>
<p>前端路由可以实现 SPA（单页面） 应用，从始至终只有一个HTML，如果这个HTML还想实现炫酷的切换，这个时候就要用到路由了</p>
<p>SPA一般有一个左边的导航区，和右边的展示区，点击左边导航区的内容展示区发生相应的变化，且页面不抖动</p>
<p>原理：</p>
<p>点击某个导航项时，上方路径发生变化，然后被路由器监视到变化，然会路由器进行规则匹配，如果匹配成功，组件展示在展示区，重新匹配后，将原组件卸载，挂载新匹配的组件</p>
<p>&#x3D;&#x3D;路径至关重要，如果不能引起路径的变化，路由器无法变化&#x3D;&#x3D;</p>
<h3 id="写一个路由"><a href="#写一个路由" class="headerlink" title="写一个路由"></a>写一个路由</h3><p><strong>写路由要做的事</strong></p>
<ol>
<li>导航区、展示区</li>
<li>请来路由器</li>
<li>制定路由的具体规则（什么路径对应什么组件）</li>
<li>形成一个一个的【???.vue】</li>
</ol>
<p>一、导航区、展示区</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240526165939915.png" alt="image-20240526165939915"></p>
<p>二、请来路由器</p>
<p>安装路由器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i vue-router</span><br></pre></td></tr></table></figure>

<p>在Vue3的环境中，不用加router的版本号，用最新的即可</p>
<p>创建，使用路由器</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240526171219169.png" alt="image-20240526171219169"></p>
<p>写完这个这里多了应该routes</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240526171740303.png" alt="image-20240526171740303"></p>
<p>三、</p>
<p>三四一起写</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240526173847185.png" alt="image-20240526173847185"></p>
<h3 id="两个注意点"><a href="#两个注意点" class="headerlink" title="两个注意点"></a>两个注意点</h3><ol>
<li>路由组件通常放在 <code>pages</code> 或者 <code>views</code> 文件夹，一般组件通常放在 <code>components</code> 文件夹</li>
<li>通过点击导航，视觉效果上消失的路由组件，是被卸载了的，需要的时候再去挂载</li>
</ol>
<p>区分路由组件和一般组件：如果有一个 Demo.vue </p>
<p>一般组件：亲手写标签出来 <code>&lt;demo&gt;&lt;/demo&gt;</code></p>
<p>路由组件：靠路由的规则渲染出来的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">routes:[</span><br><span class="line">    &#123;path:&#x27;/demo&#x27; , components:Demo&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>





<h3 id="路由器的工作模式"><a href="#路由器的工作模式" class="headerlink" title="路由器的工作模式"></a>路由器的工作模式</h3><p>一般来说给用户使用的要考虑美观需要使用history模式，后台管理使用hash</p>
<h4 id="history模式"><a href="#history模式" class="headerlink" title="history模式"></a>history模式</h4><ul>
<li>优点：URL更加美观，不带有 <code>#</code> ，更接近传统网站的URL</li>
<li>缺点：后期项目上线，&#x3D;&#x3D;需要服务器配合处理路径问题&#x3D;&#x3D;，否则刷新会有404错误</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//写法</span><br><span class="line">Vue2：mode:&#x27;history&#x27;</span><br><span class="line">Vue3：</span><br><span class="line">const router = createRouter(&#123;</span><br><span class="line">    history:createWebHistory()</span><br><span class="line">    router:[]</span><br><span class="line">&#125;)</span><br><span class="line">React：BrowserRouter</span><br></pre></td></tr></table></figure>



<h4 id="hash模式"><a href="#hash模式" class="headerlink" title="hash模式"></a>hash模式</h4><ul>
<li>优点：兼容性更好，因为不需要服务器端处理路径</li>
<li>缺点：URL带有 <code>#</code> 不太美观，且在 <code>SEO</code> 优化方面相对较差</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//别忘了引用</span><br><span class="line">const router = createRouter(&#123;</span><br><span class="line">    history:createWebHashHistory()</span><br><span class="line">    /****/</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>





<h3 id="to的两种写法"><a href="#to的两种写法" class="headerlink" title="to的两种写法"></a>to的两种写法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link to=&quot;/news&quot; active-class=&quot;active&quot;&gt;新闻&lt;/router-link&gt;</span><br><span class="line">&lt;router-link :to=&quot;&#123;path:&#x27;/about&#x27;&#125;&quot; active-class=&quot;active&quot;&gt;关于&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240526203416484.png" alt="image-20240526203416484"></p>
<h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><p>rt</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240526204529640.png" alt="image-20240526204529640"></p>
<h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p>准备路由</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240526212435860.png" alt="image-20240526212435860"></p>
<p>前端搞上</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240526212829763.png" alt="image-20240526212829763"></p>
<p>如果直接写 detail 或者 &#x2F;detail 的话，会匹配不到路由，匹配失败</p>
<h3 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h3><h4 id="query参数"><a href="#query参数" class="headerlink" title="query参数"></a>query参数</h4><p><img src="/../%E5%9B%BE%E7%89%87/image-20240527104116519.png" alt="image-20240527104116519"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527110436396.png" alt="image-20240527110436396"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527112057014.png" alt="image-20240527112057014"></p>
<h4 id="params参数"><a href="#params参数" class="headerlink" title="params参数"></a>params参数</h4><p>个人感觉params参数很一般，建议query一般梭</p>
<ul>
<li>传递params参数时，若使用to对象写法，请务必使用 name 配置项，不能使用 path</li>
<li>传递params参数时，需要提前在规则中占位</li>
</ul>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527114235375.png" alt="image-20240527114235375"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527115140815.png" alt="image-20240527115140815"></p>
<h3 id="路由的props配置"><a href="#路由的props配置" class="headerlink" title="路由的props配置"></a>路由的props配置</h3><p>用来解决之前说过的很长，很不美观的问题</p>
<p>props有三种写法</p>
<p>一、</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527121219010.png" alt="image-20240527121219010"></p>
<p>红字打错了，是&#x3D;&#x3D;占位的三个params参数&#x3D;&#x3D;，</p>
<p>这种写法有局限性只是params参数，如果是query参数这个写法是不可以的</p>
<p>二、函数写法</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527122501118.png" alt="image-20240527122501118"></p>
<p>query和params传参都行</p>
<p>三、对象写法</p>
<p>没意义</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527122814484.png" alt="image-20240527122814484"></p>
<p>这里主要是路由的props，为什么不说组件的props呢，因为没必要，路由组件是没有机会写标签的 <code>&lt;Detail/&gt;</code> 这个标签不会出现，而组件可以，爱怎么写怎么写，组件的props就是  <code>&lt;Person a=&quot;100&quot; /&gt;</code> 的那个a，一般组件直接写在标签上就行了</p>
<h3 id="replace属性"><a href="#replace属性" class="headerlink" title="replace属性"></a>replace属性</h3><p>路由跳转的时候会操作浏览器的历史记录，路由操作浏览器的历史记录有两个动作，一个是push，另一个是replace</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527135958523.png" alt="image-20240527135958523"></p>
<p>设置路由的replace也很简单，在导航栏加一个 replace 即可</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527140206218.png" alt="image-20240527140206218"></p>
<h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><p>编程式导航：脱离 <code>&lt;route-link&gt;</code> 进行路由跳转， <code>&lt;route-link&gt;</code> 本质是一个 <code>&lt;a&gt;</code> 标签</p>
<p>需求：写一个按钮点击也可以跳转到对应路由</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527150003235.png" alt="image-20240527150003235"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527151158558.png" alt="image-20240527151158558"></p>
<p>在最后说一下编程式路由导航的作用吧</p>
<p>如果我想实现登录成功后自动跳转、打开三秒后跳转、鼠标滑动跳转等等功能，这显然是一个a标签无法做到的，这个时候就需要编程式导航了</p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>重定向，让指定的路径重新定位到另一个路径</p>
<p>之前一直没说，一个很恶心的地方，就是页面打开是没有默认项的，现在就需要重定向解决</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527151549602.png" alt="image-20240527151549602"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527152221423.png" alt="image-20240527152221423"></p>
<p>这里是为了方便观察层级放到上面来到，一般写在路由下面</p>
<h3 id="小程序一些思考"><a href="#小程序一些思考" class="headerlink" title="小程序一些思考"></a>小程序一些思考</h3><p>如果是只看样式的话，路由有点像微信小程序的tabBer，但是又有区别tabBer切换页面的时候不会卸载掉，而路由切换组件的时候是要卸载掉的，于是我有想到了另一个东西，也是我经常写的，其视觉效果是相同的。单纯的view是没有生命周期的。但是这里是wx:if来控制显示的，并不是hidden隐藏，if来控制显示是进行销毁的，而hidden不销毁。</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240526200730897.png" alt="image-20240526200730897"></p>
<p>先定义一个这么个导航区，然后在后端定义一个 status ，通过点击事件来改变 status 的值，利用三元判断来定义选中后的样式，达到视觉上的选中效果，然后利用 <code>&lt;block wx:if=&quot;&#123;&#123;status==1&#125;&#125;&quot;&gt;&lt;/block&gt;</code> 这个小判断来控制元素的显示</p>
<p>码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//wxml</span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;nav&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;slike1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;slike2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;nav-view&#123;&#123;status==1 ? &#x27;status&#x27;:&#x27;&#x27;&#125;&#125;&quot;</span> <span class="attr">bind:tap</span>=<span class="string">&quot;cells1&quot;</span>&gt;</span>宣传文章<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;nav-view&#123;&#123;status==2 ? &#x27;status&#x27;:&#x27;&#x27;&#125;&#125;&quot;</span> <span class="attr">bind:tap</span>=<span class="string">&quot;cells2&quot;</span>&gt;</span>公安文件<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;nav-view&#123;&#123;status==3 ? &#x27;status&#x27;:&#x27;&#x27;&#125;&#125;&quot;</span> <span class="attr">bind:tap</span>=<span class="string">&quot;cells3&quot;</span>&gt;</span>线上讲座<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;nav-view&#123;&#123;status==4 ? &#x27;status&#x27;:&#x27;&#x27;&#125;&#125;&quot;</span> <span class="attr">bind:tap</span>=<span class="string">&quot;cells4&quot;</span>&gt;</span>知识竞赛<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;status==1&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>1<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;status==2&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>2<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;status==3&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>3<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;status==4&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>4<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//js</span></span><br><span class="line"><span class="title function_">page</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">status</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">cells1</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="number">1</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">cells2</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="number">2</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">cells3</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="number">3</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">cells4</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="number">4</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>随着继续的学习，我感觉嵌套的路由在小程序中实现类似效果似乎也不是很难，但是，到传参这里，没有了上面头绪，因为我这种方式虽然也是不同组件的切换，但是不需要去找组件的路径，那么就没有url来提供给我传参的机会，那么对于实现前端的变化我的想法是这样的，取消 <code>&lt;block&gt;</code> 标签，只写一个 view 标签，定义一个demolist来显示数据，通过不同点击事件来改变demolist的值，来达到相同的效果，但是我思考了一下这似乎并不算传参，只是效果与其类似而已。也可以参考vue的编程式导航的内容，给点击事件传一个参，然后那这个参去拿写好的数据，但是这样感觉还不是很像。</p>
<p>至于编程式导航，一开始就是了，通过各种事件来实现效果，重定向也是有的，在data中默认了status为1</p>
<h2 id="Pinia"><a href="#Pinia" class="headerlink" title="Pinia"></a>Pinia</h2><p>集中式状态（数据）管理  redux   vuex   pinia</p>
<p>集中式状态管理：当写App的时候，会有各种各样的组件，还会有组件嵌套啊什么的，这个时候如果我在抽奖页面想用到登录页面的登录信息，这个时候就需要集中式状态管理了。但是不要是一个数据都交给数据管理，要把那些共享的数据交给集中式状态管理，而不是组件自身的数据</p>
<h3 id="准备一个效果"><a href="#准备一个效果" class="headerlink" title="准备一个效果"></a>准备一个效果</h3><p>先敲一个加减效果吧</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527163724136.png" alt="image-20240527163724136"></p>
<p>再敲一个与之前生成随机狗类似的生成随机土味情话</p>
<p>网站地址：<a href="https://api.uomg.com/api/rand.qinghua?format=json">https://api.uomg.com/api/rand.qinghua?format=json</a></p>
<p>注意一下这里下载了一个随即库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i nanoid</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527172117573.png" alt="image-20240527172117573"></p>
<h3 id="搭建pinia环境"><a href="#搭建pinia环境" class="headerlink" title="搭建pinia环境"></a>搭建pinia环境</h3><p>下载pinia</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i pinia</span><br></pre></td></tr></table></figure>

<p>在main.js文件中引入</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527173739270.png" alt="image-20240527173739270"></p>
<p>成功后插件内多了一个菠萝</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527173608462.png" alt="image-20240527173608462"></p>
<h3 id="存储、读取数据"><a href="#存储、读取数据" class="headerlink" title="存储、读取数据"></a>存储、读取数据</h3><ul>
<li>Store是一个保存：状态、业务逻辑 的实体，每个组件都可以读取、写入它</li>
<li>它有三个概念：<code>state</code> <code>getter</code> <code>action</code> ，相当于组件中的 <code>data</code> <code>computed</code> <code>methods</code></li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入defineStore用于创建store</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&quot;pinia&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并暴露一个store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCountStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;count&#x27;</span>,&#123;</span><br><span class="line">    <span class="comment">// 动作</span></span><br><span class="line">    <span class="attr">actions</span>: &#123;&#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 状态</span></span><br><span class="line">    <span class="title function_">state</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">           <span class="comment">// 数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算</span></span><br><span class="line">    <span class="attr">getters</span>:&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>按照规范，要在src目录下创建一个store目录，store可以理解为pinia世界的老大</p>
<p>这里注意一下书写规范，和hooks很像，命名为use+组件名+Store</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527175925942.png" alt="image-20240527175925942"></p>
<p>在组件中引用，说一下关于ref的一个注意点</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527175800749.png" alt="image-20240527175800749"></p>
<p>store在插件中显示，但是有一点，只要使用了的才会显示，没使用过的不会显示，成功了还有小菠萝</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527200157778.png" alt="image-20240527200157778"></p>
<h3 id="修改数据的三种方式"><a href="#修改数据的三种方式" class="headerlink" title="修改数据的三种方式"></a>修改数据的三种方式</h3><p>pinia官网的话——Pinia符合直觉的 Vue.js 状态管理库</p>
<p>其实在写存储的时候，我已经按照我的直觉更改了，这是一种简单的方式，可以看到后端改的插件已经认可了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527201144046.png" alt="image-20240527201144046"></p>
<p>感觉方式和hooks类似啊</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527203540093.png" alt="image-20240527203540093"></p>
<h3 id="storeToRefs"><a href="#storeToRefs" class="headerlink" title="storeToRefs"></a>storeToRefs</h3><p>张的就像toRefs，解构使用的，toRefs解构store数据会把所以的方法、数据等等，所有的东西都变成ref响应式数据，很不合理。这个时候就需要storeToRefs了</p>
<p>值得注意的是storeToRefs这个API 是pinia提供的，因此引入需要</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; storeToRefs &#125; from &quot;pinia&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527210507661.png" alt="image-20240527210507661"></p>
<h3 id="getters的使用"><a href="#getters的使用" class="headerlink" title="getters的使用"></a>getters的使用</h3><p><img src="/../%E5%9B%BE%E7%89%87/image-20240527211537238.png" alt="image-20240527211537238"></p>
<h3 id="subscribe的使用"><a href="#subscribe的使用" class="headerlink" title="$subscribe的使用"></a>$subscribe的使用</h3><p><code>subscribe</code> 订阅  他的作用很像watch监视</p>
<p>这里写一个很重要的功能</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527213856073.png" alt="image-20240527213856073"></p>
<p>这里传的字符串严格来说叫密钥，可以在本地储存空间找到</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527214017213.png" alt="image-20240527214017213"></p>
<p>看一下ts中</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527215225761.png" alt="image-20240527215225761"></p>
<h3 id="store组合式写法"><a href="#store组合式写法" class="headerlink" title="store组合式写法"></a>store组合式写法</h3><p>有点类似hooks的形式，自己体会一下。</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527220044203.png" alt="image-20240527220044203"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return &#123;talkList,getlove&#125;</span><br></pre></td></tr></table></figure>





<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><p>组件之间互相传递数据</p>
<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>和路由的props类似</p>
<p>概述：props是使用频率最高的一种通信方式，常用于 父&lt;—&gt;子</p>
<ul>
<li>若父传子：属性值是非函数</li>
<li>若子传父：属性值是函数</li>
</ul>
<p>尽量不要在嵌套使用props。例如父要传孙，不要父传子、子传孙的</p>
<p>上面的说法多少有点抽象，看一下下面代码，父传子是定义的car，显然这不是一个函数，就可以把数据传到子组件。而子传父需要父组件内定义一个方法，将函数传给子，通过子组件的调用函数将数据传给父组件</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240528211804113.png" alt="image-20240528211804113"></p>
<p>昂，还有一个小的点 h4 标签上有一个 v-show 把toy的值给他，没来的时候是空字符串，会被当作false算，来了是toy就相当于true了，一个小把戏</p>
<h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><p>简单介绍一下 <code>$event</code> </p>
<p>懒得弄了，直接敲代码在这吧</p>
<p>&#x3D;&#x3D;自定义事件专门用来子传父&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;&lt;/h3&gt;</span><br><span class="line">        &lt;button @click=&quot;test&quot;&gt;点我&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function test(a) &#123;</span><br><span class="line">        console.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">    //如果是这样不传递任何参数，但是接受了一个参数，就会出现一个事件对象event。</span><br><span class="line">    //如果说呢，我传递了参数a,b，c这个时候就接收不到事件对象了，需要手动在传参的位置添加 $event ，然后再把这个 $event 传递给某一个参数。</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//说一个骚一点的赋值操作</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;&#123;&#123; str &#125;&#125;&lt;/h3&gt;</span><br><span class="line">        &lt;button @click=&quot;str = 哈哈&quot;&gt;点我&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line">    </span><br><span class="line">    let str = ref(&#x27;你好&#x27;)</span><br><span class="line">    // 这个时候也是实现了点击按钮进行更改赋值的操作</span><br><span class="line">    </span><br><span class="line">    //如果呢，贱一点，把str变为 $event 还是可以成功的，但是前面数据很变得很奇怪，试一下就知道了</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>





<p><img src="/../%E5%9B%BE%E7%89%87/image-20240528220430557.png" alt="image-20240528220430557"></p>
<p>这里说一下自定义事件的命名规范，HTML文件对大小写是不敏感的，因此驼峰式命名法 SendToy 将会变成 sendtoy 再到后端使用的时候会出问题，因此，自定义事件的命名推荐使用 kebab-case 羊肉串式命名法 send-toy</p>
<h3 id="mitt"><a href="#mitt" class="headerlink" title="mitt"></a>mitt</h3><p>mitt可以实现&#x3D;&#x3D;任意组件通讯&#x3D;&#x3D;，大小只有200b</p>
<p>首先安装mitt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i mitt</span><br></pre></td></tr></table></figure>

<p>一般按照规范会有tools或者utils目录</p>
<p>简单写一个emitter</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240528222059030.png" alt="image-20240528222059030"></p>
<p>在main中引入一下，一行就行</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240528222305087.png" alt="image-20240528222305087"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240528223422399.png" alt="image-20240528223422399"></p>
<p>感受一下任意组件通讯</p>
<p>父组件没啥用，截图也放不下了，代码贴这吧</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;father&quot;&gt;</span><br><span class="line">    &lt;h3&gt;父组件&lt;/h3&gt;</span><br><span class="line">    &lt;Child1/&gt;</span><br><span class="line">    &lt;Child2/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Father&quot;&gt;</span><br><span class="line">  import Child1 from &#x27;./Child1.vue&#x27;</span><br><span class="line">  import Child2 from &#x27;./Child2.vue&#x27;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240528225437649.png" alt="image-20240528225437649"></p>
<h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><p>不冷不热的知识：开发有一个UI组件库，在UI组件库中大量使用了v-model进行组件通信</p>
<p>v-model&#x3D;&#x3D;既能父传子，也能子传父&#x3D;&#x3D;</p>
<p>写一个简单的双向绑定，这是HTML标签上的v-model</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//使用v-model来实现绑定</span><br><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;username&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line">    let username = ref(0)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">//以上呢是一个简单的v-model的双向绑定，但是不够清楚明白，写一下他的逻辑</span><br><span class="line"></span><br><span class="line">&lt;input type=&quot;text&quot; :value=&quot;username&quot; @input=&quot;username = $event.target.value&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line">    let username = ref(0)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">//这两种方式是等价的</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529140752820.png" alt="image-20240529140752820"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@input=&quot;username = (&lt;HTMLInputElement&gt;$event.target).value&quot;</span><br><span class="line">//断言方法</span><br></pre></td></tr></table></figure>



<p>v-model用于组件标签上</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529142419824.png" alt="image-20240529142419824"></p>
<p>注释的第一个是语法糖，第二个是原理，但是组件内的代码还是都要写的</p>
<p>注意这里的事件直接就username &#x3D; $event 了，原因是，之前的HTML标签中 $event 是标准的DOM元素，需要.target 但是这个是在组件内的自定义事件，$event 只是数据，因此不需要.target</p>
<p>对于原生事件，$event 就是事件对象 ，所以能.target</p>
<p>对于自定义事件，$event 就是触发事件时，所传递的数据，不能.target</p>
<p>也可以更改value，既然value可以更改那么就意味着组件标签&#x3D;&#x3D;可以使用多个v-model&#x3D;&#x3D;</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529144454933.png" alt="image-20240529144454933"></p>
<p>这个飘红是以为使用了props传参，可以是软件不认可这种写法，懒得再给他接受定义一下了</p>
<h3 id="attrs"><a href="#attrs" class="headerlink" title="$attrs"></a>$attrs</h3><p>概述：$attrs 用于实现当前父组件，向当前子组件的通讯（祖——孙）</p>
<p>一个小的点：</p>
<p>父给子传数据，子是需要接受的对吧，父子之间一般为props通信，因此呢，如果接受了插件中可以看到一个props，如果没接受的话，数据会存放在attrs中</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529145801542.png" alt="image-20240529145801542"></p>
<p>如果说呢，父给子传递数据了，但是没有接收，还想使用应该怎么办呢，这个时候就要用到$attrs了，如果说在前端直接写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;&#123;&#123; $attrs &#125;&#125;&lt;/h2&gt;</span><br><span class="line">//这样就可以直接打印出来所有未接受的数据的key-value键值对</span><br></pre></td></tr></table></figure>



<p>简单说一下v-bind 单向绑定，v-bind内也可以写对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Child :a=&quot;a&quot; :b=&quot;b&quot; v-bind=&quot;&#123;x:100,y:200&#125;&quot;/&gt;</span><br><span class="line"></span><br><span class="line">//这里的v-bind内的对象相当于</span><br><span class="line">&lt;Child :a=&quot;a&quot; :b=&quot;b&quot; :x=&quot;100&quot; :y=&quot;200&quot;/&gt;</span><br></pre></td></tr></table></figure>



<p>祖传孙，传数据，孙传祖传方法，老套路了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529155221912.png" alt="image-20240529155221912"></p>
<h3 id="refs-与-parent"><a href="#refs-与-parent" class="headerlink" title="$refs 与 $parent"></a>$refs 与 $parent</h3><p>概述：</p>
<ul>
<li>$refs 用于父——子</li>
<li>$parent 用于子——父</li>
</ul>
<p>$refs</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529163122158.png" alt="image-20240529163122158"></p>
<p>$parent</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529163403963.png" alt="image-20240529163403963"></p>
<p>源代码父组件内有一个多行注释，说明的是ref数据生么时候.value的问题，这个问题之前有说过，不在赘述</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    let obj = reactive(&#123;</span><br><span class="line">		a:1,</span><br><span class="line">		b:2,</span><br><span class="line">		c:ref(3)</span><br><span class="line">	&#125;)</span><br><span class="line">	let x = ref(4)</span><br><span class="line"></span><br><span class="line">	console.log(obj.a)</span><br><span class="line">	console.log(obj.b)</span><br><span class="line">	console.log(obj.c)</span><br><span class="line">	console.log(x.value)</span><br><span class="line">	</span><br><span class="line">// reactive响应式数据会自动解包，但是ref不会，所以需要.value，reactive内的ref数据已经被解包，不需要再进行.value解包。</span><br><span class="line">// 注意点：当访问obj.c的时候，底层会自动读取value属性，因为c是在obj这个响应式对象中的</span><br></pre></td></tr></table></figure>





<h3 id="provide-与-inject"><a href="#provide-与-inject" class="headerlink" title="provide 与 inject"></a>provide 与 inject</h3><p>概述：实现祖孙之间的数据传输，虽然attrs也可以做到祖孙之间的数据传输，但是会打扰到父组件，尽管代码很少</p>
<p>provide和inject实现的隔代通信不会打扰到中间的组件</p>
<p>中间还有一个子组件，正常引用即可，用不着子组件</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529165404011.png" alt="image-20240529165404011"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529170315154.png" alt="image-20240529170315154"></p>
<h3 id="pinia"><a href="#pinia" class="headerlink" title="pinia"></a>pinia</h3><p>之前说过，不再赘述</p>
<h3 id="slot插槽"><a href="#slot插槽" class="headerlink" title="slot插槽"></a>slot插槽</h3><h4 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h4><p><img src="/../%E5%9B%BE%E7%89%87/image-20240529175423402.png" alt="image-20240529175423402"></p>
<h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><p>默认插槽是说了萝卜和坑的概念，但是如果我需要写多个标签的时候，那么就需要用到具名插槽了</p>
<p>默认插槽是没有name配置项的，所以无论什么标签到都可以放到默认插槽内，但是具名插槽不行</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529180331882.png" alt="image-20240529180331882"></p>
<p>这里v-slot还有一个小的语法糖，就是直接写 <code>#名称</code> ，如上图</p>
<p>其实默认插槽也是有名字的叫做 <code>default</code> ，一般不会写</p>
<h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><p>作用域插槽的写法很多，所以感觉很乱，习惯就好</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529191723787.png" alt="image-20240529191723787"></p>
<p>总结梳理一下：</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529192635795.png" alt="image-20240529192635795"></p>
<h2 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h2><p>API很多，说几个实用的</p>
<h3 id="shallowRef-和-shallowReactive"><a href="#shallowRef-和-shallowReactive" class="headerlink" title="shallowRef 和 shallowReactive"></a>shallowRef 和 shallowReactive</h3><p>shallowRef 即浅层次的ref 深层次就不是响应式了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529194707481.png" alt="image-20240529194707481"></p>
<p>shallowReactive 基本同理</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529195827949.png" alt="image-20240529195827949"></p>
<h3 id="readonly-与-shallowReadonly"><a href="#readonly-与-shallowReadonly" class="headerlink" title="readonly 与 shallowReadonly"></a>readonly 与 shallowReadonly</h3><p>readonly 创建一个只读副本。</p>
<p>特点：</p>
<ul>
<li>对象的所以属性都为只读</li>
<li>任何尝试更改的操作都会报错</li>
</ul>
<p>应用场景：</p>
<ul>
<li>创建不可变的状态快照</li>
<li>保护全局状态或配置不可更改</li>
</ul>
<p>shallowReadonly 只作用域顶层属性</p>
<p>特点：</p>
<ul>
<li>只将对象的顶层属性设置为可读，对象内部的嵌套属性仍然是可变的</li>
<li>适用于只需保护对象顶层属性的场景</li>
</ul>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529202813553.png" alt="image-20240529202813553"></p>
<p>使用谷歌插件也可以通过图标看到是否可以修改</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529202427375.png" alt="image-20240529202427375"></p>
<h3 id="toRaw-与-markRaw"><a href="#toRaw-与-markRaw" class="headerlink" title="toRaw 与 markRaw"></a>toRaw 与 markRaw</h3><p>toRaw</p>
<p> 获取一个响应式对象的原始对象，toRaw返回的对象不再是响应式的，不会触发视图更新</p>
<p>官网描述：这是一个可以用于临时读取而不引起代理访问&#x2F;跟踪开销，或是写入而不触发更新的特殊方法，&#x3D;&#x3D;不建议保存对原始对象的持久引用，请谨慎使用&#x3D;&#x3D;。</p>
<p>何时使用？——在需要将响应式对象传递给非 Vue 库或外部系统时，使用 toRaw 可以确保它们收到的是普通对象</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529205852348.png" alt="image-20240529205852348"></p>
<p>toRaw 去除响应式</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529204605021.png" alt="image-20240529204605021"></p>
<p>markRaw</p>
<p>标记一个对象，使其永远不会变成响应式对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; markRaw,car &#125; from &#x27;vue&#x27;</span><br><span class="line">let car = markRaw(&#123;brand:&#x27;奔驰&#x27;,price:100&#125;)</span><br><span class="line">let car2 = reactive(car)</span><br><span class="line">// 如果car没有使用markRaw包裹，car2会把car数据拿走成为响应式数据，但是标记car为不可响应后，car2也会失去响应式。</span><br></pre></td></tr></table></figure>



<p>例如呢使用一些第三方库时，为了避免把一些第三方库的数据变成响应式对象，可以使用markRaw标记一下</p>
<h3 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a>customRef</h3><h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h4><p>作用：创建一个自定义的ref，并对其依赖项跟踪和更新触发进行逻辑控制。</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529212806137.png" alt="image-20240529212806137"></p>
<p>如果说呢，我实现新输入一个内容后1s之后再在页面中显示，显然这个需要自定义ref</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529213236876.png" alt="image-20240529213236876"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529214226758.png" alt="image-20240529214226758"></p>
<p>一般这种代码会写为自定义hooks，小写一下</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; customRef &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不将数据写死，找前端要两个参数，一个是初始值，另一个个是事件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params">initValue:<span class="built_in">string</span>,delay:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> timer : <span class="built_in">any</span></span><br><span class="line">	<span class="comment">// track含义是追踪 trigger含义是触发</span></span><br><span class="line">	<span class="keyword">let</span> msg = <span class="title function_">customRef</span>(<span class="function">(<span class="params">track, trigger</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="comment">// get何时调用：msg被读取时调用</span></span><br><span class="line">			<span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">				<span class="title function_">track</span>()</span><br><span class="line">				<span class="keyword">return</span> initValue</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="comment">// set何时调用：msg被修改时调用</span></span><br><span class="line">			<span class="title function_">set</span>(<span class="params">value</span>) &#123;</span><br><span class="line">				<span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">				timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">					initValue = value</span><br><span class="line">					<span class="title function_">trigger</span>()</span><br><span class="line">				&#125;, delay);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> &#123;msg&#125;</span><br><span class="line">    <span class="comment">//返回方法msg</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>定义好hooks调用十分清爽</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529215059500.png" alt="image-20240529215059500"></p>
<p>这个API的难点就在于理解 <code>track</code> 和 <code>trigger</code> 两个底层为自定义ref准备好的方法</p>
<h2 id="Vue3-新组件"><a href="#Vue3-新组件" class="headerlink" title="Vue3 新组件"></a>Vue3 新组件</h2><h3 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h3><p>翻译：传送，游戏中TP就是他的缩写</p>
<p>Teleport是一种能够将我们的组件HTML结构移动到指定位置的技术</p>
<p>举个例子吧：</p>
<p>这里有个问题，我想在页面上写一个弹窗，但是呢这个弹窗想要按照屏幕大小定位在中间，通过css调整位置</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529222020479.png" alt="image-20240529222020479"></p>
<p>这里是通过position：fixed;  将弹窗对于浏览器窗口进行定位，而不是相对于其父组件，但是呢，这个时候有一个有意思的问题，如果我在父组件内使用了 <code>filter</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filter: saturate(100%);</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529222230109.png" alt="image-20240529222230109"></p>
<p>这个时候呢，弹窗就又会变为根据父组件大小来定位</p>
<p>这样的可以影响fixed的css还有其他的可以查一下，但是呢这个问题可以使用teleport来解决</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529222946838.png" alt="image-20240529222946838"></p>
<p>这就是teleport的作用——将HTML标签传送到指定位置</p>
<p>只是将结构传送出去，逻辑没影响</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529222714543.png" alt="image-20240529222714543"></p>
<p>即，我将饱和度设置为0，弹窗的颜色依旧是鲜艳的，因为弹窗的父组件已经改变了</p>
<p>teleport不止在这里使用，只是举个例子，可以大胆发挥想象搞事情</p>
<h3 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h3><p>概述：等待异步组件时渲染一些额外的内容，让应用有更好的体验。</p>
<p> <a href="https://api.uomg.com/api/rand.qinghua?format=json">https://api.uomg.com/api/rand.qinghua?format=json</a></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240530142221122.png" alt="image-20240530142221122"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240530143555487.png" alt="image-20240530143555487"></p>
<p>等数据请求完成后，再渲染子组件，替换掉h2标签</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240530143727780.png" alt="image-20240530143727780"></p>
<h3 id="全局API转移到对象"><a href="#全局API转移到对象" class="headerlink" title="全局API转移到对象"></a>全局API转移到对象</h3><ul>
<li>app.component</li>
<li>app.config</li>
<li>app.directive</li>
<li>app.mount</li>
<li>app.unmount</li>
<li>app.use</li>
</ul>
<p>之前在Vue2 中可以vue.xxx 的内容已经变为了 app.xxx</p>
<h4 id="app-component-全局组件"><a href="#app-component-全局组件" class="headerlink" title="app.component 全局组件"></a>app.component 全局组件</h4><p>在main.js文件中注册，在任意页面都可以使用</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240530144644628.png" alt="image-20240530144644628"></p>
<h4 id="app-config-全局变量"><a href="#app-config-全局变量" class="headerlink" title="app.config  全局变量"></a>app.config  全局变量</h4><p><img src="/../%E5%9B%BE%E7%89%87/image-20240530145954859.png" alt="image-20240530145954859"></p>
<p>在main.js内输入注释内的内容会使页面无法正常加载，但是没有这个的话，前端 x 处会飘红</p>
<p>这个全局变量不推荐大量使用</p>
<h4 id="app-directive-全局指令"><a href="#app-directive-全局指令" class="headerlink" title="app.directive  全局指令"></a>app.directive  全局指令</h4><p>注册全局指令</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240530152446862.png" alt="image-20240530152446862"></p>
<h4 id="app-mount"><a href="#app-mount" class="headerlink" title="app.mount"></a>app.mount</h4><p>mount不用说，很重要，挂载整个应用的</p>
<h4 id="app-unmount"><a href="#app-unmount" class="headerlink" title="app.unmount"></a>app.unmount</h4><p>unmount卸载mount</p>
<h4 id="app-use"><a href="#app-use" class="headerlink" title="app.use"></a>app.use</h4><p>这个之前就使用过，作用是安装插件</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240530152740768.png" alt="image-20240530152740768"></p>
<h2 id="Vue3的非兼容性改变"><a href="#Vue3的非兼容性改变" class="headerlink" title="Vue3的非兼容性改变"></a>Vue3的非兼容性改变</h2><p>这个是Vue3和Vue2改变的地方，可以直接上官网看非兼容性改变</p>
<ul>
<li>过渡类名 v-enter 修改为 v-enter-from 、过度类名 v-leave 更改为 v-leave-from</li>
<li>keyCode 作为 v-on 的修饰符支持</li>
<li>v-model 指令在组件上的使用已经被重新设计，替换掉了 v-bind.sync</li>
<li>v-if 和 v-for 在同一级元素身上使用的优先级发生了变化</li>
<li>移除了 $on、$off 和 $once 的实例方法</li>
<li>移除了过滤器 filter</li>
<li>移除了 $children 实例 propert</li>
<li>……</li>
</ul>
<p>Vue2中v-for的优先级比v-if的优先级高，不能同时用在一个标签上，但是在Vue3中把v-if的优先级调整的比v-for的优先级高</p>
<p>完结撒花，中间也有不少关于微信小程序的思考，这里记录一下</p>
<p>土味情话网址：<a href="https://api.uomg.com/api/rand.qinghua?format=json">https://api.uomg.com/api/rand.qinghua?format=json</a></p>
<p>随机狗子网址：<a href="https://dog.ceo/api/breed/pembroke/images/random">https://dog.ceo/api/breed/pembroke/images/random</a></p>
]]></content>
  </entry>
  <entry>
    <title>指针</title>
    <url>/2024/09/19/%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>这是利用指针来修改值的一个简单演示</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240915175142084.png" alt="image-20240915175142084"></p>
<h5 id="指针的概念："><a href="#指针的概念：" class="headerlink" title="指针的概念："></a>指针的概念：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两种理解方式</span><br><span class="line">	1、指针就是地址，地址就是指针；</span><br><span class="line">	2、指针变量，其实是C/C++的一种变量。这种变量比价特殊，通常会被赋值为某变量的地址 (p = &amp;a)，然后利用 *p 的方式来间接访问 p 所指向的地址</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240915181314618.png" alt="image-20240915181314618"></p>
<h5 id="指针的定义和初始化"><a href="#指针的定义和初始化" class="headerlink" title="指针的定义和初始化"></a>指针的定义和初始化</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">既然指针是一种变量，那么肯定也可以定义，也可以初始化</span><br><span class="line">	1、先定义再赋值</span><br><span class="line">		int * p;		// 定义指针变量p</span><br><span class="line">		p = &amp;a;			// 给p赋值</span><br><span class="line">		</span><br><span class="line">	2、定义的同时初始化</span><br><span class="line">		int * p = &amp;a;</span><br><span class="line">		</span><br><span class="line">	// 两种的效果是一样的</span><br></pre></td></tr></table></figure>



<h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有两个重要的运算符 &amp; 和 * </span><br><span class="line">	1、&amp;：取地址值符，将他加在某个变量的前面，组合后的符号代表这个变量的地址值</span><br><span class="line">		int a = 100; int * p; p = &amp;a;</span><br><span class="line">		表示将a的地址值赋值给p</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">			</span><br><span class="line">	2、*：指针符号。指针符号再指针定义和指针操作的时候，解析方法是不同的</span><br><span class="line">		int p;			// p是一个整型变量</span><br><span class="line">		int * p;		// p是一个指针变量，该指针指向一个整形数</span><br><span class="line">		使用该指针的时候，*p则代表变量p所指向的那个变量，这个过程有些也叫做解引用</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		符号解释：</span><br><span class="line">        	a	代表变量a本身</span><br><span class="line">			p	代表指针变量p本身</span><br><span class="line">			&amp;a	代表变量a的地址值</span><br><span class="line">			*p	代表指针变量p所指向的那个变量，也就是变量a</span><br><span class="line">			&amp;p	代表指针变量p本身的地址值。符号合法，但无意义。在二级指针中使用</span><br><span class="line">			*a	把a看作一个指针，*a表示这个指针所指向的变量。该符号不合法</span><br><span class="line">				也就是说：</span><br><span class="line">				int a = （一个地址值）</span><br><span class="line">				cout &lt;&lt; *a &lt;&lt; endl</span><br><span class="line">				这样的表述是不合法的，即使是存储的地址值也应该将a的类型转成int *来进行操作</span><br><span class="line">					int * a = (int*)0000DE298342</span><br></pre></td></tr></table></figure>



<h5 id="指针变量的解读"><a href="#指针变量的解读" class="headerlink" title="指针变量的解读"></a>指针变量的解读</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指针变量本质上是一个变量</span><br><span class="line">指针变量的类型属于指针类型</span><br><span class="line">int * p：定义了一个指针类型的变量p，p能指向的变量是int</span><br><span class="line">其他类型的指针：</span><br><span class="line">	int * pInt;</span><br><span class="line">	char * pChar;</span><br><span class="line">	float * pFloat;</span><br><span class="line">	double * pDouble;</span><br><span class="line">	各种指针类型和所指向的变量类型必须匹配，否则结果不可预知</span><br><span class="line">	</span><br><span class="line">		如果非要用的话，还可以进行指针间的强转   reinterpret_cast</span><br><span class="line">		char c = &#x27;a&#x27;;</span><br><span class="line">		int * p;</span><br><span class="line">		p = reinterpret_cast&lt;int *&gt;(&amp;c)</span><br><span class="line">		</span><br><span class="line">		// 这样强转也会出现问题的，因为char占一个字节，int占四个字节，因此结果不可预知</span><br></pre></td></tr></table></figure>





<h5 id="空指针和野指针"><a href="#空指针和野指针" class="headerlink" title="空指针和野指针"></a>空指针和野指针</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">空指针：指针指向的地址是0</span><br><span class="line">野指针：指针变量未经赋值，或者指向非法地址</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240915214624603.png" alt="image-20240915214624603"></p>
<p>C语言这里是没有默认初始化的，所以这里是野指针错误，有的语言会进行初始化</p>
<p>全局变量是会初始化的 </p>
<h5 id="指针大小"><a href="#指针大小" class="headerlink" title="指针大小"></a>指针大小</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两种情况</span><br><span class="line">	32位，64位</span><br><span class="line">	4字节，8字节</span><br><span class="line">	</span><br><span class="line">现在电脑程序一般是64位，手机是32位</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240915220004310.png" alt="image-20240915220004310"></p>
<h5 id="指针使用count"><a href="#指针使用count" class="headerlink" title="指针使用count"></a>指针使用count</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为了防止误改，使用count来修饰指针</span><br><span class="line"></span><br><span class="line"> const int* p1 = &amp;a;		// 常量指针</span><br><span class="line"> int* const p2 = &amp;a;		// 指针常量</span><br><span class="line"> const int* const p3 = &amp;a;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int a = 10;</span><br><span class="line">int b = 20;</span><br><span class="line"></span><br><span class="line">const int* p1 = &amp;a;		// 常量指针</span><br><span class="line">int* const p2 = &amp;a;		// 指针常量</span><br><span class="line">const int* const p3 = &amp;a;</span><br><span class="line"></span><br><span class="line">// 常量指针不能修改所指对象的值，但可以修改指针本身的值</span><br><span class="line">//*p1 = 30;		// 错误，常量指针不能修改所指对象的值</span><br><span class="line">p1 = &amp;b;		// 正确，指针常量只能修改指针本身的值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">// 指针常量只能修改指针本身的值，不能修改所指对象的值</span><br><span class="line">// p2 = &amp;b;		// 错误，指针常量只能修改指针本身的值</span><br><span class="line">*p2 = 30;		// 正确，指针常量只能修改指针本身的值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">// 指针常量不能修改所指对象的值，也不能修改指针本身的值</span><br><span class="line">// p3 = &amp;b;		// 错误，指针常量不能修改所指对象的值</span><br><span class="line">//*p3 = 30;		// 错误，指针常量不能修改指针本身的值</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240915221201598.png" alt="image-20240915221201598"></p>
<h5 id="指针应用"><a href="#指针应用" class="headerlink" title="指针应用"></a>指针应用</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指针应用：</span><br><span class="line">	实现函数参数引用传递</span><br><span class="line">	实现函数返回多个值</span><br><span class="line">	方便处理字符串</span><br><span class="line">	表示复杂的数据结构(结构体等)，在作为参数传递的时候更节省内存</span><br></pre></td></tr></table></figure>



<p>返回多个值是一种表述：返回值只有一个，但是可以通过利用向方法中传递指针，在函数体内修改指针指向的内容来实现多个参数改变</p>
<p>为什么说传递复杂数据结构的时候可以节省内存呢，因为是传递的地址值，不需要将这个复杂的数据结构赋值给另一个地址值来进行操作</p>
<h5 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h5><p>先看一下数组</p>
<p>int数组和char数组</p>
<p>看注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char arr_str[] = &#123;&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;\0&#x27;&#125;</span><br><span class="line">这样定义一个char数组可以正常输出</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240915225132566.png" alt="image-20240915225132566"></p>
<p>字符串数组</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240915225839433.png" alt="image-20240915225839433"></p>
<p>字符串数组在C中表示是char数组的数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char arr_str[][] = &#123;&quot;hello&quot;, &quot;world&quot;, &quot;c++&quot;, &quot;run&quot;&#125;</span><br><span class="line">// 这个时候第二个括号内需要填写数值，这个数值不能小于最长的那个字符串长度</span><br><span class="line">// 使用const char* 可以定义一个字符串，在字符串的基础上再创建一个数组就是字符串数组了，这个时候就没上上面的限制了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 上面说的是C语言中的字符串数组定义方法，C++中有string，可以直接定义</span><br></pre></td></tr></table></figure>





<p><strong>再来看指针</strong></p>
<p>int数组指针</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240915231036804.png" alt="image-20240915231036804"></p>
<p>char数组指针</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240915231654545.png" alt="image-20240915231654545"></p>
<p>字符串数组</p>
<p>int * 指向int 类型</p>
<p>int**指向int*类型这个很好理解的吧</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240915232309434.png" alt="image-20240915232309434"></p>
<h5 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h5><p>指针运算就是上面使用的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; *p++;</span><br><span class="line">cout &lt;&lt; *(++p);</span><br><span class="line">cout &lt;&lt; *(P+1);</span><br><span class="line"></span><br><span class="line">// 这些都是指针运算</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916005620645.png" alt="image-20240916005620645"></p>
<p>它的这几个运算方式是不同的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*p++ 和 *++p 这两种方法是针对p本身进行操作，p自己+1</span><br><span class="line"></span><br><span class="line">而，*(P+1)是先运算再取值，并且不对p本身的大小进行操作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">而*p++ 和 *++p 也是有差别的，看下面的输出，*p++是先输出*p然后再进行++操作，而*++p是先进行++操作再取值</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916010053987.png" alt="image-20240916010053987"></p>
<h4 id="函数参数的引用传递"><a href="#函数参数的引用传递" class="headerlink" title="函数参数的引用传递"></a>函数参数的引用传递</h4><h5 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h5><p>之前说过函数值的传递在Java中基本数据类型是做不到的</p>
<p>但是也有其他方法，比如放到数组，或者在一个类当中，数组已经演示过了，下面是在类中更改，两者的底层原理是一样代表，都是传入地址值，直接操作地址值内的数</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916012435232.png" alt="image-20240916012435232"></p>
<p>C++</p>
<p>将地址传入方法相当于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int * a = &amp;a;</span><br><span class="line">int * b = &amp;b </span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916014530238.png" alt="image-20240916014530238"></p>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>已经演示过了</p>
<p>Java</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240915174303124.png" alt="image-20240915174303124"></p>
<p>C++：</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240915223751211.png" alt="image-20240915223751211"></p>
<p>数组传递的是地址值可以直接操作，原因是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void add(int a[]);</span><br><span class="line">到解析的时候会转化为，一个int指针</span><br><span class="line">void add(int * a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一般为了能够正常输出这个数组，还会传递一个length数组长度进去</span><br><span class="line">add(arr, sizeof(arr) / sizeof(int))</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常见写法：</span><br><span class="line">	1、返回值为void，参数当作返回值，这时候需要用指针把参数变为引用传递</span><br><span class="line">	2、加密函数中，传1个context，传1个明文指针，1个明文长度，1个结果指针</span><br></pre></td></tr></table></figure>



<h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义函数指针：	</span><br><span class="line">	void (*name)(指向的函数参数类型);</span><br><span class="line">	</span><br><span class="line">// 还可以进行初始化</span><br><span class="line">	void (*pFunc)(int *,int *) = nullptr || NULL   -》 两个都可以</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">函数指针赋值：</span><br><span class="line">	pFunc = add;      或者</span><br><span class="line">	pFunc = &amp;add;</span><br><span class="line">	</span><br><span class="line">	// 因为函数和数组一样，函数名就是函数地址</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916022520615.png" alt="image-20240916022520615"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数指针的调用</span><br><span class="line">	(*pFunc)(&amp;a, b);</span><br><span class="line">	pFunc(&amp;a, b);    // 这种调用方法仅限于函数指针，其他指针不可以使用</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916023133902.png" alt="image-20240916023133902"></p>
<h5 id="函数指针数组"><a href="#函数指针数组" class="headerlink" title="函数指针数组"></a>函数指针数组</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void (*pFunc[2])(int *, int *);</span><br><span class="line">// 这个表示这个函数指针可以放三个函数</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916023746682.png" alt="image-20240916023746682"></p>
<h5 id="函数指针作为参数"><a href="#函数指针作为参数" class="headerlink" title="函数指针作为参数"></a>函数指针作为参数</h5><p>函数指针可以作为一个参数传到另一个函数内，函数指针还可以放到结构体内，结构体只能放基本数据类型，不能定义函数和方法，但是可以存放函数指针</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将函数指针放到了函数内，在函数内执行了另一个函数</span><br><span class="line"></span><br><span class="line">定义函数指针，指定函数，使用函数指针调用函数</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916024717314.png" alt="image-20240916024717314"></p>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全局变量：	</span><br><span class="line">	本文件中的全局变量定义</span><br><span class="line">	引用别的文件中定义的全局变量</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916150401967.png" alt="image-20240916150401967"></p>
<p>extern</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、extern int a; 		表示引用别的文件中的全局变量a</span><br><span class="line">2、extern &quot;C&quot; ……;		表示后续代码使用C语言进行编译，不识别标识符</span><br></pre></td></tr></table></figure>





<h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static：</span><br><span class="line">	1、静态局部变量	</span><br><span class="line">		生命周期延长，与全局变量的生命周期一致，程序结束时销毁</span><br><span class="line">		</span><br><span class="line">	2、静态全局变量	</span><br><span class="line">		限制在本文件中使用</span><br><span class="line">		</span><br><span class="line">	3、静态函数	     </span><br><span class="line">		限制在本文件中使用</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916151430742.png" alt="image-20240916151430742"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916152049596.png" alt="image-20240916152049596"></p>
<h4 id="内存四区"><a href="#内存四区" class="headerlink" title="内存四区"></a>内存四区</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码区：存放CPU执行的机器指令，该区域数据共享、只读</span><br><span class="line">全局区：存放全局变量、全局常量、静态常量、字符串常量，程序结束后由系统操作释放</span><br><span class="line">栈区：自动分配和释放，存放函数的参数、局部变量等</span><br><span class="line">堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收</span><br><span class="line">		C中进入堆区使用关键字malloc，Java、C++进入堆区使用关键字new</span><br><span class="line"></span><br><span class="line">不同区域存放的数据，赋予不同的生命周期，赋予不同的权限</span><br></pre></td></tr></table></figure>





<h4 id="模拟加密后的数据转Hex编码"><a href="#模拟加密后的数据转Hex编码" class="headerlink" title="模拟加密后的数据转Hex编码"></a>模拟加密后的数据转Hex编码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void swap() &#123;</span><br><span class="line">    char result[3];</span><br><span class="line">    char * res = result;</span><br><span class="line">    char realResult[33] = &#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 16; i++)&#123;</span><br><span class="line">        int index = i;</span><br><span class="line">        sprintf_s(res, sizeof(result), &quot;%.2X&quot;, index);</span><br><span class="line">        strcat_s(realResult, sizeof(realResult), res);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; realResult &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916155409022.png" alt="image-20240916155409022"></p>
<p>利用sprint_s格式化去两位十六进制数，然后利用strcat_s将得到的res拼接起来到realResult中</p>
<h4 id="char-和char数组"><a href="#char-和char数组" class="headerlink" title="char * 和char数组"></a>char * 和char数组</h4><p>这两个都能表示一个字符串，但是是有差别的。</p>
<p>char * p 是字符串常量，是放到全局区域的，这里还有提示，如果让他指向一个字符串的话，需要加上const</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const char * p</span><br><span class="line"></span><br><span class="line">这种形式的指针只能修改指向的内容的值，不能修改内容，可以</span><br><span class="line">p = &quot;asda&quot;; 但是不能 *p[0] = &#x27;a&#x27;</span><br><span class="line"></span><br><span class="line">而char数组的值就可以随意修改了</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916160435964.png" alt="image-20240916160435964"></p>
<h4 id="内存操作"><a href="#内存操作" class="headerlink" title="内存操作"></a>内存操作</h4><p>还是写加密后数据转Hex编码这个案例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void swap1() &#123;</span><br><span class="line">    char temp[3];</span><br><span class="line">    char * reaResult = nullptr;</span><br><span class="line">    // 使用malloc申请内存</span><br><span class="line">    reaResult = (char*) malloc(33);</span><br><span class="line">    // 申请到的内存是没有清理的，可能有乱码，需要自己清理</span><br><span class="line">    memset(reaResult, 0, 33);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 16; i++)&#123;</span><br><span class="line">        int index = i;</span><br><span class="line">        sprintf_s(temp, sizeof(temp), &quot;%.2X&quot;, index);</span><br><span class="line">        strcat_s(reaResult, 33, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; reaResult &lt;&lt; endl;</span><br><span class="line">    // 手动释放内存</span><br><span class="line">    free(reaResult);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 还有一个申请内存的操作 calloc calloc会自动把申请过来的内存清理</span><br><span class="line"></span><br><span class="line">char * realResult = (char *)calloc(33,1)</span><br><span class="line"></span><br><span class="line">// 这里free释放，释放的是内存空间，如果reaResult没有指向申请来的内存空间，释放也就没有意义，所以要将free指向指向内存空间的指针，</span><br><span class="line">// 任何一个指向这块内存空间的指针都可以释放这块空间</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916162413664.png" alt="image-20240916162413664"></p>
<h5 id="指针的注意事项"><a href="#指针的注意事项" class="headerlink" title="指针的注意事项"></a>指针的注意事项</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不要把函数内部的局部变量地址，交给函数外的指针变量</span><br><span class="line"></span><br><span class="line">// 函数执行完毕局部变量会被销毁，那么指针也就成为了野指针</span><br><span class="line">// 如果需要局部变量，可以传入参数指针，把参数当作返回值使用</span><br></pre></td></tr></table></figure>



<h4 id="多级指针"><a href="#多级指针" class="headerlink" title="多级指针"></a>多级指针</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概念：指向指针的指针</span><br><span class="line">例：</span><br><span class="line">	int a = 100;</span><br><span class="line">	int * p = &amp;a;</span><br><span class="line">	int ** pp = &amp;p;</span><br><span class="line">	int *** ppp = &amp;pp;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916201207128.png" alt="image-20240916201207128"></p>
<h4 id="多级指针的应用"><a href="#多级指针的应用" class="headerlink" title="多级指针的应用"></a>多级指针的应用</h4><p><img src="/../%E5%9B%BE%E7%89%87/image-20240916202414425.png" alt="image-20240916202414425"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从上图可以看到int *指针可以正常使用，但是char *的时候就遇到了问题，为什么呢</span><br><span class="line"></span><br><span class="line">全局区：</span><br><span class="line">	0x123456789 &quot;kong&quot;</span><br><span class="line">	0x123987654 &quot;hello world&quot;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">main栈：</span><br><span class="line">	char * res = 0x123456789</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">swap4栈：</span><br><span class="line">	char * a = 0x123987654</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">可以看到本质上main栈内res所指向的地址值并没没有改变，这个时候就需要用到二级指针了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这里的原理刚开始我有点想不通：</span><br><span class="line">	char *可以看作和int等效，因为char *用来指向字符串常量的地址，如果再用一个char *来接收这个数值，那么就是进行了一个赋值，并没有用到指针，所以需要使用char **来接收地址值，就可以实现类似与int *的效果了</span><br></pre></td></tr></table></figure>



<p>用二级指针来操作char *数组</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916210523761.png" alt="image-20240916210523761"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全局区：</span><br><span class="line">	0x123456789 &quot;kong&quot;</span><br><span class="line">	0x123987654 &quot;hello world&quot;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">main栈：</span><br><span class="line">	0x123456789 char * res = 0x123456789</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">swap4栈：</span><br><span class="line">	char ** a = 0x123456789</span><br><span class="line">	*a = &quot;hello world&quot; 0x123987654</span><br><span class="line">	</span><br><span class="line">	-&gt; swap4栈中  char ** a = 0x123987654 -&gt; main栈中  char * res = 0x123987654   -&gt;  &quot;hello world&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1、想把参数当返回值，传入的实参是char *等指针的时候</p>
<p>2、传入的实参是一级指针，那么想把参数当作返回值，形参就得是二级指针</p>
<p>3、结论：形参要比实参多一级指针，才能把参数当返回值使用</p>
</blockquote>
<h5 id="模拟加密字符串的返回"><a href="#模拟加密字符串的返回" class="headerlink" title="模拟加密字符串的返回"></a>模拟加密字符串的返回</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void swap5(const char ** result) &#123;</span><br><span class="line">    char temp[3];</span><br><span class="line">    char * reaResult = nullptr;</span><br><span class="line">    // 使用malloc申请内存</span><br><span class="line">    // 申请到的内存是没有清理的，可能有乱码，需要自己清理</span><br><span class="line">    reaResult = (char*) malloc(33);</span><br><span class="line">    memset(reaResult, 0, 33);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 16; i++)&#123;</span><br><span class="line">        int index = i;</span><br><span class="line">        sprintf_s(temp, sizeof(temp), &quot;%.2X&quot;, index);</span><br><span class="line">        strcat_s(reaResult, 33, temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *result = reaResult;</span><br><span class="line">    //cout &lt;&lt; reaResult &lt;&lt; endl;</span><br><span class="line">    // 手动释放内存，这个时候就不能释放内存了，因为释放之后，出了这个函数，就拿不到数据了，处理了个寂寞</span><br><span class="line">    //free(reaResult);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	const char * result = &quot;kong&quot;;</span><br><span class="line">	swap5(&amp;result);</span><br><span class="line">	cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	// 拿到地址之后再释放内存</span><br><span class="line">	free((void*)result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916213347260.png" alt="image-20240916213347260"></p>
<h4 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">okl * pp = &amp;ok;</span><br><span class="line">(*pp).pFunc(a);</span><br><span class="line">pp-&gt;pFunc(a);</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916215656068.png" alt="image-20240916215656068"></p>
<blockquote>
<p>结构体指针还有一种调用方式，就是箭头调用，可以去掉一层*</p>
</blockquote>
<h4 id="结构体传参"><a href="#结构体传参" class="headerlink" title="结构体传参"></a>结构体传参</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">值传递： 如果一个结构体数组，很占内存</span><br><span class="line">引用传递： 指针4或者8个</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916220146185.png" alt="image-20240916220146185"></p>
]]></content>
  </entry>
</search>
