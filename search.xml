<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Vue实践</title>
    <url>/2024/07/13/Vue%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>小敲一下</p>
<p>想写一个与之前微信小程序中相似的实时时间更新</p>
<span id="more"></span>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个方法获取时间</span></span><br><span class="line">    <span class="attr">updateDateTime</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="keyword">var</span> year = date.<span class="title function_">getFullYear</span>();</span><br><span class="line">        <span class="keyword">var</span> month = date.<span class="title function_">getMonth</span>() + <span class="number">1</span>; <span class="comment">// 月份从0开始，所以需要加1</span></span><br><span class="line">        <span class="comment">// 这个月份从0开始，转化到我们这边需要加一</span></span><br><span class="line">        <span class="keyword">var</span> day = date.<span class="title function_">getDate</span>();</span><br><span class="line">        <span class="keyword">var</span> hours = date.<span class="title function_">getHours</span>();</span><br><span class="line">        <span class="keyword">var</span> minutes = date.<span class="title function_">getMinutes</span>();</span><br><span class="line">        <span class="keyword">var</span> seconds = date.<span class="title function_">getSeconds</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这里是将时间变为自己想要的样子，如果都行无所谓的话也可以直接</span></span><br><span class="line">        <span class="keyword">var</span> newdate = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toLocaleString</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 格式化日期和时间</span></span><br><span class="line">        <span class="keyword">var</span> formattedDateTime = <span class="string">`<span class="subst">$&#123;year&#125;</span>-<span class="subst">$&#123;month.toString().padStart(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)&#125;</span>-<span class="subst">$&#123;day.toString().padStart(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)&#125;</span> <span class="subst">$&#123;hours.toString().padStart(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)&#125;</span>:<span class="subst">$&#123;minutes.toString().padStart(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)&#125;</span>:<span class="subst">$&#123;seconds.toString().padStart(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)&#125;</span>`</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">            <span class="attr">currentDateTime</span>: formattedDateTime</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">        </span><br><span class="line">    <span class="title function_">onLoad</span>(<span class="params">options</span>) &#123;</span><br><span class="line">         <span class="comment">// 页面加载时开始更新时间</span></span><br><span class="line">         <span class="variable language_">this</span>.<span class="title function_">updateDateTime</span>();</span><br><span class="line">         <span class="comment">// 设置定时器，每秒更新一次时间</span></span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">timer</span> = <span class="built_in">setInterval</span>(<span class="variable language_">this</span>.<span class="property">updateDateTime</span>, <span class="number">1000</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">onUnload</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">timer</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">//Vue3中的写法与之类似，但是有个问题，因为Vue3 我使用的是Vue3语法糖就有一些问题</span></span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    //我的想法捏</span><br><span class="line">    import &#123; ref,onMounted &#125; from &#x27;vue&#x27;</span><br><span class="line">    </span><br><span class="line">    let date = ref(new Date().toLocaleString())</span><br><span class="line">    </span><br><span class="line">    function updateTime() &#123;</span><br><span class="line">        date = ref(new Date().toLocaleString())</span><br><span class="line">    &#125;</span><br><span class="line">    onMounted() &#123;</span><br><span class="line">        updateTime()</span><br><span class="line">        setInterval(updateTime, 1000);</span><br><span class="line">    &#125;</span><br><span class="line">    // 但是，不刷新数据是不会自动更新的，也就是说setInterval(updateTime, 1000);并没有起作用</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>其实，这里有两个问题，第一个onMounted这个钩子的用法不对，这里写的用法是类似于微信小程序中钩子的写法在Vue3中应该为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">onMounted(()=&gt;&#123;</span><br><span class="line">     updateTime()</span><br><span class="line">     setInterval(updateTime, 1000);    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>第二个问题，这里的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240530202913984.png" alt="image-20240530202913984"></p>
<p>需要改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date.value = new Date().toLocaleString()</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">    //我的想法捏</span><br><span class="line">    import &#123; ref,onMounted,onUnmounted &#125; from &#x27;vue&#x27;</span><br><span class="line">    </span><br><span class="line">    let date = ref(new Date().toLocaleString())</span><br><span class="line">    let timer:any</span><br><span class="line">    </span><br><span class="line">    function updateTime() &#123;</span><br><span class="line">        date.value = new Date().toLocaleString()</span><br><span class="line">    &#125;</span><br><span class="line">    onMounted() &#123;</span><br><span class="line">        updateTime()</span><br><span class="line">        timer = setInterval(updateTime, 1000);</span><br><span class="line">    &#125;</span><br><span class="line">    onUnmounted(()=&gt;&#123;</span><br><span class="line">		clearInterval(timer)</span><br><span class="line">	&#125;)</span><br><span class="line">    // 卸载计时器，因为即使是组件卸载掉了，计时器仍然会继续date依然更新，浪费性能没必要</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>但是通过对比发现两者的写法差别是不大的</p>
<h2 id="组件模仿页面切换"><a href="#组件模仿页面切换" class="headerlink" title="组件模仿页面切换"></a>组件模仿页面切换</h2><p>但是微信小程序和Vue3 我感觉主要的区别在于，Vue3所有的活动都是在App.vue这个根上的，而微信小程序可以创建很多新的页面，这个时候我准备给Vue3写一个类似于小程序的东西</p>
<p>先搞一个路由</p>
<p>因为只有一个根组件，那么我可以只用路由来达到目的，App.vue中先写一个占位，更换路由占位更换，这就相当于页面更换，这样的话，我感觉就实现了微信小程序页面更换的问题</p>
<p>看一下App.vue</p>
<p>App.vue相当简洁，写了 一个路由占位符，准备渲染组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;app&quot;&gt;</span><br><span class="line">	</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>



<p>写一下路由组件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="comment">// 引入组件和路由器，设置一个history传参</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Index</span> <span class="keyword">from</span> <span class="string">&quot;./index.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Demo</span> <span class="keyword">from</span> <span class="string">&quot;./demo.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Demolist</span> <span class="keyword">from</span> <span class="string">&quot;./demolist.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Get</span> <span class="keyword">from</span> <span class="string">&quot;./get.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Text</span> <span class="keyword">from</span> <span class="string">&quot;./text.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Mess</span> <span class="keyword">from</span> <span class="string">&quot;./mess.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">	<span class="attr">history</span>: <span class="title function_">createWebHistory</span>(),</span><br><span class="line">	<span class="attr">routes</span>: [&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 封装路由，将/设置为index组件，默认展示index组件，然后在index路由下封装四个组件准备展示在index组件</span></span><br><span class="line">		<span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">		<span class="attr">component</span>: <span class="title class_">Index</span>,</span><br><span class="line">		<span class="attr">children</span>: [</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">name</span>: <span class="string">&#x27;demo&#x27;</span>,</span><br><span class="line">				<span class="attr">path</span>: <span class="string">&#x27;demo&#x27;</span>,</span><br><span class="line">				<span class="attr">component</span>: <span class="title class_">Demo</span></span><br><span class="line">			&#125;, &#123;</span><br><span class="line">				<span class="attr">name</span>: <span class="string">&#x27;demolist&#x27;</span>,</span><br><span class="line">				<span class="attr">path</span>: <span class="string">&#x27;demolist&#x27;</span>,</span><br><span class="line">				<span class="attr">component</span>: <span class="title class_">Demolist</span></span><br><span class="line">			&#125;, &#123;</span><br><span class="line">				<span class="attr">name</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">				<span class="attr">path</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">				<span class="attr">component</span>: <span class="title class_">Get</span></span><br><span class="line">			&#125;, &#123;</span><br><span class="line">				<span class="attr">name</span>:<span class="string">&#x27;mess&#x27;</span>,</span><br><span class="line">				<span class="attr">path</span>: <span class="string">&#x27;mess&#x27;</span>,</span><br><span class="line">				<span class="attr">component</span>: <span class="title class_">Mess</span></span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;,&#123;</span><br><span class="line">        <span class="comment">// 再写一个text组件，脱离index，我打算以点击事件的方式将这个组件渲染到App.vue 来实现类似微信小程序的页面跳转</span></span><br><span class="line">		<span class="attr">path</span>: <span class="string">&#x27;/text&#x27;</span>,</span><br><span class="line">		<span class="attr">component</span>: <span class="title class_">Text</span></span><br><span class="line">	&#125;,&#123;</span><br><span class="line">		<span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">		<span class="attr">redirect</span>:<span class="string">&#x27;/home&#x27;</span></span><br><span class="line">	&#125;]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>

<p>这样呢是形成了两个页面的效果，一个是&#x2F;home首页，另一个是&#x2F;text 因为index.vue内是写了一些样式，是一个路由，所以只能算一个页面，而这个text组件，确实是独立的一个页面效果，他是再index组件卸载后，渲染上去的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// text.vue</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;h2&gt;text&lt;/h2&gt;</span><br><span class="line">	&lt;button @click=&quot;showHome()&quot;&gt;点我&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">	import &#123; useRouter &#125; from &#x27;vue-router&#x27;;</span><br><span class="line">	</span><br><span class="line">	let router = useRouter()</span><br><span class="line">	</span><br><span class="line">	function showHome() &#123;</span><br><span class="line">		router.push(&#123;</span><br><span class="line">			path:&#x27;/&#x27;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240530222305593.png" alt="image-20240530222305593"></p>
<p>这样这个效果基本实现，但是是这个跳转方法是不太好复现的，因为无论是history还是hash跳转都是卸载掉当前组件，然后再挂载新的组件的，毕竟一直在那里的只有app.vue，但是还是有点相像的毕竟history可以有浏览器提供的返回键来返回，就相当于wx.navigateTo这种跳转，hash不能由浏览器提供的返回键返回，是属于覆盖性的，就相当于wx.redirectTo跳转了</p>
<h2 id="引入Vant组件库"><a href="#引入Vant组件库" class="headerlink" title="引入Vant组件库"></a>引入Vant组件库</h2><p>之前在微信小程序中使用的 vant4 组件库也支持Vue版本，这边搞一下</p>
<p>先在Vue3项目中下载Vant</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i vant</span><br></pre></td></tr></table></figure>

<p>官方文档：<a href="https://vant-ui.github.io/vant/#/zh-CN/quickstart">https://vant-ui.github.io/vant/#/zh-CN/quickstart</a></p>
<h3 id="全局引用"><a href="#全局引用" class="headerlink" title="全局引用"></a>全局引用</h3><p>因为 我的Vue3是使用vite 来构建的，因此，会有一个vite.comfig.js文件</p>
<p>更改这个文件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 看变量名也可以猜出来，自动引入组件API</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AutoImport</span> <span class="keyword">from</span> <span class="string">&#x27;unplugin-auto-import/vite&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个会在使用组件后，自动解析并注册组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Components</span> <span class="keyword">from</span> <span class="string">&#x27;unplugin-vue-components/vite&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个从vant中拿到相应的样式</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">VantResolver</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@vant/auto-import-resolver&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="title function_">vue</span>(),</span><br><span class="line">        <span class="title class_">AutoImport</span>(&#123;</span><br><span class="line">            <span class="attr">resolvers</span>: [<span class="title class_">VantResolver</span>()],</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="title class_">Components</span>(&#123;</span><br><span class="line">            <span class="attr">resolvers</span>: [<span class="title class_">VantResolver</span>()],</span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>如果报错的话，依次下载三个引入的地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i unplugin-auto-import -D</span><br><span class="line">npm i unplugin-vue-components -D</span><br><span class="line">npm i @vant/auto-import-resolver -D</span><br></pre></td></tr></table></figure>



<p>这个时候就可以直接在页面中使用vant组件了，不再需要任何的引用</p>
<p>  <img src="/../%E5%9B%BE%E7%89%87/image-20240531115246422.png" alt="image-20240531115246422"></p>
<h3 id="按需引用"><a href="#按需引用" class="headerlink" title="按需引用"></a>按需引用</h3><p>按需引用比较麻烦，需要再 main.js 的入口文件中引入</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个代码的意思是将Button这个组件中拿出来，如果我还需要 cell,calendae 等等，这里就会写很长</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Button</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vant&#x27;</span></span><br><span class="line"><span class="comment">// 引入组件样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;vant/lib/index.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里要使用app.use使用组件，感觉这种方式有点麻烦，不如全局引入，一劳永逸</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title class_">Button</span>)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>剩下的就用就完了，没啥好说的。</p>
<h2 id="引入three-js"><a href="#引入three-js" class="headerlink" title="引入three.js"></a>引入three.js</h2><p>官方文档：<a href="https://threejs.org/docs/index.html#manual/en/introduction/Creating-a-scene">https://threejs.org/docs/index.html#manual/en/introduction/Creating-a-scene</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i three</span><br></pre></td></tr></table></figure>



<p>安装版本号</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240531135049372.png" alt="image-20240531135049372"></p>
<p>这个时候新建一个组件开始敲</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div ref=&quot;threeContainer&quot; class=&quot;three-container&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;ThreeComponent&quot;&gt;</span><br><span class="line">	import * as THREE from &#x27;three&#x27;</span><br><span class="line">	import &#123; ref,onMounted &#125; from &#x27;vue&#x27;;</span><br><span class="line">	</span><br><span class="line">	const threeContainer = ref(null)</span><br><span class="line">	</span><br><span class="line">	onMounted (()=&gt;&#123;</span><br><span class="line">		// 初始化Three，获取容器信息</span><br><span class="line">		const container = threeContainer.value</span><br><span class="line">        </span><br><span class="line">		</span><br><span class="line">		// 创建场景，创建一个新的 Three.js 场景</span><br><span class="line">		const scene = new THREE.Scene();</span><br><span class="line">        </span><br><span class="line">		</span><br><span class="line">		// 创建相机，创建一个透明相机，并设置其位置</span><br><span class="line">	 	const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1 ,1000 );</span><br><span class="line">        // 这个postion.z 是设置相机高度</span><br><span class="line">		camera.position.z = 5</span><br><span class="line">        </span><br><span class="line">		</span><br><span class="line">		// 创建渲染器，将其大小设置为容器的宽度和高度，然后将渲染器的 DOM 元素添加到容器中</span><br><span class="line">		const renderer = new THREE.WebGLRenderer();</span><br><span class="line">		renderer.setSize( window.innerWidth, window.innerHeight );</span><br><span class="line">		container.appendChild( renderer.domElement )</span><br><span class="line">        </span><br><span class="line">		</span><br><span class="line">		// 创建一个立方体，并将其组合成一个网格对象，然后将该网络对象添加到场景中</span><br><span class="line">		const geometry = new THREE.BoxGeometry();</span><br><span class="line">		const material = new THREE.MeshBasicMaterial(&#123; color:0x00ff00 &#125;)</span><br><span class="line">        // 设置立方体颜色，color</span><br><span class="line">		const cube = new THREE.Mesh(geometry,material)</span><br><span class="line">		scene.add(cube)</span><br><span class="line">        // 将这个cude添加到 Three.js 中</span><br><span class="line">        </span><br><span class="line">		</span><br><span class="line">		// 渲染循环，创建一个动画循环，在每一帧中，旋转立方体，渲染场景</span><br><span class="line">		const animate = () =&gt; &#123;</span><br><span class="line">			requestAnimationFrame(animate);</span><br><span class="line">			</span><br><span class="line">			cube.rotation.x += 0.01</span><br><span class="line">			cube.rotation.y += 0.01</span><br><span class="line">			// x,y 分别为x,y方向旋转的速度</span><br><span class="line">			renderer.render(scene,camera)</span><br><span class="line">		&#125;</span><br><span class="line">		animate()</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .three-container &#123;</span><br><span class="line">		width: 100%;</span><br><span class="line">		height: 100%;</span><br><span class="line">		overflow: hidden;</span><br><span class="line">	&#125;</span><br><span class="line">    // 设置div样式，使其覆盖整个视口并隐藏溢出内容</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240531143824887.png" alt="image-20240531143824887"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save-dev @types/three</span><br></pre></td></tr></table></figure>



<p>这样就写出来了一个自动旋转的绿色正方体</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240531150142785.png" alt="image-20240531150142785"></p>
<p>注意这里是有循环的，要使用卸载钩子将组件不引用时卸载掉three场景，释放资源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 引入监听页面卸载的钩子，小改一下代码，懒得写注释了</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;ThreeComponent&quot;&gt;</span><br><span class="line">	import * as THREE from &#x27;three&#x27;</span><br><span class="line">	import &#123; ref,onMounted,onUnmounted &#125; from &#x27;vue&#x27;;</span><br><span class="line">	</span><br><span class="line">	const threeContainer = ref&lt;HTMLDivElement | null&gt;(null)</span><br><span class="line">	const cube = new THREE.Mesh</span><br><span class="line">	const renderer = new THREE.WebGLRenderer();</span><br><span class="line">	let animationId:number</span><br><span class="line">	</span><br><span class="line">	onMounted (()=&gt;&#123;</span><br><span class="line">		if (!threeContainer.value) return;</span><br><span class="line">		</span><br><span class="line">		// 初始化Three</span><br><span class="line">		const container = threeContainer.value</span><br><span class="line">		</span><br><span class="line">		// 创建场景</span><br><span class="line">		const scene = new THREE.Scene();</span><br><span class="line">		</span><br><span class="line">		// 创建相机</span><br><span class="line">	 	const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1 ,1000 );</span><br><span class="line">		camera.position.z = 3</span><br><span class="line">		</span><br><span class="line">		// 创建渲染器</span><br><span class="line">		renderer.setSize( window.innerWidth, window.innerHeight );</span><br><span class="line">		container.appendChild( renderer.domElement )</span><br><span class="line">		</span><br><span class="line">		// 创建一个立方体</span><br><span class="line">		const geometry = new THREE.BoxGeometry();</span><br><span class="line">		const material = new THREE.MeshBasicMaterial(&#123; color:0x00ff00 &#125;)</span><br><span class="line">		const cube = new THREE.Mesh(geometry,material)</span><br><span class="line">		scene.add(cube)</span><br><span class="line">		</span><br><span class="line">		// 渲染循环</span><br><span class="line">		const animate = () =&gt; &#123;</span><br><span class="line">			animationId = requestAnimationFrame(animate);</span><br><span class="line">			</span><br><span class="line">			cube.rotation.x += 0.01</span><br><span class="line">			cube.rotation.y += 0.01</span><br><span class="line">			console.log(&#x27;1&#x27;)</span><br><span class="line">			renderer.render(scene,camera)</span><br><span class="line">		&#125;</span><br><span class="line">		animate()</span><br><span class="line">	&#125;),</span><br><span class="line">	onUnmounted (()=&gt;&#123;</span><br><span class="line">        // 停止动画循环</span><br><span class="line">		cancelAnimationFrame(animationId)</span><br><span class="line">        </span><br><span class="line">        // 清除几何体材质</span><br><span class="line">		cube.geometry.dispose();</span><br><span class="line">		(cube.material as THREE.Material).dispose()</span><br><span class="line">        </span><br><span class="line">        // 移除渲染器的 DOM 元素</span><br><span class="line">		if (renderer &amp;&amp; renderer.domElement &amp;&amp; renderer.domElement.parentNode) &#123;</span><br><span class="line">			renderer.domElement.parentNode.removeChild(renderer.domElement);</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        // 清理渲染器</span><br><span class="line">		renderer.dispose();</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>这里写了一个打印1的地方，通过编程式导航来进行跳转发现，返回后，1停止打印，说明已经释放资源  </p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240531160347088.png" alt="  "></p>
<h2 id="防止父容器的点击态"><a href="#防止父容器的点击态" class="headerlink" title="防止父容器的点击态"></a>防止父容器的点击态</h2><p>想写一个俄罗斯方块，写到暂停键的时候，遇到了问题，先看一下能不能看出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div class=&quot;box-right&quot;&gt;</span><br><span class="line">		&lt;div style=&quot;margin-top: 80px;&quot;&gt;&#123;&#123;forTime&#125;&#125;&lt;/div&gt;</span><br><span class="line">			&lt;div class=&quot;box-right-icon&quot; @click=&quot;stop&quot;&gt;</span><br><span class="line">				&lt;div @click=&quot;stop&quot; :class=&quot;status?&#x27;icon-content&#x27;:&#x27;icon-stop&#x27;&quot; &gt;&lt;/div&gt;</span><br><span class="line">    	&lt;/div&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">	import &#123; ref,watch,onMounted,onUnmounted &#125; from &#x27;vue&#x27;;</span><br><span class="line">	</span><br><span class="line">	let num = 200</span><br><span class="line">	let hour = ref(0)</span><br><span class="line">	let minute = ref(0)</span><br><span class="line">	let second = ref(0)</span><br><span class="line">	let timer:any</span><br><span class="line">	let forTime = ref(&#x27;&#x27;)</span><br><span class="line">	let status = ref(true)</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	function updatatime() &#123;</span><br><span class="line">		if (status.value=true) &#123;</span><br><span class="line">			if (second.value == 59) &#123;</span><br><span class="line">				second.value = 0</span><br><span class="line">				minute.value += 1</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				second.value += 1</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	function stop() &#123;</span><br><span class="line">		console.log(&#x27;stop triggered&#x27;)</span><br><span class="line">		status.value = !status.value</span><br><span class="line">		if (status.value) &#123;</span><br><span class="line">		    timer = setInterval(updatatime, 1000); // 继续计时</span><br><span class="line">		  &#125; else &#123;</span><br><span class="line">		    clearInterval(timer)</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	onMounted(()=&gt;&#123;</span><br><span class="line">		updatatime()</span><br><span class="line">		timer = setInterval(updatatime,1000)</span><br><span class="line">	&#125;)</span><br><span class="line">	onUnmounted(()=&gt;&#123;</span><br><span class="line">		clearInterval(timer)</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">	const time = watch(second,(value)=&gt;&#123;</span><br><span class="line">		if (minute.value&lt;10 &amp;&amp; second.value&lt;10) &#123;</span><br><span class="line">			forTime.value =	hour.value+&#x27;:0&#x27;+minute.value+&#x27;:0&#x27;+second.value</span><br><span class="line">		&#125; else if(second.value&lt;10) &#123;</span><br><span class="line">			forTime.value =	hour.value+&#x27;:&#x27;+minute.value+&#x27;:0&#x27;+second.value</span><br><span class="line">		&#125; else if(minute.value&lt;10) &#123;</span><br><span class="line">			forTime.value =	hour.value+&#x27;:0&#x27;+minute.value+&#x27;:&#x27;+second.value</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			forTime.value =	hour.value+&#x27;:&#x27;+minute.value+&#x27;:&#x27;+second.value</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>我是通过打印事件，排查出来的，点击样式内的div后，会触发两次点击事件，true变为false又变为false，以此，导致了视觉上的子容器的点击事件不好使的情况</p>
<p>解决方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	function stop(event: Event) &#123;</span><br><span class="line">		event.stopPropagation()</span><br><span class="line">		status.value = !status.value</span><br><span class="line">		if (status.value) &#123;</span><br><span class="line">		    timer = setInterval(updatatime, 1000); // 继续计时</span><br><span class="line">		  &#125; else &#123;</span><br><span class="line">		    clearInterval(timer)</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">// 给他来一个event.stopPropagation()阻止冒泡即可，之前从未遇到过这样需求，长知识了</span><br></pre></td></tr></table></figure>





<h2 id="获取非普通标签的DOM元素"><a href="#获取非普通标签的DOM元素" class="headerlink" title="获取非普通标签的DOM元素"></a>获取非普通标签的DOM元素</h2><p>写俄罗斯方块的时候，我将方块封装为不同的组件</p>
<p>封装组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div class=&quot;lang&quot; ref=&quot;rootElement&quot;&gt;</span><br><span class="line">		&lt;div v-for=&quot;x in 4&quot; class=&quot;lang-bor&quot;&gt;&lt;/div&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">	import &#123; ref &#125; from &#x27;vue&#x27;;</span><br><span class="line">	</span><br><span class="line">	const rootElement =ref&lt;HTMLElement | null&gt;(null)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>想要获取组件的DOM元素，只需要给最外层一个ref即可</p>
<p>然后再调用组件的页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;long-vue ref=&quot;movableDiv&quot;&gt;&lt;/long-vue&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">	import &#123; ref,watch,onMounted,onUnmounted,nextTick &#125; from &#x27;vue&#x27;;</span><br><span class="line">    import longVue from &#x27;../components/long.vue&#x27;;</span><br><span class="line">    </span><br><span class="line">    onMounted(async ()=&gt;&#123;</span><br><span class="line">		await nextTick()</span><br><span class="line">		if (movableDiv.value) &#123;</span><br><span class="line">			const movawidth = movableDiv.value.$el.offsetWidth</span><br><span class="line">			const movaheight = movableDiv.value.$el.offsetHeight</span><br><span class="line">			console.log(movawidth,movaheight)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>比直接获取HTML标签的DOM元素中多了一个 <code>$el</code> 加上就可以直接拿到组件的DOM 元素</p>
<h2 id="导出微信语音"><a href="#导出微信语音" class="headerlink" title="导出微信语音"></a>导出微信语音</h2><p>首先将微信呢语音收藏，然后呢在手机版中，将语音转化为笔记</p>
<p>再在..\FileStorage\Fav\Temp\xxxxx\res中 找到一个拓展名为silk的文件</p>
<p>利用一个小工具silk2mp3，我是不敢在真机中使用，所以扔虚拟机了</p>
<p>直接解码为mp3即可导出微信语音</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>autoplay</td>
<td>autoplay</td>
<td>如果出现该属性，则音频在就绪后马上播放。</td>
</tr>
<tr>
<td>controls</td>
<td>controls</td>
<td>如果出现该属性，则向用户显示音频控件（比如播放&#x2F;暂停按钮）。</td>
</tr>
<tr>
<td>loop</td>
<td>loop</td>
<td>如果出现该属性，则每当音频结束时重新开始播放。</td>
</tr>
<tr>
<td>muted</td>
<td>muted</td>
<td>如果出现该属性，则音频输出为静音。</td>
</tr>
<tr>
<td>preload</td>
<td>auto<br/>metadata<br/>none</td>
<td>规定当网页加载时，音频是否默认被加载以及如何被加载。</td>
</tr>
<tr>
<td>src</td>
<td>URL</td>
<td>规定音频文件的 URL。</td>
</tr>
</tbody></table>
<h3 id="audio属性"><a href="#audio属性" class="headerlink" title="audio属性"></a>audio属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>audioTracks</td>
<td>返回表示可用音频轨道的 AudioTrackList 对象</td>
</tr>
<tr>
<td>autoplay</td>
<td>设置或返回是否在加载完成后随即播放音频</td>
</tr>
<tr>
<td>buffered</td>
<td>返回表示音频已缓冲部分的 TimeRanges 对象</td>
</tr>
<tr>
<td>controller</td>
<td>返回表示音频当前媒体控制器的 MediaController 对象</td>
</tr>
<tr>
<td>controls</td>
<td>设置或返回音频是否显示控件（比如播放&#x2F;暂停等）</td>
</tr>
<tr>
<td>crossOrigin</td>
<td>设置或返回音频的 CORS 设置</td>
</tr>
<tr>
<td>currentSrc</td>
<td>回当前音频的 URL</td>
</tr>
<tr>
<td>currentTime</td>
<td>设置或返回音频中的当前播放位置（以秒计）</td>
</tr>
<tr>
<td>defaultMuted</td>
<td>设置或返回音频默认是否静音</td>
</tr>
<tr>
<td>defaultPlaybackRate</td>
<td>设置或返回音频的默认播放速度</td>
</tr>
<tr>
<td>duration</td>
<td>返回当前音频的长度（以秒计）</td>
</tr>
<tr>
<td>ended</td>
<td>返回音频的播放是否已结束</td>
</tr>
<tr>
<td>error</td>
<td>返回表示音频错误状态的 MediaError 对象</td>
</tr>
<tr>
<td>loop</td>
<td>设置或返回音频是否应在结束时重新播放</td>
</tr>
<tr>
<td>mediaGroup</td>
<td>设置或返回音频所属的组合（用于连接多个音频元素）</td>
</tr>
<tr>
<td>muted</td>
<td>设置或返回音频是否静音</td>
</tr>
<tr>
<td>networkState</td>
<td>返回音频的当前网络状态</td>
</tr>
<tr>
<td>paused</td>
<td>设置或返回音频是否暂停</td>
</tr>
<tr>
<td>playbackRate</td>
<td>设置或返回音频播放的速度</td>
</tr>
<tr>
<td>played</td>
<td>返回表示音频已播放部分的 TimeRanges 对象</td>
</tr>
<tr>
<td>preload</td>
<td>设置或返回音频是否应该在页面加载后进行加载</td>
</tr>
<tr>
<td>readyState</td>
<td>返回音频当前的就绪状态</td>
</tr>
<tr>
<td>seekable</td>
<td>返回表示音频可寻址部分的 TimeRanges 对象</td>
</tr>
<tr>
<td>seeking</td>
<td>返回用户是否正在音频中进行查找</td>
</tr>
<tr>
<td>src</td>
<td>设置或返回音频元素的当前来源</td>
</tr>
<tr>
<td>textTracks</td>
<td>返回表示可用文本轨道的 TextTrackList 对象</td>
</tr>
<tr>
<td>volume</td>
<td>设置或返回音频的音量</td>
</tr>
</tbody></table>
<h3 id="audio方法"><a href="#audio方法" class="headerlink" title="audio方法"></a>audio方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>addTextTrack()</td>
<td>在音频中添加一个新的文本轨道</td>
</tr>
<tr>
<td>canPlayType()</td>
<td>检查浏览器是否可以播放指定的音频类型</td>
</tr>
<tr>
<td>fastSeek()</td>
<td>在音频播放器中指定播放时间。</td>
</tr>
<tr>
<td>getStartDate()</td>
<td>返回一个新的Date对象，表示当前时间轴偏移量</td>
</tr>
<tr>
<td>load()</td>
<td>重新加载音频元素</td>
</tr>
<tr>
<td>play()</td>
<td>开始播放音频</td>
</tr>
<tr>
<td>pause()</td>
<td>暂停当前播放的音频</td>
</tr>
</tbody></table>
<h2 id="封装图片验证码"><a href="#封装图片验证码" class="headerlink" title="封装图片验证码"></a>封装图片验证码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div class=&quot;img-verify&quot;&gt;</span><br><span class="line">		&lt;canvas ref=&quot;verify&quot; :width=&quot;state.width&quot; :height=&quot;state.height&quot; @click=&quot;handleDraw&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">	import &#123; ref,onMounted,reactive &#125; from &#x27;vue&#x27;;</span><br><span class="line">	</span><br><span class="line">	const verify = ref(null)</span><br><span class="line">	const emit = defineEmits([&quot;get-code&quot;])</span><br><span class="line">	const state = reactive(&#123;</span><br><span class="line">		pool:&quot;qwertyuiopasdfghjklzxcvbnm1234567890&quot;,</span><br><span class="line">		width:120,</span><br><span class="line">		height:40,</span><br><span class="line">		imgCode:&#x27;&#x27;,</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">	// 随机数字</span><br><span class="line">	const randomNum = (min,max) =&gt; &#123;</span><br><span class="line">		return parseInt(Math.random() * (max - min) + min)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 随机颜色</span><br><span class="line">	const randomColor = (min,max) =&gt; &#123;</span><br><span class="line">		const r = randomNum(min,max)</span><br><span class="line">		const g = randomNum(min,max)</span><br><span class="line">		const b = randomNum(min,max)</span><br><span class="line">		return `rgb($&#123;r&#125;,$&#123;g&#125;,$&#123;b&#125;)`</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 绘制图片</span><br><span class="line">	const draw = () =&gt; &#123;</span><br><span class="line">		// 填充背景颜色</span><br><span class="line">		const ctx = verify.value.getContext(&quot;2d&quot;)</span><br><span class="line">		// 填充颜色</span><br><span class="line">		ctx.fillStyle = randomColor(180,230)</span><br><span class="line">		// 填充位置</span><br><span class="line">		ctx.fillRect(0,0,state.width,state.width)</span><br><span class="line">		</span><br><span class="line">		// 定义paramText</span><br><span class="line">		let imgCode = &#x27;&#x27;;</span><br><span class="line">		</span><br><span class="line">		// 产生随机数字，并且随即旋转</span><br><span class="line">		for (let i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">			// 产生随机数字</span><br><span class="line">			const text = state.pool[randomNum(0,state.pool.length)]</span><br><span class="line">			imgCode += text</span><br><span class="line">			</span><br><span class="line">			// 随机大小字体</span><br><span class="line">			const fontSize = randomNum(18,40);</span><br><span class="line">			</span><br><span class="line">			// 随机字体角度</span><br><span class="line">			const deg = randomNum(-30,30)</span><br><span class="line">			</span><br><span class="line">			ctx.font = fontSize + &#x27;px Simhei&#x27;;</span><br><span class="line">			ctx.textBaseline = &quot;top&quot;;</span><br><span class="line">			ctx.fillStyle = randomColor(80,150)</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			ctx.save()</span><br><span class="line">			ctx.translate(30 * i + 15,15);</span><br><span class="line">			ctx.rotate((deg * Math.PI) / 180)</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			ctx.fillText(text, -15 + 5, -15)</span><br><span class="line">			ctx.restore()</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		// 随机5条干扰线</span><br><span class="line">		for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">			ctx.beginPath();</span><br><span class="line">			ctx.moveTo(randomNum(0,state.width),randomNum(0,state.height))</span><br><span class="line">			ctx.lineTo(randomNum(0,state.width),randomNum(0,state.height))</span><br><span class="line">			ctx.strokeStyle = randomColor(180,230);</span><br><span class="line">			ctx.closePath()</span><br><span class="line">			ctx.stroke()</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		// 产生40个干扰点</span><br><span class="line">		for (var i = 0; i &lt; 40; i++) &#123;</span><br><span class="line">			ctx.beginPath();</span><br><span class="line">			ctx.acr(</span><br><span class="line">				randomNum(0,state.width),</span><br><span class="line">				randomNum(0,state.height),</span><br><span class="line">				1,</span><br><span class="line">				0,</span><br><span class="line">				2 * Math.PI</span><br><span class="line">			);</span><br><span class="line">			ctx.closePath();</span><br><span class="line">			ctx.fillStyle = randomColor(150,200);</span><br><span class="line">			ctx.fill();</span><br><span class="line">		&#125;</span><br><span class="line">		return imgCode</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 点击切换图片</span><br><span class="line">	const handleDraw = () =&gt; &#123;</span><br><span class="line">		state.imgCode = draw();</span><br><span class="line">		emit(&quot;get-code&quot;,state.imgCode)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 初始化</span><br><span class="line">	onMounted(()=&gt;&#123;</span><br><span class="line">		state.imgCode = draw();</span><br><span class="line">		emit(&quot;get-code&quot;,state.imgCode)</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">	.img-verify &#123;</span><br><span class="line">		height: 40px;</span><br><span class="line">		margin: 0 0.1rem;</span><br><span class="line">	&#125;</span><br><span class="line">	.img-verify canvas &#123;</span><br><span class="line">		cursor: pointer;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>VUE框架</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title>form表单验证</title>
    <url>/2024/07/03/form%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<h1 id="form表单验证"><a href="#form表单验证" class="headerlink" title="form表单验证"></a>form表单验证</h1><p>前言：做获奖申报时，我想把一些输入框设置为必填，原生小程序中没有表单验证，如果在后端将输入框内的变量挨个使用 <code>if ……else</code> 似乎过于麻烦，结构太复杂，我想用vant组件的表单验证解决，但是遇到点问题：vant-form组件无法引入</p>
<span id="more"></span>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240401203626963.png" alt="image-20240401203626963"></p>
<p>改变思路，尝试引入vue组件，经过一些操作，成功报错</p>
<p>发生错误SyntaxError: parse js file (D:\微信小程序开发\微信小程序练习\miniprogram-18&#x2F;miniprogram&#x2F;node_modules&#x2F;@vue&#x2F;compiler-sfc&#x2F;dist&#x2F;compiler-sfc.cjs.js) failed: Unexpected token (333:15)</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240401200131194.png" alt="image-20240401200131194"></p>
<p>解决方法：</p>
<p>清除npm缓存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm cache clean --force</span><br></pre></td></tr></table></figure>



<h2 id="柳暗花明又一村"><a href="#柳暗花明又一村" class="headerlink" title="柳暗花明又一村"></a>柳暗花明又一村</h2><p><img src="/../%E5%9B%BE%E7%89%87/image-20240401202139114.png" alt="image-20240401202139114"></p>
<h2 id="uni-app"><a href="#uni-app" class="headerlink" title="uni-app"></a>uni-app</h2><p>然后我选择了uni-app组件</p>
<p>组件官方文档：<a href="https://uniapp.dcloud.io/">https://uniapp.dcloud.io/</a></p>
<p>uni-app 推荐使用 Hbuilderx 开发工具来开发项目</p>
<p>下载地址：<a href="https://www.dcloud.io/hbuilderx.html">https://www.dcloud.io/hbuilderx.html</a></p>
<h3 id="Hbuilder-X"><a href="#Hbuilder-X" class="headerlink" title="Hbuilder X"></a>Hbuilder X</h3><h4 id="使用HbuilderX打开微信开发者工具"><a href="#使用HbuilderX打开微信开发者工具" class="headerlink" title="使用HbuilderX打开微信开发者工具"></a>使用HbuilderX打开微信开发者工具</h4><p>1、安装 sass 插件</p>
<p>点击 <strong>工具 &#x3D;&gt; 插件安装 &#x3D;&gt; 安装新插件 &#x3D;&gt; 前往插件市场安装</strong> ，找到需要的插件之后点击下载 &#x3D;&gt; 使用Hbuilderx 导入插件，这里需要登录 sass 的网站，如果登录成功则会打开 Hbuilderx 编译器，然后点击确定就可以安装了；</p>
<p>2、新建uni-app项目</p>
<p>Hbuilderx 点击 <strong>文件&#x3D;&gt;新增&#x3D;&gt;项目</strong> ，本文新建一个小程序项目：uni-app &#x3D;&gt; 填写项目名称、选择项目存放路径 &#x3D;&gt; 模板 uni-ui 项目&#x3D;&gt;创建，然后就可以生成一个小程序项目；</p>
<p>3、配置 appid</p>
<p>在 <strong>manifest.json 文件 &#x3D;&gt; 微信小程序配置</strong> 填写微信小程序 appID；（在微信开放平台上找）</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240401212830280.png" alt="image-20240401212830280"></p>
<p>4、在 Hbuilderx 配置微信开发者工具的安装路径：这样可以在 Hbuilderx 里面运行的时候自动打开微信开发者工具查看项目</p>
<p><strong>工具 &#x3D;&gt; 设置 &#x3D;&gt; 运行配置 &#x3D;&gt; 小程序运行配置</strong> 配置微信开发者工具的安装路径，如：D:\微信小程序开发\微信web开发者工具</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240401212737689.png" alt="image-20240401212737689"></p>
<p>5、在<strong>微信开发者工具</strong>开启服务端口</p>
<p><strong>设置 &#x3D;&gt; 安全设置 &#x3D;&gt; 安全</strong>  开启服务端口</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240401212706282.png" alt="image-20240401212706282"></p>
<p>6、运行</p>
<p>Hbuilderx 点击 <strong>运行&#x3D;&gt;运行到小程序模拟器</strong> 点击第一个就可以在 Hbuilderx 自动编译，成功之后会<strong>自动打开</strong>微信开发者工具；</p>
<p>注意：这个时候我们想修改项目里面的内容，需要在 Hbuilderx 里面修改，例如修改配置：manifest.json 文件 &#x3D;&gt; 源码视图</p>
<p>成功：</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240401212623601.png" alt="image-20240401212623601"></p>
<h4 id="浅尝Hbuilder-X"><a href="#浅尝Hbuilder-X" class="headerlink" title="浅尝Hbuilder X"></a>浅尝Hbuilder X</h4><h5 id="创建新页面"><a href="#创建新页面" class="headerlink" title="创建新页面"></a>创建新页面</h5><p>打开pages文件夹，右键创建新页面</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240401214421029.png" alt="image-20240401214421029"></p>
<p>创建成功之后，pages.json中出现一下内容</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240401215210866.png" alt="image-20240401215210866"></p>
<h5 id="尝试创建tabbar"><a href="#尝试创建tabbar" class="headerlink" title="尝试创建tabbar"></a>尝试创建tabbar</h5><p>在pages.json中写入，同app.json中写法相同</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240401215544190.png" alt="image-20240401215544190"></p>
<p>通过<code>ctrl</code> + <code>s</code> 快捷键保存自动运行，微信开发者工具上即可显示</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240401215625920.png" alt="image-20240401215625920"></p>
<h5 id="尝试表单"><a href="#尝试表单" class="headerlink" title="尝试表单"></a>尝试表单</h5><p>HbuilderX页面中只有一个index.vue文件，因此要将前后端写在一起</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240402104926882.png" alt="image-20240402104926882"></p>
<p>template前端（wxml）</p>
<p>script后端（js）</p>
<p>style样式（wxss）</p>
<p>后端代码中，小程序中的 <code>data:&#123;&#125;</code> 中的变量相当于这里的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">       变量</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">methods: &#123;</span><br><span class="line">    这里写事件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240402105103849.png" alt="image-20240402105103849"></p>
<p>经过官方文档发现，这里改变赋值不需要</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.setData(&#123;</span><br><span class="line">    inputvalue: e.detail.value</span><br><span class="line">&#125;)</span><br><span class="line">而是以一种简单的方法</span><br><span class="line">this.inputvalue = e.detail.value</span><br></pre></td></tr></table></figure>



<p>再来看前端代码</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240402105612322.png" alt="image-20240402105612322"></p>
<p>这里的<code>@submit</code> 相当于微信小程序中的 <code>bindsubmit</code>  <code>@input</code> 相当于 <code>bindinput</code> 大胆推测在vue中 <code>@</code> 的作用相当于小程序中的 <code>bind</code></p>
<p>这样似乎就写好了一个表单，但是我们的目的是做表单验证，让输入框为必填项</p>
<h3 id="开始表单验证"><a href="#开始表单验证" class="headerlink" title="开始表单验证"></a>开始表单验证</h3><p>这里需要引入 <code>uni-forms</code> 组件进入 <code>Hbuilder X</code> ：</p>
<p>官方文档提供的组件下载地址：<a href="https://ext.dcloud.net.cn/plugin?id=2773">https://ext.dcloud.net.cn/plugin?id=2773</a></p>
<p>在vue文件中<strong>引入组件</strong>，注意文件夹位置为实际文件夹位置，不要复制粘贴</p>
<p>一定要引入组件！！！找了好多文章，完全没有提引入的事情</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    </span><br><span class="line">import uniForms from &#x27;@/uni_modules/uni-forms/components/uni-forms/uni-forms.vue&#x27;;</span><br><span class="line">import uniFormsItem from &#x27;@/uni_modules/uni-forms/components/uni-forms-item/uni-forms-item.vue&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    uniForms,</span><br><span class="line">    uniFormsItem</span><br><span class="line">    // 可以在这里注册其他在本页面使用的组件</span><br><span class="line">  &#125;</span><br><span class="line">  // 其他数据和方法...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>引入之后，我的小程序依旧报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Component is not found in path &quot;uni_modules/uni-forms/components/uni-forms/uni-forms&quot; (using by &quot;pages/index/index&quot;)(env: Windows,mp,1.06.2402021; lib: 3.3.4)</span><br><span class="line">Component is not found in path &quot;uni_modules/uni-forms/components/uni-forms-item/uni-forms-item&quot; (using by &quot;pages/index/index&quot;)(env: Windows,mp,1.06.2402021; lib: 3.3.4)</span><br></pre></td></tr></table></figure>

<p>如果路径没有问题的话，就可以尝试清除缓存，重新启动</p>
<p> <code>&lt;uni-forms&gt; </code>  提供了 rules属性来描述校验规则、 <code>&lt;uni-forms-item&gt;</code> 子组件来包裹具体的表单项，以及给原生或三方组件提供了 <code>onFieldChange()</code> 来校验表单值。</p>
<p>每个要校验的表单项，不管input还是checkbox，都必须放在 <code>&lt;uni-forms-item&gt;</code> 组件中，且一个 <code>&lt;uni-forms-item&gt;</code> 组件只能放置一个表单项。</p>
<p> <code>&lt;uni-forms-item&gt;</code> 组件内部预留了显示error message的区域，默认是在表单项的底部。</p>
<p>另外， <code>&lt;uni-forms&gt;</code> 组件下面的各个表单项，可以通过 <code>&lt;uni-group&gt;</code> 包裹为不同的分组。同一 <code> &lt;uni-group&gt;</code> 下的不同表单项目将聚拢在一起，同其他group保持垂直间距。 <code>&lt;uni-group&gt;</code> 仅影响视觉效果。</p>
<h4 id="来写一个简单的表单吧"><a href="#来写一个简单的表单吧" class="headerlink" title="来写一个简单的表单吧"></a>来写一个简单的表单吧</h4><h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><p><img src="/../%E5%9B%BE%E7%89%87/image-20240402195909896.png" alt="image-20240402195909896"></p>
<h6 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;view class=&quot;content&quot;&gt;</span><br><span class="line">		&lt;uni-forms ref=&quot;form&quot; :model=&quot;formData&quot; :rules=&quot;rules&quot;&gt;</span><br><span class="line">			&lt;uni-forms-item label=&quot;姓名&quot; required=true name=&quot;name&quot;&gt;</span><br><span class="line">				&lt;input type=&quot;text&quot; v-model=&quot;formData.name&quot; @input=&quot;event =&gt; binddata(&#x27;name&#x27;,event.detail.value,&#x27;form&#x27;)&quot;/&gt;</span><br><span class="line">			&lt;/uni-forms-item&gt;</span><br><span class="line">			</span><br><span class="line">			&lt;uni-forms-item label=&quot;年龄&quot; required=true name=&quot;age&quot;&gt;</span><br><span class="line">				&lt;input type=&quot;text&quot; v-model=&quot;formData.age&quot; @input=&quot;event =&gt; binddata(&#x27;age&#x27;,event.detail.value,&#x27;form&#x27;)&quot;/&gt;</span><br><span class="line">			&lt;/uni-forms-item&gt;</span><br><span class="line">			&lt;button @click=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class="line">		&lt;/uni-forms&gt;</span><br><span class="line">	&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>



<p>这里要用到了两个之前引入的组件</p>
<p><code>ref</code> 是这个表单的名字   </p>
<p><code>:model</code> 定义的是该表单储存数据的字典，内的元素以key&#x2F;value这种键值对的形式存在</p>
<p><code>:rules</code> 定义的是验证规则</p>
<p>实现表单验证主要依靠这个组件</p>
<p>之前提到过，uni-forms中要实现表单验证需要搭配uni-forms-item组件使用，一个组件内只能放一个input，因此可以get到这个组件类似于view且将表单中的name元素写在这个位置</p>
<p>一些属性：</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240402200724302.png" alt="image-20240402200724302"></p>
<p>还要注意的是这里的input内几个用法</p>
<ol>
<li><p><code>v-model=&quot;formData.name&quot;</code> </p>
<p>我的理解是这个相当于微信小程序input组件的value元素，这里的 <code>v-model </code> 指向的是之前<code>:model</code> 定义过的字典，对应的是name的value</p>
</li>
<li><p><code>@input=&quot;event =&gt; binddata(&#39;name&#39;,event.detail.value,&#39;form&#39;)&quot;</code> </p>
<p>之前提到过@相当于bind所有这个解释bindinput输入事件，作用是输入时改变字典内相对于的值</p>
<p>‘name’，就是指向字典内的key值；</p>
<p>‘event.detail.value’，是输入的内容；</p>
<p>‘form’，是指表单名称，由之前的ref定义的</p>
</li>
</ol>
<h5 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	import uniForms from &#x27;@/uni_modules/uni-forms/components/uni-forms/uni-forms.vue&#x27;;</span><br><span class="line">	import uniFormsItem from &#x27;@/uni_modules/uni-forms/components/uni-forms-item/uni-forms-item.vue&#x27;;</span><br><span class="line">	</span><br><span class="line">	export default &#123;</span><br><span class="line">		components: &#123;</span><br><span class="line">		  uniForms,</span><br><span class="line">		  uniFormsItem</span><br><span class="line">		  // 可以在这里注册其他在本页面使用的组件</span><br><span class="line">		&#125;,</span><br><span class="line">		data() &#123;</span><br><span class="line">			return &#123;</span><br><span class="line">				formData: &#123;</span><br><span class="line">					name: &#x27;&#x27;,</span><br><span class="line">					age: &#x27;&#x27;</span><br><span class="line">				&#125;,</span><br><span class="line">				rules: &#123;</span><br><span class="line">					name: &#123;</span><br><span class="line">						rules: [&#123;</span><br><span class="line">							required: true,</span><br><span class="line">							errorMessage: &#x27;姓名不能为空&#x27;</span><br><span class="line">						&#125;]</span><br><span class="line">					&#125;,</span><br><span class="line">					age: &#123;</span><br><span class="line">						rules: [&#123;</span><br><span class="line">							required: true,</span><br><span class="line">							errorMessage: &#x27;年龄不能为空&#x27;</span><br><span class="line">						&#125;, &#123;</span><br><span class="line">							format: &#x27;number&#x27;,</span><br><span class="line">							errorMessage: &#x27;年龄只能输入数字&#x27;</span><br><span class="line">						&#125;]</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		onLoad() &#123;</span><br><span class="line"></span><br><span class="line">		&#125;,</span><br><span class="line">		methods: &#123;</span><br><span class="line">			submit() &#123;</span><br><span class="line">						this.$refs.form.validate().then(res=&gt;&#123;</span><br><span class="line">							console.log(&#x27;表单数据信息：&#x27;, res);</span><br><span class="line">						&#125;).catch(err =&gt;&#123;</span><br><span class="line">							console.log(&#x27;表单错误信息：&#x27;, err);</span><br><span class="line">						&#125;)</span><br><span class="line">					&#125;,</span><br><span class="line">			binddata(fieldName, value, form) &#123;</span><br><span class="line">			      // 这里实现 binddata 方法的逻辑</span><br><span class="line">			      // 例如，更新 formData 对象中对应字段的值</span><br><span class="line">			      this.formData[fieldName] = value;</span><br><span class="line">			      console.log(this.formData[fieldName])</span><br><span class="line">			      // 如果有额外的逻辑需要根据表单名处理，也可以在这里添加</span><br><span class="line">			    &#125;,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>后端相比于小程序的变化前面已经说过了，直接看代码，因为之前定义了一个 <code>formData</code> 的变量，因此需要在后端进行补充，这里定义了需要用到的键值对</p>
<p>然后定义表单验证规则，毕竟红点只是前端，只是看，这里的结构为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的rules是前端用 `:rules` 命名的无特殊含义</span></span><br><span class="line"><span class="attr">rules</span>: &#123;</span><br><span class="line">   变量: &#123;</span><br><span class="line">       <span class="attr">rules</span>: [&#123;</span><br><span class="line">           <span class="attr">required</span>: <span class="literal">true</span>, </span><br><span class="line">           <span class="comment">// 确定元素是否为必填项</span></span><br><span class="line"></span><br><span class="line">		   <span class="attr">errorMessage</span>: <span class="string">&#x27;姓名不能为空&#x27;</span></span><br><span class="line">           <span class="comment">// 元素未填时的提示信息</span></span><br><span class="line">       &#125;]</span><br><span class="line">   &#125;,</span><br><span class="line">   变量: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>rules的一些属性</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240403082244110.png" alt="image-20240403082244110"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240403082415300.png" alt="image-20240403082415300"></p>
<h6 id="这里学到了一个知识点，对代码简化很有帮助"><a href="#这里学到了一个知识点，对代码简化很有帮助" class="headerlink" title="这里学到了一个知识点，对代码简化很有帮助"></a>这里学到了一个知识点，对代码简化很有帮助</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">binddata</span>(<span class="params">fieldName, value, form</span>) &#123;</span><br><span class="line">	<span class="comment">// 这里实现 binddata 方法的逻辑</span></span><br><span class="line">	<span class="comment">// 例如，更新 formData 对象中对应字段的值</span></span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">formData</span>[fieldName] = value;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">formData</span>[fieldName])</span><br><span class="line">	<span class="comment">// 如果有额外的逻辑需要根据表单名处理，也可以在这里添加</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>这里的<code>fieldName</code> 是一个动态参数，而且<code>fieldName</code> 并不固定可以由自己随意改变</p>
<p>这个函数为多输入框的单一函数提供了简单方法，去掉了一些机械重复的代码，爽了</p>
<p>注意官网上并没有用到这个方法，是直接通过<code>v-model</code> 绑定的，一些不支持绑定的组件才会使用<code>@input</code>事件</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240403081929654.png" alt="image-20240403081929654"></p>
<h6 id="提交-验证事件"><a href="#提交-验证事件" class="headerlink" title="提交&#x2F;验证事件"></a>提交&#x2F;验证事件</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">submit() &#123;</span><br><span class="line">			this.$refs.form.validate().then(res=&gt;&#123;</span><br><span class="line">				console.log(&#x27;表单数据信息：&#x27;, res);</span><br><span class="line">			&#125;).catch(err =&gt;&#123;</span><br><span class="line">				console.log(&#x27;表单错误信息：&#x27;, err);</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;,</span><br></pre></td></tr></table></figure>

<p>这里的<code>$refs</code>  是一个对象</p>
<p><code>$refs.form</code> 指向的就是命名为<code>form</code> 的表单</p>
<p><code>validate()</code> 是组件内自带的一个方法，作用就是验证表单，比较有了规则，还有有执行规则的</p>
<ul>
<li><code>validate</code>方法返回一个<code>Promise</code>，它在校验成功时会被解析，校验失败时会被拒绝。</li>
</ul>
<p>这样一个简陋的表单验证就完成了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240403081629036.png" alt="image-20240403081629036"></p>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>python、java多环境</title>
    <url>/2024/07/07/python%E3%80%81java%E5%A4%9A%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h3 id="python虚拟环境"><a href="#python虚拟环境" class="headerlink" title="python虚拟环境"></a>python虚拟环境</h3><h4 id="venv"><a href="#venv" class="headerlink" title="venv"></a>venv</h4><p>创建虚拟环境需要用到venv，python3.6以上默认安装的</p>
<span id="more"></span>



<h4 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h4><p>可以在任意文件夹下创建虚拟环境，注意的是，创建出来的虚拟环境是和当前python版本是一样的，主要作用是下载脚本相适配的库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyhton -m venv [要创建环境的名称]</span><br></pre></td></tr></table></figure>

<p>执行成功后生成一个和名称相同的文件夹，文件夹内的Scripts文件夹内是启动虚拟环境的脚本，lin文件夹内是环境依赖</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240707162341789.png" alt="image-20240707162341789"></p>
<h4 id="启动虚拟环境"><a href="#启动虚拟环境" class="headerlink" title="启动虚拟环境"></a>启动虚拟环境</h4><p>通过启动脚本，来启动虚拟环境，脚本不能在Windows PowerShell中启动，需要使用默认的命令行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[虚拟环境的名称]\Scripts\Activate.ps1</span><br></pre></td></tr></table></figure>



<h4 id="启动问题——Windows-PowerShell执行策略"><a href="#启动问题——Windows-PowerShell执行策略" class="headerlink" title="启动问题——Windows PowerShell执行策略"></a>启动问题——Windows PowerShell执行策略</h4><p>我这就是没用过Windows PowerShell的提示，因为Windows PowerShell默认是只能执行本地的脚本，不能执行下载的脚本，是一种安全模式(Restricted)</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240707163923274.png" alt="image-20240707163923274"></p>
<p>在Windows PowerShell中查看当前的执行策略</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-ExecutionPolicy</span><br></pre></td></tr></table></figure>

<p>管理员运行Windows PowerShell更改策略</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-ExecutionPolicy RemoteSigned</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240707164700351.png" alt="image-20240707164700351"></p>
<p>再次执行脚本，出现绿框内容表示成功进入虚拟环境，通过pip list可以发现环境十分干净，没有其他的库</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240707164918878.png" alt="image-20240707164918878"></p>
<h4 id="退出环境"><a href="#退出环境" class="headerlink" title="退出环境"></a>退出环境</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<p>python的虚拟环境不算很复杂，可以根据脚本的要求下载对象版本的库</p>
<h3 id="python多环境管理"><a href="#python多环境管理" class="headerlink" title="python多环境管理"></a>python多环境管理</h3><h4 id="下载安装pyenv"><a href="#下载安装pyenv" class="headerlink" title="下载安装pyenv"></a>下载安装pyenv</h4><p>从gitup上下载pyenv-win <a href="https://github.com/pyenv-win/pyenv-win#readme">https://github.com/pyenv-win/pyenv-win#readme</a> </p>
<p>解压下来，找到pyenv-win的bin目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xxx\pyenv-win-master\pyenv-win-master\pyenv-win</span><br></pre></td></tr></table></figure>



<p>也可以使用pip安装，但是会安装到C盘，我就没有弄</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install pyenv-win</span><br></pre></td></tr></table></figure>



<h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><p>新建一个系统变量 <code>PYENV</code></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240707203445362.png" alt="image-20240707203445362"></p>
<p>新增两行环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%PYENV%\bin</span><br><span class="line">%PYENV%\shims</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240707203537895.png" alt="image-20240707203537895"></p>
<p>配置完成后，命令行输入pyenv验证一下</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240707203657370.png" alt="image-20240707203657370"></p>
<h4 id="切换python版本"><a href="#切换python版本" class="headerlink" title="切换python版本"></a>切换python版本</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyenv global [切换到的版本]</span><br></pre></td></tr></table></figure>



<p>pyenv的方法输入pyenv都可以看到，install下载版本什么的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240707205346137.png" alt="image-20240707205346137"></p>
<h4 id="下载问题"><a href="#下载问题" class="headerlink" title="下载问题"></a>下载问题</h4><p>补档：</p>
<p>当时下载第一个成功下载了，后面再下载一直提示失败</p>
<p>可以尝试更改国内源，添加环境变量，地址有很多，随便选一个就行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://jedore.netlify.app/tools/python-mirrors/</span><br><span class="line">https://jedore.vercel.app/tools/python-mirrors/</span><br><span class="line">https://mirrors.huaweicloud.com/python/</span><br></pre></td></tr></table></figure>

<img src="../图片/image-20240810001647296.png" alt="image-20240810001647296" style="zoom: 67%;" />



<p>如果还是提示失败，可以直接将对应的python版本下载下来，放到这个目录下，install_cache</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\pyenv-win-master\pyenv-win-master\pyenv-win\install_cache</span><br></pre></td></tr></table></figure>

<p>再执行下载命令，这个时候就不会下载了，而是直接进行安装操作</p>
<h4 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h4><p>输入pyenv versions是看不到本地下载的python版本的，只能看到通过pyenv install下载的python版本</p>
<p>我认为呢，问题不大，可以再将本地再重新下载一个，因为库是不变的，更该python版本，系统上的库不会变化，如何有需要，可以再创建虚拟环境</p>
<p>pyenv下载的python版本在pyenv的目录下的versions目录下</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240707211345538.png" alt="image-20240707211345538"></p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>在Linux系统下，需要用到update-alternatives来管理多系统</p>
<p>使用update-alternatives的前提是Linux里已经装好了不同版本的python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update-alternatives --install [链接] [名称] [路径] [优先级]</span><br><span class="line">链接/usr/bin/python</span><br><span class="line">名称一般为python，也可以自定义</span><br><span class="line">路径为python的版本路径</span><br></pre></td></tr></table></figure>



<p>配置好链接后，切换版本时，只需要</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update-alternatives --config python</span><br></pre></td></tr></table></figure>

<p>然后输入要切换的编号即可</p>
<p>Linux中Java的多环境和python一样，也是通过update-alternatives来实现</p>
<p>我也没配置jdk8的环境，直接切换就可以使用</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240707230355226.png" alt="image-20240707230355226"></p>
<p>注意还要配置javac</p>
]]></content>
      <tags>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序对称加密</title>
    <url>/2024/07/13/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<h1 id="crypto-js"><a href="#crypto-js" class="headerlink" title="crypto-js"></a>crypto-js</h1><p>利用crypto-js这个Java包来实现数据的加密解密</p>
<p>引入Java包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install crypto-js</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240519204321372.png" alt="image-20240519204321372"></p>
<p>然后小程序中就有这么一个文件夹</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240519204355653.png" alt="image-20240519204355653"></p>
<p>将文件夹内的crypto-js.js复制到需要用到加密的页面下，如：</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240519204449695.png" alt="image-20240519204449695"></p>
<h2 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h2><p>先引用crypto-js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const CryptoJs = require(&#x27;crypto-js&#x27;);</span><br></pre></td></tr></table></figure>



<p>AES加密存在一个key值和一个iv值</p>
<p>定义密钥和初始化向量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var key = CryptoJS.enc.Utf8.parse(&#x27;0123456789abcdef&#x27;); // 定义密钥</span><br><span class="line">var iv = CryptoJS.enc.Utf8.parse（&#x27;abcdef0123456789&#x27;)；// 定义初始化向量</span><br></pre></td></tr></table></figure>



<p>进行加密</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var encrypted = CryptoJs.AEs.encrypt(&#x27;hello world&#x27;, key, &#123; iv: iv );</span><br><span class="line">var date = encrypted.tostring()</span><br><span class="line">//date就是加密后的数据</span><br></pre></td></tr></table></figure>



<p>数据拿回来的时候同样需要解密</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var decrypted = CryptoJs.AES.decrypt(date, key, &#123; iv: iv &#125;);</span><br><span class="line">console.log(decrypted.toString(CryptoJs.enc.Utf8))； // 输出解密后的数据</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240713213602201.png" alt="image-20240713213602201"></p>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>-微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>wxss实践</title>
    <url>/2024/07/13/wxss%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><p>肝（抄）了一周wxss，有了点心得，分享一下</p>
<h4 id="居中三板斧"><a href="#居中三板斧" class="headerlink" title="居中三板斧"></a>居中三板斧</h4><p>设置容器为弹性盒</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">display:flex;</span><br><span class="line">justify-content: center;</span><br><span class="line">//如果主轴是水平的，那么Flex项目将在容器内水平居中。</span><br><span class="line">align-items: center;</span><br><span class="line">//如果主轴是水平的，那么交叉轴就是垂直的，Flex项目将在容器内垂直居中。</span><br></pre></td></tr></table></figure>





<h4 id="极限微操"><a href="#极限微操" class="headerlink" title="极限微操"></a>极限微操</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">position: absolute;</span><br><span class="line">//position: absolute;设置为绝对位置，可以和其他元素重合（因为z-index不同，不在同一图层），这样就有一个好处就是不会牵一发而动全身，可以肆意调整容器位置</span><br><span class="line"></span><br><span class="line">z-index: 1;</span><br><span class="line">//设置图层，设置背景的时候经常用，z-index越小，图层越靠下</span><br><span class="line"></span><br><span class="line">margin: 0 0 0 0;</span><br><span class="line">//分别为距离上，右，下，左，的边距</span><br><span class="line">//只写两个的话，调整上下，左右的边距</span><br><span class="line">//只写一个，调整上下左右的边距</span><br></pre></td></tr></table></figure>



<p>margin和padding，个人感觉比padding好用，上图</p>
<p>初始状态</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240518110607965.png" alt="image-20240518110607965"></p>
<p>使用padding调整边距</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240518110644254.png" alt="image-20240518110644254"></p>
<p>使用margin调整边距</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240518110704801.png" alt="image-20240518110704801"></p>
<h4 id="模块美化一：圆角-阴影"><a href="#模块美化一：圆角-阴影" class="headerlink" title="模块美化一：圆角+阴影"></a>模块美化一：圆角+阴影</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">border-radius: 30px;</span><br><span class="line">//设置圆角</span><br><span class="line"></span><br><span class="line">box-shadow: 1px 1px 1px rgb(88, 88, 88);</span><br><span class="line">//设置阴影，属性分别为，水平偏移量，垂直偏移量，模糊半径，阴影颜色，可以根据自己的喜好将阴影放到想要的位置</span><br><span class="line"></span><br><span class="line">//text-shadow是设置字体阴影的也很不错，可以自己创建艺术字效果</span><br></pre></td></tr></table></figure>



<p>无阴影</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240518105315289.png" alt="image-20240518105315289"></p>
<p>有阴影</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240518105332800.png" alt="image-20240518105332800"></p>
<p>有阴影无圆角</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240518105414374.png" alt="image-20240518105414374"></p>
<p>总之阴影可以给容器增加一种层次感，很好的美化效果</p>
<h4 id="模块美化二：渐变"><a href="#模块美化二：渐变" class="headerlink" title="模块美化二：渐变"></a>模块美化二：渐变</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">background: linear-gradient(to right, #c528d3 , #2033df);</span><br><span class="line">//渐变可以背景渐变，字体渐变一会再说</span><br></pre></td></tr></table></figure>





<p>渐变没啥好说的都见过渐变色，整个花活吧</p>
<p>写一个容器外层限制大小，内层实现一个鼠标移动过去出现一个从左向右的下弧线，鼠标移开，下划线从左向右消失</p>
<p>主要利用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">box-min-title view&#123;</span><br><span class="line">    background: linear-gradient(to right, #7e2f3b, #146420) no-repeat right bottom;</span><br><span class="line">    //设置背景为渐变，to right 从左向右渐变 ，no-repeat 背景图像只显示一次（不设置重复的背景会铺满容器） ， right bottom 设置背景在右下方</span><br><span class="line">    background-size: 0 2px;</span><br><span class="line">    //设置背景大小，宽度为0，高度为2px，将背景设置为线性，达到下划线的效果</span><br><span class="line">    transition: background-size 1s;</span><br><span class="line">    //给代码增加一个过渡效果，是得background-size（背景大小）变化在1s内完成，算是一个动画效果了</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box-min-title view:hover&#123;</span><br><span class="line">    background-position: left bottom;</span><br><span class="line">    //添加鼠标放置动画，鼠标放上去之后，背景从左下开始，增加至100%</span><br><span class="line">    background-size: 100% 2px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//鼠标移开时背景右在右下，背景宽度减少至0，动画效果就是从左向右消失</span><br></pre></td></tr></table></figure>



<p>不设置no-repeat</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240518113322383.png" alt="image-20240518113322383"></p>
<p>源码加成品</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box-min-title&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    width: 47%;</span><br><span class="line">    margin:  20px 0 0 50%;</span><br><span class="line">    height: auto;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">&#125;</span><br><span class="line">.box-min-title view&#123;</span><br><span class="line">    background: linear-gradient(to right, #7e2f3b, #146420) no-repeat right bottom;</span><br><span class="line">    background-size: 0 2px;</span><br><span class="line">    transition: background-size 1s;</span><br><span class="line">    position: absolute;</span><br><span class="line">    margin: 30px 0 0 0;</span><br><span class="line">    font-size: 30px;</span><br><span class="line">&#125;</span><br><span class="line">.box-min-title view:hover&#123;</span><br><span class="line">    background-position: left bottom;</span><br><span class="line">    background-size: 100% 2px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240518113648360.png" alt="image-20240518113648360"></p>
<h4 id="艺术字"><a href="#艺术字" class="headerlink" title="艺术字"></a>艺术字</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">line-height: 50px;</span><br><span class="line">//行间距</span><br><span class="line">letter-spacing: 35rpx;</span><br><span class="line">//字间距</span><br><span class="line">font-style: italic;</span><br><span class="line">//倾斜</span><br><span class="line"></span><br><span class="line">background: linear-gradient(to bottom,rgb(93, 68, 233) ,rgb(116, 147, 177));</span><br><span class="line">-webkit-background-clip: text;</span><br><span class="line">background-clip: text;</span><br><span class="line">color: transparent;</span><br><span class="line">//渐变字体组合拳</span><br></pre></td></tr></table></figure>



<p>效果：艺术细菌和审美实在有限</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240518115344814.png" alt="image-20240518115344814"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box-text&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">    height: 100px;</span><br><span class="line">    width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">//整个居中弹性盒没啥好说的</span><br><span class="line"></span><br><span class="line">.box-text text&#123;</span><br><span class="line">    background: linear-gradient(to bottom,rgb(93, 68, 233) ,rgb(116, 147, 177));</span><br><span class="line">    -webkit-background-clip: text;</span><br><span class="line">    background-clip: text;</span><br><span class="line">    color: transparent;</span><br><span class="line">    </span><br><span class="line">/*</span><br><span class="line">整个渐变字体，color: transparent;将文本设置为透明，为了显示出来渐变的背景颜色，利用 -webkit-background-clip: text; 将背景限制在文本的位置，-webkit-background-clip: text;需要 background-clip: text; 才不会有黄色问题标识，实测，只有-webkit-background-clip: text; 就可以实现功能，但是只有background-clip: text; 不行</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">    font-size: 30px;</span><br><span class="line">    font-style: italic;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    //分别为设置字体大小，字体倾斜，字体加粗</span><br><span class="line">    </span><br><span class="line">    letter-spacing: 20px;</span><br><span class="line">    //设置字间距为20px</span><br><span class="line">    text-shadow: 1px 1px 30px rgb(226, 143, 143);</span><br><span class="line">    opacity:0.8;</span><br><span class="line">    //设置字体透明度0-1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>没有找到小程序内实现文本透视效果的方法，欢迎大佬斧正</p>
<h4 id="展示成品"><a href="#展示成品" class="headerlink" title="展示成品"></a>展示成品</h4><p>说了那么多，应该能看懂下面的源码……了吧？</p>
<img src="../图片/image-20240518125039100.png" alt="image-20240518125039100" style="zoom:50%;" />



<p>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;view class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;view class=&quot;content&quot;&gt;</span><br><span class="line">        &lt;form bindsubmit=&quot;onform&quot;&gt;</span><br><span class="line">            &lt;view class=&quot;okk&quot;&gt;</span><br><span class="line">                &lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; class=&quot;ok&quot;/&gt;</span><br><span class="line">            &lt;/view&gt;</span><br><span class="line">            &lt;view class=&quot;okk&quot;&gt;</span><br><span class="line">                &lt;input type=&quot;text&quot; placeholder=&quot;请输入密码&quot; class=&quot;ok&quot;/&gt;</span><br><span class="line">            &lt;/view&gt;</span><br><span class="line">            &lt;view class=&quot;container&quot; style=&quot;padding: 5px 0;&quot;&gt;</span><br><span class="line">                &lt;view class=&quot;bt&quot; form-type=&quot;submit&quot;&gt;</span><br><span class="line">                &lt;text class=&quot;container&quot; bind:tap=&quot;denglu&quot;&gt;登录&lt;/text&gt;</span><br><span class="line">                &lt;/view&gt;</span><br><span class="line">                &lt;view style=&quot;height: 20px;&quot;&gt;&lt;/view&gt;</span><br><span class="line">                &lt;view class=&quot;bt&quot; style=&quot;background: #c61dff;&quot;&gt;</span><br><span class="line">                &lt;text class=&quot;container&quot;&gt;注册&lt;/text&gt;</span><br><span class="line">                &lt;/view&gt;</span><br><span class="line">            &lt;/view&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">page,</span><br><span class="line">.box,</span><br><span class="line">.content &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">&#125;</span><br><span class="line">page &#123;</span><br><span class="line">    background: #eff0f4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: space-between;</span><br><span class="line">    margin: 130px auto;</span><br><span class="line">    width: 470px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box .content &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">    justify-content: space-around;</span><br><span class="line">    align-items: center;</span><br><span class="line">    width: 350px;</span><br><span class="line">    height: 350px;</span><br><span class="line">    padding: 60px 20px;</span><br><span class="line">    box-shadow: </span><br><span class="line">        20px 20px 20px rgba(0, 0, 0, 0.3),</span><br><span class="line">        25px 35px 20px rgba(0, 0, 0, 0.3),</span><br><span class="line">        25px 30px 30px rgba(0, 0, 0, 0.3);</span><br><span class="line">    transition: .5s;</span><br><span class="line">    border-radius: 52% 48% 33% 67% / 38% 45% 55% 62%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box .content:hover &#123;</span><br><span class="line">    border-radius: 50%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box .content::before &#123;</span><br><span class="line">    content: &quot;&quot;;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50px;</span><br><span class="line">    left: 85px;</span><br><span class="line">    width: 35px;</span><br><span class="line">    height: 35px;</span><br><span class="line">    border-radius: 50%;</span><br><span class="line">    background: #fff;</span><br><span class="line">    opacity: 0.9;</span><br><span class="line">&#125;</span><br><span class="line">.ok&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    border-radius: 25px;</span><br><span class="line">    box-shadow: 2px 5px 10px rgb(204, 193, 193);</span><br><span class="line">    padding: 0 30rpx;</span><br><span class="line">    font-size: 16px;</span><br><span class="line">    outline: none;</span><br><span class="line">&#125;</span><br><span class="line">.okk&#123;</span><br><span class="line">    padding: 30rpx 0;</span><br><span class="line">&#125;</span><br><span class="line">.bt&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    transition: 0.5s;</span><br><span class="line">    background: #ff0f5b;</span><br><span class="line">    border-radius: 25px;</span><br><span class="line">    padding: 7rpx 3rpx;</span><br><span class="line">    box-shadow: 2px 5px 10px rgba(0, 0, 0, 0.5);</span><br><span class="line">&#125;</span><br><span class="line">.box .content .container .bt:hover&#123;</span><br><span class="line">    width: 150px;</span><br><span class="line">&#125;</span><br><span class="line">.page&#123;</span><br><span class="line">    height:100%;</span><br><span class="line">  &#125;</span><br><span class="line">.background &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">    position:fixed; </span><br><span class="line">    background-size:100% 100%;</span><br><span class="line">    z-index: -1;</span><br><span class="line">    filter: blur(6rpx);</span><br><span class="line">    filter: brightness(0.9);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240518125106524.png" alt="image-20240518125106524"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240518125112348.png" alt="image-20240518125112348"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;view class=&quot;searchBar&#123;&#123;expand ? &#x27;change-width&#x27;: &#x27;&#x27;&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;view class=&quot;icons&quot;&gt;</span><br><span class="line">        &lt;image src=&quot;../../image/搜索.png&quot; bind:tap=&quot;show&quot;/&gt; </span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">    &lt;view class=&quot;textinput&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; placeholder=&quot;请输入搜索关键字&quot; value=&quot;&#123;&#123;myinput&#125;&#125;&quot; bindinput=&quot;valueinput&quot;/&gt;</span><br><span class="line">        &lt;image src=&quot;../../image/删除.png&quot; class=&quot;clear&quot; bind:tap=&quot;clear&quot;/&gt;</span><br><span class="line">        &lt;view class=&quot;bt&quot;&gt;</span><br><span class="line">            &lt;text class=&quot;goBtn&quot;&gt;搜索&lt;/text&gt;</span><br><span class="line">        &lt;/view&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">page&#123;</span><br><span class="line">    width: 100vm;</span><br><span class="line">    height: 100vh;</span><br><span class="line">    background: linear-gradient(</span><br><span class="line">        to bottom skyblue #003462</span><br><span class="line">    );</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">&#125;</span><br><span class="line">.searchBar&#123;</span><br><span class="line">    width: 400px;</span><br><span class="line">    height: 60px;</span><br><span class="line">    background-color: #fff;</span><br><span class="line">    box-shadow: 0 0 10px rgba(0, 0, 0, 0.4);</span><br><span class="line">    border-radius: 60px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    transition: 0.5s;</span><br><span class="line">    z-index: 1;</span><br><span class="line">&#125;</span><br><span class="line">.icons&#123;</span><br><span class="line">    width: 60px;</span><br><span class="line">    height: 60px;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">    cursor: pointer;</span><br><span class="line">&#125;</span><br><span class="line">.icons image&#123;</span><br><span class="line">    width: 30px;</span><br><span class="line">    height: 30px;</span><br><span class="line">    font-size: 30px;</span><br><span class="line">&#125;</span><br><span class="line">.textinput&#123;</span><br><span class="line">    width: 320px;</span><br><span class="line">    height: 60px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 60px;</span><br><span class="line">    right: 50px;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">    background-color: rgb(255, 255, 255);</span><br><span class="line">&#125;</span><br><span class="line">.textinput input&#123;</span><br><span class="line">    width: 270px;</span><br><span class="line">    height: 100%;</span><br><span class="line">    border: none;</span><br><span class="line">    outline: none;</span><br><span class="line">    font-size: 18px;</span><br><span class="line">    padding: 0 90px 0 0;</span><br><span class="line">&#125;</span><br><span class="line">.clear&#123;</span><br><span class="line">    width: 20px;</span><br><span class="line">    height: 20px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    right: 18%;</span><br><span class="line">    top: 50%;</span><br><span class="line">    transform: translateY(-50%);</span><br><span class="line">    cursor: pointer;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">&#125;</span><br><span class="line">.clear image&#123;</span><br><span class="line">    width: 20px;</span><br><span class="line">    height: 20px;</span><br><span class="line">    color: #999;</span><br><span class="line">&#125;</span><br><span class="line">.goBtn&#123;</span><br><span class="line">    width: 14%;</span><br><span class="line">    height: 60%;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 20%;</span><br><span class="line">    right: 0;</span><br><span class="line">    border-radius: 8px;</span><br><span class="line">    outline: none;</span><br><span class="line">    border: none;</span><br><span class="line">    color: rgb(80, 0, 0);</span><br><span class="line">    box-shadow: 0 0 2px rgba(0, 0, 0, 0.4);</span><br><span class="line">    background: linear-gradient(</span><br><span class="line">        skblue,deepskyblue</span><br><span class="line">    );</span><br><span class="line">    cursor: pointer;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.searchBarchange-width&#123;</span><br><span class="line">    width: 60px;</span><br><span class="line">    height: 60px;</span><br><span class="line">    background-color: #fff;</span><br><span class="line">    box-shadow: 0 0 10px rgba(0, 0, 0, 0.4);</span><br><span class="line">    border-radius: 60px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    transition: 0.5s;</span><br><span class="line">    margin: -500px 0 0 0;</span><br><span class="line">    z-index: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>指针</title>
    <url>/2024/09/19/%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>这是利用指针来修改值的一个简单演示</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240915175142084.png" alt="image-20240915175142084"></p>
<span id="more"></span>



<h5 id="指针的概念："><a href="#指针的概念：" class="headerlink" title="指针的概念："></a>指针的概念：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两种理解方式</span><br><span class="line">	1、指针就是地址，地址就是指针；</span><br><span class="line">	2、指针变量，其实是C/C++的一种变量。这种变量比价特殊，通常会被赋值为某变量的地址 (p = &amp;a)，然后利用 *p 的方式来间接访问 p 所指向的地址</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240915181314618.png" alt="image-20240915181314618"></p>
<h5 id="指针的定义和初始化"><a href="#指针的定义和初始化" class="headerlink" title="指针的定义和初始化"></a>指针的定义和初始化</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">既然指针是一种变量，那么肯定也可以定义，也可以初始化</span><br><span class="line">	1、先定义再赋值</span><br><span class="line">		int * p;		// 定义指针变量p</span><br><span class="line">		p = &amp;a;			// 给p赋值</span><br><span class="line">		</span><br><span class="line">	2、定义的同时初始化</span><br><span class="line">		int * p = &amp;a;</span><br><span class="line">		</span><br><span class="line">	// 两种的效果是一样的</span><br></pre></td></tr></table></figure>



<h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有两个重要的运算符 &amp; 和 * </span><br><span class="line">	1、&amp;：取地址值符，将他加在某个变量的前面，组合后的符号代表这个变量的地址值</span><br><span class="line">		int a = 100; int * p; p = &amp;a;</span><br><span class="line">		表示将a的地址值赋值给p</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">			</span><br><span class="line">	2、*：指针符号。指针符号再指针定义和指针操作的时候，解析方法是不同的</span><br><span class="line">		int p;			// p是一个整型变量</span><br><span class="line">		int * p;		// p是一个指针变量，该指针指向一个整形数</span><br><span class="line">		使用该指针的时候，*p则代表变量p所指向的那个变量，这个过程有些也叫做解引用</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		符号解释：</span><br><span class="line">        	a	代表变量a本身</span><br><span class="line">			p	代表指针变量p本身</span><br><span class="line">			&amp;a	代表变量a的地址值</span><br><span class="line">			*p	代表指针变量p所指向的那个变量，也就是变量a</span><br><span class="line">			&amp;p	代表指针变量p本身的地址值。符号合法，但无意义。在二级指针中使用</span><br><span class="line">			*a	把a看作一个指针，*a表示这个指针所指向的变量。该符号不合法</span><br><span class="line">				也就是说：</span><br><span class="line">				int a = （一个地址值）</span><br><span class="line">				cout &lt;&lt; *a &lt;&lt; endl</span><br><span class="line">				这样的表述是不合法的，即使是存储的地址值也应该将a的类型转成int *来进行操作</span><br><span class="line">					int * a = (int*)0000DE298342</span><br></pre></td></tr></table></figure>



<h5 id="指针变量的解读"><a href="#指针变量的解读" class="headerlink" title="指针变量的解读"></a>指针变量的解读</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指针变量本质上是一个变量</span><br><span class="line">指针变量的类型属于指针类型</span><br><span class="line">int * p：定义了一个指针类型的变量p，p能指向的变量是int</span><br><span class="line">其他类型的指针：</span><br><span class="line">	int * pInt;</span><br><span class="line">	char * pChar;</span><br><span class="line">	float * pFloat;</span><br><span class="line">	double * pDouble;</span><br><span class="line">	各种指针类型和所指向的变量类型必须匹配，否则结果不可预知</span><br><span class="line">	</span><br><span class="line">		如果非要用的话，还可以进行指针间的强转   reinterpret_cast</span><br><span class="line">		char c = &#x27;a&#x27;;</span><br><span class="line">		int * p;</span><br><span class="line">		p = reinterpret_cast&lt;int *&gt;(&amp;c)</span><br><span class="line">		</span><br><span class="line">		// 这样强转也会出现问题的，因为char占一个字节，int占四个字节，因此结果不可预知</span><br></pre></td></tr></table></figure>





<h5 id="空指针和野指针"><a href="#空指针和野指针" class="headerlink" title="空指针和野指针"></a>空指针和野指针</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">空指针：指针指向的地址是0</span><br><span class="line">野指针：指针变量未经赋值，或者指向非法地址</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240915214624603.png" alt="image-20240915214624603"></p>
<p>C语言这里是没有默认初始化的，所以这里是野指针错误，有的语言会进行初始化</p>
<p>全局变量是会初始化的 </p>
<h5 id="指针大小"><a href="#指针大小" class="headerlink" title="指针大小"></a>指针大小</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两种情况</span><br><span class="line">	32位，64位</span><br><span class="line">	4字节，8字节</span><br><span class="line">	</span><br><span class="line">现在电脑程序一般是64位，手机是32位</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240915220004310.png" alt="image-20240915220004310"></p>
<h5 id="指针使用count"><a href="#指针使用count" class="headerlink" title="指针使用count"></a>指针使用count</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为了防止误改，使用count来修饰指针</span><br><span class="line"></span><br><span class="line"> const int* p1 = &amp;a;		// 常量指针</span><br><span class="line"> int* const p2 = &amp;a;		// 指针常量</span><br><span class="line"> const int* const p3 = &amp;a;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int a = 10;</span><br><span class="line">int b = 20;</span><br><span class="line"></span><br><span class="line">const int* p1 = &amp;a;		// 常量指针</span><br><span class="line">int* const p2 = &amp;a;		// 指针常量</span><br><span class="line">const int* const p3 = &amp;a;</span><br><span class="line"></span><br><span class="line">// 常量指针不能修改所指对象的值，但可以修改指针本身的值</span><br><span class="line">//*p1 = 30;		// 错误，常量指针不能修改所指对象的值</span><br><span class="line">p1 = &amp;b;		// 正确，指针常量只能修改指针本身的值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">// 指针常量只能修改指针本身的值，不能修改所指对象的值</span><br><span class="line">// p2 = &amp;b;		// 错误，指针常量只能修改指针本身的值</span><br><span class="line">*p2 = 30;		// 正确，指针常量只能修改指针本身的值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">// 指针常量不能修改所指对象的值，也不能修改指针本身的值</span><br><span class="line">// p3 = &amp;b;		// 错误，指针常量不能修改所指对象的值</span><br><span class="line">//*p3 = 30;		// 错误，指针常量不能修改指针本身的值</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240915221201598.png" alt="image-20240915221201598"></p>
<h5 id="指针应用"><a href="#指针应用" class="headerlink" title="指针应用"></a>指针应用</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指针应用：</span><br><span class="line">	实现函数参数引用传递</span><br><span class="line">	实现函数返回多个值</span><br><span class="line">	方便处理字符串</span><br><span class="line">	表示复杂的数据结构(结构体等)，在作为参数传递的时候更节省内存</span><br></pre></td></tr></table></figure>



<p>返回多个值是一种表述：返回值只有一个，但是可以通过利用向方法中传递指针，在函数体内修改指针指向的内容来实现多个参数改变</p>
<p>为什么说传递复杂数据结构的时候可以节省内存呢，因为是传递的地址值，不需要将这个复杂的数据结构赋值给另一个地址值来进行操作</p>
<h5 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h5><p>先看一下数组</p>
<p>int数组和char数组</p>
<p>看注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char arr_str[] = &#123;&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;\0&#x27;&#125;</span><br><span class="line">这样定义一个char数组可以正常输出</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240915225132566.png" alt="image-20240915225132566"></p>
<p>字符串数组</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240915225839433.png" alt="image-20240915225839433"></p>
<p>字符串数组在C中表示是char数组的数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char arr_str[][] = &#123;&quot;hello&quot;, &quot;world&quot;, &quot;c++&quot;, &quot;run&quot;&#125;</span><br><span class="line">// 这个时候第二个括号内需要填写数值，这个数值不能小于最长的那个字符串长度</span><br><span class="line">// 使用const char* 可以定义一个字符串，在字符串的基础上再创建一个数组就是字符串数组了，这个时候就没上上面的限制了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 上面说的是C语言中的字符串数组定义方法，C++中有string，可以直接定义</span><br></pre></td></tr></table></figure>





<p><strong>再来看指针</strong></p>
<p>int数组指针</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240915231036804.png" alt="image-20240915231036804"></p>
<p>char数组指针</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240915231654545.png" alt="image-20240915231654545"></p>
<p>字符串数组</p>
<p>int * 指向int 类型</p>
<p>int**指向int*类型这个很好理解的吧</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240915232309434.png" alt="image-20240915232309434"></p>
<h5 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h5><p>指针运算就是上面使用的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; *p++;</span><br><span class="line">cout &lt;&lt; *(++p);</span><br><span class="line">cout &lt;&lt; *(P+1);</span><br><span class="line"></span><br><span class="line">// 这些都是指针运算</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916005620645.png" alt="image-20240916005620645"></p>
<p>它的这几个运算方式是不同的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*p++ 和 *++p 这两种方法是针对p本身进行操作，p自己+1</span><br><span class="line"></span><br><span class="line">而，*(P+1)是先运算再取值，并且不对p本身的大小进行操作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">而*p++ 和 *++p 也是有差别的，看下面的输出，*p++是先输出*p然后再进行++操作，而*++p是先进行++操作再取值</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916010053987.png" alt="image-20240916010053987"></p>
<h4 id="函数参数的引用传递"><a href="#函数参数的引用传递" class="headerlink" title="函数参数的引用传递"></a>函数参数的引用传递</h4><h5 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h5><p>之前说过函数值的传递在Java中基本数据类型是做不到的</p>
<p>但是也有其他方法，比如放到数组，或者在一个类当中，数组已经演示过了，下面是在类中更改，两者的底层原理是一样代表，都是传入地址值，直接操作地址值内的数</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916012435232.png" alt="image-20240916012435232"></p>
<p>C++</p>
<p>将地址传入方法相当于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int * a = &amp;a;</span><br><span class="line">int * b = &amp;b </span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916014530238.png" alt="image-20240916014530238"></p>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>已经演示过了</p>
<p>Java</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240915174303124.png" alt="image-20240915174303124"></p>
<p>C++：</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240915223751211.png" alt="image-20240915223751211"></p>
<p>数组传递的是地址值可以直接操作，原因是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void add(int a[]);</span><br><span class="line">到解析的时候会转化为，一个int指针</span><br><span class="line">void add(int * a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一般为了能够正常输出这个数组，还会传递一个length数组长度进去</span><br><span class="line">add(arr, sizeof(arr) / sizeof(int))</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常见写法：</span><br><span class="line">	1、返回值为void，参数当作返回值，这时候需要用指针把参数变为引用传递</span><br><span class="line">	2、加密函数中，传1个context，传1个明文指针，1个明文长度，1个结果指针</span><br></pre></td></tr></table></figure>



<h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义函数指针：	</span><br><span class="line">	void (*name)(指向的函数参数类型);</span><br><span class="line">	</span><br><span class="line">// 还可以进行初始化</span><br><span class="line">	void (*pFunc)(int *,int *) = nullptr || NULL   -》 两个都可以</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">函数指针赋值：</span><br><span class="line">	pFunc = add;      或者</span><br><span class="line">	pFunc = &amp;add;</span><br><span class="line">	</span><br><span class="line">	// 因为函数和数组一样，函数名就是函数地址</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916022520615.png" alt="image-20240916022520615"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数指针的调用</span><br><span class="line">	(*pFunc)(&amp;a, b);</span><br><span class="line">	pFunc(&amp;a, b);    // 这种调用方法仅限于函数指针，其他指针不可以使用</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916023133902.png" alt="image-20240916023133902"></p>
<h5 id="函数指针数组"><a href="#函数指针数组" class="headerlink" title="函数指针数组"></a>函数指针数组</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void (*pFunc[2])(int *, int *);</span><br><span class="line">// 这个表示这个函数指针可以放三个函数</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916023746682.png" alt="image-20240916023746682"></p>
<h5 id="函数指针作为参数"><a href="#函数指针作为参数" class="headerlink" title="函数指针作为参数"></a>函数指针作为参数</h5><p>函数指针可以作为一个参数传到另一个函数内，函数指针还可以放到结构体内，结构体只能放基本数据类型，不能定义函数和方法，但是可以存放函数指针</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将函数指针放到了函数内，在函数内执行了另一个函数</span><br><span class="line"></span><br><span class="line">定义函数指针，指定函数，使用函数指针调用函数</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916024717314.png" alt="image-20240916024717314"></p>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全局变量：	</span><br><span class="line">	本文件中的全局变量定义</span><br><span class="line">	引用别的文件中定义的全局变量</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916150401967.png" alt="image-20240916150401967"></p>
<p>extern</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、extern int a; 		表示引用别的文件中的全局变量a</span><br><span class="line">2、extern &quot;C&quot; ……;		表示后续代码使用C语言进行编译，不识别标识符</span><br></pre></td></tr></table></figure>





<h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static：</span><br><span class="line">	1、静态局部变量	</span><br><span class="line">		生命周期延长，与全局变量的生命周期一致，程序结束时销毁</span><br><span class="line">		</span><br><span class="line">	2、静态全局变量	</span><br><span class="line">		限制在本文件中使用</span><br><span class="line">		</span><br><span class="line">	3、静态函数	     </span><br><span class="line">		限制在本文件中使用</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916151430742.png" alt="image-20240916151430742"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916152049596.png" alt="image-20240916152049596"></p>
<h4 id="内存四区"><a href="#内存四区" class="headerlink" title="内存四区"></a>内存四区</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码区：存放CPU执行的机器指令，该区域数据共享、只读</span><br><span class="line">全局区：存放全局变量、全局常量、静态常量、字符串常量，程序结束后由系统操作释放</span><br><span class="line">栈区：自动分配和释放，存放函数的参数、局部变量等</span><br><span class="line">堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收</span><br><span class="line">		C中进入堆区使用关键字malloc，Java、C++进入堆区使用关键字new</span><br><span class="line"></span><br><span class="line">不同区域存放的数据，赋予不同的生命周期，赋予不同的权限</span><br></pre></td></tr></table></figure>





<h4 id="模拟加密后的数据转Hex编码"><a href="#模拟加密后的数据转Hex编码" class="headerlink" title="模拟加密后的数据转Hex编码"></a>模拟加密后的数据转Hex编码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void swap() &#123;</span><br><span class="line">    char result[3];</span><br><span class="line">    char * res = result;</span><br><span class="line">    char realResult[33] = &#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 16; i++)&#123;</span><br><span class="line">        int index = i;</span><br><span class="line">        sprintf_s(res, sizeof(result), &quot;%.2X&quot;, index);</span><br><span class="line">        strcat_s(realResult, sizeof(realResult), res);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; realResult &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916155409022.png" alt="image-20240916155409022"></p>
<p>利用sprint_s格式化去两位十六进制数，然后利用strcat_s将得到的res拼接起来到realResult中</p>
<h4 id="char-和char数组"><a href="#char-和char数组" class="headerlink" title="char * 和char数组"></a>char * 和char数组</h4><p>这两个都能表示一个字符串，但是是有差别的。</p>
<p>char * p 是字符串常量，是放到全局区域的，这里还有提示，如果让他指向一个字符串的话，需要加上const</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const char * p</span><br><span class="line"></span><br><span class="line">这种形式的指针只能修改指向的内容的值，不能修改内容，可以</span><br><span class="line">p = &quot;asda&quot;; 但是不能 *p[0] = &#x27;a&#x27;</span><br><span class="line"></span><br><span class="line">而char数组的值就可以随意修改了</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916160435964.png" alt="image-20240916160435964"></p>
<h4 id="内存操作"><a href="#内存操作" class="headerlink" title="内存操作"></a>内存操作</h4><p>还是写加密后数据转Hex编码这个案例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void swap1() &#123;</span><br><span class="line">    char temp[3];</span><br><span class="line">    char * reaResult = nullptr;</span><br><span class="line">    // 使用malloc申请内存</span><br><span class="line">    reaResult = (char*) malloc(33);</span><br><span class="line">    // 申请到的内存是没有清理的，可能有乱码，需要自己清理</span><br><span class="line">    memset(reaResult, 0, 33);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 16; i++)&#123;</span><br><span class="line">        int index = i;</span><br><span class="line">        sprintf_s(temp, sizeof(temp), &quot;%.2X&quot;, index);</span><br><span class="line">        strcat_s(reaResult, 33, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; reaResult &lt;&lt; endl;</span><br><span class="line">    // 手动释放内存</span><br><span class="line">    free(reaResult);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 还有一个申请内存的操作 calloc calloc会自动把申请过来的内存清理</span><br><span class="line"></span><br><span class="line">char * realResult = (char *)calloc(33,1)</span><br><span class="line"></span><br><span class="line">// 这里free释放，释放的是内存空间，如果reaResult没有指向申请来的内存空间，释放也就没有意义，所以要将free指向指向内存空间的指针，</span><br><span class="line">// 任何一个指向这块内存空间的指针都可以释放这块空间</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916162413664.png" alt="image-20240916162413664"></p>
<h5 id="指针的注意事项"><a href="#指针的注意事项" class="headerlink" title="指针的注意事项"></a>指针的注意事项</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不要把函数内部的局部变量地址，交给函数外的指针变量</span><br><span class="line"></span><br><span class="line">// 函数执行完毕局部变量会被销毁，那么指针也就成为了野指针</span><br><span class="line">// 如果需要局部变量，可以传入参数指针，把参数当作返回值使用</span><br></pre></td></tr></table></figure>



<h4 id="多级指针"><a href="#多级指针" class="headerlink" title="多级指针"></a>多级指针</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概念：指向指针的指针</span><br><span class="line">例：</span><br><span class="line">	int a = 100;</span><br><span class="line">	int * p = &amp;a;</span><br><span class="line">	int ** pp = &amp;p;</span><br><span class="line">	int *** ppp = &amp;pp;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916201207128.png" alt="image-20240916201207128"></p>
<h4 id="多级指针的应用"><a href="#多级指针的应用" class="headerlink" title="多级指针的应用"></a>多级指针的应用</h4><p><img src="/../%E5%9B%BE%E7%89%87/image-20240916202414425.png" alt="image-20240916202414425"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从上图可以看到int *指针可以正常使用，但是char *的时候就遇到了问题，为什么呢</span><br><span class="line"></span><br><span class="line">全局区：</span><br><span class="line">	0x123456789 &quot;kong&quot;</span><br><span class="line">	0x123987654 &quot;hello world&quot;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">main栈：</span><br><span class="line">	char * res = 0x123456789</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">swap4栈：</span><br><span class="line">	char * a = 0x123987654</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">可以看到本质上main栈内res所指向的地址值并没没有改变，这个时候就需要用到二级指针了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这里的原理刚开始我有点想不通：</span><br><span class="line">	char *可以看作和int等效，因为char *用来指向字符串常量的地址，如果再用一个char *来接收这个数值，那么就是进行了一个赋值，并没有用到指针，所以需要使用char **来接收地址值，就可以实现类似与int *的效果了</span><br></pre></td></tr></table></figure>



<p>用二级指针来操作char *数组</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916210523761.png" alt="image-20240916210523761"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全局区：</span><br><span class="line">	0x123456789 &quot;kong&quot;</span><br><span class="line">	0x123987654 &quot;hello world&quot;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">main栈：</span><br><span class="line">	0x123456789 char * res = 0x123456789</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">swap4栈：</span><br><span class="line">	char ** a = 0x123456789</span><br><span class="line">	*a = &quot;hello world&quot; 0x123987654</span><br><span class="line">	</span><br><span class="line">	-&gt; swap4栈中  char ** a = 0x123987654 -&gt; main栈中  char * res = 0x123987654   -&gt;  &quot;hello world&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1、想把参数当返回值，传入的实参是char *等指针的时候</p>
<p>2、传入的实参是一级指针，那么想把参数当作返回值，形参就得是二级指针</p>
<p>3、结论：形参要比实参多一级指针，才能把参数当返回值使用</p>
</blockquote>
<h5 id="模拟加密字符串的返回"><a href="#模拟加密字符串的返回" class="headerlink" title="模拟加密字符串的返回"></a>模拟加密字符串的返回</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void swap5(const char ** result) &#123;</span><br><span class="line">    char temp[3];</span><br><span class="line">    char * reaResult = nullptr;</span><br><span class="line">    // 使用malloc申请内存</span><br><span class="line">    // 申请到的内存是没有清理的，可能有乱码，需要自己清理</span><br><span class="line">    reaResult = (char*) malloc(33);</span><br><span class="line">    memset(reaResult, 0, 33);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 16; i++)&#123;</span><br><span class="line">        int index = i;</span><br><span class="line">        sprintf_s(temp, sizeof(temp), &quot;%.2X&quot;, index);</span><br><span class="line">        strcat_s(reaResult, 33, temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *result = reaResult;</span><br><span class="line">    //cout &lt;&lt; reaResult &lt;&lt; endl;</span><br><span class="line">    // 手动释放内存，这个时候就不能释放内存了，因为释放之后，出了这个函数，就拿不到数据了，处理了个寂寞</span><br><span class="line">    //free(reaResult);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	const char * result = &quot;kong&quot;;</span><br><span class="line">	swap5(&amp;result);</span><br><span class="line">	cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	// 拿到地址之后再释放内存</span><br><span class="line">	free((void*)result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916213347260.png" alt="image-20240916213347260"></p>
<h4 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">okl * pp = &amp;ok;</span><br><span class="line">(*pp).pFunc(a);</span><br><span class="line">pp-&gt;pFunc(a);</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916215656068.png" alt="image-20240916215656068"></p>
<blockquote>
<p>结构体指针还有一种调用方式，就是箭头调用，可以去掉一层*</p>
</blockquote>
<h4 id="结构体传参"><a href="#结构体传参" class="headerlink" title="结构体传参"></a>结构体传参</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">值传递： 如果一个结构体数组，很占内存</span><br><span class="line">引用传递： 指针4或者8个</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240916220146185.png" alt="image-20240916220146185"></p>
]]></content>
      <categories>
        <category>逆向学习</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门学习</title>
    <url>/2024/10/09/Java%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Java上"><a href="#Java上" class="headerlink" title="Java上"></a>Java上</h1><p>常用的dos命令</p>
<table>
<thead>
<tr>
<th>作用</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>切换盘符</td>
<td>盘符名:-&gt;</td>
</tr>
<tr>
<td>查看目录下文件</td>
<td>dir</td>
</tr>
<tr>
<td>跳转文件夹</td>
<td>cd</td>
</tr>
<tr>
<td>清空</td>
<td>cls</td>
</tr>
<tr>
<td>退出</td>
<td>exit</td>
</tr>
<tr>
<td>创建文件夹</td>
<td>mkdir</td>
</tr>
<tr>
<td>删除文件夹</td>
<td>rd</td>
</tr>
<tr>
<td>删除文件</td>
<td>del</td>
</tr>
</tbody></table>
<span id="more"></span>



<p>jvm和跨平台</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、jvm：Java运行程序的假想虚拟机，主要用来运行Java程序</span><br><span class="line">2、跨平台：Java代码可以在不同的操作系统上运行</span><br></pre></td></tr></table></figure>



<p>java是运行命令，javac是编译命令，跳过让人头疼的环境变量吧</p>
<h5 id="写一个helloword"><a href="#写一个helloword" class="headerlink" title="写一个helloword"></a>写一个helloword</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、编写</span><br><span class="line">   a.新建一个.java文件</span><br><span class="line">2、编译</span><br><span class="line">   a.命令javac java文件名.java</span><br><span class="line">   b.javac会将Java文件编译生成一个.class文件，jvm只认识.class文件</span><br><span class="line">3、运行</span><br><span class="line">   a.命令：Java class文件名</span><br></pre></td></tr></table></figure>



<p>这里我一直错误，配置了好久的环境变量，结果不是环境变量的问题</p>
<p>输入运一下java -cd .&#x2F; Hello 即可，神经</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240601133633823.png" alt="image-20240601133633823"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240601133733346.png" alt="image-20240601133733346"></p>
<p>注释</p>
<p>有三种注释方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   文档注释：文档注释的内容可以根据javadoc命令生成一个文档（API文档），拿到文档可以快速对此类和此类实现的功能快速了解</span></span><br><span class="line"><span class="comment">   命令：javadoc -d 要生成的文件夹名称 -author（作者） -version（版本） 文件名.Java</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240601134430217.png" alt="image-20240601134430217"></p>
<h5 id="解释一下之前的入门程序"><a href="#解释一下之前的入门程序" class="headerlink" title="解释一下之前的入门程序"></a>解释一下之前的入门程序</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hello</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  public class Hello 定义一个类</span></span><br><span class="line"><span class="comment">  class：代表的就是类，类是Java程序最基本的组成单元，所有代码都需要在类中写</span></span><br><span class="line"><span class="comment">  class 后面跟的名字叫做类名，类名要求要和文件名保持一致，有求一致</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       main是一个方法，是程序的入口，jvm运行程序要找这个main当入口开始执行</span></span><br><span class="line"><span class="comment">       public static void main(String[] args)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">           下面的语句是输出语句</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>养成语句结束使用分号的好习惯</p>
<h5 id="字符编码问题"><a href="#字符编码问题" class="headerlink" title="字符编码问题"></a>字符编码问题</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、保存数据的过程就是编码的过程</span><br><span class="line">2、读取数据的过程就是解码的过程</span><br><span class="line">3、编解码要是同一个编码</span><br><span class="line">   常见的编码规范：</span><br><span class="line">      GDK：专门为中文设计的编码（ANSI），一个中文汉字占两个字节</span><br><span class="line">      utf-8：一个中文汉字占三个字节</span><br><span class="line">      dos窗口默认编码为GDK</span><br></pre></td></tr></table></figure>





<h5 id="源文件名与类目一致问题"><a href="#源文件名与类目一致问题" class="headerlink" title="源文件名与类目一致问题"></a>源文件名与类目一致问题</h5><p>并不是必须的，如果不一致，需要将class前的public删掉</p>
<p>javac编译生成的class文件名称与类名相同</p>
<p>一个Java文件中可以有多个类名，但是只能有一个类带public，建议不要在一个文件中随意写class</p>
<p>main方法必须写在带public的类中</p>
<h5 id="println和print的区别"><a href="#println和print的区别" class="headerlink" title="println和print的区别"></a>println和print的区别</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相同点：都是输出语句</span><br><span class="line">不同点：println输出后带换行效果；相当于python中print</span><br><span class="line">       print输出后不带换行效果；相当于python中的print(end=&#x27;&#x27;)</span><br></pre></td></tr></table></figure>





<h3 id="常量、变量、类型转化"><a href="#常量、变量、类型转化" class="headerlink" title="常量、变量、类型转化"></a>常量、变量、类型转化</h3><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>在代码的运行过程中其值不会发生改变的数据</p>
<p>分类：</p>
<p>整数常量：所有整数</p>
<p>小数常量：带小数点就算</p>
<p>字符常量：带单引号的，单引号中必须有且只能有一个内容 <code>&#39;1&#39;(算) &#39;11&#39;(不算) &#39;&#39;(不算) &#39; &#39;(算) &#39;  &#39;(不算) </code>  单引号内打一个Tab键也算</p>
<p>字符串常量：带双引号的，双引号内容随意</p>
<p>布尔常量：true和false</p>
<p>空常量：null（不能直接使用）</p>
<h4 id="注意一下常量的运算"><a href="#注意一下常量的运算" class="headerlink" title="注意一下常量的运算"></a>注意一下常量的运算</h4><p>除法是：如果前后都是整数那么，结果只取整数部分</p>
<p>前后只要有一个带小数点，结果就是正常小数</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、基本数据类型：四类八种</span><br><span class="line">    整型：byte、short、int、long</span><br><span class="line">    浮点型：float、double</span><br><span class="line">    字符型：char</span><br><span class="line">    布尔型：boolean</span><br><span class="line">2、引用数据类型</span><br><span class="line">    类、数组、接口、枚举、注解</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">关键字</th>
<th align="center">内存占用</th>
<th align="center">数值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字节型</td>
<td align="center">byte</td>
<td align="center">1字节</td>
<td align="center">-128至127</td>
</tr>
<tr>
<td align="center">短整型</td>
<td align="center">short</td>
<td align="center">2字节</td>
<td align="center">-32768至32767</td>
</tr>
<tr>
<td align="center">整型</td>
<td align="center">int</td>
<td align="center">4字节</td>
<td align="center">-2^31^ 至 2^31^  正负21亿</td>
</tr>
<tr>
<td align="center">长整型</td>
<td align="center">long</td>
<td align="center">8字节</td>
<td align="center">-2^63^ 至 2^63^</td>
</tr>
<tr>
<td align="center">单精度浮点数</td>
<td align="center">float</td>
<td align="center">4字节</td>
<td align="center">1.4013E-45 至 1.4013E+38  1.4乘十的负45次方</td>
</tr>
<tr>
<td align="center">双精度浮点数</td>
<td align="center">double</td>
<td align="center">8字节</td>
<td align="center">4.9E-324 至 1.7977E+308</td>
</tr>
<tr>
<td align="center">字符型</td>
<td align="center">char</td>
<td align="center">2字节</td>
<td align="center">0 至 2^16^-1</td>
</tr>
<tr>
<td align="center">布尔类型</td>
<td align="center">boolean</td>
<td align="center">1字节</td>
<td align="center">true 和 false</td>
</tr>
</tbody></table>
<p>注意：</p>
<p>定义Long类型是后面要加一个大写的L</p>
<p>定义float类型时后面加上一个F</p>
<p>float 和 double的区别</p>
<p>float的小数位只有23位二进制，能表示最大的十进制位（8388608），七位数</p>
<p>double的小数位有52位，能表示最大的十进制位（4 503 599 627 370 496），十六位数</p>
<p>&#x3D;&#x3D;不要用float和double直接参与运算&#x3D;&#x3D;，精度不准</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240601194854742.png" alt="image-20240601194854742"></p>
<p>输出结果为  1.4300001</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>在代码运行过程中，值会随着不同的情况而随时发生改变的数据</p>
<p>定义方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、数据类型 变量名 = 值</span><br><span class="line"></span><br><span class="line">2、数据类型 变量名;</span><br><span class="line">变量名 = 值</span><br><span class="line"></span><br><span class="line">3、数据类型 变量1 变量2 变量3;</span><br><span class="line">变量1 = 值</span><br><span class="line">变量2 = 值</span><br><span class="line">变量3 = 值</span><br><span class="line"></span><br><span class="line">4、数据类型 变量名1 = 值, 变量名2 = 值, 变量名3 = 值;</span><br></pre></td></tr></table></figure>



<p>字符串属于引用数据类型，用String表示，String是一个类，只不过是字符串定义是和基本数据类型定义格式一样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String name = &quot;张三&quot;;</span><br></pre></td></tr></table></figure>



<p>变量没赋值，没有初始化无法使用，在同一个作用域中不能定义重名的变量</p>
<p>不同作用域的变量不要随意访问</p>
<p>小作用域中可以访问大作用域的变量</p>
<p>大作用域中不可以访问小作用域的变量 </p>
<h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><p><code>\</code> ：将普通字符转换成具有特殊含义的字符，将带有特殊含义的字符转换为普通字符</p>
<h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>给类、方法、变量取的名字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意：</span><br><span class="line">    硬性规定：</span><br><span class="line">        标识符可以包含数字，字母 $_</span><br><span class="line">        标识符不能以数字开头</span><br><span class="line">        标识符不能是关键字</span><br><span class="line">    软性建议：</span><br><span class="line">    	给类取名字是遵循大驼峰式命名 -&gt; 每个单词首字母大写</span><br><span class="line">    	给方法和变量遵循小驼峰式命名 -&gt; 从第二个单词开始大写</span><br><span class="line">    	见名知意</span><br></pre></td></tr></table></figure>





<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">什么时候发生数据类型转换：</span><br><span class="line">	等号两边类型不一致的时候，如：long和float定义值时需要加L、F，如果不加的话会类型转化</span><br><span class="line">	不同类型的数据做运算</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">基本数据类型按照取值范围从小到大排序</span><br><span class="line">byte,short,char -&gt; int -&gt; long -&gt; float -&gt; double</span><br></pre></td></tr></table></figure>



<h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><p>将取值范围小的数据类型赋值给取值范围大的数据类型会自动数据转换 -&gt; 小转大</p>
<p>取值范围小的数据类型和取值范围大的数据类型做运算 -&gt; 小转大</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       main是一个方法，是程序的入口，jvm运行程序要找这个main当入口开始执行</span></span><br><span class="line"><span class="comment">       public static void main(String[] args)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 等号右边是整数，整数默认类型为int，等号左边是long型的变量</span></span><br><span class="line"><span class="comment">         * 将取值范围小的数据赋值给取值范围大的数据类型，发生了自动数据类型转换</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        System.out.print(num1);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2.5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * double = int + double</span></span><br><span class="line"><span class="comment">         * double = double + double</span></span><br><span class="line"><span class="comment">         * int 自动提升为 double ，发生了自动数据类型转换</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> i + x;</span><br><span class="line">        System.out.print(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>当取值范围大的数据类型赋值给取值范围小的数据类型 -&gt; 强制转换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">取值范围小的数据类型 变量名 = （取值范围小的数据类型）取值范围大的数据类型</span><br><span class="line">	// 右边的数据是小数，小数默认类型为double</span><br><span class="line">	float num = (float)2.5;</span><br><span class="line">	float num = 2.5F;</span><br></pre></td></tr></table></figure>



<p>注意，不要随意写成强制转换的形式，会有精度损失问题以及数量溢出现象</p>
<p>精度损失问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int i = (int)2.9</span><br><span class="line">// 这个时候 i 的值为2，0.9损失掉了，不是四舍五入，而是抹零</span><br></pre></td></tr></table></figure>



<p>数据溢出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 数据溢出</span></span><br><span class="line"><span class="comment"> * int型占内存4个字节，四个字节变为二进制是32位</span></span><br><span class="line"><span class="comment"> * 100亿的二进制 ：10 0101 0100 0000 1011 1110 0100 0000 0000 -&gt; 34位</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 100亿的二进制位比int型的二进制位多出来两位，因此要干掉两位</span></span><br><span class="line"><span class="comment"> *      0101 0100 0000 1011 1110 0100 0000 0000</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">10000000000L</span>;</span><br><span class="line"> <span class="comment">// 这里相当于把10升水倒入2升的容器内，将值位100亿的长整型赋值给整型，会出现损失，但是输出结果并不是整型的极限，这里涉及到二进制</span></span><br><span class="line"> System.out.print(j); <span class="comment">// 输出结果1410065408</span></span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240602101902325.png" alt="image-20240602101902325"></p>
<p>但是也有不得不用强制转换的时候例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调用find()功能获取2.5这个数据，以为find()要求必须使用float型的变量接收</span><br><span class="line"></span><br><span class="line">float number = 对象.find()</span><br></pre></td></tr></table></figure>



<p>数字默认为int</p>
<p>byte 和 short 定义的时候如果等号右边是常量，但是取值在范围内，不需要强转，jvm会自动转型</p>
<p>byte 和 short 如果&#x3D;&#x3D;等号右边有变量参与&#x3D;&#x3D;，byte和short自动提升为int，然后结果再次赋值给byte和short，需要我们自己手动强转</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte i = 10;</span><br><span class="line">System.out.print(i)</span><br><span class="line">// 输出没问题</span><br><span class="line"></span><br><span class="line">i = i + 1;</span><br><span class="line">System.out.print(i)</span><br><span class="line">// 这个时候就会给出提示，从int转化为byte可能会有损失</span><br><span class="line"></span><br><span class="line">i = (byte)(i+1)</span><br><span class="line">// 转化</span><br></pre></td></tr></table></figure>





<p>char类型数据，如果参与运算会自动提升为int类型</p>
<p>如果char转换为int类型，如果是字母会去ASCII码表中去查，对应数字</p>
<p>如果在ASCII码表中没有找到对应字符，那么就会去Unicode（万国码）码表中找</p>
<p>byte类型强转有一点事</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte i = (byte)200</span><br><span class="line">System.out.print(i)  // 输出-56</span><br></pre></td></tr></table></figure>



<p>这里涉及到二进制的源码、反码、补码的问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">200，转换成二进制</span><br><span class="line">原码：1100 1000</span><br><span class="line"></span><br><span class="line">反码是原码第一位不变，其余0、1互换</span><br><span class="line">反码：1011 0111</span><br><span class="line"></span><br><span class="line">补码是在反码的基础上加一</span><br><span class="line">补码：1011 1000</span><br><span class="line"></span><br><span class="line">注意一下，因为byte的取值范围为 -128至127，所以正数的时候第一位是一直为0，因此，第一位代码的0、1设计为了正负的判断，第一位为1是负数，为0是正数</span><br><span class="line">现在再看补码，除去第一位是56，第一位是1，因此结果为-56</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">还有一种更简单的理解方式</span><br><span class="line">byte i = (byte)128</span><br><span class="line"></span><br><span class="line">这个时候也是超出范围的输出结果为 -128 再结合200找一下规律，发现也可以理解为 byte 的数是从 -128至127循环的，128就变为了 -128</span><br></pre></td></tr></table></figure>





<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><table>
<thead>
<tr>
<th align="center">位运算符</th>
<th align="center">符号解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&amp;</code></td>
<td align="center">按位与，当两位相同时为1才返回1，and</td>
</tr>
<tr>
<td align="center">&#96;</td>
<td align="center">&#96;</td>
</tr>
<tr>
<td align="center"><code>~</code></td>
<td align="center">按位非，将操作数的每个位（包括符号位）全部取反</td>
</tr>
<tr>
<td align="center"><code>^</code></td>
<td align="center">按位异或，当两位相同时返回0，不同时返回1</td>
</tr>
<tr>
<td align="center"><code>&lt;&lt;</code></td>
<td align="center">左移运算符</td>
</tr>
<tr>
<td align="center"><code>&gt;&gt;</code></td>
<td align="center">右移运算符</td>
</tr>
<tr>
<td align="center"><code>&gt;&gt;&gt;</code></td>
<td align="center">无符号右移运算符</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;	-&gt; 有假则假</span><br><span class="line">|	-&gt; 有真则真</span><br><span class="line">~	-&gt; 取反</span><br><span class="line">^	-&gt; 前后结果一样为false，不一样为true</span><br><span class="line">&lt;&lt;	-&gt; 左移几位相当于乘以2的几次方，很好理解吧，左移指的是二进制的左移</span><br><span class="line">&gt;&gt;	-&gt; 右移几位相当于乘以2的负几次方，向下取整，理解为二进制右移即可</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>



<p>计算机在存储数据的时候都是存储的数据的补码，计算也用的补码，但是最终看到的结果是原码，正数最高位为0，负数最高位为1</p>
<p>如果是正数，原反补是一致的，负数的原反补之前在byte是写过，我的理解是128八位二进制时最高位为1，对于byte来说只有八位二进制，因此使用了负数的原反补形式</p>
<h4 id="右移"><a href="#右移" class="headerlink" title="右移"></a>右移</h4><p>说一下右移，除了&#x3D;&#x3D;负数的右移是补1，其他的都是补0&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9&gt;&gt;2</span><br><span class="line">结果为2</span><br><span class="line">0000 1001右移两位，补零，成为 0000 0010</span><br><span class="line"></span><br><span class="line">正数还好，看一下负数</span><br><span class="line">-9&gt;&gt;2</span><br><span class="line"></span><br><span class="line">-9的原码</span><br><span class="line">1000 …0… 0000 1001</span><br><span class="line"></span><br><span class="line">-9的反码</span><br><span class="line">1111 …1… 1111 0110</span><br><span class="line"></span><br><span class="line">-9的补码</span><br><span class="line">1111 …1… 1111 0111</span><br><span class="line"></span><br><span class="line">补码右移两位，这个时候左边空了，但是不能补0，因为补0就是正数了，因此要补1</span><br><span class="line">1111 …1… 1111 1101</span><br><span class="line"></span><br><span class="line">根据补码算反码</span><br><span class="line">1111 …1… 1111 1100</span><br><span class="line"></span><br><span class="line">反码推原码</span><br><span class="line">1000 …0… 0000 0011</span><br><span class="line"></span><br><span class="line">结果为-3</span><br></pre></td></tr></table></figure>





<h4 id="无符号右移"><a href="#无符号右移" class="headerlink" title="无符号右移"></a>无符号右移</h4><p>向右移动后，&#x3D;&#x3D;左边空出来的位直接补0&#x3D;&#x3D;，无论正负，无符号还是很生动形象的</p>
<p>负数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-9&gt;&gt;&gt;2</span><br><span class="line"></span><br><span class="line">补码成为了这个，中间很多1，变为原码时数字会变得很大，因为第二位会是1</span><br><span class="line">0011 …1… 1111 1101</span><br><span class="line"></span><br><span class="line">结果为</span><br><span class="line">1073741821</span><br></pre></td></tr></table></figure>



<p>这里有个很有意思的事情</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8&gt;&gt;&gt;32  -&gt;  8一共只有32为，右移32为结果是不变的，意思是右移32为相当于没移</span><br><span class="line"></span><br><span class="line">8&gt;&gt;&gt;34  -&gt;  8右移了两位</span><br></pre></td></tr></table></figure>





<h4 id="位运算符-1"><a href="#位运算符-1" class="headerlink" title="位运算符"></a>位运算符</h4><h5 id="与"><a href="#与" class="headerlink" title="与&amp;"></a>与&amp;</h5><p>运算规则：对应位都是1才是1，相当于符号左右两边都是true，结果才是true</p>
<p>有个比较抽象的地方</p>
<p>1&amp;1 结果为1</p>
<p>0&amp;0 结果为0</p>
<p>1&amp;0 结果为0</p>
<p>这都很好理解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5&amp;3 结果为1</span><br><span class="line"></span><br><span class="line">用二进制解释一下：</span><br><span class="line">5、3的二进制</span><br><span class="line">0000 0101</span><br><span class="line">0000 0011</span><br><span class="line">同0为0，不同为0，同1为1</span><br><span class="line">0000 0001</span><br><span class="line">因此</span><br><span class="line"></span><br><span class="line">5&amp;3为</span><br><span class="line">0000 0001</span><br><span class="line">结果为1</span><br></pre></td></tr></table></figure>



<h5 id="或"><a href="#或" class="headerlink" title="或|"></a>或|</h5><p>运算规则：</p>
<p>有1则1，同0则0</p>
<p>1|1  &gt;&gt;&gt;&gt;	1</p>
<p>0|1	&gt;&gt;&gt;&gt;	1</p>
<p>0|0	&gt;&gt;&gt;&gt;	0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5|3</span><br><span class="line"></span><br><span class="line">5、3的二进制</span><br><span class="line">0000 0101</span><br><span class="line">0000 0011</span><br><span class="line"></span><br><span class="line">0000 0111</span><br><span class="line">结果为7</span><br></pre></td></tr></table></figure>



<h5 id="异或"><a href="#异或" class="headerlink" title="异或^"></a>异或^</h5><p>运算规则：相同为0，不同为1</p>
<p>1^1		0</p>
<p>0^1		1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5^3</span><br><span class="line"></span><br><span class="line">0000 0101</span><br><span class="line">0000 0011</span><br><span class="line"></span><br><span class="line">0000 0110</span><br><span class="line">结果为6</span><br></pre></td></tr></table></figure>





<h5 id="按位取反"><a href="#按位取反" class="headerlink" title="按位取反"></a>按位取反</h5><p>运算规则：<del>0就是1，</del>1就是0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~10   结果为-11</span><br><span class="line"></span><br><span class="line">10为正数</span><br><span class="line">0000 …0… 0000 1010</span><br><span class="line"></span><br><span class="line">~10</span><br><span class="line"></span><br><span class="line">按位取反后的补码</span><br><span class="line">1111 …1… 1111 0101</span><br><span class="line"></span><br><span class="line">反码</span><br><span class="line">1111 …1… 1111 0100</span><br><span class="line"></span><br><span class="line">原码</span><br><span class="line">1000 …0… 0000 1011</span><br><span class="line"></span><br><span class="line">结果为-11</span><br></pre></td></tr></table></figure>



<h4 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h4><p>1、表达式不要太复杂，有小括号先算小括号里的内容<br>2、</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240602120911121.png" alt="image-20240602120911121"></p>
<h3 id="使用开发工具idea"><a href="#使用开发工具idea" class="headerlink" title="使用开发工具idea"></a>使用开发工具idea</h3><p>idea 的目录结构</p>
<p>一个根目录project（项目）</p>
<p>项目下面会有子文件夹module（模块）</p>
<p>模块下面的文件夹叫做package（包）package需要放到模块文件夹下的src目录下</p>
<p>package取名规范</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">域名倒着写</span><br><span class="line">	比如：www.sdpc.com</span><br><span class="line">	写为：com.sdpc 来创建包</span><br></pre></td></tr></table></figure>



<p>而创建包的时候就会发现com.sdpc不是一个文件夹，而是嵌套文件夹com&#x2F;sdpc</p>
<h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><p>AIt + Enter  快速修复</p>
<p>Ctrl + d   复制粘贴行</p>
<p>Ctrl + k   格式化代码</p>
<p>ctrl  +  &#x2F;   单行注释</p>
<p>Ctrl  + shift   + &#x2F;    多行注释</p>
<p>10.var   可以直接生成等号左边的内容</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>简单的运算符直接省略了</p>
<h4 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、格式</span><br><span class="line">	模式：</span><br><span class="line">		变量++    -&gt;   后自加</span><br><span class="line">		++变量	-&gt;   前自加</span><br><span class="line">		</span><br><span class="line">		变量--    -&gt;   后自减</span><br><span class="line">		--变量	-&gt;   前自减</span><br><span class="line">		</span><br><span class="line">		自增自减只变化1</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">2、使用</span><br><span class="line">	a.单独使用	++   --    单独为一句，不和其他语句混合使用</span><br><span class="line">		i++;</span><br><span class="line">		符号在前在后都是先运算</span><br><span class="line">	b.混合使用</span><br><span class="line">		++  --  和其他语句掺和使用（如：输出语句，赋值语句）</span><br><span class="line">		符号在前：先运算、再使用运算后的值</span><br><span class="line">			int j = 100;</span><br><span class="line">			int i = ++j;</span><br><span class="line">			这个时候分别输出i和j输出结构均为101，先运算</span><br><span class="line">		符号在后：先使用原值，使用原值后再运算</span><br><span class="line">			int x = 10;</span><br><span class="line">			int y = x++;</span><br><span class="line">				这个时候分别输出y和x输出结果分别为10，11，先输出，再运算</span><br></pre></td></tr></table></figure>





<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用：连接多个Boolean结果</span><br><span class="line">结果：Boolean类型</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;（与，和）</td>
<td>有假则假，and</td>
</tr>
<tr>
<td>||（或者）</td>
<td>有真则真，or</td>
</tr>
<tr>
<td>！（非，取反）</td>
<td>取反，true就是false</td>
</tr>
<tr>
<td>^（异或）</td>
<td>结果一样是false，不一样为true</td>
</tr>
</tbody></table>
<p>区别一下单与和双与</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>1、单与，如果前后都是布尔型，有假则假，第一个运算为false时。第二个仍会继续运算<br>2、如果判断的是数字，看作是位运算符，算二进制</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>双与，有假则假，但是有短路效果，第一个运算为false时，会停止运算</td>
</tr>
<tr>
<td>|</td>
<td>1、单或，有真则真，第一个运算为true时。第二个仍会继续运算<br/>2、如果前后都是数字，看作位运算符</td>
</tr>
<tr>
<td>||</td>
<td>双或，有真则真，第一个运算为true时，会停止运算</td>
</tr>
</tbody></table>
<p>可以用代码验证一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 10</span><br><span class="line">int b = 20</span><br><span class="line">boolean c = (++a&gt;100) &amp; (++b&gt;10)</span><br><span class="line">System.out.print(a,b)</span><br><span class="line">//  输出结果位11，21</span><br><span class="line"></span><br><span class="line">boolean c = (++a&gt;100) &amp;&amp; (++b&gt;10)</span><br><span class="line">System.out.print(a,b)</span><br><span class="line">//  输出结果为11，20</span><br></pre></td></tr></table></figure>



<p>Java内使用逻辑运算符拼接各种运算</p>
<h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	boolean 表达式？表达式1:表达式2</span><br><span class="line">	</span><br><span class="line">执行流程：</span><br><span class="line">	先判断，如果是true，则执行表达式1，如果是false则执行表达式2</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">使用三元运算符时</span><br><span class="line">经常会提示我可以使用,Math.max(表达式1，表达式2)的形式来替换三元运算</span><br></pre></td></tr></table></figure>





<h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><h3 id="Scanner键盘录入"><a href="#Scanner键盘录入" class="headerlink" title="Scanner键盘录入"></a>Scanner键盘录入</h3><p>功能相当于python的input，比input麻烦</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、Scanner：Java定义好的一个类</span><br><span class="line">2、作用：将数据通过键盘录入的方式放到代码中参与运行</span><br><span class="line">3、位置：java.util</span><br><span class="line">4、使用：</span><br><span class="line">	a.导包（引入/import）</span><br><span class="line">		import java.util.Scanner;</span><br><span class="line">		位置在类的上面</span><br><span class="line">	b.创建对象</span><br><span class="line">		Scanner 变量名 = new Scanner(System.in);</span><br><span class="line">	c.调用方法</span><br><span class="line">		变量名.nextInt()   输入整数int的</span><br><span class="line">		变量名.next()   输入字符串String的</span><br></pre></td></tr></table></figure>



<p>next 和 nextLine 的区别</p>
<p>next 遇到空格和回车就结束了，不能接收空格</p>
<p>nextLine 遇到回车结束</p>
<p>一个有意思的事情</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjjws.a;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">i</span> <span class="operator">=</span> input.next();</span><br><span class="line">        <span class="type">String</span> <span class="variable">i2</span> <span class="operator">=</span> input.nextLine();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(i2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我只录入了一次，缺分别给i和i2赋值了，因此，尽量不要将next和next Line连起来使用</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240602164324489.png" alt="image-20240602164324489"></p>
<h3 id="Random随机数"><a href="#Random随机数" class="headerlink" title="Random随机数"></a>Random随机数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">random老朋友了</span><br><span class="line">也是Java自带的一个类</span><br><span class="line">位置在：Java.util</span><br><span class="line">使用方法和Scanner类似</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Random</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">date</span> <span class="operator">=</span> sum.nextInt();</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>设置随机范围</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int date = sum.nextInt();</span><br><span class="line">// 和python类似，写一个x 从0开始到x-1结束</span><br></pre></td></tr></table></figure>





<h3 id="流程控制语句-1"><a href="#流程控制语句-1" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	switch(变量)&#123;</span><br><span class="line">		case 常量值1:</span><br><span class="line">			执行语句1;</span><br><span class="line">			break;</span><br><span class="line">			</span><br><span class="line">		case 常量值2:</span><br><span class="line">			执行语句2;</span><br><span class="line">			break;</span><br><span class="line">			</span><br><span class="line">			…………</span><br><span class="line">			</span><br><span class="line">		default:</span><br><span class="line">			执行语句n;</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">执行流程：</span><br><span class="line">	用变量接收的值和下面case后面的常量值匹配，匹配上哪个case就执行哪个case对应的执行语句</span><br><span class="line">	如果都没有匹配上，就执行default对应的语句</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">break：结束关键字</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">switch可以匹配到的数据类型：byte、short、int、char、枚举、String</span><br></pre></td></tr></table></figure>



<p>case有穿透性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果没有break，就会出现case的穿透性，程序就一直往下穿透运行，直到遇到break或者switch代码执行完毕，停止</span><br></pre></td></tr></table></figure>



<h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if的一些操作懒得说了，说点不一样的，第一个如果使用if比较的数据类型为布尔类型，可以只写一个等号</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if两种情况以上的判断</span><br><span class="line">if()&#123;</span><br><span class="line"></span><br><span class="line">&#125; else if()&#123;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 最后不一定使用else但是要保证所有情况都有</span><br></pre></td></tr></table></figure>





<h4 id="switch和if的区别"><a href="#switch和if的区别" class="headerlink" title="switch和if的区别"></a>switch和if的区别</h4><p>打个断点看一下，右键&#x3D;&#x3D;调试&#x3D;&#x3D;，看一下if判断的流程，发现有高亮有暗点，可以发现if从上往下便利到if等于三时，if判断结束，再看一下switch，switch会直接跳到匹配的case</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240602220039241.png" alt="image-20240602220039241"></p>
<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	for(初始化变量;比较;步进表达式)&#123;</span><br><span class="line">		循环语句</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">执行流程：</span><br><span class="line">	a.先走初始化变量</span><br><span class="line">	b.比较如果为true，走循环语句，走步进表达式（初始化变量）</span><br><span class="line">	c.再比较，如果还是true，继续走循环语句，走步进表达式</span><br><span class="line">	d.比较，如果为false，结束</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">先循环，再加一</span><br><span class="line">循环快捷键</span><br><span class="line">次数.fori</span><br></pre></td></tr></table></figure>



<h4 id="do……while循环"><a href="#do……while循环" class="headerlink" title="do……while循环"></a>do……while循环</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	do&#123;</span><br><span class="line">		循环语句；</span><br><span class="line">		步进表达式；</span><br><span class="line">	&#125; while （比较）；</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	1、初始化变量</span><br><span class="line">	2、循环语句</span><br><span class="line">	3、步进表达式</span><br><span class="line">	4、判断循环</span><br><span class="line">	</span><br><span class="line">do……while的特点是至少循环一次，先循环再判断</span><br></pre></td></tr></table></figure>





<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">特点：</span><br><span class="line">	即可以储存基本类型数据，还能引用储存的数据</span><br><span class="line">	定长（定义数组时长度为多长，最多就能存多少数据）</span><br><span class="line">	</span><br><span class="line">	定长是数组最大的特点，也是最大的缺点</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">定义：</span><br><span class="line">	1、动态初始化：在定义数组的时候，我们没有给具体的数据，只指定了长度</span><br><span class="line">		数据类型[] 数组名 = new 数据类型[长度]</span><br><span class="line">		</span><br><span class="line">			等号左边的数据类型：规定了数组中只能存储什么类型的数据</span><br><span class="line">			[]:代表的是数组，一个[]代表一维数组，两个[][]代表二维数组</span><br><span class="line">			new:代表创建数组</span><br><span class="line">			等号右边的数据类型要和左边的数据类型一致</span><br><span class="line">			[长度]：表示数组最多能存贮多少数据</span><br><span class="line">		</span><br><span class="line">	2、静态初始化：在定义数组的时候，我们直接给出数据</span><br><span class="line">		数据类型[] 数组名 = new 数据类型[]&#123;元素1，元素2，……&#125;</span><br><span class="line">		数据类型 数组名[] = new 数据类型[]&#123;元素1，元素2，……&#125;</span><br><span class="line">		</span><br><span class="line">		静态初始化的简化：</span><br><span class="line">			数据类型[] 数组名 = &#123;元素1，元素2，……&#125;</span><br></pre></td></tr></table></figure>





<h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><p>在数组中数据的存储、查询都需要指定索引</p>
<h4 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组名.length</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">	length后面不要带小括号，因为length不是数组中的方法，而是数组中的一个属性</span><br></pre></td></tr></table></figure>



<h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">元素赋值格式</span><br><span class="line">	数组名[索引] = 值</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">获取元素</span><br><span class="line">	数组名[索引]</span><br><span class="line">	</span><br><span class="line">	注意点:</span><br><span class="line">		直接输出数组名，会输出数组在内存中的地址值</span><br><span class="line">		地址值：数组在内存中的一个身份证号，唯一标识，我们可以通过这个唯一标识在内存中找到这个数组，从而操作这个数组中的数据</span><br><span class="line">		</span><br><span class="line">		如果数组中没有数据，那么也是可以获取到默认的数据</span><br><span class="line">		整数：0</span><br><span class="line">		小数：0.0</span><br><span class="line">		字符：&#x27;\u0000&#x27;   对应是int值是0 </span><br><span class="line">		布尔：false</span><br><span class="line">		引用：null</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">遍历数组的快捷方式</span><br><span class="line">数组名.fori</span><br></pre></td></tr></table></figure>

<h4 id="数组操作的常见异常"><a href="#数组操作的常见异常" class="headerlink" title="数组操作的常见异常"></a>数组操作的常见异常</h4><h5 id="数组索引越界异常-ArrayIndexOutOfBoundsException"><a href="#数组索引越界异常-ArrayIndexOutOfBoundsException" class="headerlink" title="数组索引越界异常_ArrayIndexOutOfBoundsException"></a>数组索引越界异常_ArrayIndexOutOfBoundsException</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">操作的索引超过数组的长度范围</span><br><span class="line"></span><br><span class="line">注意Java的索引是没有负数的，不想python那样-1表示倒数第一个元素</span><br></pre></td></tr></table></figure>



<h5 id="空指针异常-NullPinterException"><a href="#空指针异常-NullPinterException" class="headerlink" title="空指针异常_NullPinterException"></a>空指针异常_NullPinterException</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组为null时，再调用此对象中的其他成员</span><br></pre></td></tr></table></figure>





<h4 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">新建一个数组，将老数组的元素赋值给新数组，然后将老数组的地址值改为新数组的地址值</span><br><span class="line"></span><br><span class="line">int[] old = &#123;1,2,3,4,5&#125;</span><br><span class="line">int[] now = new int[10];</span><br><span class="line">for……</span><br><span class="line"></span><br><span class="line">old = now</span><br><span class="line"></span><br><span class="line">但是我就产生了一个问题，新建的数组地址值是多少，去哪了,</span><br><span class="line">结果是，新老两个数组此时的地址值是相同的</span><br></pre></td></tr></table></figure>





<h4 id="内存图"><a href="#内存图" class="headerlink" title="内存图"></a>内存图</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、内存可以理解为“内存条”，所有的软件，程序运行起来都会进入到内存中，占用内存，在Java的世界中，将内存划分为了五块</span><br><span class="line"></span><br><span class="line">2、</span><br><span class="line">	a.栈（重点）（Stack）</span><br><span class="line">		主要运行方法，方法的运行都会进入栈内存运行，运行完毕后，需要“弹栈”，为了腾空间</span><br><span class="line">		</span><br><span class="line">	b.堆（重点）(Heap)</span><br><span class="line">		保存的是对象，数组，每new一次，都会在堆内存中开辟空间，并为这个空间分配一个地址值，堆中的数据都是有默认值的</span><br><span class="line">		整数：0；</span><br><span class="line">		小数：0.0；</span><br><span class="line">		字符：“\u0000”；</span><br><span class="line">		布尔：false；</span><br><span class="line">		引用：null;</span><br><span class="line">		</span><br><span class="line">	c.方法区（重点）（Method Area）</span><br><span class="line">		代码的“预备区”，记录了类的信息以及方法的信息</span><br><span class="line">		方法区中主要保存class文件以及其中的信息</span><br><span class="line">		代码运行之前，需要先进内存（方法区）</span><br><span class="line"></span><br><span class="line">	d.本地方法栈（了解）（Native Method Stack）:专门运行native方法（本地方法）</span><br><span class="line">		本地方法可以理解为堆对Java功能的补充</span><br><span class="line">		有很多功能Java实现不了。所有需要依靠本地方法完成（C语言编写）</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	e.寄存器（了解）（pc register） -&gt; (和CPU有关)</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240603171101185.png" alt="image-20240603171101185"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240603171441822.png" alt="image-20240603171441822"></p>
<p>现在再回顾一下之前的数组扩容操作，新老数组的地址值是一样的，这个时候两个数组同时指向了堆内存的同一个空间，这个时候，更改任意一个数组另一个数组都会变化</p>
<h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：数组中嵌套数组</span><br><span class="line">格式：</span><br><span class="line">	1、动态初始化</span><br><span class="line">		数据类型[][] 数组名 = new 数据类型[m][n]</span><br><span class="line">		数据类型 数组名[][] = new 数据类型[m][n]</span><br><span class="line">		数据类型[] 数组名[] = new 数据类型[m][n]</span><br><span class="line">		</span><br><span class="line">		m：代表的是二维数组的长度</span><br><span class="line">		n：代表的是二维数组内每个一维数组的长度</span><br><span class="line">		</span><br><span class="line">	2、静态初始化</span><br><span class="line">		数据类型[][] 数组名 = new 数据类型[][]&#123;&#123;元素1，元素2……&#125;，&#123;元素1，元素2……&#125;……&#125;</span><br><span class="line">		数据类型 数组名[][] = new 数据类型[][]&#123;&#123;元素1，元素2……&#125;，&#123;元素1，元素2……&#125;……&#125;</span><br><span class="line">		数据类型[] 数组名[] = new 数据类型[][]&#123;&#123;元素1，元素2……&#125;，&#123;元素1，元素2……&#125;……&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	简化静态初始化：</span><br><span class="line">		数据类型[][] 数组名 = &#123;&#123;元素1，元素2……&#125;，&#123;元素1，元素2……&#125;……&#125;</span><br><span class="line">		数据类型 数组名[][] = &#123;&#123;元素1，元素2……&#125;，&#123;元素1，元素2……&#125;……&#125;</span><br><span class="line">		数据类型[] 数组名[] = &#123;&#123;元素1，元素2……&#125;，&#123;元素1，元素2……&#125;……&#125;</span><br></pre></td></tr></table></figure>





<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">之前的所有代码都在main方法中写，如果我们将来所有的功能代码都放到main方法内，会显得main方法代码太多，太乱，不便于维护</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">将对应的代码封装成方法，使用时调用即可</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">	修饰符 返回值类型 方法名（参数）&#123;</span><br><span class="line">		方法体</span><br><span class="line">		return 结果</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">修饰符：public static（这个并不是固定搭配，public表示该成员变量或方法是公开的，可以被任何其他类访问，static表示成员变量或方法是静态的）</span><br><span class="line">返回值类型：</span><br><span class="line">	该方法返回的结果的数据类型，无返回值为 void</span><br><span class="line">	比如：return 1 -&gt; int</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">可以分为四种方法：</span><br><span class="line">	无参无返回值方法</span><br><span class="line">	有参无返回值方法</span><br><span class="line">	无参有返回值方法</span><br><span class="line">	有参有返回值方法</span><br></pre></td></tr></table></figure>



<h3 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">无参无返回值方法</span><br><span class="line"></span><br><span class="line">	public static void 方法名()&#123;</span><br><span class="line">		方法体</span><br><span class="line">	&#125;</span><br><span class="line">	void 方法表示无返回值，写了void就不要写（return 结果）了，只写return是没问题的；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">有参无返回值方法</span><br><span class="line"></span><br><span class="line">	public static void 方法名(数据类型 变量名)&#123;</span><br><span class="line">		方法体</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">无参有返回值方法</span><br><span class="line"></span><br><span class="line">	public static 返回值类型 方法名()&#123;</span><br><span class="line">		方法体</span><br><span class="line">		return 返回值</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">有参有返回值方法</span><br><span class="line"></span><br><span class="line">	public static 返回值类型 方法名(参数)&#123;</span><br><span class="line">		方法体</span><br><span class="line">		return 返回值</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">形式参数（形参）：在定义方法的时候形式上定义的参数，此时参数还没有值</span><br><span class="line">实际参数（实参）：在调用方法的时候给形参赋予的具体的值</span><br></pre></td></tr></table></figure>



<h4 id="三层架构思想"><a href="#三层架构思想" class="headerlink" title="三层架构思想"></a>三层架构思想</h4><p><img src="/../%E5%9B%BE%E7%89%87/image-20240603195815403.png" alt="image-20240603195815403"></p>
<h4 id="数组作为参数"><a href="#数组作为参数" class="headerlink" title="数组作为参数"></a>数组作为参数</h4><p>传递到方法中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义的int[]，就传int[]，就接收int[]</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240603202706652.png" alt="image-20240603202706652"></p>
<p>数据本身是引用数据类型，引用数据类型传入的是地址值</p>
<p>返回值也是数组时，返回值也是地址值</p>
<h4 id="重载方法"><a href="#重载方法" class="headerlink" title="重载方法"></a>重载方法</h4><p>如果，我写一个加法的方法，但是会有不同的需要，比如两个数相加，三个数相加，四个数相加，这个时候再去找哪些定义的那些方法会很麻烦，我们可以通过方法的重载，来达到节省方法名的目的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如：我写一个方法名称是sum，传递两个参数，再写一个方法名称仍然是sum，传递三个参数，以此类推，当我向调用时。只需要传入不同的参数个数，就可以找到相应的方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方法名相同，参数列表不同的方法——重载方法</span><br></pre></td></tr></table></figure>





<p>重载方法主要通过参数的不同来区分，什么叫做参数列表不同</p>
<ul>
<li>参数个数不同</li>
<li>参数类型不同</li>
<li>参数类型顺序不同</li>
</ul>
<p>只要是参数列表不同的，都可以重载，可以共存</p>
<p>判断不可以重载的与什么无关</p>
<ul>
<li>与参数名无关</li>
<li>与返回值无关</li>
</ul>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、面向过程：自己的事情自己干，代表语言C语言</span><br><span class="line"></span><br><span class="line">2、面向对象：自己的事情要别人帮忙干，代表Java</span><br><span class="line">	很多功能都是被封装好的，我们只需要拿过来直接使用即可，简化了编写过程，减少代码量</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">之前使用的获取键盘录入和随机数字就是面向对象的一种体现</span><br><span class="line">这里回忆一下当时的使用方法，可以看到这里是引入，然后赋值，然后创建对象</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjjws.a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetNumGame</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">Random</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sum.nextInt(<span class="number">1</span>,<span class="number">101</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;请输入数字：&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">                <span class="keyword">if</span> (number == num) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;次，恭喜猜对了，答案为&quot;</span>+num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (number &gt; num)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;次，数字偏大了&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;次，数字偏小了&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请输入正确的数字&quot;</span>);</span><br><span class="line">                input.next();</span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240603221549141.png" alt="image-20240603221549141"></p>
<p>通过图片可以发现，这里没有static，只要是定义的时候没有static的，调用时都需要new，如果调用时带static，就不需要new，直接类目即可</p>
<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">类class</span><br><span class="line">	测试类：带main方法，主要是运行代码的</span><br><span class="line">	实体类：是一类事务的抽象表示形式</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">组成部分：</span><br><span class="line">	1、属性（成员变量）（全局变量）</span><br><span class="line">		a.定义位置：类中方法外</span><br><span class="line">		b.作用范围：当前类</span><br><span class="line">		c.定义格式：数据类型 变量名</span><br><span class="line">		d.有默认值</span><br><span class="line">	2、行为（成员方法）</span><br><span class="line">		只需要将static干掉，就是成员方法</span><br></pre></td></tr></table></figure>



<p>对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：一类事物的具体体现</span><br><span class="line">使用：</span><br><span class="line">	1、导包（如果在同一个包下，不需要导包。</span><br><span class="line">		特殊包：使用java.long下的，不需要导包）</span><br><span class="line">	2、创建对象</span><br><span class="line">		用哪个类的成员，就new哪个对象</span><br><span class="line">		类名 对象名 = new 类名（）</span><br><span class="line">	3、调用成员</span><br><span class="line">		想要使用哪个类中的成员，就用哪个类的对象.成员</span><br></pre></td></tr></table></figure>





<h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正常的对象：</span><br><span class="line">	int i = 10</span><br><span class="line">	Random p = new Random()</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">所谓的匿名对象：其实就是没有等号左边的部分，只有等号右边的部分（对象）</span><br><span class="line">使用：</span><br><span class="line">	new 成员()</span><br><span class="line">	</span><br><span class="line">注意，如果只是调用一下方法，可以直接匿名调用，但是如果有赋值操作的话，不能使用这个操作</span><br></pre></td></tr></table></figure>



<h4 id="一个对象调用时的内存图"><a href="#一个对象调用时的内存图" class="headerlink" title="一个对象调用时的内存图"></a>一个对象调用时的内存图</h4><p><img src="/../%E5%9B%BE%E7%89%87/image-20240603225038086.png" alt="image-20240603225038086"></p>
<p>new一下就会在堆中开辟，新的地址，互不干涉</p>
<h4 id="全局变量（成员变量）和局部变量的区别"><a href="#全局变量（成员变量）和局部变量的区别" class="headerlink" title="全局变量（成员变量）和局部变量的区别"></a>全局变量（成员变量）和局部变量的区别</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、定义位置不同</span><br><span class="line">2、初始化值不同</span><br><span class="line">	成员变量有默认值可以不初始化直接使用</span><br><span class="line">	局部变量没有默认值，必须赋值后使用</span><br><span class="line">	</span><br><span class="line">3、作用范围不同</span><br><span class="line"></span><br><span class="line">一二三都很熟悉了，懒得说，还有四五两个事</span><br><span class="line"></span><br><span class="line">4、内存位置不同</span><br><span class="line">	成员变量：在堆中，跟着对象走</span><br><span class="line">	局部变量：在栈中，跟着方法走</span><br><span class="line">	</span><br><span class="line">5、生命周期不同</span><br><span class="line">	成员变量：随着对象的创建而产生，随着对象的消失而消失</span><br><span class="line">	局部变量：随着方法的调用而产生，随着方法的调用完毕而消失</span><br></pre></td></tr></table></figure>





<h3 id="封装思想"><a href="#封装思想" class="headerlink" title="封装思想"></a>封装思想</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">面向对象的三大特征：封装 继承 多态</span><br></pre></td></tr></table></figure>





<h4 id="private隐藏"><a href="#private隐藏" class="headerlink" title="private隐藏"></a>private隐藏</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、问题：</span><br><span class="line">	定义的成员变量，可以拿来随意赋值，哪怕赋值不合理，解决方法呢：</span><br><span class="line">		将属性封装起来（隐藏细节）</span><br><span class="line">		</span><br><span class="line">	关键字：private（私有化的） -&gt; 被private修饰的成员只能在本类中使用，在别的类用不了</span><br><span class="line">	</span><br><span class="line">	注意：将代码放到一个方法中，也是封装的体现</span><br><span class="line">	一个成员被private修饰也是封装的体现，只不过private最具代表性</span><br><span class="line">	</span><br><span class="line">	private的使用：</span><br><span class="line">		修饰成员变量：private 数据类型 变量名</span><br><span class="line">		修饰方法：将public改为private，其他的都一样</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">	这个时候属性被私有化了，外界调用不了，那么此时属性就不能直接赋值取值了，所以需要提供公共的接口</span><br><span class="line">	</span><br><span class="line">	get/set方法</span><br><span class="line">	</span><br><span class="line">	set方法：为属性赋值</span><br><span class="line">	get方法：获取属性值</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjjws.method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pervate</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String Name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String xingMing)</span>&#123;</span><br><span class="line">        Name = xingMing;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Setage</span><span class="params">(<span class="type">int</span> nianling)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nianling &lt; <span class="number">0</span> || nianling &gt; <span class="number">150</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;错误年龄&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            age = nianling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>小结：</p>
<p>  用private将属性封装起来，外界不能直接调用，保护了属性</p>
<p>  对外提供set\get方法，通过公共接口间接使用隐藏起来的属性</p>
<h4 id="this的使用"><a href="#this的使用" class="headerlink" title="this的使用"></a>this的使用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果成员变量和局部变量重名时，遵循就近原则，先找局部变量</span><br><span class="line">this概述：代表的是当前变量</span><br><span class="line">	this可以区分重名的成员变量和局部变量</span><br><span class="line">	this点出来的是成员变量</span><br><span class="line">	</span><br><span class="line">this代表的是哪个对象呢？</span><br><span class="line">	哪个对象调用的this所在的方法，this就代表哪个对象，如下图，如果想要调用到成员变量，需要在选中的name前加一个this，这里的this代表的是Person对象，因为是在Person对象中调用的，所以指向person中的name</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240604222613517.png" alt="image-20240604222613517"></p>
<p>如果在person内打印this，这个时候打印出来的地址值是和person这个对象打印出来的地址值是一样的</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">之前使用的new 类名()</span><br><span class="line">这种形式就是一种构造方法，这个类名就是一种方法，记作类名只是为了好记</span><br><span class="line"></span><br><span class="line">概述：</span><br><span class="line">	方法名和类名一致并且能初始化对象的方法</span><br><span class="line">	</span><br><span class="line">分类：</span><br><span class="line">	无参构造：没有参数</span><br><span class="line">	有参构造：有参数，参数是为指定的属性赋值</span><br><span class="line">	满参构造：给所有属性赋值</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">特点：</span><br><span class="line">	方法名和类名一致</span><br><span class="line">	没有返回值，连void都没有</span><br></pre></td></tr></table></figure>



<h5 id="无参构造"><a href="#无参构造" class="headerlink" title="无参构造"></a>无参构造</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	public 类名()&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">作用：</span><br><span class="line">	new对象使用</span><br><span class="line">	</span><br><span class="line">特点：</span><br><span class="line">	每个类中默认有一个无参构造，不写也有，jvm会自动提供</span><br><span class="line">	</span><br><span class="line">使用：</span><br><span class="line">	之前使用的new 对象就是在调用构造方法</span><br></pre></td></tr></table></figure>



<h5 id="有参构造"><a href="#有参构造" class="headerlink" title="有参构造"></a>有参构造</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	public 类名(参数)&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">作用：</span><br><span class="line">	new对象</span><br><span class="line">	为属性赋值</span><br><span class="line">	</span><br><span class="line">注意：</span><br><span class="line">	jvm不会自动提供有参构造，只能自己写出来，但是如果写上有参构造，那么jvm将不会提供无参构造，所有建议写有参构造的时候把无参构造一起写进去</span><br></pre></td></tr></table></figure>





<h5 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h5><p>JavaBean是Java语言编写类的一种标准规范，符合 <code>JavaBean</code> 的类，要求：</p>
<ul>
<li>类必须是具体的（非抽象abstract  和公共的  public  class 类名）</li>
<li>并且具有无参数的构造方法，有参构造</li>
<li>成员变量私有化，并提供用来操作成员变量的 set 和 get 方法</li>
</ul>
<p>开发的时候需要分包分层：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.…….controller -&gt; 专门放和页面打交道的类（表现层）</span><br><span class="line">com.…….service -&gt; 专门放业务处理的类（业务层）</span><br><span class="line">com.…….dao -&gt; 专门放和数据库打交道的类（持久层）</span><br><span class="line">com.…….pojo -&gt; 专门放JavaBean类</span><br><span class="line">com.…….utils -&gt; 专门放工具类</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">快捷键：</span><br><span class="line">	快速生成标准JavaBean：Alt+insert</span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、将来的JavaBean都是和数据库的表相关联的</span><br><span class="line">	类名 -&gt; 表名</span><br><span class="line">	属性名 -&gt; 列名</span><br><span class="line">	对象 -&gt; 表中每行数据</span><br><span class="line">	属性值 -&gt; 表中单元格的数据</span><br></pre></td></tr></table></figure>



<p>这样的一个JavaBean类</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240605153546987.png" alt="image-20240605153546987"></p>
<p>在其他页面为其添加数据，可以直接调用有参构造</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user user1 = new user(1,&quot;tom&quot;,&quot;111&quot;);</span><br><span class="line">user user1 = new user(2,&quot;joker&quot;,&quot;admin&quot;);</span><br></pre></td></tr></table></figure>



<p>JavaBean添加业务过程</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240605154558597.png" alt="image-20240605154558597"></p>
<p>查询业务过程</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240605164045536.png" alt="image-20240605164045536"></p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static是一个静态关键字</span><br><span class="line">使用：</span><br><span class="line">	a.修饰一个成员变量</span><br><span class="line">	static 数据类型 变量名</span><br><span class="line">	</span><br><span class="line">	b.修饰一个方法</span><br><span class="line">	修饰符 static 返回值类型 方法名(形参)&#123;</span><br><span class="line">		方法体</span><br><span class="line">		return 结果</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">调用静态成员：</span><br><span class="line">	类名直接调用，不需要new对象</span><br><span class="line">	</span><br><span class="line">静态成员特点：</span><br><span class="line">	a.静态成员属于类成员，不属于对象成员（非静态的成员属于对象成员）</span><br><span class="line">	b.静态成员会随着类的加载而加载</span><br><span class="line">	c.静态成员优先于非静态成员存在于内存中</span><br><span class="line">	d.凡是根据静态成员所在的类创建出来的对象，都可以共享这个静态成员</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240605170403893.png" alt="image-20240605170403893"></p>
<p>静态成员在内存中的说明</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240605170719595.png" alt="image-20240605170719595"></p>
<h5 id="static修饰成员的访问特点"><a href="#static修饰成员的访问特点" class="headerlink" title="static修饰成员的访问特点"></a>static修饰成员的访问特点</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意一下静态成员的特点，思考一下</span><br><span class="line">1、在静态方法中能直接访问非静态成员吗？ F</span><br><span class="line">	想要调用的时候使用new对象调用</span><br><span class="line"></span><br><span class="line">2、在非静态方法中能直接访问静态成员吗？ Y</span><br><span class="line"></span><br><span class="line">3、在静态方法中能直接访问静态成员吗？ Y</span><br><span class="line">	同类：</span><br><span class="line">		直接调用</span><br><span class="line">		类名调用（new对象调用）</span><br><span class="line">	不同类：</span><br><span class="line">		类名调用</span><br><span class="line"></span><br><span class="line">4、在非静态方法中能直接访问非静态成员吗？ Y</span><br><span class="line">	同类：</span><br><span class="line">		直接调用</span><br><span class="line">		类名调用</span><br><span class="line">	不同类：</span><br><span class="line">		类名调用</span><br></pre></td></tr></table></figure>



<p>思考一</p>
<p>显然易见静态成员先加载，是不能直接调用的，但是可以另辟蹊径，这是访问自己的非静态，访问别人的非静态流程相同都是new对象</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240605171901185.png" alt="image-20240605171901185"></p>
<p>思考二</p>
<p>显然可以，后来者调用前者没啥毛病，直接调，如果是掉别人的静态方法，直接点出来，不用new对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">总结：</span><br><span class="line">	不管在不在同一个类当中，非静态成员都可以new对象调用</span><br><span class="line">	不管在不在同一个类当中，静态成员都可以类名调用</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">注意，不要将所有的成员都定义为静态成员</span><br><span class="line">	因为静态成员会随着类的加载而加载，如果将所有的成员都变为静态的，那么类一加载，所有的静态成员都会进入内存，占用大量空间</span><br><span class="line">	</span><br><span class="line">	一般情况下，我们在抽取工具类的时候可以将工具类中的所有成员定义为静态的</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">那么什么时候定义工具类？</span><br><span class="line">	比如在写代码的时候，发现很多功能反复使用，那么就可以把这个功能定义</span><br></pre></td></tr></table></figure>



<p>构建工具类时注意</p>
<p>构造方法使用private修饰，工具类中的成员都是静态的，静态成员都是类名调用，不需要new对象，所以工具类的构造方法都是用private修饰</p>
<p>如果构造方法被private修饰，那么在别的类中，就不能利用构造方法new对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjjws.stati;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ArrayUtils</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max &lt;= arr[i]) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="定义可变参数"><a href="#定义可变参数" class="headerlink" title="定义可变参数"></a>定义可变参数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法参数配置，只明确了参数的类型，但是不明确参数个数，此时就可以定义可变参数</span><br><span class="line"></span><br><span class="line">定义格式：</span><br><span class="line">	数据类型...变量名</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">参数位置不能写多个可变参数，可变参数和其他参数一起使用时，可变参数要放在最后</span><br><span class="line">可变参数的本质是一个数组</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240605175519804.png" alt="image-20240605175519804"></p>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：</span><br><span class="line">	方法内部自己调用自己；</span><br><span class="line">	</span><br><span class="line">分类：</span><br><span class="line">	直接递归：</span><br><span class="line">		public static void method()&#123;</span><br><span class="line">			method</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	间接递归：</span><br><span class="line">		A调B，B调C，C调A</span><br><span class="line">		</span><br><span class="line">注意：</span><br><span class="line">	递归必须要有出口，否则会出现“栈内存溢出”</span><br><span class="line">	就算有出口，也不要调用次数太多，使用return结束方法。</span><br></pre></td></tr></table></figure>





<h4 id="数组翻转"><a href="#数组翻转" class="headerlink" title="数组翻转"></a>数组翻转</h4><p>Java中并没有数组翻转的封装方法，需要自己敲一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	int[] arr = &#123;1,2,3,4,5,6,7&#125;</span><br><span class="line">	for (int min = 0, max = arr.length-1; min&lt;max; min++ ; max--)&#123;</span><br><span class="line">		int temp = arr[min];</span><br><span class="line">		arr[min] = arr[max];</span><br><span class="line">		arr[max] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 左手导右手</span><br></pre></td></tr></table></figure>



<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="&#x3D;&#x3D;冒泡排序&#x3D;&#x3D;"></a>&#x3D;&#x3D;冒泡排序&#x3D;&#x3D;</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一种按照从小到大，或者从大到小的方法</span><br><span class="line"></span><br><span class="line">	for(int j = 1; j &lt; arr.length; j++)&#123;</span><br><span class="line">		for(int i = 0; i &lt; arr.length-j; i++)&#123;</span><br><span class="line">			if(arr[i]&gt;arr[i+1])&#123;</span><br><span class="line">				int temp = arr[i];</span><br><span class="line">				arr[i] = arr[i+1];</span><br><span class="line">				arr[i+1] = arr[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前提：数组中的数据必须是有序的</span><br><span class="line">查询思想：</span><br><span class="line">	老式查询：遍历数组，一个个比较 -&gt; 查询效率比较慢</span><br><span class="line">	二分查找：每次找中间索引对应的元素进行比较查询（每一次查询少一半数据）</span><br></pre></td></tr></table></figure>

<p>二分顾名思义，再加上数组中的数据是有序的，所以就很好理解</p>
<p>找中间索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int min = 0;</span><br><span class="line">int max = arr.length-1;</span><br><span class="line">int mid = (min + max)/2;</span><br><span class="line"></span><br><span class="line">// 因为这个中间索引是需要不断变化的，留个容器</span><br><span class="line"></span><br><span class="line">第一次二分没找到后，再找中间索引</span><br><span class="line"></span><br><span class="line">min = mid + 1;    或者     max = mid - 1;</span><br><span class="line">mid = (min + max)/2;</span><br></pre></td></tr></table></figure>



<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binary</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> data)</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr.length-<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(min&lt;=max)&#123;</span><br><span class="line">		mid = (min+max)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (data&gt;arr[mid])&#123;</span><br><span class="line">			min = mid + <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(data&lt;arr[mid])&#123;</span><br><span class="line">			max = mid - <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写一个封装方法，person，随便封装一个姓名年龄就行</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	创建int、double、String等数组的时候对需要</span></span><br><span class="line"><span class="comment">	int[] 变量名 = new int[x]</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	以此类推，我想定义一个对象数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	person[] arr = <span class="keyword">new</span> <span class="title class_">person</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建对象</span></span><br><span class="line">	<span class="type">person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">	<span class="type">person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">18</span>);</span><br><span class="line">	<span class="type">person</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保存到数组中</span></span><br><span class="line">	arr[<span class="number">0</span>] = p1;</span><br><span class="line">	arr[<span class="number">1</span>] = p2;</span><br><span class="line">	arr[<span class="number">2</span>] = p3;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240605212357849.png" alt="image-20240605212357849"></p>
<h4 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h4><h5 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h5><p>方法进栈是有一个压栈动作的，越早进入的在栈底，方法运行完毕，会进行一个弹栈动作</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240605213400036.png" alt="image-20240605213400036"></p>
<p>看一下上面的代码，基本数据类型当作实参传递时，只会传递值，不会传递变量本身，method方法执行完毕后，再输出a和b的值，还是main方法中的a和b的值，并没有什么变化</p>
<h5 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">引用数据类型作为方法传递是会被影响的，因为传参传的是数组的地址值，是整个数组的内存空间，并不是基本数据类型的那种值，因此，传递引用数据类型，在方法内改变数据，到main方法中，数组也会改变，因为两个方法操作的是同一个数组</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240605214015132.png" alt="image-20240605214015132"></p>
<h5 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h5><p>命令行参数是给main方法中的args传参</p>
<p>第一种方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用原始的命令行</span><br><span class="line">javac 文件名.java</span><br><span class="line">Java 文件名 hello world</span><br><span class="line"></span><br><span class="line">// 通过这样的方式就给main传了两个参数，一个是hello，另一个是world</span><br></pre></td></tr></table></figure>



<p>IDEA中也可以手动配置参数</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240605214750649.png" alt="image-20240605214750649"></p>
<h4 id="debug调试"><a href="#debug调试" class="headerlink" title="debug调试"></a>debug调试</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">能清楚的看到每个变量在代码执行过程中的变化，便于寻找错误</span><br><span class="line">使用：</span><br><span class="line">	点击出现断点</span><br></pre></td></tr></table></figure>





<h2 id="Java下"><a href="#Java下" class="headerlink" title="Java下"></a>Java下</h2><p>内容还是面向对象里的继承的内容</p>
<h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义了多个类，发现这些类有很多重复性代码，我们就定义了一个父类，将相同的代码抽取出来放到父类中，其他的类直接继承这个父类，就可以直接使用父类的内容了</span><br><span class="line"></span><br><span class="line">如何继承：</span><br><span class="line">	子类 extends 父类</span><br><span class="line">	</span><br><span class="line">注意：</span><br><span class="line">	子类可以继承父类中私有和非私有成员，但是不能使用父类中私有成员</span><br><span class="line">	构造方法不能继承</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">继承不要从是否“拥有”方面来学习，要从是否能“使用方面来学习”</span><br></pre></td></tr></table></figure>





<h4 id="继承的使用"><a href="#继承的使用" class="headerlink" title="继承的使用"></a>继承的使用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义一个父类，写入重复使用的代码</span><br><span class="line">定义一个子类 -&gt; 继承</span><br><span class="line">	子类 extends 父类</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240606173648473.png" alt="image-20240606173648473"></p>
<h4 id="继承中成员访问特点"><a href="#继承中成员访问特点" class="headerlink" title="继承中成员访问特点"></a>继承中成员访问特点</h4><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建父类对象，可以使用父类的数据。但是不能使用子类的数据</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">	看等号左边是谁，先调用谁中的成员，子类没有，找父类</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240606204111385.png" alt="image-20240606204111385"></p>
<p>父类对象不能调用子类对象的数据，子类可以继承调用父类非私有的数据，如果有重名的数据，子类先拿到自己的数据，如果自己没有才拿到父类的数据</p>
<p>这个思想在多态内也适用</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240606211249275.png" alt="image-20240606211249275"></p>
<p>这个时候拿父对象来new一个子，很迷的操作，我也不清楚，但是，从打印可以看到，打印了10000，是父类型里面的num，可以总结，先拿的数据是等号左边的相同类型</p>
<h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><p>以上是对成员变量的操作，下面是成员方法，方法与其相反，看new后面的是谁，就先调用谁的方法</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240606212442130.png" alt="image-20240606212442130"></p>
<h4 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：子类中有一个和父类方法名以及参数列表相同的方法</span><br><span class="line">前提：继承</span><br><span class="line">访问：看new的是谁，先调用谁中的，如果new的是子类，调用子类重写的方法，子类没有，找父类</span><br><span class="line">检测是否有重写方法：在该方法上写</span><br><span class="line">	@Override</span><br><span class="line">	如果不报错说明是一个重写方法</span><br><span class="line">	</span><br><span class="line">使用场景：</span><br><span class="line">	功能升级改造，子类需要对父类已经实现好的功能进行重新改造</span><br></pre></td></tr></table></figure>



<p>之前举例子访问成员方法时就涉及方法的重写</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240606215302104.png" alt="image-20240606215302104"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意事项：</span><br><span class="line">	子类重写父类方法后，权限必须要保证大于等于父类权限</span><br><span class="line">	权限修饰符： public -&gt; protected -&gt; 默认(default) -&gt; private</span><br><span class="line">	</span><br><span class="line">	重写方法：方法名和参数列表要一样</span><br><span class="line">	私有方法不能被重写，构造方法不能被重写，静态方法static不能被重写</span><br></pre></td></tr></table></figure>

<p>不写修饰符就是default，但是也不能写public权限最大</p>
<h4 id="super和this"><a href="#super和this" class="headerlink" title="super和this"></a>super和this</h4><p>new子类时，会首先默认执行一个父类无参构造</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240607145638128.png" alt="image-20240607145638128"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原因：</span><br><span class="line">	每个构造方法的第一行，都默认有一个super()，不写jvm自动提供</span><br><span class="line">	super()代表的是父类的无参构造</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">super()的具体使用</span><br><span class="line">	概述：代表的是父类引用</span><br><span class="line">	</span><br><span class="line">	作用：可以调用父类中的成员</span><br><span class="line">	</span><br><span class="line">	使用：既然是调用父类的东西，肯定就是在子类中调用了</span><br><span class="line">		1、调用父类构造方法</span><br><span class="line">			super() -&gt; 调用无参构造</span><br><span class="line">			super(实参) -&gt; 调用有参构造</span><br><span class="line">			</span><br><span class="line">		2、调用父类成员变量</span><br><span class="line">			super.成员变量名</span><br><span class="line">			</span><br><span class="line">		3、调用父类成员方法</span><br><span class="line">			super.成员方法名</span><br></pre></td></tr></table></figure>

<p>感觉super和this类似，this指向当前对象，super指向继承的父对象</p>
<p>this的具体使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this：代表的是当前对象</span><br><span class="line">作用：</span><br><span class="line">	区分重名的成员变量和局部变量</span><br><span class="line">	调用当前对象中的成员</span><br><span class="line">使用：</span><br><span class="line">	调用当前对象的构造：在构造中写</span><br><span class="line">	this()</span><br><span class="line">	this(实参)</span><br><span class="line">	</span><br><span class="line">	调用当前对象的成员变量：</span><br><span class="line">		this.成员变量名</span><br><span class="line">		</span><br><span class="line">	调用当前对象的成员方法</span><br><span class="line">		this.成员方法名</span><br></pre></td></tr></table></figure>



<p>super和this都是写在第一行的，因此两者&#x3D;&#x3D;不能同时出现&#x3D;&#x3D;</p>
<h4 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">继承只支持单继承，不能多继承（就是一个子类不能有多个父类）</span><br><span class="line">	public class A extends B&#123;&#125;</span><br><span class="line">	</span><br><span class="line">但是可以多层继承</span><br><span class="line">	public class B extends C&#123;&#125;</span><br><span class="line">	</span><br><span class="line">一个父类可以有多个子类</span><br><span class="line"></span><br><span class="line">构造方法不能继承，也不能重写</span><br><span class="line">私有方法可以继承，但是不能被重写</span><br><span class="line">静态方法可以继承，但是不能重写</span><br></pre></td></tr></table></figure>





<p>之前说私有属性，可以继承但是不能直接使用，那么应该如何使用呢？</p>
<p>成员变量：</p>
<p>利用父对象的get&#x2F;set方法</p>
<p>利用构造方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在子类中定义构造方法：</span><br><span class="line">	public zi(name,age)&#123;</span><br><span class="line">		super(name,age)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>这个super相当于调用了父对象的构造方法，原理就是子类的有参构造层层调用</p>
<h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>将共有的方法抽取出来，形成父类，但是抽取出来的这个方法方法体没法确定，此时该方法不用写方法体了，没有方法体的方法，可以定义成抽象方法</p>
<p>1、抽象类怎么来的？抽取共性方法，放到父类中，发现方法没办法确定具体实现，因为每个子类对此方法的实现不一样，此时方法体无法确定，就可以定位成抽象方法</p>
<p>&#x3D;&#x3D;抽象方法所在的类必须是抽象类&#x3D;&#x3D;</p>
<p>继承到子类后再重写抽象方法</p>
<p>2、关键字：&#x3D;&#x3D;abstract&#x3D;&#x3D;</p>
<p>3、定义抽象方法</p>
<p>​	修饰符 abstract 返回值类型 方法名(参数);</p>
<p>4、抽象类：</p>
<p>​	public abstract class 类名{}</p>
<p>5、注意：</p>
<p>​	抽象方法所在的类一定是抽象类</p>
<p>​	抽象类中不一定非得有抽象方法</p>
<p>​	子类继承抽象父类时，需要重写父类中所有的抽象方法，不然编译报错</p>
<p>​	抽象类不能new对象，只能通过new子类对象去调用重写的方法</p>
<p>6、可以将抽象类看成是一类事物的标准，要求只要是属于这一个类的，都必须要拥有抽象类中的方法，必须要实现</p>
<h5 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、抽象类不能直接new对象，只能创建非抽象子类的对象</span><br><span class="line">2、抽象类中不一定非得有抽象方法，但是有抽象方法一定是抽象类</span><br><span class="line">3、抽象类的子类必须重写父类中的所有抽象方法，除非子类也是抽象类</span><br><span class="line">4、抽象类中可以有成员变量，构造方法，成员方法</span><br><span class="line">5、抽象类中的构造方法不是为了new对象的，是供子类创建对象时，初始化父类属性使用的。使用需要利用super</span><br></pre></td></tr></table></figure>



<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>1、是一个引用数据类型，是一种标准、规则</p>
<p>2、关键字：</p>
<p>​	 a.interface 接口</p>
<p>​		public interface 接口名{}</p>
<p>​	b.implements 实现</p>
<p>​		实现类 implements 接口名{}</p>
<p>3、接口中可以定义的成员：</p>
<p>​	a.jdk7以及之前：</p>
<p>​		抽象方法：public abstract   -&gt;  即使不写public abstract，默认也是抽象方法</p>
<p>​		成员变量：public static final 数据类型名 变量名 &#x3D; 值  -&gt;  即使不写，默认写</p>
<p>​			final是最终的，被final修饰的变量不能二次赋值，所有final修饰的变量也可以看作常量</p>
<p>​	b.jdk8</p>
<p>​		默认方法：public default 返回值类型 方法名(形参){}</p>
<p>​		静态方法：public static 返回值类型 方法名(形参){}</p>
<p>​	c.jdk9开始</p>
<p>​		私有方法：private（用的不多）</p>
<p>接口的使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、定义接口：</span><br><span class="line">	public interface 接口名&#123;&#125;</span><br><span class="line">2、实现：</span><br><span class="line">	public class 实现类类名 implements 接口名&#123;&#125;</span><br><span class="line">3、使用：</span><br><span class="line">	a.实现类实现接口</span><br><span class="line">	b.重写接口中的抽象方法</span><br><span class="line">	c.创建实现类对象（接口不能直接new对象）</span><br><span class="line">	d.调用重写方法</span><br></pre></td></tr></table></figure>



<p>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.sjjws.j_interface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">USB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口，重写方法</span></span><br><span class="line"><span class="comment">// 这里按照规范，实现类应该取名为xxImpl</span></span><br><span class="line"><span class="keyword">package</span> com.sjjws.j_interface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Monse</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用接口</span></span><br><span class="line"><span class="keyword">package</span> com.sjjws.j_interface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_">Monse</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Monse</span> <span class="variable">mouses</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Monse</span>();</span><br><span class="line">        mouses.open();</span><br><span class="line">        mouses.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="接口中的成员"><a href="#接口中的成员" class="headerlink" title="接口中的成员"></a>接口中的成员</h3><h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><p>上方的示例代码就是对抽象方法的使用</p>
<h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	public default 返回值类型 方法名(形参)&#123;</span><br><span class="line">		方法体</span><br><span class="line">		return 结果</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">使用：</span><br><span class="line">	a.实现定义类，实现接口</span><br><span class="line">	b.默认方法可以不重写</span><br><span class="line">	c.创建实现类对象，调用默认方法</span><br></pre></td></tr></table></figure>



<p>默认方法直接调用即可，如果默认方法需要重写的话，需要将default去掉，default只能在接口中使用，去除default仍然是重写方法</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240704183926597.png" alt="image-20240704183926597"></p>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	public static 返回值类型 方法名(形参)&#123;</span><br><span class="line">		方法体</span><br><span class="line">		return 结果</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">使用：</span><br><span class="line">	接口名直接调用</span><br></pre></td></tr></table></figure>



<p>直接使用接口名.静态方法调用</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240704184415375.png" alt="image-20240704184415375"></p>
<p>静态方法和默认方法主要是用于临时添加一个小功能使用，因为如果添加为抽象方法，所有与接口有关的类都会报错，需要重写</p>
<h4 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	public static final 数据类型 变量名 = 值</span><br><span class="line"></span><br><span class="line">final是最终的，被final修饰的变量不能二次赋值，所以final修饰的变量也可以看作常量</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">	不写public static final默认也有，调用和静态方法相同直接接口名调用</span><br><span class="line">	注意呢，变量必须要有值，因为是不能二次赋值的</span><br><span class="line">	习惯呢，将final修饰的变量名改为大写</span><br></pre></td></tr></table></figure>



<h3 id="接口的特点"><a href="#接口的特点" class="headerlink" title="接口的特点"></a>接口的特点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、接口可以多继承 -&gt; 一个接口可以继承多个接口</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceA</span> <span class="keyword">extends</span> <span class="title class_">InterfaceB</span>,InterfaceC&#123;&#125;</span><br><span class="line"><span class="number">2</span>、接口可以多实现 -&gt; 一个实现类可以实现一个或者多个接口</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceImpl</span> <span class="keyword">implements</span> <span class="title class_">InterfaceA</span>,InterfaceB&#123;&#125;</span><br><span class="line"><span class="number">3</span>、一个子类可以继承一个父类的同时实现一个或者多个结果</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> exthends Fu <span class="keyword">implements</span> <span class="title class_">InterfaceA</span>,InterfaceB&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、注意</span><br><span class="line">    继承、实现接口，只要是父类中或者接口的抽象方法，子类或者实现类都需要重写</span><br></pre></td></tr></table></figure>

<p>特殊情况：</p>
<p>​	当一个类实现多个接口时，如果接口中的抽象方法重名且变量名相同时，只需要重写一次</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240704211741799.png" alt="image-20240704211741799"></p>
<p>​	当一个类实现多个接口时，如果多个接口中默认方法有重名的，且参数一样的，必须重写一次默认方法</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240704212445576.png" alt="image-20240704212445576"></p>
<h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相同点：</span><br><span class="line">	a.都位于继承体系的顶端，用于被其他类实现或者继承</span><br><span class="line">	b.都不能new</span><br><span class="line">	c.都包含抽象方法，其子类或者实现类都必须重写这些抽象方法</span><br><span class="line">	</span><br><span class="line">不同点：</span><br><span class="line">	a.抽象类：一般作为父类使用，可以有成员变量，构造，成员方法，抽象方法等</span><br><span class="line">	b.接口：成员单一，一般抽取接口，抽取的都是方法，视为功能的大集合</span><br><span class="line">	c.类不能多继承，但接口可以</span><br></pre></td></tr></table></figure>

<p>接口内一般定义只有抽象方法，偏向于功能的大集合，抽象类内什么都可以有</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>不要从字面意思上来理解多态，要从使用形式上来掌握</p>
<p>要知道多态的好处和前提</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前提：</span><br><span class="line">	1、必须有子父类继承或者接口实现关系</span><br><span class="line">	2、必须有方法的重写（没有重写，多态没有意义），多态玩的就是重写方法</span><br><span class="line">	3、new对象：父类引用指向子类对象</span><br><span class="line">		之前也这么使用过一次</span><br><span class="line">		Fu fu = new zi() -&gt; 大致理解为大类型接收了应该小类型数据</span><br><span class="line">	注意：</span><br><span class="line">		多态下不能直接调用子类特有功能</span><br></pre></td></tr></table></figure>



<p>回忆一下</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240704214535249.png" alt="image-20240704214535249"></p>
<p>理解一下</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240704215758742.png" alt="image-20240704215758742"></p>
<h3 id="多态下成员访问的特点"><a href="#多态下成员访问的特点" class="headerlink" title="多态下成员访问的特点"></a>多态下成员访问的特点</h3><p>成员访问特点已经回忆完了</p>
<p>成员变量：</p>
<p>&#x3D;&#x3D;看等号左边是谁，先调用谁中的变量&#x3D;&#x3D;</p>
<p>成员方法：</p>
<p>&#x3D;&#x3D;看new的是谁，先带哦有谁中的成员方法&#x3D;&#x3D;</p>
<h3 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">问题：</span><br><span class="line">	如果使用原始方式new对象，既能调用重写的，还能调用继承的，还能调用自己特有的成员，但是多态方式new对象，只能调用重写的，不能直接调用子类特有的成员，那么为什么还要用多态</span><br><span class="line">	</span><br><span class="line">多态和原始方式的优缺点：</span><br><span class="line">	原始方式：</span><br><span class="line">		优点：既能调用重写的，还能调用继承的，还能调用自己特有的成员</span><br><span class="line">		缺点：扩展性差（主要是方法参数传递方面，会加大代码量）</span><br><span class="line">		</span><br><span class="line">	多态形式：</span><br><span class="line">		优点：扩展性强</span><br><span class="line">		缺点：不能直接调用子类特有功能</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240704224134475.png" alt="image-20240704224134475"></p>
<p>说一下我自己的感觉，多态的这个优点适用于同一个给方法很多人都在用，但是只有几个数不一样，是不是感觉很熟悉，微信小程序中的idx，解决大量重复代码的</p>
<p>形参传递父类类型，调用此方法父类类型可以接收任意他的子类对象</p>
<p>传递哪个子类对象，就指向哪个子类对象，就调用哪个子类对象重写的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">zi</span> <span class="variable">zi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">zi</span>()</span><br><span class="line">method(zi)</span><br><span class="line"><span class="comment">//虽然这里没有用到多态传递子类对象，但是！</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(fu fu)</span>&#123;</span><br><span class="line">    <span class="comment">// 子类对象传递到方法内，相当于是写了一个</span></span><br><span class="line">    <span class="comment">// fu fu = new zi();</span></span><br><span class="line">    fu.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="多态中的转型"><a href="#多态中的转型" class="headerlink" title="多态中的转型"></a>多态中的转型</h3><p>哎，就是想用多态调用子类特有方法怎么办？</p>
<h4 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">就好比是：double b = 1;</span><br><span class="line">表现方式：</span><br><span class="line">	父类类型 对象名1 = new 子类对象()</span><br></pre></td></tr></table></figure>



<h4 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">好比是：int i = (int)b  强转</span><br><span class="line">表现方式：</span><br><span class="line">	子类类型 对象名2 = (子类类型)对象名1</span><br></pre></td></tr></table></figure>



<p>想要调用子类特有功能就需要用到向下转型了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">fu</span> <span class="variable">name1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">zi</span>();</span><br><span class="line"><span class="type">zi</span> <span class="variable">name2</span> <span class="operator">=</span> (zi)name1</span><br><span class="line">name2.xxx(特有功能)</span><br></pre></td></tr></table></figure>



<h4 id="向下转型问题"><a href="#向下转型问题" class="headerlink" title="向下转型问题"></a>向下转型问题</h4><p>这个时候呢，由于强转是会出现一些问题的：如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">zii</span> <span class="variable">zii</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">zii</span>();</span><br><span class="line">        method(zii);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(fu fu)</span> &#123;</span><br><span class="line">        fu.eat();</span><br><span class="line"></span><br><span class="line">        <span class="type">zi</span> <span class="variable">zi</span> <span class="operator">=</span> (zi) fu;</span><br><span class="line">        zi.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码运行起来，会出现类型转换异常（ClassCastException）</p>
<p>当调用method时，传递zii对象，然后由fu向上转换成fu类型，但是方法中，将代表zii对象的fu强转成了zi</p>
<p>此时等号左右两边 不一样，所有出现了类型转换异常</p>
<p>解决方法也很简单，在向下转型之前，判断一下类型即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用关键字：instanceof</span><br><span class="line">判断结果为布尔型</span><br><span class="line">使用：</span><br><span class="line">	对象名 instanceof 类型</span><br><span class="line">	判断的是关键字前面的对象是否符合关键字后面的类型</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fu <span class="keyword">instanceof</span> zi)&#123;</span><br><span class="line">    <span class="type">zi</span> <span class="variable">zi</span> <span class="operator">=</span> (zi) fu;</span><br><span class="line">    zi.work();<span class="comment">//特有方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (fu <span class="keyword">instanceof</span> zii)&#123;</span><br><span class="line">    <span class="type">zii</span> <span class="variable">zii</span> <span class="operator">=</span> (zii) fu;</span><br><span class="line">    zii.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><p>Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限</p>
<ul>
<li>public：公共的，最高权限，被public修饰的成员，在哪里都能访问</li>
<li>protected：受保护的</li>
<li>default：默认的 注意 不写权限修饰符就是默认权限，不能直接将default写出来，只有在接口中可以用default</li>
<li>private：私有的，只能在自己的类中直接访问</li>
</ul>
<p>只需要知道一个成员被这四个权限修饰符修饰在四种情况下能不能访问就行了</p>
<table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>default</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>同类</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>同包不同类</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>不同包子父类</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>不同包非子父类</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
</tbody></table>
<p>public具有最大权限，private具有最小权限</p>
<p>如果没有特殊考虑的话</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、属性：用private -&gt; 封装思想</span><br><span class="line">2、成员方法：用public -&gt; 便于调用</span><br><span class="line">3、构造public -&gt; 便于new对象</span><br></pre></td></tr></table></figure>



<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final：最终的</span><br><span class="line">使用：</span><br><span class="line">	修饰一个类</span><br><span class="line">	修饰一个方法</span><br><span class="line">	修饰一个局部变量</span><br><span class="line">	修饰一个成员变量</span><br><span class="line">	修饰一个对象</span><br><span class="line">	</span><br><span class="line">只需要知道被final修饰之后的特点即可</span><br></pre></td></tr></table></figure>



<h4 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	public final class 类名&#123;&#125;</span><br><span class="line">	</span><br><span class="line">特点：</span><br><span class="line">	太监类，不能被继承，没后代</span><br></pre></td></tr></table></figure>



<h4 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	修饰符 final 返回值类型 方法名(形参)&#123;</span><br><span class="line">		方法体</span><br><span class="line">		return 结果</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">特点：</span><br><span class="line">	被final修饰的方法，不能被重写</span><br><span class="line">	</span><br><span class="line">注意：</span><br><span class="line">	final和abstract两个关键字冲突不能同时使用</span><br></pre></td></tr></table></figure>



<h4 id="修饰局部变量"><a href="#修饰局部变量" class="headerlink" title="修饰局部变量"></a>修饰局部变量</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	final 数据类型 变量名 = 值</span><br><span class="line">	</span><br><span class="line">特点：</span><br><span class="line">	被final修饰的变量不能二次赋值</span><br><span class="line">	</span><br><span class="line">	final int i = 10;</span><br><span class="line">	&amp;&amp;</span><br><span class="line">	final int j;</span><br><span class="line">	j = 100;</span><br><span class="line">	</span><br><span class="line">	这都属于一次赋值</span><br></pre></td></tr></table></figure>



<h4 id="修饰对象"><a href="#修饰对象" class="headerlink" title="修饰对象"></a>修饰对象</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	final 数据类型 对象名 = new 对象()</span><br><span class="line">	</span><br><span class="line">特点：</span><br><span class="line">	被final修饰的对象，地址值不能改变。但是对象中的属性值可以改变</span><br></pre></td></tr></table></figure>



<p>举个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>)</span><br><span class="line">	System.out.println(p1);</span><br><span class="line">    p1 = <span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">10</span>)</span><br><span class="line">    System.out.println(p1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个时候输出p1的地址值是不同的，因为new了对象，所以说</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> <span class="type">person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>)</span><br><span class="line">	System.out.println(p1);</span><br><span class="line">    p1 = <span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">10</span>)</span><br><span class="line">    System.out.println(p1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个操作是报错的，因为地址值改变了，但是final修饰的对象，是可以使用set/get方法来更改数值的，这种方法并不会更改地址值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> <span class="type">person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>)</span><br><span class="line">	System.out.println(p1);</span><br><span class="line">	p1.setName(<span class="string">&quot;李四&quot;</span>)</span><br><span class="line">    p1.setAge(<span class="number">10</span>)</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 这样的操作是合法的</span></span><br></pre></td></tr></table></figure>



<h4 id="修饰成员变量"><a href="#修饰成员变量" class="headerlink" title="修饰成员变量"></a>修饰成员变量</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	final 数据类型 变量名 = 值</span><br><span class="line">	</span><br><span class="line">特点：</span><br><span class="line">	1、需要手动赋值</span><br><span class="line">	2、不能二次赋值</span><br></pre></td></tr></table></figure>



<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><h4 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	&#123;</span><br><span class="line">		代码</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">特点：</span><br><span class="line">	构造代码块优先于无参构造方法执行</span><br><span class="line">	每new一个执行一次</span><br></pre></td></tr></table></figure>



<h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	static&#123;</span><br><span class="line">		代码</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">特点：</span><br><span class="line">	静态代码块优先于构造代码块执行</span><br><span class="line">	只执行一次</span><br></pre></td></tr></table></figure>



<p>静态代码块的使用更加广泛，他常用于需要有限执行，但是只需要执行一次的情况</p>
<p>小小的拓展一下</p>
<p>Java操作数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、注册驱动</span><br><span class="line">2、初始化操作数据库的地址</span><br><span class="line">3、初始化数据库用户名</span><br><span class="line">4、初始化数据库密码</span><br></pre></td></tr></table></figure>

<p>这些东西都是需要放到静态代码块内的</p>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">什么时候使用内部类：	</span><br><span class="line">	当一个事物内部，还有一个部分需要完整的结构去描述，而这个内部的完整结构又只为外部事物提供服务，那么整个内部的完成结构最好使用内部类</span><br><span class="line">	</span><br><span class="line">	比如：组织-器官-个体，人体本事具有一定属性，需要去描述，人体内部的一些器官也有一定的特殊属性和行为，这个时候，器官就可以看作人体中的一个内部类</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">在Java中允许定义位于另外一个类内部，前者就称之为内部类，后者称之为外部类</span><br><span class="line">class A&#123;</span><br><span class="line">	class B&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	类A就是类B的外部类</span><br><span class="line">	类B就是类A的内部类</span><br><span class="line">	</span><br><span class="line">分类：</span><br><span class="line">	成员内部类(静态、非静态)</span><br><span class="line">	局部内部类</span><br><span class="line">	匿名内部类(重点)</span><br></pre></td></tr></table></figure>



<h5 id="静态成员内部类"><a href="#静态成员内部类" class="headerlink" title="静态成员内部类"></a>静态成员内部类</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	直接在定义内部类的时候加上static关键字</span><br><span class="line">	public class A&#123;</span><br><span class="line">		static class B&#123;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	注意：</span><br><span class="line">		a.内部类可以定义属性，方法，构造等</span><br><span class="line">		b.静态内部类可以被final或者abstract修饰</span><br><span class="line">		  被final修饰之后，不能被继承</span><br><span class="line">		  被abstract修饰之后，不能new</span><br><span class="line">		c.静态内部类不能调用外部的非静态成员</span><br><span class="line">		d.内部类还可以被四种权限修饰符修饰</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">调用静态内部类成员：</span><br><span class="line">	外部类.内部类 对象名 = new 外部类.内部类()</span><br></pre></td></tr></table></figure>



<h5 id="非静态成员内部类"><a href="#非静态成员内部类" class="headerlink" title="非静态成员内部类"></a>非静态成员内部类</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	public class A&#123;</span><br><span class="line">		class B&#123;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	注意：</span><br><span class="line">		a.内部类可以定义属性，方法，构造等</span><br><span class="line">		b.静态内部类可以被final或者abstract修饰</span><br><span class="line">		  被final修饰之后，不能被继承</span><br><span class="line">		  被abstract修饰之后，不能new</span><br><span class="line">		c.静态内部类不能调用外部的非静态成员</span><br><span class="line">		d.内部类还可以被四种权限修饰符修饰</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">注意点和静态成员内部相同，但是调用方法不同:</span><br><span class="line">	外部类.内部类 对象名 = new 外部类().new 内部类()</span><br></pre></td></tr></table></figure>



<p>有一个问题：</p>
<p>​	外部类的成员变量和内部类的成员变量以及内部类的局部变量重名时，如何区分</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240705211413762.png" alt="image-20240705211413762"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">monse</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">person</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;王五&quot;</span>;</span><br><span class="line">            System.out.println(name); <span class="comment">// 内部类的局部变量</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.name); <span class="comment">// 内部类的成员变量</span></span><br><span class="line">            System.out.println(Test.<span class="built_in">this</span>.name); <span class="comment">// 外部类的成员变量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用this解决</span></span><br></pre></td></tr></table></figure>



<h5 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h5><h6 id="局部内部类基本操作"><a href="#局部内部类基本操作" class="headerlink" title="局部内部类基本操作"></a>局部内部类基本操作</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">可以定义在方法中，代码块中，构造中</span><br><span class="line">局部内部类使用起来很麻烦，演示一下</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">hemp</span>&#123;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;你好&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">hemp</span>().jump</span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部内部类在外面是没办法new的，也就意味着外界无法调用，因此在定义的时候，需要new好局部变量类的方法，很麻烦不建议使用</span></span><br></pre></td></tr></table></figure>



<h6 id="局部内部类实际操作"><a href="#局部内部类实际操作" class="headerlink" title="局部内部类实际操作"></a>局部内部类实际操作</h6><p>补充一下不同类作为方法参数和返回值的情况</p>
<p>接口类型作为方法参数传递和返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">接口不能直接<span class="keyword">new</span>对象，在多态部分提到过，接口作为方法参数传递时，传递的是他的实现类</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">monse</span> <span class="variable">monse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">monse</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 传递实现类</span></span><br><span class="line">        method(monse);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 接收实现类</span></span><br><span class="line">        <span class="type">USB</span> <span class="variable">usb</span> <span class="operator">=</span> method01();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	接口作为方法参数，传递实参时，传递的是实现类对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(USB usb)</span>&#123;</span><br><span class="line">        <span class="comment">// 这里接口作为方法参数，但是传进来的monse是USB的实现类，在这里进行了向上转化</span></span><br><span class="line">        <span class="comment">// USB usb = new monse();</span></span><br><span class="line">        usb.open()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> USB <span class="title function_">method01</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">mouse</span>();</span><br><span class="line">        <span class="comment">// 接口作为返回值类型时，实际返回的也是实现类对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<blockquote>
<p>接口作为方法参数，传递实参时，传递的是实现类对象</p>
<p>接口作为返回值类型时，实际返回的也是实现类对象</p>
</blockquote>
<hr>
<p>抽象类作为方法参数和返回值</p>
<blockquote>
<p>抽象类作为方法参数传递时，传递的是其子类对象</p>
<p>抽象类作为方法返回值类型返回，实际返回的是其子类对象</p>
</blockquote>
<hr>
<p>普通类作为方法参数和返回值</p>
<blockquote>
<p>普通类作为方法参数和返回值时，传递的是对象</p>
</blockquote>
<p>局部内部类实际操作</p>
<p>拿接口示范一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用多态接收实现类</span></span><br><span class="line">		<span class="type">USB</span> <span class="variable">usb</span> <span class="operator">=</span> method();</span><br><span class="line">		usb.open();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> USB <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 局部内部类，这个类定义为USB的实现类</span></span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">Monse</span> <span class="keyword">implements</span> <span class="title class_">USB</span> &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;鼠标打开&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 同时将new好的实现类对象返回出去</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Monse</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h5><blockquote>
<p>所谓的匿名内部类，可以理解为没有显示声明出类名的内部类</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">要想实现接口，或者抽象类的方法需要以下步骤</span><br><span class="line">	1、创建实现类，实现接口</span><br><span class="line">	2、重写方法</span><br><span class="line">	3、创建实现类对象</span><br><span class="line">	4、调用方法</span><br><span class="line">	</span><br><span class="line">如果呢，只想使用一次接口中的方法，那么麻烦大可不必，可以四合一</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">	new 接口/抽象类()&#123;</span><br><span class="line">		重写方法</span><br><span class="line">	&#125;.重写的方法();</span><br><span class="line">	</span><br><span class="line">	--------or-------</span><br><span class="line">	</span><br><span class="line">	类名 对象名 = new 接口/抽象类() &#123;</span><br><span class="line">		重写方法</span><br><span class="line">	&#125;</span><br><span class="line">	对象名.重写的方法();</span><br><span class="line">	</span><br><span class="line">	// 注意这里是对象名而不是类名，如果定义了类名就是实现类，不是匿名内部类了，感觉类似于python中的一行函数</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240708154426053.png" alt="image-20240708154426053"></p>
<blockquote>
<p>匿名内部类在代码编译时会生成class文件的</p>
<p>简单调用一次接口中的方法时，就可以使用匿名内部类</p>
<p>将一种格式代表实现类对象或者子类对象来看待</p>
</blockquote>
<h6 id="匿名内部类的复杂使用"><a href="#匿名内部类的复杂使用" class="headerlink" title="匿名内部类的复杂使用"></a>匿名内部类的复杂使用</h6><p><img src="/../%E5%9B%BE%E7%89%87/image-20240708155932065.png" alt="image-20240708155932065"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TEST01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">USB</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(USB usb)</span>&#123;</span><br><span class="line">        usb.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>同样的返回值也可以这样操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TEST01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">USB</span> <span class="variable">usb</span> <span class="operator">=</span> method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> USB <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">USB</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><img src="/../%E5%9B%BE%E7%89%87/image-20240708162747315.png" alt="image-20240708162747315"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> calss test &#123;</span><br><span class="line">	pubilc <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// 错误error，内存栈溢出</span></span><br><span class="line">        <span class="comment">// StackOverflowError</span></span><br><span class="line">		method();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 运行时期异常</span></span><br><span class="line">        <span class="comment">// ArrayIndexOutOfBoundsException</span></span><br><span class="line">        <span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        System.out.println(arr1[<span class="number">4</span>]);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 编译时期异常</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	下面就是一个编译时期异常，下面的parse方法会标红，但这个并不是代码写错了</span></span><br><span class="line"><span class="comment">        	这里标红是因为代码底层抛的一个编译时期异常</span></span><br><span class="line"><span class="comment">        	一旦触发了这个异常，jvm就会将异常信息打印到控制台上</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> <span class="string">&quot;2000-10-10 10:10:10&quot;</span>;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf.parse(time);</span><br><span class="line">        System.out.printlin(date);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">		method();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="创建异常对象（了解）"><a href="#创建异常对象（了解）" class="headerlink" title="创建异常对象（了解）"></a>创建异常对象（了解）</h4><blockquote>
<p>创建异常对象，只是为了后面学习如何处理异常，其他的暂时没有啥意义</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">关键字：throw</span><br><span class="line">格式：</span><br><span class="line">	throw new 异常</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a.txt&quot;</span>;</span><br><span class="line">        method(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!s.endsWith(<span class="string">&quot;.txt&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">// s.endsWith的作用是检验字符串的结尾是否为.txt</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="comment">// 调用Java中写好的异常方法，制造一个异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240708212431809.png" alt="image-20240708212431809"></p>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h5 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式： 在方法参数和方法体之间写</span><br><span class="line">	throws 异常</span><br><span class="line">	</span><br><span class="line">	public static void 方法名(方法参数)throws 异常&#123;</span><br><span class="line">		方法体</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">作用方面比较鸡肋，是将异常信息向上抛，而jvm处理异常的逻辑也是往上抛，如果没人处理，最后再由jvm来打印异常信息，终止程序</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上抛多个异常：<br>throws 异常1,异常2</p>
<p>如果多个异常之间有子父类关系，可以直接throws父类异常</p>
<p>也可以擒贼擒王，直接throws Exception</p>
</blockquote>
<p>层层上抛，没啥意思</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240708213430874.png" alt="image-20240708213430874"></p>
<h5 id="try……catch"><a href="#try……catch" class="headerlink" title="try……catch"></a>try……catch</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	try &#123;</span><br><span class="line">		可能出现异常的代码</span><br><span class="line">	&#125;catch(异常 对象名)&#123;</span><br><span class="line">		处理异常的代码 -&gt; 正常开发是将异常信息保存到日志文件中</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a.txtl&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将详细的异常信息打印到控制台</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(String s)</span><span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!s.endsWith(<span class="string">&quot;.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// s.endsWith的作用是检验字符串的结尾是否为.txt</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>(<span class="string">&quot;找不到文件&quot;</span>);</span><br><span class="line">            <span class="comment">// 调用Java中写好的异常方法，制造一个异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240708215553755.png" alt="image-20240708215553755"></p>
<h6 id="处理多个异常"><a href="#处理多个异常" class="headerlink" title="处理多个异常"></a>处理多个异常</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	try &#123;</span><br><span class="line">		可能出现异常的代码</span><br><span class="line">	&#125;catch(异常 对象名)&#123;</span><br><span class="line">		处理异常的代码</span><br><span class="line">	&#125;catch(异常 对象名)&#123;</span><br><span class="line">		处理异常的代码</span><br><span class="line">	&#125;catch(异常 对象名)&#123;</span><br><span class="line">		处理异常的代码</span><br><span class="line">	&#125;catch(异常 对象名)&#123;</span><br><span class="line">		处理异常的代码</span><br><span class="line">	&#125;catch(异常 对象名)&#123;</span><br><span class="line">		处理异常的代码</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">和throws一样，如果多个异常之间有子父类关系，可以直接catch父类异常</span><br></pre></td></tr></table></figure>



<h4 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：代表的是不管是否触发异常，都会执行的代码块</span><br><span class="line">	特殊情况：如果之前执行了System.exit(0) -&gt; 终止jvm虚拟机</span><br><span class="line">	</span><br><span class="line">需要搭配try……catch使用</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">	try &#123;</span><br><span class="line">		可能出现异常的代码</span><br><span class="line">	&#125;catch(异常 对象名)&#123;</span><br><span class="line">		需要处理的异常</span><br><span class="line">	&#125;finally&#123;</span><br><span class="line">		必须执行的代码</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>finally里有一个比较细的点，执行顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(s.length());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行&quot;</span>);</span><br><span class="line">        <span class="comment">// return 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里控制台会先输出 <code>执行</code> 然后输入返回值2，如果没有只是 <code>return 3</code> 的话会直接截胡，输出 执行 和 3</p>
<h5 id="finally的使用场景"><a href="#finally的使用场景" class="headerlink" title="finally的使用场景"></a>finally的使用场景</h5><blockquote>
<p>1、关闭资源</p>
<p>2、原因，对象如果没有用了，GC(垃圾回收器)回收，用来回收堆内存中的垃圾，释放内存，但是有一些对象GC回收不了，比如：连接对象(Connection)，IO流对象，Socker对象，这些对象GC回收不了，因此需要手动回收关闭。</p>
<p>​	将来不能回收的对象new完之后，后续不管是否操作成功，是否有异常，我们就手动关闭，这个时候就需要将关闭资源的代码放到finally中</p>
</blockquote>
<h4 id="抛异常的注意事项"><a href="#抛异常的注意事项" class="headerlink" title="抛异常的注意事项"></a>抛异常的注意事项</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、如果父类方法抛了异常，那么子类重写后需不要抛</span><br><span class="line">	可抛可不抛</span><br><span class="line">2、如果父类方法中没有抛异常，那么子类重写可不可以抛异常</span><br><span class="line">	不能抛</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240708222135613.png" alt="image-20240708222135613"></p>
<p>try  throws使用时机，三层架构</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240708223319330.png" alt="image-20240708223319330"></p>
<blockquote>
<p>1、编译时期异常必须要处理，不然没法往下写了</p>
<p>2、运行时期异常一般不处理，一旦出现运行时期异常，肯定是代码有问题，try catch没有意义，直接修改代码细节即可</p>
</blockquote>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>自定义异常，首先要有这个异常类</p>
<p>定义异常类时需要继承</p>
<blockquote>
<p>如果继承Exception就是编译时期异常</p>
<p>如果继承RuntimeException就是运行时期异常</p>
</blockquote>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240708224511099.png" alt="image-20240708224511099"></p>
<p>如果要传入异常原因的话，只需要在自定义异常写一个有参构造</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LoginUserException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">	<span class="built_in">super</span>(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="打印错误信息的三个方法"><a href="#打印错误信息的三个方法" class="headerlink" title="打印错误信息的三个方法"></a>打印错误信息的三个方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">都是Throwable类中的方法：</span><br><span class="line">	String toString();  // 输出异常类型和设置的异常信息</span><br><span class="line">	String getMessage();  // 输出设置的异常信息</span><br><span class="line">	void printStackTrace();  // 打印异常信息是最全的：包括异常类型，信息，以及出现的行数等</span><br></pre></td></tr></table></figure>



<img src="../图片/image-20240708225857252.png" alt="image-20240708225857252" style="zoom:50%;" />



<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>继承来继承去，最后继承的都是Object，所有类都会直接或者间接的继承Object，Object类是根类</p>
<p>这里的Object指的是lang包内的Object</p>
<p>ctrl+n 搜索</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240709134231364.png" alt="image-20240709134231364"></p>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p><img src="/../%E5%9B%BE%E7%89%87/image-20240709134348318.png" alt="image-20240709134348318"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">toString方法并不复杂</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">    <span class="comment">// 这句代码也很好理解，返回包名 + 类名 + @ + 地址值的十六进制</span></span><br><span class="line">    <span class="comment">// hashCode()是获取地址值的十进制，也是Obkect内的一个方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">    <span class="number">1</span>、如果没有重写Object中的toStrig方法，直接输出对象名会默认输出Objict中的toString方法，直接输出地址值</span><br><span class="line">    <span class="number">2</span>、如果重写了object中的toString，再输出地址值，重写没意义，所以重写完tostring之后，应该返回对象的内容</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240709135331805.png" alt="image-20240709135331805"></p>
<p>之前在学生管理系统的编写上，就使用过重写toString，toString也可以通过 ait+insert 快捷键快速生成</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240709135918444.png" alt="image-20240709135918444"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找一个写好的toString方法</span></span><br><span class="line">	ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">	list.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">	list.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">	System.out.println(list); <span class="comment">// -&gt; [张三、李四、王五]</span></span><br><span class="line">    System.out.println(list.toString()); <span class="comment">// -&gt; [张三、李四、王五]</span></span><br></pre></td></tr></table></figure>

<p>这个是写好的toString()重写</p>
<h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><p><img src="/../%E5%9B%BE%E7%89%87/image-20240709140358236.png" alt="image-20240709140358236"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">作用：</span><br><span class="line">    比较两个地址值是否相等</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240709150804921.png" alt="image-20240709150804921"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这里有两种方法</span><br><span class="line">第一个是直接p1==p2</span><br><span class="line"></span><br><span class="line">第二种是 p1.equals(p2);</span><br><span class="line">将p2作为方法参数传入equals方法，然后this和obj比较，由于是p1调用的equals，所以this是指向p1的</span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==  针对于基本数据类型来说，比较的是值</span><br><span class="line">    对两个基本数据类型使用equals，调用的是重写后的equals，并不是object中的equals</span><br><span class="line">==  针对于引用数据类型来说，比较的是地址值</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240709152216046.png" alt="image-20240709152216046"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240709151841212.png" alt="image-20240709151841212"></p>
<p>如果没有重写object中的equals方法，那么就会调用object中的equals方法，如果重写了就调用重写后的equals方法</p>
<p>自己重写一个equals</p>
<p>考虑三个因素，空、自身、目的（比较内部信息）</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240709161141298.png" alt="image-20240709161141298"></p>
<p>这样比较好看，也可以直接根据引导生成重写后的equals，意思和上方代码是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成的equals	</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">object</span> <span class="variable">object</span> <span class="operator">=</span> (object) o;</span><br><span class="line">        <span class="keyword">return</span> age == object.age &amp;&amp; Objects.equals(name, object.name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>小结：</p>
<p>​	1、如果直接输出对象名，不想输出地址值，重写toString方法</p>
<p>​	2、如果想要比较两个对象的内容，就重写运行equals方法</p>
<p>​	3、输出对象名找toString，比较对象找equals</p>
<p>​	4、ait+insert 快捷键重写方法</p>
</blockquote>
<h4 id="clone方法-克隆"><a href="#clone方法-克隆" class="headerlink" title="clone方法(克隆)"></a>clone方法(克隆)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用：</span><br><span class="line">	复制一个属性值一样的新对象</span><br><span class="line">	</span><br><span class="line">使用：</span><br><span class="line">	需要被克隆的对象实现Cloneable接口</span><br><span class="line">	重写clone方法</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240709163703601.png" alt="image-20240709163703601"></p>
<p>截图少截了，重写clone之前，需要实现Cloneable接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class object implements Cloneable</span><br></pre></td></tr></table></figure>



<h3 id="经典接口"><a href="#经典接口" class="headerlink" title="经典接口"></a>经典接口</h3><h4 id="java-lang-Comparable"><a href="#java-lang-Comparable" class="headerlink" title="java.lang.Comparable"></a>java.lang.Comparable</h4><blockquote>
<p>基本数据类型（除布尔类型外）需要比较大小的话，直接使用比较运算符即可，但是引用数据类型是不能直接使用比较运算符来比较大小的。那么如何解决这个问题？</p>
</blockquote>
<p>java给所有引用数据类型的大小比较，指定了一个标准接口，就是java.lang.Comparable接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object obj)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要使得我们某个类的对象可以比较大小，怎么做？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一： 哪个类的对象要比较大小，哪个类就实现Comparable接口，并重写方法</span><br><span class="line">	方法体就是你要如何比较当前对象和指定的另一个对象的大小</span><br><span class="line">	</span><br><span class="line">第二： 对象比较大小时，通过对象调用compareto方法，根据方法的返回值决定谁打谁小。</span><br><span class="line">	this对象（调用compareTo）减 指定对象（传入compareTo()的参数对象）大于0，返回正整数</span><br><span class="line">	this对象（调用compareTo）减 指定对象（传入compareTo()的参数对象）小于0，返回负整数</span><br><span class="line">	this对象（调用compareTo）减 指定对象（传入compareTo()的参数对象）等于0，返回零</span><br></pre></td></tr></table></figure>



<p>代码实例：</p>
<p>代码排序还是依靠冒泡排序，只是使用compareTo()方法进行比较的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjjws.a_comparable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        student[] students = <span class="keyword">new</span> <span class="title class_">student</span>[<span class="number">3</span>];</span><br><span class="line">        students[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">100</span>);</span><br><span class="line">        students[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">student</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">60</span>);</span><br><span class="line">        students[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">student</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;students.length-<span class="number">1</span> ; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;students.length-<span class="number">1</span>-j ; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (students[i].compareTo(students[i+<span class="number">1</span>])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="type">student</span> <span class="variable">temp</span> <span class="operator">=</span> students[i];</span><br><span class="line">                    students[i] = students[i+<span class="number">1</span>];</span><br><span class="line">                    students[i+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;students.length ; i++) &#123;</span><br><span class="line">            System.out.println(students[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	student&#123;name=&#x27;李四&#x27;, score=60&#125;</span></span><br><span class="line"><span class="comment">	student&#123;name=&#x27;王五&#x27;, score=80&#125;</span></span><br><span class="line"><span class="comment">	student&#123;name=&#x27;张三&#x27;, score=100&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p>实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjjws.a_comparable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, score=&quot;</span> + score +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">student</span><span class="params">(String name,<span class="type">int</span> score )</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    	<span class="type">student</span> <span class="variable">s1</span> <span class="operator">=</span> (student) o;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getScore() - o.getScore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="java-util-Comparator"><a href="#java-util-Comparator" class="headerlink" title="java.util.Comparator"></a>java.util.Comparator</h4><blockquote>
<p>思考：</p>
<p>​	1、如果一个类，没有实现Comparable接口，而这个类又不方便修改（例如：一些第三方的类，你只有.class文件，没有源文件）</p>
<p>​	2、如果一个类，实现了Comparable接口，也指定了两个对象比较大小的规则，但是此时此刻我不想按照它预定义的方法比较大小，但是我又不能随意修改，因为会影响其他地方的使用，怎么办？</p>
</blockquote>
<p>这个时候就需要用到Comparator接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1,Object o2)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们想要比较某个类的两个对象的大小，怎么做呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一步： 编写一个类，我们称之为比较器类型，实现java.util.Comparator接口，并重写方法</span><br><span class="line">	方法体就是你要如何指定的两个对象的大小</span><br><span class="line">	</span><br><span class="line">第二步：比较大小时，通过比较器类型的对象调用compare()方法，将要比较大小的两个对象作为compare方法的实参传入，根据方法的返回值决定谁大谁小。</span><br><span class="line">	o1对象减o2大于0返回正整数</span><br><span class="line">	o1对象减o2小于0返回负整数</span><br><span class="line">	o1对象减o2等于0返回零</span><br></pre></td></tr></table></figure>



<p>实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">student01</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">student01</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, score=&quot;</span> + score +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">student01</span><span class="params">(String name, <span class="type">int</span> score )</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="type">student01</span> <span class="variable">s1</span> <span class="operator">=</span> (student01) o1;</span><br><span class="line">        <span class="type">student01</span> <span class="variable">s2</span> <span class="operator">=</span> (student01) o2;</span><br><span class="line">        <span class="keyword">return</span> s1.getScore()-s2.getScore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        student01[] students = <span class="keyword">new</span> <span class="title class_">student01</span>[<span class="number">3</span>];</span><br><span class="line">        students[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">student01</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">100</span>);</span><br><span class="line">        students[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">student01</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">60</span>);</span><br><span class="line">        students[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">student01</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">student01</span> <span class="variable">student01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">student01</span>();</span><br><span class="line">        <span class="comment">// 注意这里新new了一个对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;students.length-<span class="number">1</span> ; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;students.length-<span class="number">1</span>-j ; i++) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 这里是用新new的对象来.compare的</span></span><br><span class="line">                <span class="keyword">if</span> (student01.compare(students[i],students[i+<span class="number">1</span>])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="type">student01</span> <span class="variable">temp</span> <span class="operator">=</span> students[i];</span><br><span class="line">                    students[i] = students[i+<span class="number">1</span>];</span><br><span class="line">                    students[i+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;students.length ; i++) &#123;</span><br><span class="line">            System.out.println(students[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="API部分"><a href="#API部分" class="headerlink" title="API部分"></a>API部分</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="了解string"><a href="#了解string" class="headerlink" title="了解string"></a>了解string</h4><p>string是lang包下的类，lang包下的类在使用的时候，不需要导包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String类代表字符串</span><br><span class="line">特点：</span><br><span class="line">	1、Java程序中的所有字符串面值（如&quot;abc&quot;）都作为此类的实例（对象）实现</span><br><span class="line">	   凡是带双引号的，都是String的对象</span><br><span class="line">	   String s = &quot;abc&quot;</span><br><span class="line">	   &quot;abc&quot;就是对象；String就是对象的数据类型；s就是对象名</span><br><span class="line">	2、字符串是常量，它们的值在创建后不能更改</span><br><span class="line">	   String s = &quot;hello&quot;;</span><br><span class="line">	   s += &quot;world&quot;;</span><br><span class="line">	   </span><br><span class="line">	   这种操作虽然存在，但底层的逻辑是产生一个新的对象的，它的地址值改变了，并不是修改了s，字符串是常量，在底层代码内是使用final修饰的</span><br><span class="line">	</span><br><span class="line">	3、String对象是不可变的，所以可以共享</span><br><span class="line">	   String s1 = &quot;abc&quot;;</span><br><span class="line">	   String s2 = &quot;abc&quot;;</span><br><span class="line">	   System.out.println(s1==s2)</span><br><span class="line">	   S1和s2的地址值是一样的，返回结果为true</span><br><span class="line">	   </span><br></pre></td></tr></table></figure>



<p>共享：指向的堆内存空间相同</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240709202601853.png" alt="image-20240709202601853"></p>
<blockquote>
<p>想到了一个很有意思的事情</p>
<p>学习equals是曾经比较过两个字符串，返回是false，如下图</p>
<p>解释一下：</p>
<p>​	常量池：</p>
<p>​		首先要引入常量池这个概念，当使用自负床字面量创建字符串时 如： String s1 &#x3D; “abc”; Java会在常量池内查找是否已经存在相同内容的字符串。如果存在，则直接返回该字符串的引用；如果不存在，则在常量池中创建一个新的字符串并返回其引用。这个机制也很好理解，减少内存栈资源占用。</p>
<p>​	new关键字：</p>
<p>​		当使用new关键字创建字符串时，Java会在堆内存中创建一个新的字符串对象，即使字符串常量池中已经存在相同内容的字符串</p>
<p>​	然后就很好理解了，s1和s2的地址值是相同的，但是s2,s3,s4的地址值各不相同</p>
</blockquote>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240709202954094.png" alt="image-20240709202954094"></p>
<p>值得注意的是，new的对象的内容是abc在常量池中的地址值，如果abc没有在常量池内，那么new的话会先在常量池中创建一个abc，然后将常量池中的abc的地址值给到 new 出的对象</p>
<h4 id="String的实现原理"><a href="#String的实现原理" class="headerlink" title="String的实现原理"></a>String的实现原理</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、jdk8的时候：String底层是一个被final修饰的char数组 -&gt; private final char[] value;</span><br><span class="line"></span><br><span class="line">2、jdk9开始到以后：底层是一个被final修饰的byte数组 -&gt; private final byte[] value;</span><br><span class="line"></span><br><span class="line">jdk8 - jdk9 版本更新出现了拉姆达表达式（函数式编程思想），因此有了很大变动，所有有些脚本、软件会要求Java的jdk8环境，其他的版本更新主要是优化内存</span><br><span class="line"></span><br><span class="line">一个char类型数据占两个字节，一个byte类型数据占一个字节，节省了内存空间</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符串定义完之后，数组就创建好了，被final一修饰，数组的地址值就固定死了</span><br></pre></td></tr></table></figure>



<h4 id="String的创建"><a href="#String的创建" class="headerlink" title="String的创建"></a>String的创建</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、String() -&gt; 利用String的无参构造创建String对象</span><br><span class="line"><span class="number">2</span>、String(String original) -&gt; 根据字符串创建String对象</span><br><span class="line"><span class="number">3</span>、String(<span class="type">char</span>[] value) -&gt; 根据<span class="type">char</span>数组创建String对象</span><br><span class="line"><span class="number">4</span>、String(<span class="type">byte</span>[] bytes) -&gt; 通过使用平台的默认字符集解码指定的 <span class="type">byte</span> 数组，构造一个新的 String</span><br><span class="line">    </span><br><span class="line">简化形式：</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>



<p>演示一下：注意char数组不能用双引号</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240709210419074.png" alt="image-20240709210419074"></p>
<blockquote>
<p>再说一下byte数组的事</p>
<p>-&gt; 通过平台的默认字符集解码指定的 byte 数组，构造一个新的 String</p>
<p>​	平台：操作系统</p>
<p>​	操作系统默认字符集：GBK</p>
<p>​	GBK这个东西前面说过</p>
<p>​		GBK：一个中文占2个字节</p>
<p>​		UTF-8：一个中文占3个字节</p>
</blockquote>
<p>中文在编码集中一般为负数，但是使用byte的时候注意，要在编码表中可以找到，否则就是乱码</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240709211240996.png" alt="image-20240709211240996"></p>
<blockquote>
<p>这里的“你”字是由三个字节的，原因是代码是在idea中写的，idea启动的时候，会自动加一个启动参数，此启动参数为UTF-8 -Dfile,encoding&#x3D;UTF-8</p>
</blockquote>
<p>以上是比较常用的几种构造，现在看几个不常用的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、String(<span class="type">char</span>[] value, <span class="type">int</span> offset, <span class="type">int</span> count) -&gt; 将<span class="type">char</span>数组的一部分转化成String对象</span><br><span class="line">    value:要转String的<span class="type">char</span>数组</span><br><span class="line">    offset:从数组的哪个索引开始转</span><br><span class="line">    count:转多少个</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、String(<span class="type">byte</span>[] bytes, <span class="type">int</span> offset, <span class="type">int</span> length) -&gt; 将<span class="type">byte</span>数组的一部分转成String对象</span><br><span class="line">    bytes:要转String的<span class="type">byte</span>数组</span><br><span class="line">    offset:从数组的哪个索引开始转</span><br><span class="line">    length:转多少个</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">问题：</span><br><span class="line">	String s = new String(&quot;abc&quot;); 共有几个对象</span><br><span class="line">		两个 new 和 &quot;abc&quot;</span><br><span class="line">		</span><br><span class="line">	String s = new String(&quot;abc&quot;); 共创建了几个对象	</span><br><span class="line">		一个或者两个</span><br><span class="line">		要看 &quot;abc&quot; 有没有提前创建，如果之前没有就会创建两个，先创建常量池中的 abc 再创建 new 对象，因为new对象的是abc在常量池中的地址值</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240709213155605.png" alt="image-20240709213155605"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;world&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">   System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">   System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">   System.out.println(s3 == s6);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>以上代码的输出结果分别为 true false false</p>
<p>为了能够可视化的看到区别呢，倒置了一个小时的反编译，解决了一个小问题 jd-gui 无法打开class文件时，将文件打成压缩包再放到jd-gui中，但是编译出来的情况和网课不一样</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240709230959676.png" alt="image-20240709230959676"></p>
<p>抛开上面不看了，这是XJad编译出来的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240709231620186.png" alt="image-20240709231620186"></p>
<p>从反编译结果可以看出s3和s4是等价的，但是s5、s6是new了新的对象的，因此地址值不同</p>
<blockquote>
<p>总结一下这个问题：</p>
<p>​	1、字符串拼接，如果等号右边是字符串字面值拼接，不会产生新的对象</p>
<p>​	2、字符串拼接，如果等号右边有变量参数拼接，会产生新字符串对象</p>
</blockquote>
<h4 id="String常用方法"><a href="#String常用方法" class="headerlink" title="String常用方法"></a>String常用方法</h4><h5 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean equals(String s) -&gt; 比较字符串内容</span><br><span class="line">boolean equalsIgnoreCase(String s) -&gt; 比较字符串内容，忽略大小写（可用于图片验证码）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">equals方法还是一样</span><br><span class="line">s1.equals(s2)</span><br><span class="line">s1.equalsIgnoreCase(s2)</span><br></pre></td></tr></table></figure>



<p>Java中也有比较两个对象的方法</p>
<blockquote>
<p>工具类：Objects（注意是Objects不是根类Object）</p>
<p>方法：equals，这个是重写的equals方法，但是是传的两个对象，而且有防空指针的效果</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static boolean equals(Object a, Object b) &#123;</span><br><span class="line">	return (a == b) || (a != null &amp;&amp; a.equals(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="获取功能"><a href="#获取功能" class="headerlink" title="获取功能"></a>获取功能</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、获取字符串长度</span><br><span class="line">	int length();</span><br><span class="line">2、字符串拼接，返回新字符串</span><br><span class="line">	String concat(String s);</span><br><span class="line">3、根据索引获取对应字符</span><br><span class="line">	char charAt(int index);</span><br><span class="line">4、获取指定字符在大字符串中第一次出现的索引位置</span><br><span class="line">	int indexOf(String s);</span><br><span class="line">5、截取字符串，从指定索引开始截取到最后，返回新字符串</span><br><span class="line">	String subString(int beginIndex);</span><br><span class="line">6、截取字符串，从beginIndex开始到endIndex结束（含头不含尾），返回新字符串</span><br><span class="line">	String subString(int beginIndex, int endIndex);</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240710222320914.png" alt="image-20240710222320914"></p>
<p>这个时候就可以遍历一下字符串了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s = &quot;asdfghjkl&quot;;</span><br><span class="line">for (int i = 0; i &lt; s.length()-1; i++) &#123;</span><br><span class="line">	System.out.println(s.charAt(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="转换功能"><a href="#转换功能" class="headerlink" title="转换功能"></a>转换功能</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、char[] toCharArray() -&gt; 将字符串转为char数组</span><br><span class="line">2、byte[] getBytes() -&gt; 将字符串转成byte数组</span><br><span class="line">3、String replace(CharSequence c1, CharSequence c2) -&gt; 替换字符</span><br><span class="line">4、byte[] getBytes(String charsetName) -&gt; 按照指定的编码将字符串转成byte数组</span><br></pre></td></tr></table></figure>





<p><img src="/../%E5%9B%BE%E7%89%87/image-20240710223709233.png" alt="image-20240710223709233"></p>
<blockquote>
<p>CharSequence是String类的接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">实例代码：</span><br><span class="line">	        <span class="comment">// 转换</span></span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//1、char[] toCharArray() -&gt; 将字符串转为char数组</span></span><br><span class="line">        <span class="type">char</span>[] chars = s1.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            System.out.print(chars[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、byte[] getBytes() -&gt; 将字符串转成byte数组</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="type">byte</span>[] bytes = s1.getBytes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">            System.out.print(bytes[i]+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、String replace(CharSequence c1, CharSequence c2) -&gt; 替换字符</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.replace(<span class="string">&quot;asd&quot;</span>,<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">        System.out.println(s1+<span class="string">&quot;||&quot;</span>+s2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、byte[] getBytes(String charsetName) -&gt; 按照指定的编码将字符串转成byte数组</span></span><br><span class="line">        <span class="type">byte</span>[] byteGBK = <span class="string">&quot;你好&quot;</span>.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; byteGBK.length; i++) &#123;</span><br><span class="line">            System.out.print(byteGBK[i]);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240710224422591.png" alt="image-20240710224422591"></p>
<h5 id="分割功能"><a href="#分割功能" class="headerlink" title="分割功能"></a>分割功能</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String[] split(String regex) -&gt; 按照指定的规则分割字符串</span><br><span class="line"></span><br><span class="line">注意：regex写的是正则表达式 -&gt; .在正则表达式中代表任意字符，如果要以.来切割的话，使用转义符//</span><br></pre></td></tr></table></figure>



<h5 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、boolean contains(String s) -&gt; 判断老字符串内是否包含指定的字符串</span><br><span class="line">2、boolean endsWith(String s) -&gt; 判断老字符串是否以指定的字符串结尾</span><br><span class="line">3、boolean startsWith(String s) -&gt; 判断老字符串是否以指定的字符串开头</span><br><span class="line">4、String toLowerCase() -&gt; 将字母转成小写</span><br><span class="line">5、String toUpperCase() -&gt; 将字母转成大写</span><br><span class="line">6、String trim() -&gt; 去掉字符串两端空格</span><br></pre></td></tr></table></figure>



<h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><blockquote>
<p>概述：一个可变的字符序列，此类提供了一个与StringBuffer兼容的一套API，但是不保证同步(线程不安全，效率高)</p>
<p>作用：主要是字符串拼接</p>
<p>问题：</p>
<p>​	1、String也能做到字符串拼接，直接使用+拼接，那么为什么还要用StringBuilder拼接呢</p>
<p>​	2、原因：</p>
<p>​		String每拼接一次，就会产生新的字符串对象，就会在堆内存中开辟新空间，如果拼接过多，会占用内存，效率降低</p>
<p>​	3、StringBuilder，底层自带一个缓冲区（没有被final修饰的byte数组）拼接字符串之后都会在缓冲区中保存，在拼接过程中，不会随意产生新对象，节省内存</p>
<p>特点：</p>
<p>​	1、底层自带缓冲区，此缓冲区是备用被final修饰的byte数组，默认长度是16</p>
<p>​	2、如果超出了数组长度，数组会自动扩容</p>
<p>​		因为定长，所以创建一个新长度的数组，将老数组的元素复制到新数组中，然后将新数组的地址值重新赋值给老数组</p>
<p>​	3、默认每次扩容老数组的2倍+2</p>
<p>​		如果一次性添加的数据超出了默认的扩容数组长度(2倍+2)。但有例外，比如存了36个字符，超出了第一扩容的34，就按照实际数据个数为准，就是以36扩容</p>
</blockquote>
<h4 id="深入♂了解一下"><a href="#深入♂了解一下" class="headerlink" title="深入♂了解一下"></a>深入♂了解一下</h4><p>看一下StringBuilder的底层代码</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240710231951379.png" alt="image-20240710231951379"></p>
<p>创建出来的缓冲区</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240710232348458.png" alt="image-20240710232348458"></p>
<p>搞点事情，打个断点观察一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sb.append(&quot;1111111111111111111111111111111&quot;);</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240710233101853.png" alt="image-20240710233101853"></p>
<p>判断是否应该扩容</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240710233705340.png" alt="image-20240710233705340"></p>
<p>开始扩容</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240710233953734.png" alt="image-20240710233953734"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240710234511279.png" alt="image-20240710234511279"></p>
<p>返回34之后在copyOf内创建了新的长度为34的数组，赋值，更改地址等一系列操作</p>
<blockquote>
<p>补充：</p>
<p>​	如果len大于34的话，最后的扩容计算会正好等于length，然后返回这个值</p>
<p>​	值得注意的是，StringBuilder扩容时也会创建新的对象，也会占用内存，但是不可否认的是，完成同样的事，StringBuilder所占的内存更少</p>
</blockquote>
<h4 id="StringBuilter的使用"><a href="#StringBuilter的使用" class="headerlink" title="StringBuilter的使用"></a>StringBuilter的使用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构造：</span><br><span class="line">	StringBuilder()</span><br><span class="line">	StringBuilder(String str)</span><br><span class="line">	</span><br><span class="line">	两种构造方法，空参是空的缓冲区，传参是往缓冲区添加</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常用方法：</span><br><span class="line">	StringBUilder append(任意类型数据) -&gt; 字符串拼接的效果，但是底层逻辑和字符串拼接不一样，返回值是StringBuilder自己</span><br><span class="line">	StringBuilder reverse() -&gt; 字符串翻转，返回的是StringBUilder自己</span><br><span class="line">	String toString() -&gt; 将StringBuilder转换成String。老朋友toString了</span><br><span class="line">		用StringBuilder拼接字符串是为了效率，为了不占内存，那么拼接完成之后处理字符串就需要调用String中的方法，所以需要将StringBuilder转换成String</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> sb.append(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        System.out.println(sb==s1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链式调用</span></span><br><span class="line">        sb.append(<span class="string">&quot;李四&quot;</span>).append(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 翻转</span></span><br><span class="line">        System.out.println(sb+<span class="string">&quot;---||---&quot;</span>+sb.reverse());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换成String</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> sb.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240711001057714.png" alt="image-20240711001057714"></p>
<p>小练习：判断键盘录入的内容是否回文</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 准备StringBuilder和键盘录入</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入要判断的内容：&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 录入字符串，添加到StringBuilder</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">oldster</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        sb.append(oldster);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 翻转比较</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">newS</span> <span class="operator">=</span> sb.reverse().toString();</span><br><span class="line">        <span class="keyword">if</span> (oldster.equals(newS)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;符合回文特征&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不符合回文特征&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<blockquote>
<p>总结一下：</p>
<p>String：拼接字符串效率低，每拼接一次，都会产生一个新的字符串对象，耗费内存资源</p>
<p>StringBuilder和StringBuffer区别：</p>
<p>1、相同点：</p>
<p>​	用法一样、作用一样</p>
<p>2、不同点</p>
<p>​	StringBuilder拼接效率比StringBuffer高，但是线程不安全</p>
<p>​	StringBuffer反之</p>
</blockquote>
<p>拼接效率比较：StringBuilder&gt;StringBuffer&gt;String</p>
<h3 id="数学相关类"><a href="#数学相关类" class="headerlink" title="数学相关类"></a>数学相关类</h3><h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：数学工具类，主要用于数学运算</span><br><span class="line">特点：</span><br><span class="line">	1、构造方法私有，外界不能根据构造方法new对象</span><br><span class="line">	2、方法都是静态</span><br><span class="line">	</span><br><span class="line">使用：</span><br><span class="line">	类名直接调用</span><br></pre></td></tr></table></figure>



<h5 id="Math方法"><a href="#Math方法" class="headerlink" title="Math方法"></a>Math方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int abs(int a) -&gt; 求参数的绝对值</span><br><span class="line">static double ceil(double a) -&gt; 向上取证</span><br><span class="line">static double floor(double a) -&gt; 向下取证</span><br><span class="line">static long round(double a) -&gt; 四舍五入</span><br><span class="line">static int max(int a, int b) -&gt; 求两个数之间的较大值</span><br><span class="line">static int min(int a, int b) -&gt; 求两个数之间的较小值</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">math</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//static int abs(int a)-&gt;求参数的绝对值</span></span><br><span class="line">        System.out.println(Math.abs(-<span class="number">10</span>));</span><br><span class="line">        <span class="comment">//static double ceil(double a)-&gt;向上取整</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">3.6</span>));</span><br><span class="line">        <span class="comment">// static double floor(double a) -&gt;向下取整</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">3.6</span>));</span><br><span class="line">        <span class="comment">// static long round(double a) -&gt;四舍五入</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">3.6</span>));</span><br><span class="line">        System.out.println(Math.round(-<span class="number">2.8</span>));</span><br><span class="line">        <span class="comment">// static int max(int a，int b) -&gt;求两个数之间的较大值</span></span><br><span class="line">        System.out.println(Math.max(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">        <span class="comment">// static int min(int a，int b) -&gt;求两个数之间的较小值</span></span><br><span class="line">        System.out.println(Math.min(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712140005159.png" alt="image-20240712140005159"></p>
<blockquote>
<p>Math类还包含用于执行基本数学运算的方法，如初等函数、对数、平方根和三角函数</p>
</blockquote>
<h4 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将来可能操作特别大的数据，大到比long还大，这种数据我们称之为“对象”</span><br><span class="line"></span><br><span class="line">作用：</span><br><span class="line">	处理超大整数</span><br><span class="line">	</span><br><span class="line">构造：</span><br><span class="line">	BigInteger(String val) -&gt; 参数的格式必须是整数</span><br><span class="line">	</span><br><span class="line">方法：</span><br><span class="line">	BigInteger add(BigInteger val) -&gt; 加 返回其值为(this + val)的BigInteger</span><br><span class="line">	BigInteger subtract(BigInteger val) -&gt; 减 返回值为(this - val)的BigInteger</span><br><span class="line">	BigInteger multiply(BigInteger val) -&gt; 乘 返回其值为(this * val)的BigInteger</span><br><span class="line">	BigInteger divide(BigInteger val) -&gt; 除 返回其值为(this / val)的BigInteger</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712141206432.png" alt="image-20240712141206432"></p>
<blockquote>
<p>BigInteger主要是处理大数据，数据大到基本数据类型接受不了，传入字符串的形式，进行运算</p>
<p>int intValue()       将BigInteger转成int</p>
<p>long longValue()     将BigInteger转成long</p>
<p>BigInteger上限：42亿的21亿次方，这个大小的数一般内存遭不住，所以也可以认为BigInteger无上限</p>
</blockquote>
<h4 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">之前说过不能直接用floor或者double，因为会出现精度损失的问题</span><br><span class="line"></span><br><span class="line">这个BigDecimal 主要就是解决floor和double直接做运算时出现的精度损失问题</span><br><span class="line"></span><br><span class="line">构造：</span><br><span class="line">	BigDecimal(String val) -&gt; val必须说数字形式</span><br><span class="line">	// 构造方式有很多种，也可以直接传入double类型，但是结果具有不可预知性，不准确</span><br><span class="line">	// 如果死犟的话，可以使用静态方法 static valueOf(double)</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">常用方法：、</span><br><span class="line">	static BigDecimal valueOf(double) -&gt; 此方法初始化小数时可以传入double类型数据</span><br><span class="line">	BigDecimal add(BigDecimal val) -&gt; 加 返回其值为(this + val)的BigDecimal</span><br><span class="line">	BigDecimal subtract(BigDecimalval) -&gt; 减 返回值为(this - val)的BigDecimal</span><br><span class="line">	BigDecimal multiply(BigDecimal val) -&gt; 乘 返回其值为(this * val)的BigDecimal</span><br><span class="line">	BigDecimal divide(BigDecimal val) -&gt; 除 返回其值为(this / val)的BigDecimal</span><br><span class="line">	// 加减乘除的方法和BigInteger一样的</span><br><span class="line">	// 这个除法如果除不尽是会报一个运算错误的</span><br><span class="line">	</span><br><span class="line">	BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)</span><br><span class="line">		divisor:除数（除号后面的数）</span><br><span class="line">		scale:指定保留几位小数</span><br><span class="line">		roundingMode:取舍方式</span><br><span class="line">			static int ROUND_UP -&gt; 向上加一</span><br><span class="line">			static int ROUND_DOWN -&gt; 直接舍去</span><br><span class="line">			static int ROUND_HALF_UP -&gt; 四舍五入</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712143430357.png" alt="image-20240712143430357"></p>
<blockquote>
<p>double doubleValue()  将BigDecimal转换成doubleValue</p>
</blockquote>
<p>之前的几个取舍方式是过时的，表示已经被新的内容的替代了</p>
<p>文档上加了 <code>@Deprecated</code> 就代表是过时的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712143708424.png" alt="image-20240712143708424"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">新方法：</span><br><span class="line">	BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode)</span><br><span class="line">		divisor:除数（除号后面的数）</span><br><span class="line">		scale:指定保留几位小数</span><br><span class="line">		roundingMode(它的类型改变了):取舍方式 -&gt; RoundingMode是一个枚举，里面的成员可以直接调用</span><br><span class="line">			UP -&gt; 向上加一</span><br><span class="line">			DOWN -&gt; 直接舍去</span><br><span class="line">			HALF_UP -&gt; 四舍五入</span><br></pre></td></tr></table></figure>

<p>这个时候黄线就没了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712144355763.png" alt="image-20240712144355763"></p>
<h3 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h3><h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表示特定时间，精确到毫秒</span><br><span class="line">常识：</span><br><span class="line">	1、1000毫秒 = 1秒</span><br><span class="line">	2、时间原点1970年1月1日 0时0分0秒(UNIX系统起始时间)，叫做格林威治时间，在0时区上</span><br><span class="line">	3、时区：北京位于东八区，一个时区经度差15度，时间相差一个小时，所以北京时间比时间原点时区时间相差八个小时</span><br><span class="line">	</span><br><span class="line">使用：</span><br><span class="line">	构造方法：</span><br><span class="line">	Date() -&gt; 获取系统时间</span><br><span class="line">	Date(long time) -&gt; 获取指定时间，传递毫秒值 -&gt; 从时间原点开始算</span><br></pre></td></tr></table></figure>



<p>因为东八区，所以时间原点+了八个小时</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712172206591.png" alt="image-20240712172206591"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Date date = new Date();</span><br><span class="line">// 设置时间，从时间原点开始计算</span><br><span class="line">date.setTime(1000L);</span><br><span class="line">// 获取设置的时间，返回毫秒值</span><br><span class="line">System.out.println(date.getTime());</span><br></pre></td></tr></table></figure>



<h4 id="Calendar日历类"><a href="#Calendar日历类" class="headerlink" title="Calendar日历类"></a>Calendar日历类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：日历类，抽象类（abstract）</span><br><span class="line">获取方法：Calendar中的方法</span><br><span class="line">	static Calendar getInstance()</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">time</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">System.out.println(time);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">java.util.GregorianCalendar[time=<span class="number">1720776818898</span>,areFieldsSet=<span class="literal">true</span>,areAllFieldsSet=<span class="literal">true</span>,lenient=<span class="literal">true</span>,zone=sun.util.calendar.ZoneInfo[id=<span class="string">&quot;Asia/Shanghai&quot;</span>,offset=<span class="number">28800000</span>,dstSavings=<span class="number">0</span>,useDaylight=<span class="literal">false</span>,transitions=<span class="number">31</span>,lastRule=<span class="literal">null</span>],firstDayOfWeek=<span class="number">1</span>,minimalDaysInFirstWeek=<span class="number">1</span>,ERA=<span class="number">1</span>,YEAR=<span class="number">2024</span>,MONTH=<span class="number">6</span>,WEEK_OF_YEAR=<span class="number">28</span>,WEEK_OF_MONTH=<span class="number">2</span>,DAY_OF_MONTH=<span class="number">12</span>,DAY_OF_YEAR=<span class="number">194</span>,DAY_OF_WEEK=<span class="number">6</span>,DAY_OF_WEEK_IN_MONTH=<span class="number">2</span>,AM_PM=<span class="number">1</span>,HOUR=<span class="number">5</span>,HOUR_OF_DAY=<span class="number">17</span>,MINUTE=<span class="number">33</span>,SECOND=<span class="number">38</span>,MILLISECOND=<span class="number">898</span>,ZONE_OFFSET=<span class="number">28800000</span>,DST_OFFSET=<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">注意月份：</span><br><span class="line">    国外从<span class="number">0</span>开始，国内从<span class="number">1</span>开始，因此转换的时候月份要+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>java.util.GregorianCalendar[&#x3D;&#x3D;time&#x3D;&#x3D;&#x3D;1720776818898,areFieldsSet&#x3D;true,areAllFieldsSet&#x3D;true,lenient&#x3D;true,zone&#x3D;sun.util.calendar.ZoneInfo[id&#x3D;”Asia&#x2F;Shanghai”,offset&#x3D;28800000,dstSavings&#x3D;0,useDaylight&#x3D;false,transitions&#x3D;31,lastRule&#x3D;null],firstDayOfWeek&#x3D;1,minimalDaysInFirstWeek&#x3D;1,ERA&#x3D;1,&#x3D;&#x3D;YEAR&#x3D;&#x3D;&#x3D;2024,&#x3D;&#x3D;MONTH&#x3D;&#x3D;&#x3D;6,WEEK_OF_YEAR&#x3D;28,WEEK_OF_MONTH&#x3D;2,&#x3D;&#x3D;DAY_OF_MONTH&#x3D;&#x3D;&#x3D;12,DAY_OF_YEAR&#x3D;194,&#x3D;&#x3D;DAY_OF_WEEK&#x3D;&#x3D;&#x3D;6,DAY_OF_WEEK_IN_MONTH&#x3D;2,AM_PM&#x3D;1,&#x3D;&#x3D;HOUR&#x3D;&#x3D;&#x3D;5,&#x3D;&#x3D;HOUR_OF_DAY&#x3D;&#x3D;&#x3D;17,&#x3D;&#x3D;MINUTE&#x3D;&#x3D;&#x3D;33,&#x3D;&#x3D;SECOND&#x3D;&#x3D;&#x3D;38,MILLISECOND&#x3D;898,ZONE_OFFSET&#x3D;28800000,DST_OFFSET&#x3D;0]</p>
<table>
<thead>
<tr>
<th>字段值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR</td>
<td>年</td>
</tr>
<tr>
<td>MONTH</td>
<td>月</td>
</tr>
<tr>
<td>DAY_OF_DAY</td>
<td>日</td>
</tr>
<tr>
<td>HOUR<br/>AM_PM</td>
<td>时（12小时制）</td>
</tr>
<tr>
<td>HOUR_OF_DAY</td>
<td>时（24小时制）</td>
</tr>
<tr>
<td>MINUTE</td>
<td>分</td>
</tr>
<tr>
<td>SECOND</td>
<td>秒</td>
</tr>
<tr>
<td>DAY_OF_WEEK</td>
<td>周中的天（周日为1）</td>
</tr>
</tbody></table>
<p>最前面返回的是实现类的对象，因为不同时区不一样，因此实现类也不一样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常用方法:</span><br><span class="line">	int get(int field) -&gt; 返回给指定日历字段的值</span><br><span class="line">	void set(int field, int value) -&gt; 给定的日历字段设置为指定的值</span><br><span class="line">	void add(int field, int amount) -&gt; 根据日历的规则，为给定的日历字段添加或者减去指定的时间量</span><br><span class="line">	Date getTime() -&gt; 将Calendar转成Date对象</span><br><span class="line">	</span><br><span class="line">field：代表的是日历字段 -&gt; 年、月、日、星期等，都是静态的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">拓展方法：</span><br><span class="line">	void set(int year, int month, int date) -&gt; 直接设置年月日</span><br></pre></td></tr></table></figure>

<blockquote>
<p>比较无聊，也不演示了</p>
</blockquote>
<h4 id="SipleDateFormat日期格式化"><a href="#SipleDateFormat日期格式化" class="headerlink" title="SipleDateFormat日期格式化"></a>SipleDateFormat日期格式化</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：格式化日期，让获取到的日期看着舒服</span><br><span class="line">构造：</span><br><span class="line">	SipleDateFormat(String pattern)</span><br><span class="line">	pathhern代表的是我们自己指定的日期格式-字母不能改变，中间的连接符可以改变</span><br><span class="line">	yyyy-MM-dd HH:mm:ss</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>时间字母表示</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>y</td>
<td>年</td>
</tr>
<tr>
<td>M</td>
<td>月</td>
</tr>
<tr>
<td>d</td>
<td>日</td>
</tr>
<tr>
<td>H</td>
<td>时</td>
</tr>
<tr>
<td>m</td>
<td>分</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两个方法：</span><br><span class="line">	String format(Date date) -&gt; 将Date对象按照指定的格式转成String</span><br><span class="line">	Date parse(String source) -&gt; 将符合日期格式的字符串转化成Date对象</span><br><span class="line">	</span><br><span class="line">	SipleDateFormat sdf = new SipleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">	String time = sdf.format(new Date());</span><br><span class="line">	</span><br><span class="line">	注意：Date parse(String source)这东西有异常是个，编译时期异常，引用时需要处理，如果格式正确返回正确结果，格式错误就飘红</span><br></pre></td></tr></table></figure>



<h4 id="jdk8新日期类"><a href="#jdk8新日期类" class="headerlink" title="jdk8新日期类"></a>jdk8新日期类</h4><h5 id="LocalDate本地日期"><a href="#LocalDate本地日期" class="headerlink" title="LocalDate本地日期"></a>LocalDate本地日期</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：LocalDate是一个不可变的日期时间对象，表示日期，通常被视为年月日</span><br><span class="line">获取：</span><br><span class="line">	static LocalDate now() -&gt; 创建LocalDate对象</span><br><span class="line">	static LocalDate of(int year, int month, int datOfMonth) -&gt; 创建LocalDate对象，设置年月日</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        System.out.println(<span class="string">&quot;localDate = &quot;</span> + localDate);</span><br><span class="line"></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> LocalDate.of(<span class="number">2000</span>,<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;localDate1 = &quot;</span> + localDate1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712180450765.png" alt="image-20240712180450765"></p>
<h6 id="LocalDateTime对象"><a href="#LocalDateTime对象" class="headerlink" title="LocalDateTime对象"></a>LocalDateTime对象</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：LocalDateTime是一个不可变的日期时间对象，通常被视为年-月-日-时-分-秒</span><br><span class="line"></span><br><span class="line">获取：</span><br><span class="line">	static LocalDateTime now() -&gt; 创建LocalDateTime对象</span><br><span class="line">	static LocalDateTime of(int year，Month month，int dayofMonth，int hour，int minute，int second) -&gt; 创建Loca1DateTime对象，设置年月日时分秒</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">System.out.println(&quot;localDateTime = &quot; + localDateTime);</span><br><span class="line"></span><br><span class="line">LocalDateTime localDateTime1 = LocalDateTime.of(2000,10,10,10,10,10);</span><br><span class="line">System.out.println(&quot;localDateTime1 = &quot; + localDateTime1);</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712180934217.png" alt="image-20240712180934217"></p>
<blockquote>
<p>还可以往下设置毫秒</p>
</blockquote>
<h6 id="获取对应字段get开头"><a href="#获取对应字段get开头" class="headerlink" title="获取对应字段get开头"></a>获取对应字段get开头</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法：</span><br><span class="line">	int getYear()  -&gt; 获取年份</span><br><span class="line">	int getMonthValue() -&gt; 获取月份</span><br><span class="line">	int getDayOfMonth() -&gt; 获取月中的第几天</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line">localDate.getYear() -&gt; 获取年份</span><br><span class="line">localDate.getMonthValue() -&gt; 获取月份</span><br><span class="line">localDate.getDayOfMonth() -&gt; 获取月中的第几天</span><br></pre></td></tr></table></figure>



<h6 id="设置日期字段with开头"><a href="#设置日期字段with开头" class="headerlink" title="设置日期字段with开头"></a>设置日期字段with开头</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LocalDate withYear(int year) -&gt; 设置年份</span><br><span class="line">LocalDate withMonth(int month) -&gt; 设置月份</span><br><span class="line">LocalDate withDayOfMonth(int day) -&gt; 设置月中的第几天（从0开始）</span><br></pre></td></tr></table></figure>

<blockquote>
<p>懒得写了，调用使用对象名.方法</p>
</blockquote>
<h6 id="日期字段偏移"><a href="#日期字段偏移" class="headerlink" title="日期字段偏移"></a>日期字段偏移</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设置日期字段的偏移量，方法名以plus开头，向后偏移</span><br><span class="line">设置日期字段的偏移量，方法名以minus开头，向前偏移</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712182037010.png" alt="image-20240712182037010"></p>
<blockquote>
<p>这些方法顾名思义吧，都是点出来的</p>
</blockquote>
<h5 id="Period计算日期之间的偏差"><a href="#Period计算日期之间的偏差" class="headerlink" title="Period计算日期之间的偏差"></a>Period计算日期之间的偏差</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法：</span><br><span class="line">	static Period between(LocalDate d1,LocalDate d2) -&gt; 计算两个日期的差值</span><br><span class="line">	</span><br><span class="line">	使用Period对象接收这个差值后，使用下面方法获取对应的差值</span><br><span class="line">	</span><br><span class="line">	getYears()</span><br><span class="line">	getMonths()</span><br><span class="line">	getDays()</span><br></pre></td></tr></table></figure>



<h5 id="Duration计算时间之间的偏差"><a href="#Duration计算时间之间的偏差" class="headerlink" title="Duration计算时间之间的偏差"></a>Duration计算时间之间的偏差</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法：</span><br><span class="line">	static Duration between(Temporal startInclusive,Temporal endExclusive) -&gt; 精确计算两个日期的差值</span><br><span class="line">	</span><br><span class="line">Temporal:一个接口</span><br><span class="line">	它实现类包含：LocalDate LocalDateTime</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">注意：这两个方法不同点在于参数，Duration需要传递Temporal的实现类对象，注意要传递LocalDateTime，因为Duration计算精确时间偏差，所以需要传递能操作精确时间的LocalDateTime</span><br><span class="line"></span><br><span class="line">利用Duration获取相差的时分秒 -&gt; to开头</span><br><span class="line">	toDays()</span><br><span class="line">	toHours()</span><br><span class="line">	toMinutes()</span><br><span class="line">	toMillis() -&gt; 获取相差毫秒</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结一下两个计算时间差值的类</p>
<p>​	Period就是硬减2024-10-12减2023-9-11获取相差的年月日都是1，很离谱</p>
<p>​	Duration2024-10-12减2023-9-11获取相差的时分秒是根据实际情况来的</p>
</blockquote>
<h5 id="DateTimeFormatter日期格式化类（麻烦、难记、有替代）"><a href="#DateTimeFormatter日期格式化类（麻烦、难记、有替代）" class="headerlink" title="DateTimeFormatter日期格式化类（麻烦、难记、有替代）"></a>DateTimeFormatter日期格式化类（麻烦、难记、有替代）</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取：</span><br><span class="line">	static DateTimeFormatter ofPattern(String pattern) -&gt; 获取对象，指定格式</span><br><span class="line">	</span><br><span class="line">方法：</span><br><span class="line">	String format(TemporalAccessor temporal) -&gt; 将日期对象按照指定的规则转成String</span><br><span class="line">	TemporalAccessor:接口，子接口包括Temporal</span><br><span class="line">	Temporal的实现类LocalDate LocalDateTime</span><br><span class="line">	</span><br><span class="line">	TemporalAccessor parse(CharSeqence text) -&gt; 将符合规则的字符串转成日期对象</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter dtf =DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">Stringtime =&quot;2000-10-1010:10:10&quot;;</span><br><span class="line">TemporalAccessor temporalAccessor = dtf.parse(time);</span><br><span class="line">System.out.println(temporalAccessor);</span><br><span class="line">LocalDateTime localDateTime=LocalDateTime.from(temporalAccessor);</span><br><span class="line">System.out.println(&quot;localDateTime =&quot;+localDateTime);</span><br></pre></td></tr></table></figure>



<h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><h4 id="System"><a href="#System" class="headerlink" title="System"></a>System</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：系统相关类，是一个工具类</span><br><span class="line">特点：</span><br><span class="line">	1、构造私有化，不能new对象</span><br><span class="line">	2、方法都是静态的，类名直接调用</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>static long currentTimeMillis()</td>
<td>返回以毫秒为单位的当前时间，可以测试效率使用</td>
</tr>
<tr>
<td>static void exit(int status)</td>
<td>终止当前正在运行的Java虚拟机</td>
</tr>
<tr>
<td>static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</td>
<td>数组复制<br/>src:源数组<br/>srcPos:从源数组的哪个索引开始复制<br/>dest:目标数组<br/>destPos:从目标数组哪个索引开始粘贴<br/>length:复制多少个元素</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(System.currentTimeMillis());</span><br><span class="line">// 输出的是当前时间</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712185356217.png" alt="image-20240712185356217"></p>
<p>演示一下</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712190214070.png" alt="image-20240712190214070"></p>
<h4 id="Arrays数组工具类"><a href="#Arrays数组工具类" class="headerlink" title="&#x3D;&#x3D;Arrays数组工具类&#x3D;&#x3D;"></a>&#x3D;&#x3D;Arrays数组工具类&#x3D;&#x3D;</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：数组工具类</span><br><span class="line">特点：</span><br><span class="line">	构造私有</span><br><span class="line">	方法静态（这是工具类的特点）</span><br><span class="line">使用：类名直接调用</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>static String toString(int[] a)</td>
<td>按照格式打印数组元素<br/>[元素1，元素2……]</td>
</tr>
<tr>
<td>static void sort(int[] a)</td>
<td>升序排序（底层原理并不是冒泡排序，效果相同）</td>
</tr>
<tr>
<td>static int binarySearch(int[] a, int key)</td>
<td>二分查找(前提是升序)</td>
</tr>
<tr>
<td>static int[] copyOf(int[] orginal, int newLength)</td>
<td>数组扩容</td>
</tr>
</tbody></table>
<blockquote>
<p>之前使用过的数组操作的方法都有封号好的类之间使用即可</p>
</blockquote>
<p>排序的底层方法和之前手写的toString很相似</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712195049760.png" alt="image-20240712195049760"></p>
<p>数组扩容的底层方法和之前手写也很相似</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712215725839.png" alt="image-20240712215725839"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712220101112.png" alt="image-20240712220101112"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(arr1,<span class="number">3</span>);</span><br><span class="line">        System.out.println(index);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        arr2 = Arrays.copyOf(arr2,<span class="number">10</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr2));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：就是基本类型对应的类(包装类)，我们需要将基本类型转成包装类，从而让基本类型拥有类的特性（基本类型转成包装类之后，就可以使用包装类中的方法操作数据）</span><br><span class="line"></span><br><span class="line">为啥学包装类：</span><br><span class="line">	1、将来有一些特定场景，特定操作，比如调用方法传递包装类</span><br><span class="line">	  比如：ArrayList集合，里面有一个方法add(Integer i)，此时我们不能调用add方法之后直接传递基本类型，因为引用类型不能直接接收基本类型的值，就需要先将基本类型转成包装类，传递到add方法中</span><br><span class="line">	2、将来还可以将包装类转成基本类，因为包装类无法进行运算</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712222402317.png" alt="image-20240712222402317"></p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>Charactor</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<h4 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：int的包装类</span><br><span class="line">构造：	不推荐使用</span><br><span class="line">	Integer(int value)</span><br><span class="line">	Integer(String s) s必须是数字</span><br><span class="line">	</span><br><span class="line">	这样的构造方法是过时了的，输入就飘红了，注意这个构造方法是八个类型都有的，但是有一个特殊</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Boolean bl = new Boolean(s:&quot;true&quot;);</span><br><span class="line">System.out.println(&quot;b1 = &quot; + b1);</span><br><span class="line">Boolean b2 = new Boolean(&quot;false&quot;);</span><br><span class="line">System.out.println(&quot;b2 =&quot;+ b2);</span><br><span class="line">Boolean b3 = new Boolean(&quot;True&quot;);</span><br><span class="line">System.out.println(&quot;b3 = &quot; + b3);</span><br></pre></td></tr></table></figure>

<p>b1、b2可以理解，但是b3这里是有说法的</p>
<p>输出还是 <code>true</code> </p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712223833312.png" alt="image-20240712223833312"></p>
<p>看一下底层</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712224332386.png" alt="image-20240712224332386"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">装箱：</span><br><span class="line">	将基本类型转成对应的包装类</span><br><span class="line"></span><br><span class="line">方法：</span><br><span class="line">	static Integer valueOf(int i)</span><br><span class="line">	static Integer valueOf(String s)</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;i1 = &quot;</span> + i1);</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;i2 = &quot;</span> + i2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">拆箱：将包装类转成基本类型</span><br><span class="line">方法：</span><br><span class="line">	int intValue()</span><br><span class="line">	其他类型的包装类的拆箱方法分别是类型名+Value()</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;i1 = &quot;</span> + i1);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> i1.intValue();</span><br><span class="line">        System.out.println(<span class="string">&quot;(i+10) = &quot;</span> + (i+<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="自动拆箱装箱"><a href="#自动拆箱装箱" class="headerlink" title="自动拆箱装箱"></a>自动拆箱装箱</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">拆箱和装箱多数时候都是自动完成，在idea内可以直接</span><br><span class="line">	Integer i = 10;</span><br><span class="line">	</span><br><span class="line">	这个时候就发生了自动装箱</span><br><span class="line">	</span><br><span class="line">	Integer sum = i+10;</span><br><span class="line">	</span><br><span class="line">	自动拆箱又装箱</span><br></pre></td></tr></table></figure>



<p>反编译可以看到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> Integer.valueOf(i.intValue() + <span class="number">10</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712225700354.png" alt="image-20240712225700354"></p>
<p>拓展一下：</p>
<p>很有意思的事情，同样Integer地址值不一样</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712230119350.png" alt="image-20240712230119350"></p>
<p>看一下Integer中的装箱代码</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712230514533.png" alt="image-20240712230514533"></p>
<p>往上一翻可以发现范围是[-128,127]</p>
<p>数组内是[-128,127]的Integer对象，如果传入的数在这个范围内，就会共享这个Integer对象</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240712230801133.png" alt="image-20240712230801133"></p>
<h4 id="基本类型和String类之间的转换"><a href="#基本类型和String类之间的转换" class="headerlink" title="基本类型和String类之间的转换"></a>基本类型和String类之间的转换</h4><h5 id="基本类型转String"><a href="#基本类型转String" class="headerlink" title="基本类型转String"></a>基本类型转String</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方式一：</span><br><span class="line">	+&quot;&quot; 拼接</span><br><span class="line"></span><br><span class="line">方式二：String内的静态方法</span><br><span class="line">	static String valueOf(int i)</span><br></pre></td></tr></table></figure>



<h5 id="String转成基本数据类型"><a href="#String转成基本数据类型" class="headerlink" title="String转成基本数据类型"></a>String转成基本数据类型</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">每一个类中都有一个类似的方法： parseXXX</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>位置</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Byte</td>
<td>static byte parseByte(String s)</td>
<td>将String转成byte类型</td>
</tr>
<tr>
<td>Short</td>
<td>static byte parseShort(String s)</td>
<td>将String转成short类型</td>
</tr>
<tr>
<td>Integer</td>
<td>static byte parseInteger(String s)</td>
<td>将String转成int类型</td>
</tr>
<tr>
<td>Long</td>
<td>static byte parseLong(String s)</td>
<td>将String转成long类型</td>
</tr>
<tr>
<td>Float</td>
<td>static byte parseFloat(String s)</td>
<td>将String转成float类型</td>
</tr>
<tr>
<td>Double</td>
<td>static byte parseDouble(String s)</td>
<td>将String转成double类型</td>
</tr>
<tr>
<td>Boolean</td>
<td>static byte parseBoolean(String s)</td>
<td>将String转成boolean类型</td>
</tr>
</tbody></table>
<p>注意没有char类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private staticvoid method02() &#123;</span><br><span class="line">	int number = Integer.parseInt(&quot;1111&quot;);</span><br><span class="line">	System.out.println(number+1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在实际开发过程中如何定义一个标准的javabean</span><br><span class="line">	之前说过一些，还要补充一个：</span><br><span class="line">	定义JavaBean的时候一般会将基本类型的属性定义成包装类</span><br><span class="line">	</span><br><span class="line">其实呢，就是在原有的基础上把基本数据类型改成包装类即可</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">javabeantest</span> &#123;</span><br><span class="line"><span class="comment">//    private int uid;</span></span><br><span class="line">    <span class="keyword">private</span> Integer uid;</span><br><span class="line">    <span class="comment">// 只更改这里即可</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">javabeantest</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">javabeantest</span><span class="params">(Integer uid, String age, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.uid = uid;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(String age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getUid</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUid</span><span class="params">(Integer uid)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.uid = uid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>举例：如果uid为Integer型，默认值为null</p>
<p>1、将来JavaBean中的数据都是和数据库表联系起来的，我们可以将JavaBean中的数据添加到表中，如果表中的uid为主键自增，此时添加语句的uid中的数据不用我们单独进行赋值了</p>
<p>​	添加语句的sql语句就可以这样写：</p>
<p>​	insert into user(uid,name,age) value(NULL,”张三”,18)</p>
<p>2、到时候，我们需要将JavaBean中封装的数据获取出来放到sql语句中，如果uid为主键自增，而且JavaBean中的uid为包装类型，默认值为null，这样就不用单独维护uid的值了，也不用先给uid赋值再保存到数据库中了，就可以直接使用默认值，将默认值放到sql语句的uid列中</p>
<p>3、而且将JavaBean中的属性变为包装类，还可以使用包装类中的方法去操作此属性值</p>
</blockquote>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="了解多线程"><a href="#了解多线程" class="headerlink" title="了解多线程"></a>了解多线程</h3><h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进程：在内存上执行的引用程序</span><br><span class="line">线程：是进程中的最小执行单元</span><br><span class="line">线程作用：负责当前进程中程序的运行，一个进程中至少有一个线程</span><br><span class="line"></span><br><span class="line">在CPU和内存之间为每一个功能开辟对应的通道，方便CPU去内存中提取代码做计算，这个通道称之为“线程”</span><br><span class="line"></span><br><span class="line">简单理解：一个功能就需要一条线程去执行</span><br></pre></td></tr></table></figure>



<blockquote>
<p>1、使用场景：软件耗时操作 -&gt; 拷贝大文件，加载大量资源，聊天软件，后台服务器</p>
<p>一个线程可以干一件事，我们就可以同时做多件事</p>
</blockquote>
<h4 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">并行：在同一时刻，有多个执行在多个CPU上同时执行（就好比是多个人做不同的事）</span><br><span class="line">	比如：多个厨师在炒多个菜</span><br><span class="line">	</span><br><span class="line">并发：在同一时刻，有多个指令在单个CPU上（交替）执行</span><br><span class="line">	比如：一个厨师炒多个菜</span><br><span class="line">	</span><br><span class="line">1、之前CPU是单核，但是在执行多个程序的时候好像是在同时执行，原因是CPU在多个线程之间做高速切换</span><br><span class="line">2、现在的CPU都是多核多线程了，比如2核4线程，那么CPU可以同时执行4个线程，但是如果多了，CPU就开始切换了，所以CPU在执行程序的时候并发和并行都存在</span><br></pre></td></tr></table></figure>



<h4 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分时调度：指的是让所看的线程轮流获取CPU使用权，并且平均分配每个线程占用CPU的时间片</span><br><span class="line">2.抢占式调度：多个线程轮流抢占CPU使用权，哪个线程先抢到了，哪个线程先执行，一般都是优先级高的先抢到CPU使用权的几率大，Java程序就是抢占式调度</span><br></pre></td></tr></table></figure>



<blockquote>
<p>主线程的概念：</p>
<p>CPU和内存之间为main方法开辟的通道专门为main方法服务，这个通道叫做主线程”</p>
</blockquote>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="创建线程（重点）"><a href="#创建线程（重点）" class="headerlink" title="创建线程（重点）"></a>创建线程（重点）</h3><h4 id="继承Thread"><a href="#继承Thread" class="headerlink" title="继承Thread"></a>继承Thread</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、定义一个类，继承Thread</span><br><span class="line">2、重写run方法，在run方法中设置线程任务（所谓的线程任务指的是此线程要干的具体的事，具体执行的代码）</span><br><span class="line">3、创建自定义线程类的对象</span><br><span class="line">4、调用Thread的start方法，开启线程，jvm自动调用run方法</span><br></pre></td></tr></table></figure>



<p>重写的run方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mythread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;mythread....执行了&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>main</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">mythread</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mythread</span>();</span><br><span class="line">        <span class="comment">// 调用start方法，开启线程，jvm自动调用run方法</span></span><br><span class="line">        p1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main....执行了&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以清除的看到有抢占情况</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240713111557786.png" alt="image-20240713111557786"></p>
<blockquote>
<p>多线程在内存中的运行：</p>
<p>开启一个线程会开启一个栈空间，去运行对应的线程代码，死循环开线程，电脑直接卡死</p>
<p>同一个线程对象只能调用一个start，不能连续调用start，想再开一个线程，就new一个新的线程对象</p>
</blockquote>
<h5 id="Thread中的方法"><a href="#Thread中的方法" class="headerlink" title="Thread中的方法"></a>Thread中的方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void start() -&gt; 开启线程，jvm自动调用run方法</span><br><span class="line">void run() -&gt; 设置线程任务，这个run方法是Thread重写接口Runnable中的run方法</span><br><span class="line">String getName() -&gt; 获取线程名字 默认是Thread-i i从0递增</span><br><span class="line">String setName() -&gt; 设置线程名字</span><br><span class="line">static Thread currentThread() -&gt; 获取正在执行的线程对象</span><br><span class="line">static void sleep(long millis) -&gt; 线程休眠，单位是毫秒</span><br></pre></td></tr></table></figure>



<p>复习一下异常的知识，这里继承的Thread是不能抛异常的，原因是Thread中的run方法没有抛异常，这里也不能上抛，只能try……catch</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240713113958896.png" alt="image-20240713113958896"></p>
<blockquote>
<p>如果我想知道主线程的线程名称，我的main方法又没有继承Thread很显然不能getName，这个时候就需要currentThread()方法，获得当先运行的Thread对象，写一个链式调用即可</p>
<p>Thread.currentThread().getName()</p>
<p>返回结果是main</p>
</blockquote>
<h5 id="Thread中的其他方法"><a href="#Thread中的其他方法" class="headerlink" title="Thread中的其他方法"></a>Thread中的其他方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void setPriority(int newPriority) -&gt; 设置线程优先级，优先级越高的线程，抢到CPU使用权的几率越大，但是不是每次都能抢到</span><br><span class="line"></span><br><span class="line">int getPriority() -&gt; 获取线程优先级</span><br><span class="line"></span><br><span class="line">void setDaemon(boolean on) -&gt; 设置为守护线程 执行完非守护线程，守护线程就要结束，无论是否执行完毕</span><br><span class="line"></span><br><span class="line">static void yie1d() -&gt; 礼让线程，让当前线程让出CPU使用权</span><br><span class="line"></span><br><span class="line">void join() -&gt; 插入线程或者插队线程</span><br></pre></td></tr></table></figure>



<h6 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h6><p>可以看到优先级都为5</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240713115035035.png" alt="image-20240713115035035"></p>
<blockquote>
<p>看一下底层代码，最小为1，默认为5，最大为10</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240713115157530.png" alt="image-20240713115157530"></p>
<p>但是效果并不是特点明显，最高优先级也不是每次都能抢到</p>
</blockquote>
<h6 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h6><p>main</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">mythread</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mythread</span>();</span><br><span class="line">        <span class="type">mythread01</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mythread01</span>();</span><br><span class="line">        p1.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        p2.setDaemon(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用start方法，开启线程，jvm自动调用run方法</span></span><br><span class="line">        p1.start();</span><br><span class="line">        p2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>守护线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mythread01</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">100</span> ; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;李四....执行了&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>非守护线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mythread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;mythread....执行了&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到其他线程结束后，守护线程也结束了，并没有循环完100次</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240713115832529.png" alt="image-20240713115832529"></p>
<blockquote>
<p>守护线程也不是马上结束了，当非守护线程结束之后，系统会告诉守护线程，告知的过程中，守护线程仍在执行，我感觉使用场景很适合游戏反作弊</p>
</blockquote>
<h6 id="礼让线程"><a href="#礼让线程" class="headerlink" title="礼让线程"></a>礼让线程</h6><p>写在一个实现类内，理想型是p1、p2交叉执行，但是并不是绝对的，只是尽可能的平衡，即使礼让了仍然会有连续执行的情况</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240713121008607.png" alt="image-20240713121008607"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">核心语句：</span><br><span class="line">	Thread.yield();</span><br></pre></td></tr></table></figure>



<h6 id="插入线程"><a href="#插入线程" class="headerlink" title="插入线程"></a>插入线程</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">插入线程的效果不错，但是用的不是很多</span><br></pre></td></tr></table></figure>



<p>main</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">mythread</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mythread</span>();</span><br><span class="line">        p1.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用start方法，开启线程，jvm自动调用run方法</span></span><br><span class="line">        p1.start();</span><br><span class="line">        p1.join();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main执行了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread实现了Runnable接口，重写了run方法，Runnable接口中只要一个run方法</span><br><span class="line"></span><br><span class="line">1、创建类，实现Runnable接口</span><br><span class="line">2、重写run方法，设置线程任务</span><br><span class="line">3、利用Thread类的构造方法：Thread(Runnable target)，创建Thread对象(线程对象)，将自定义的类当参数传递到Thread构造中 -&gt; 这一步是让我们自己定义的类成为一个真正的线程类对象</span><br><span class="line">4、调用Thread中的start方法，开启线程，jvm自动调用run方法</span><br></pre></td></tr></table></figure>



<p>实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;...执行了&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>main</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">m1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Thread(Runnable target);</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(m1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用start方法开启线程</span></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;执行&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="两种创建方法的区别"><a href="#两种创建方法的区别" class="headerlink" title="两种创建方法的区别"></a>两种创建方法的区别</h4><blockquote>
<p>1、继承Thread：继承只支持单继承，有继承的局限性</p>
<p>2、实现Runnable：没有继承的局限性</p>
<p>MyRunnable extends Fu implements Runnable</p>
<p>总结就是：Runnable节省了一个继承卡槽</p>
</blockquote>
<h4 id="匿名内部类创建多线程"><a href="#匿名内部类创建多线程" class="headerlink" title="匿名内部类创建多线程"></a>匿名内部类创建多线程</h4><blockquote>
<p>严格意义来说，匿名内部类方式不属于创建多线程方式其中之一，因为匿名内部类形式建立在实现Runnable接口或者继承Thread的基础上完成的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">回顾：</span><br><span class="line">	new 接口/抽象类()&#123;</span><br><span class="line">		重写方法</span><br><span class="line">	&#125;.重写的方法()</span><br><span class="line">	</span><br><span class="line">	or</span><br><span class="line">	</span><br><span class="line">	接口名/类名 对象名 = new 接口/抽象类()&#123;</span><br><span class="line">		重写方法</span><br><span class="line">	&#125;</span><br><span class="line">	 对象名.重写的方法();</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 相当于继承Thread</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;张三&quot;</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 相当于实现Runnable</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;李四&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Thread也为匿名内部类提供了命名的方法：</p>
<p>继承Thread的时候，直接传入一个字符串，会给线程命名</p>
<p>实现Runnable的时候，传入一个Runnable对象的同时再传入一个字符串实现命名</p>
</blockquote>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><blockquote>
<p>什么时候发生：</p>
<p>​	多个线程访问同一个资源时，导致了数据出现问题</p>
</blockquote>
<p>可以看到三个人访问了同一个，甚至还买到了第0张</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240713152801971.png" alt="image-20240713152801971"></p>
<p>线程有问题的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">ticker</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ticker &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;买了第&quot;</span>+ticker+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                ticker--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">myRunnable</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">myRunnable</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(p1,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(p1,<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(p1,<span class="string">&quot;王五&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因：CPU在不同线程之间做高速切换导致的，在前一个人进入线程还没还得及ticket–的时候，下一个人也访问了进来，就造成了有3个第100的现象，0也是这样，前一个人还没–，就通过if判断进入，前者–，后者输出ticket就出现了0</p>
</blockquote>
<h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">问题抛出来了，肯定得解决</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">	synchronized(任意对象)&#123;</span><br><span class="line">		线程可能出现的不安全代码</span><br><span class="line">	&#125;</span><br><span class="line">1、任意对象：就是锁对象</span><br><span class="line">2、执行：</span><br><span class="line">	一个线程拿到锁之后，会进入到同步代码块中执行，在此期间，其他线程拿不到锁，就进不去同步代码块，需要在同步代码块外面等待排队，需要等着执行的线程执行完毕，出了同步代码块，相当于释放锁，等待的线程才能抢到锁，才能进入到同步代码块中执行</span><br><span class="line">3、默认锁：this</span><br></pre></td></tr></table></figure>



<p>解决问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">ticker</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                <span class="keyword">if</span> (ticker &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;买了第&quot;</span>+ticker+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    ticker--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样的方式既可以解决访问用一个对象，还加了一个sleep防止全被同一个人拿走</p>
<p>锁只能有一把，不能多把，联合实际也可以理解</p>
</blockquote>
<h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><h5 id="普通同步方法"><a href="#普通同步方法" class="headerlink" title="普通同步方法"></a>普通同步方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	修饰符 synchronized 返回值类型 方法名(参数)&#123;</span><br><span class="line">		方法体</span><br><span class="line">		return 结果</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">ticker</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//method();</span></span><br><span class="line">            testMethod();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ticker &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;买了第&quot;</span>+ticker+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            ticker--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ticker &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;买了第&quot;</span>+ticker+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                ticker--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上方代码块内method是普通同步方法，虽然没有指定锁，但是这个锁是this，也就是说，普通同步方法method和下方的同步代码块testMethod是一样的</p>
</blockquote>
<h5 id="静态同步方法"><a href="#静态同步方法" class="headerlink" title="静态同步方法"></a>静态同步方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	修饰符 static synchronized 返回值类型 方法名(参数)&#123;</span><br><span class="line">		方法体</span><br><span class="line">		return 结果</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">默认锁：class对象</span><br></pre></td></tr></table></figure>



<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticker</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//method01();</span></span><br><span class="line">            testMethod01();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ticker &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;买了第&quot;</span>+ticker+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            ticker--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testMethod01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (myRunnable.class)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ticker &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;买了第&quot;</span>+ticker+<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                ticker--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为静态成员不能访问非静态成员，所以需要将ticket变为静态的，然后锁变为了class，其他的和普通同步方法很相似</p>
</blockquote>
<p>拓展一下：之前说过StringBuilder多线程时不安全，但是效率高，StringBuffer安全但是效率低</p>
<p>原因就是StringBuffer的方法都是带synchronized的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240713162603427.png" alt="image-20240713162603427"></p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁是指两个或者两个以上的线程在执行过程中由于竞争同步锁而产生的一种阻塞现象；如果没有外力的作用，他们将无法继续执行下去，这种情况称之为死锁</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240713162944893.png" alt="image-20240713162944893"></p>
<blockquote>
<p>如图所示：线程1正在持有锁1，但是线程1必须再拿到锁2，才能继续执行</p>
<p>而线程2正在持有锁2，但是线程2需要再拿到锁1，才能继续执行</p>
<p>此时两个线程处于互相等待的状态，就是死锁，在程序中的死锁将出现在同步代码块的嵌套中</p>
</blockquote>
<p>因此，我们应该&#x3D;&#x3D;避免同步代码的嵌套&#x3D;&#x3D;</p>
<p>实现一个死锁看看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">LockA</span> <span class="variable">lockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockA</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">LockB</span> <span class="variable">lockB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockB</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Run</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Run</span><span class="params">(<span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Run</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LockA.lockA)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;if...LockA&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (LockB.lockB)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;if...LockB&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LockB.lockB)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;else...LockA&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (LockA.lockA)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;else...LockB&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Run</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Run</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Run</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Run</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(p1).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(p2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种情况大概率死锁，但也有小概率手快，两个都拿了，执行完毕释放出来。</p>
<p>看个乐呵，还是要避免嵌套</p>
</blockquote>
<h3 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程被创建并启动后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程中生命周期中，有几种状态呢？在API中Java.lang.Thread.State这个枚举中给出了六种线程状态：</span><br><span class="line">	这里先列出各个线程状态发生的条件，下面将会每种状态进行详细解析。</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>线程状态</th>
<th>导致状态发生体哦阿健</th>
</tr>
</thead>
<tbody><tr>
<td>NEW(新建)</td>
<td>线程刚被创建，但是并未启动。还没调用start方法。</td>
</tr>
<tr>
<td>Runnable(可运行)</td>
<td>线程可以在Java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器</td>
</tr>
<tr>
<td>Blocked(锁阻塞)</td>
<td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁，该线程将变成Runnable状态</td>
</tr>
<tr>
<td>Waiting(无线等待)</td>
<td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒</td>
</tr>
<tr>
<td>Timed Waiting(计时等待)</td>
<td>同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这个状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep、Object.wait。</td>
</tr>
<tr>
<td>Terminated(被终止)</td>
<td>因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。或者调用过时方法stop()</td>
</tr>
</tbody></table>
<p>画图表示</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240713175148947.png" alt="image-20240713175148947"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意以下方法</span><br><span class="line"></span><br><span class="line">1、sleep(time)和wait(time)的区别</span><br><span class="line">	sleep(time):线程睡眠，在睡眠的过程中，线程不会释放锁，此时其他线程抢不到锁，设置时间一旦超时，自动醒来，继续执行</span><br><span class="line">	wait(time):线程等待，在等待的过程中会释放锁，其他线程就可能抢到锁，如果在等待的过程中被唤醒或者时间超时，会和其他的线程重新抢锁，如果抢到了继续执行，抢不到进入锁阻塞</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、wait()和notify()</span><br><span class="line">	wait():空参wait，线程进入无限等待状态，会释放锁，需要其他线程调用notify(一次唤醒一条等待的线程，唤醒的线程是随机的)或者notifyAll方法(将所有等待线程全唤醒)，被唤醒之后，会和其他的线程重新抢锁，如果抢到了继续执行，抢不到进入锁阻塞</span><br><span class="line">	notify():notify会唤醒正在等待的线程，一次只能唤醒一条等待的线程；如果多线程等待，随机唤醒一条 </span><br><span class="line">	notifyAll():唤醒所有等待的线程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3、wait和notify两个方法的用法：</span><br><span class="line">	两个方法都需要锁对象调用，所以两个方法需要用到同步代码块、同步方法中</span><br><span class="line">	俩个方法的调用必须是同一个锁对象调用，可以理解为用同一个锁对象，将多条线程分到了一组中，这样notify就知道唤醒的是自己本组的等待线程</span><br></pre></td></tr></table></figure>



<h3 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需求：一个线程生产，一个线程消费，不能连续生产，不能连续消费 -&gt; 等待唤醒机制（线程之间通信）</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void wait()</td>
<td>线程等待，等待的过程会释放锁，需要被其他线程调用notify方法将其唤醒，重新抢锁执行</td>
</tr>
<tr>
<td>void notify()</td>
<td>线程唤醒，一次唤醒一个等待线程，多条线程等待，随机唤醒一条线程</td>
</tr>
<tr>
<td>void notifyAll()</td>
<td>线程唤醒，唤醒所有等待线程</td>
</tr>
</tbody></table>
<blockquote>
<p>wait和notify方法需要锁对象调用，所以需要用到同步代码块中，而且必须是同一锁对象</p>
</blockquote>
<p>案例代码</p>
<blockquote>
<p>思路：</p>
<p>​	1、怎么生产和消费包子</p>
<p>​			count++,count–</p>
<p>​	2、怎么证明有没有包子</p>
<p>​			设置一个flag flag&#x3D;true表示有</p>
<p>​	3、如何防止生产到一半，CPU切换</p>
<p>​			加锁</p>
<p>​	4、如何保证生产一个消费一个，防止连续生产，连续消费</p>
<p>​			wait和notify方法</p>
</blockquote>
<p>生产流水线</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjjws.h_stop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">suo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Test test;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">suo</span><span class="params">(Test test)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.test = test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (test)&#123;</span><br><span class="line">                <span class="keyword">if</span> (test.isFlag()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        test.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    test.setCount();</span><br><span class="line">                    test.setFlag(<span class="literal">true</span>);</span><br><span class="line">                    test.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>消费流水线</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjjws.h_stop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">baoz</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Test test;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">baoz</span><span class="params">(Test test)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.test = test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (test)&#123;</span><br><span class="line">                <span class="keyword">if</span> (test.isFlag()==<span class="literal">false</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        test.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    test.getCount();</span><br><span class="line">                    test.setFlag(<span class="literal">false</span>);</span><br><span class="line">                    test.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>包子铺</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjjws.h_stop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFlag</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlag</span><span class="params">(<span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费第&quot;</span>+count+<span class="string">&quot;个包子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCount</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产第&quot;</span>+count+<span class="string">&quot;个包子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了方便查看，消费包子就不count--了</span></span><br></pre></td></tr></table></figure>



<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjjws.h_stop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">suo</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">suo</span>(test);</span><br><span class="line">        <span class="type">baoz</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">baoz</span>(test);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(p1);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(p2);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试这里很关键，在两个线程内添加了锁，但是应该如何保证是同一把锁呢，这个就需要将两个方法的对象设置成同一个，使用有参构造来更改对象地址值，确保是同一把锁。</span></span><br></pre></td></tr></table></figure>



<p>还可以使用同步方法来完成</p>
<p>生产</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjjws.h_stop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">suo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Test test;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">suo</span><span class="params">(Test test)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.test = test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            test.setCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>消费</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjjws.h_stop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">baoz</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Test test;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">baoz</span><span class="params">(Test test)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.test = test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            test.getCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>包子铺</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjjws.h_stop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFlag</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlag</span><span class="params">(<span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.flag==<span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.flag = <span class="literal">false</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费第&quot;</span>+count+<span class="string">&quot;个包子&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.flag) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产第&quot;</span>+count+<span class="string">&quot;个包子&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.notify();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后一次测试就不粘贴了。和上面一样，更改就在于将setcount和getcount更改为了同步方法，因为同步方法的锁默认是this，因此和上面的代码效果是相同的</span></span><br></pre></td></tr></table></figure>



<p><strong>多等待多唤醒案例</strong></p>
<blockquote>
<p>如果有多条线程的话，上面的方法还是有点问题的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"></span><br><span class="line">     <span class="type">suo</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">suo</span>(test);</span><br><span class="line">     <span class="type">baoz</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">baoz</span>(test);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(p1).start();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(p1).start();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(p1).start();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(p2).start();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(p2).start();</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(p2).start();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>症结在于notify，因为是随机唤醒，这个机制面对6个对象抢锁的时候会出现问题，因此面对多线程的时候要使用notifyAll来防止没有线程来抢锁了</p>
</blockquote>
<p>因此只需要改变notify即可</p>
<blockquote>
<p>不改变：这个情况是全都wait了，卡死了，全休眠去了，没有活着的线程了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240717165337495.png" alt="image-20240717165337495"></p>
</blockquote>
<p>这里老师讲的很迷，连续消费，连续生产的问题，只需要加上应该else就可以解决，因为他的代码没有else出了if就还会继续执行下面的语句</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240717170023463.png" alt="image-20240717170023463"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240717170224882.png" alt="image-20240717170224882"></p>
<p>他之所以这样写，是为了铺垫下面的把if改成while，就是循环判断，防止唤醒之后，没有判断就继续执行代码，仔细想一下还是while比较安全、迅速一些</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.flag) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.flag = <span class="literal">false</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费。。。。。。。第&quot;</span>+count+<span class="string">&quot;个包子&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">this</span>.flag) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">    System.out.println(<span class="string">&quot;生产第&quot;</span>+count+<span class="string">&quot;个包子&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">this</span>.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：</span><br><span class="line">	Lock是一个接口</span><br><span class="line">	</span><br><span class="line">实现类：</span><br><span class="line">	ReentrantLock</span><br><span class="line">	</span><br><span class="line">方法：</span><br><span class="line">	lock() -&gt; 获取锁</span><br><span class="line">	unlock() -&gt; 释放锁</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjjws.j_lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">ticker</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (ticker &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;买了第&quot;</span> + ticker + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                ticker--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以小小借用一下try</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">ticker</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span> (ticker &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;买了第&quot;</span> + ticker + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    ticker--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>synchronized：不管是同步代码块还是同步方法，都需要在结束一对{}之后，释放锁对象</p>
<p>Lock：是通过两个方法控制需要被同步的代码，形式上更加灵活</p>
</blockquote>
<h3 id="实现多线程方式3-Callable接口"><a href="#实现多线程方式3-Callable接口" class="headerlink" title="实现多线程方式3-Callable接口"></a>实现多线程方式3-Callable接口</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、继承Thread</span><br><span class="line">2、实现Runnable接口</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Callable&lt;V&gt;是一个接口，类似于Runnable</span><br><span class="line">方法：</span><br><span class="line">	V call() -&gt; 设置线程任务，类似于run方法</span><br><span class="line">	</span><br><span class="line">&lt;V&gt;：</span><br><span class="line">	泛型</span><br><span class="line">	用于指定我们操作什么类型的数据，&lt;&gt;内只能写引用数据类型，也就是说基本数据类型要转换成包装类，如果泛型不写，默认是Object类型数据</span><br><span class="line">	实现callable接口时，指定泛型是什么类型的，重写call方法返回值就是什么类型</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">获取call方法返回值：FutureTask&lt;V&gt;</span><br><span class="line">	1、FutureTask&lt;V&gt;实现了一个接口：Future&lt;V&gt;</span><br><span class="line">	2、FutureTask&lt;V&gt;中有一个方法：</span><br><span class="line">	// FutureTask是Future的实现类</span><br><span class="line">	</span><br><span class="line">		V get() -&gt; 获取call方法的返回值</span><br></pre></td></tr></table></figure>

<blockquote>
<p>run方法和call方法的区别：</p>
<p>​	相同点：</p>
<p>​		设置线程任务</p>
<p>​	不同点：</p>
<p>​		call方法有返回值，有异常可以throws</p>
<p>​		run方法没有返回值，有异常不能throws</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240717175339488.png" alt="image-20240717175339488"></p>
</blockquote>
<p>实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mycall</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;隔壁老王和金莲不得不说的故事&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">mycall</span> <span class="variable">call</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mycall</span>();</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(call);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程对象 -&gt; Thread(Runnable targer) </span></span><br><span class="line">        <span class="comment">// 可以看出FutureTask和Runnable还是有一些关系的</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// futureTask.get()是获取call方法返回值的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实现多线程方式4-线程池"><a href="#实现多线程方式4-线程池" class="headerlink" title="实现多线程方式4-线程池"></a>实现多线程方式4-线程池</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">之前来一个线程任务，就需要创建一个线程对象去执行，用完还需要销毁线程对象，如果线程任务多了，就需要频繁创建线程对象和线程对象，这样会耗费内存资源，所以我们就想到线程对象能不能循环利用，用的时候直接拿线程对象，用完还回去</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>线程池：</p>
<p>​	创建线程池对象，指定最多能有几个线程对象</p>
<p>​	未到达上限时，如果没有线程对象，创建线程对象，用还还回去</p>
<p>​	到达上限后，等其他线程任务执行完毕归还线程对象后，再使用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建线程池对象：</span><br><span class="line">	工具类：Executors</span><br><span class="line">	</span><br><span class="line">获取线程池对象：</span><br><span class="line">	Executors中的静态方法</span><br><span class="line">	static ExecutorService newFixedThreadPool(int nThreads)</span><br><span class="line">	1、参数：指定线程池中最多创建的线程对象条数</span><br><span class="line">	2、返回值ExecutorService是线程池，用来管理线程对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">执行线程任务：ExceutorService中的方法</span><br><span class="line">	Future&lt;?&gt; submit(Runnable task) -&gt; 提交一个Runnable任务，用于执行</span><br><span class="line">	Future&lt;T&gt; submit(Callable&lt;T&gt; task) -&gt; 提交一个Callable任务用于执行</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">submit方法的返回值：Future接口</span><br><span class="line">	用于接收run方法或者call方法返回值的，但是run方法没有返回值，所以不用Future接收，执行call方法需要用Future接收</span><br><span class="line">	Future中有一个方法：V get() -&gt; 获取call方法的返回值</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">ExecutorService中的方法：</span><br><span class="line">	void shutdown() -&gt; 启动有序关闭，其中先前提交的任务被执行，但不会接收新的任务（关闭线程池）</span><br></pre></td></tr></table></figure>


<p>定义线程任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sjjws.k_call;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">mycall</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;执行了&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>执行方法一——run方法使用较多</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">method</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">mycall</span>());</span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">mycall</span>());</span><br><span class="line">        es.submit(<span class="keyword">new</span> <span class="title class_">mycall</span>());</span><br><span class="line"></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>执行方法二——获取返回值（call）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">public class method01 &#123;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(2);</span><br><span class="line">        Future&lt;Integer&gt; future = es.submit(new mycall());</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="定时器-Timer"><a href="#定时器-Timer" class="headerlink" title="定时器 Timer"></a>定时器 Timer</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不属于上面的内容，算作一个补充</span><br><span class="line">构造：</span><br><span class="line">	Timer()</span><br><span class="line">	</span><br><span class="line">方法：</span><br><span class="line">	void schedule(TimerTask task, Date firstTime, long period)</span><br><span class="line">		task:抽象类，是Runnable的实现类</span><br><span class="line">		firstTime：从什么时间开始执行，一般写new Date</span><br><span class="line">		period:每隔多长时间执行一次，设置的是毫秒值</span><br></pre></td></tr></table></figure>



<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="集合框架（单列集合）"><a href="#集合框架（单列集合）" class="headerlink" title="集合框架（单列集合）"></a>集合框架（单列集合）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">之前学了的保存数据的有：变量、数组、但是数组有一个很大的缺点——定长，如果增删改数据，数组并不好用，需要创建新数组</span><br><span class="line"></span><br><span class="line">集合是一个长度可变的容器</span><br><span class="line">特点：</span><br><span class="line">	1、只能存储引用数据类型数据</span><br><span class="line">	2、长度可变</span><br><span class="line">	3、集合中有大量的方法，方便操作</span><br><span class="line">	</span><br><span class="line">分类：</span><br><span class="line">	1、单列集合：一个元素就一个组成部分</span><br><span class="line">		list.add(&quot;张三&quot;)</span><br><span class="line">	2、双列集合：一个元素有两个组成部分（key value）键值对一一对应（字典）</span><br><span class="line">		map.put(&quot;李四&quot;,&quot;王五&quot;)</span><br></pre></td></tr></table></figure>



<h4 id="框架介绍："><a href="#框架介绍：" class="headerlink" title="框架介绍："></a>框架介绍：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单列集合顶级接口：</span><br><span class="line">	Collection接口</span><br><span class="line">	</span><br><span class="line">Collection下有两个接口list和set</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list有三个实现类ArrayList、LinkedList、Vector</span><br><span class="line"></span><br><span class="line">ArrayList：</span><br><span class="line">	1、元素有序</span><br><span class="line">	2、元素可重复</span><br><span class="line">	3、有索引</span><br><span class="line">	4、线程不安全</span><br><span class="line">	5、底层数据结构是数组</span><br><span class="line">	</span><br><span class="line">LinkedLink：</span><br><span class="line">	1、元素有序</span><br><span class="line">	2、元素可重复</span><br><span class="line">	3、有索引</span><br><span class="line">	4、线程不安全</span><br><span class="line">	5、底层数据结构是双向链表</span><br><span class="line">	</span><br><span class="line">Vector：</span><br><span class="line">	1、元素有序</span><br><span class="line">	2、元素可重复</span><br><span class="line">	3、有索引</span><br><span class="line">	4、线程不安全</span><br><span class="line">	5、底层数据结构是数组</span><br><span class="line">	// 元老级别的了，因为安全所以慢，用的也少</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">set接口也有三个实现类HashSet、LinkedHashSet、TreeSet</span><br><span class="line"></span><br><span class="line">HashSet：</span><br><span class="line">	1、元素无序</span><br><span class="line">	2、元素唯一</span><br><span class="line">	3、无索引</span><br><span class="line">	4、线程不安全</span><br><span class="line">	5、底层数据结构是哈希表</span><br><span class="line">	</span><br><span class="line">LinkedHashSet：</span><br><span class="line">	还是HashSet的子类</span><br><span class="line">	1、元素有序</span><br><span class="line">	2、元素唯一</span><br><span class="line">	3、无索引</span><br><span class="line">	4、线程不安全</span><br><span class="line">	5、底层数据结构是哈希表+双向链表</span><br><span class="line">	LinkedList本质上无索引，但是Java为其提供了很多根据索引操作元素的方法</span><br><span class="line">	</span><br><span class="line">TreeSet：</span><br><span class="line">	1、可对元素进行排序</span><br><span class="line">	2、元素唯一</span><br><span class="line">	3、无索引</span><br><span class="line">	4、线程不安全</span><br><span class="line">	5、底层数据结构是红黑树</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240719200404369.png" alt="image-20240719200404369"></p>
<h4 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：单列集合的顶级接口</span><br><span class="line">使用：</span><br><span class="line">	创建：</span><br><span class="line">		Collection&lt;E&gt; 对象名 = new 实现类对象&lt;E&gt;()</span><br><span class="line">	&lt;E&gt;泛型：</span><br><span class="line">		决定了集合中能存储什么类型的数据，可以统一元素类型</span><br><span class="line">		泛型中只能写引用数据类型，因此集合只能存储引用数据类型，如果不写，默认是Object类型，此时什么类型的数据都可以存储</span><br><span class="line">	细节：</span><br><span class="line">		我们等号前面的泛型必须写，等号后面的泛型可以不写，jvm可以根据前面的泛型推导出后面的泛型是啥</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常用方法：</span><br><span class="line">	boolean add(E e)：将给定的元素添加到当前集合中（我们一般调add时，不用boolean接收，因为add一定会成功）</span><br><span class="line">	boolean addAll(collection&lt;？extendsE&gt;c):将另一个集合元素添加到当前集合中（集合合并）(把括号内的元素添加到后面)</span><br><span class="line">	void clear()：清除集合中所有的元素</span><br><span class="line">	boolean contains(object o)：判断当前集合中是否包含指定的元素</span><br><span class="line">	boolean isEmpty(）：判断当前集合中是否有元素-&gt;判断集合是否为空</span><br><span class="line">	boolean remove(object o)：将指定的元素从集合中删除</span><br><span class="line">	int size()：返回集合中的元素个数。</span><br><span class="line">	object[] toArray()：把集合中的元素，存储到数组中</span><br></pre></td></tr></table></figure>



<blockquote>
<p>为啥说add一定成功呢，因为如果传入的类型不正确，会出现编译时期异常</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240719203320666.png" alt="image-20240719203320666"></p>
</blockquote>
<p>实践一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01collection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;String&gt; c1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//boolean add(E e)：将给定的元素添加到当前集合中（我们一般调add时，不用boolean接收，因为add一定会成功）</span></span><br><span class="line">        c1.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        c1.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        c1.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        c1.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        c1.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        c1.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        System.out.println(c1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//boolean addAll(collection&lt;？extendsE&gt;c):将另一个集合元素添加到当前集合中（集合合并）(把括号内的元素添加到后面)</span></span><br><span class="line">        Collection&lt;String&gt; c2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        c2.add(<span class="string">&quot;王二麻子&quot;</span>);</span><br><span class="line">        c2.add(<span class="string">&quot;王二麻子&quot;</span>);</span><br><span class="line">        c2.add(<span class="string">&quot;王二麻子&quot;</span>);</span><br><span class="line">        c2.add(<span class="string">&quot;王二麻子&quot;</span>);</span><br><span class="line">        c2.add(<span class="string">&quot;王二麻子&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;c2 = &quot;</span> + c2);</span><br><span class="line">        c1.addAll(c2);</span><br><span class="line">        System.out.println(<span class="string">&quot;c1 = &quot;</span> + c1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//void clear()：清除集合中所有的元素</span></span><br><span class="line">        c2.clear();</span><br><span class="line">        System.out.println(<span class="string">&quot;c2 = &quot;</span> + c2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//boolean contains(object o)：判断当前集合中是否包含指定的元素</span></span><br><span class="line">        System.out.println(c1.contains(<span class="string">&quot;赵四&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//boolean isEmpty(）：判断当前集合中是否有元素-&gt;判断集合是否为空</span></span><br><span class="line">        System.out.println(<span class="string">&quot;c1中无元素&quot;</span>+c1.isEmpty());</span><br><span class="line">        System.out.println(<span class="string">&quot;c2中无元素&quot;</span>+c2.isEmpty());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//boolean remove(object o)：将指定的元素从集合中删除</span></span><br><span class="line">        System.out.println(<span class="string">&quot;c1 = &quot;</span> + c1);</span><br><span class="line">        c1.remove(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;c1 = &quot;</span> + c1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//int size()：返回集合中的元素个数。</span></span><br><span class="line">        System.out.println(c1.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//object[] toArray()：把集合中的元素，存储到数组中</span></span><br><span class="line">        Object[] arr = c1.toArray();</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240719211259568.png" alt="image-20240719211259568"></p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：主要作用就是遍历集合</span><br><span class="line">需要用到一个接口：Iterator</span><br><span class="line">获取：</span><br><span class="line">	Inerator&lt;E&gt; iterator()</span><br><span class="line">	// 这是collection中的一个方法</span><br><span class="line">	</span><br><span class="line">方法：</span><br><span class="line">	boolean hasNext() -&gt; 判断集合中有没有下一个元素</span><br><span class="line">	E next() -&gt; 获取下一个元素</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240719213600905.png" alt="image-20240719213600905"></p>
<blockquote>
<p>注意：next方法在获取的时候不要连续使用多次</p>
<p>很好理解，告诉你下一个有，结果一次拿两个，第二个可能拿不到，报错&#x3D;&#x3D;NoSuchElementException&#x3D;&#x3D;：没有操作的元素异常</p>
</blockquote>
<p>说说我自己的看法，这个迭代器的作用就是用来遍历集合，通过for循环或者增强的for循环也可以解决</p>
<h4 id="迭代器的迭代过程"><a href="#迭代器的迭代过程" class="headerlink" title="迭代器的迭代过程"></a>迭代器的迭代过程</h4><p><img src="/../%E5%9B%BE%E7%89%87/image-20240719220403029.png" alt="image-20240719220403029"></p>
<p>这里定义了一个负一，这样查看下一个是否存在的方法就可以检验索引了，这样迭代的过程就很好理解了，和for循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int cursor;</span><br><span class="line">int lasRet = -1;</span><br></pre></td></tr></table></figure>



<h4 id="迭代器底层原理"><a href="#迭代器底层原理" class="headerlink" title="迭代器底层原理"></a>迭代器底层原理</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取Iterator的时候怎么获取</span><br><span class="line">	Iterator iterator = list.iterator()</span><br><span class="line">	我们知道Iterator是一个接口。等号右边一定是它的实现类对象</span><br><span class="line">	Iterator接收的是哪个实现类对象呢？ -&gt; ArrayList中的内部类Itr对象</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240721082927838.png" alt="image-20240721082927838"></p>
<blockquote>
<p>注意：</p>
<p>​	只要ArrayList使用迭代器的时候Iterator接口才会是Itr来实现，其他的集合使用迭代器，不是由Itr来实现的</p>
<p>例如：HashSet做迭代指向KeyIterator</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240721084358237.png" alt="image-20240721084358237"></p>
</blockquote>
<h4 id="并发修改异常"><a href="#并发修改异常" class="headerlink" title="并发修改异常"></a>并发修改异常</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需求：定义一个集合，存储 唐僧、悟空、猪八戒、沙和尚，要求遍历到猪八戒的时候在后面添加上白龙马</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02collection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;唐僧&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;悟空&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;猪八戒&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;沙和尚&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">em</span> <span class="operator">=</span> iterator.next().toString();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;猪八戒&quot;</span>.equals(em)) &#123;</span><br><span class="line">                list.add(<span class="string">&quot;白龙马&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候异常就来了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240721090259358.png" alt="image-20240721090259358"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	modCount：表示实际操作次数</span></span><br><span class="line"><span class="comment">    	expectedModCount：表示预计操作次数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    …………………………</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="comment">// 当实际操作次数和预计操作次数不等时，抛出并发修改异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkForComodification抛的异常就是并发修改异常</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>结论：</p>
<p>​	当预计操作次数和实际操作次数不相等时，抛出并发修改异常</p>
<p>异常原因：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line"> modCount++;</span><br><span class="line"> add(e, elementData, size);</span><br><span class="line"> return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>add方法上来就是一个modCount++，让实际操作次数+1，再次调用next方法的时候并没有重新把修改后的modCount赋值给expectedModCount，导致next方法底层判断实际操作次数和预期操作次数不相等</p>
</blockquote>
<p>也不是没有方法搞定 <code>ListIterator</code> 这个和ArrayList有关</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ListIterator&lt;String&gt; listIterator = list.listIterator();</span><br><span class="line">while(listIterator.hasNext())&#123;</span><br><span class="line">	String element = listIterator.next();</span><br><span class="line">	if(&quot;猪八戒&quot;.equals)element))&#123;</span><br><span class="line">		listIterator.add(&quot;白龙马&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

<p>因为ListIterator是有add这个方法的，所以可以正常添加</p>
<p>但是呢：<strong>使用迭代器、增强for，迭代集合的过程中，不要随意修改集合长度</strong></p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据结构是一种具有一定逻辑关系，在计算机中应用某种存储结构，并且封装了相应操作的数据元素集合，它包含三方面的内容，逻辑关系、存储关系以及操作。</span><br></pre></td></tr></table></figure>

<p><strong>为什么需要数据结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">随着应用程序变得越来越复杂和数据越来越丰富，几百万、几十亿甚至几百亿的数据就会出现，而面对这么大对数据进行搜素插入或者排序等的操作就越来越慢。数据结构就是来解决这个问题的</span><br><span class="line"></span><br><span class="line">数据结构非常复杂，这里只对数据结构进行简单的了解</span><br></pre></td></tr></table></figure>



<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">特点：</span><br><span class="line">	先进后出(就好比手枪压子弹)</span><br></pre></td></tr></table></figure>



<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">特点：</span><br><span class="line">	先进先出（就好比过安检）</span><br></pre></td></tr></table></figure>



<h4 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">特点：</span><br><span class="line">	查询快，增删慢</span><br><span class="line">	</span><br><span class="line">查询快：</span><br><span class="line">	因为有索引，我们可以直接通过索引操作元素</span><br><span class="line">增删慢：</span><br><span class="line">	数组定长</span><br><span class="line">	添加元素：创建新数组，将老数组中的元素复制到新数组中去，在最后添加元素；但是如果在中间添加元素就麻烦了，插入完新元素，后面的元素都要向后移动</span><br><span class="line">	删除元素：创建新数组，将老数组中的元素复制到新数组中去，要删除的元素不赋值；如果在中间删除元素，被删除元素后面的元素都要往前移动</span><br></pre></td></tr></table></figure>



<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在集合中涉及了两种链表：单向链表、双向链表</span><br><span class="line">单向链表：</span><br><span class="line">	1、节点：一个节点分为两个部分</span><br><span class="line">		第一部分：数据域(存储数据)</span><br><span class="line">		第二部分：指针域(保存下一个节点地址值)</span><br><span class="line">	2、特点：前面节点保存后面节点的地址，但是后面节点地址不记录前面节点地址</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">双向链表：</span><br><span class="line">	1、节点：一个节点分为三部分</span><br><span class="line">		第一部分：指针域(保存上一个节点地址值)</span><br><span class="line">		第二部分：数据域(保存的数据)</span><br><span class="line">		第三部分：指针域(保存下一个节点地址值)</span><br><span class="line">	2、特点：前面节点记录后面节点地址，后面节点也记录前面节点地址</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">链表结构特点：查询慢，增删快</span><br></pre></td></tr></table></figure>



<h5 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h5><img src="../图片/image-20240721141112175.png" alt="image-20240721141112175" style="zoom:50%;" />



<h5 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h5><p><img src="/../%E5%9B%BE%E7%89%87/image-20240721141317663.png" alt="image-20240721141317663"></p>
<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><p>list接口是collection接口的子接口</p>
<p>常见的实现类：ArrayList、LinkedList、Vector</p>
<h4 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayList是List接口的实现类</span><br><span class="line">特点：</span><br><span class="line">	1、元素有序</span><br><span class="line">	2、元素可重复</span><br><span class="line">	3、有索引</span><br><span class="line">	4、线程不安全</span><br><span class="line">	</span><br><span class="line">数据结构：数组</span><br><span class="line"></span><br><span class="line">常用方法：</span><br><span class="line">	boolean add(E e) -&gt; 将元素添加到集合中（尾部）（之前说过，这个一旦执行，一定成功，所以不需要接收返回值）</span><br><span class="line">	void add(int index, E element) -&gt; 在指定位置添加元素</span><br><span class="line">	boolean remove(Object o) -&gt; 删除指定元素，删除成功为true</span><br><span class="line">	E remove(int index) -&gt; 删除指定索引位置上的元素，返回值是被删除的哪个元素</span><br><span class="line">	E set(int index, E element) -&gt; 将指定索引位置上的元素，修改为后面的element元素</span><br><span class="line">	E get(int index) -&gt; 根据索引获取元素</span><br><span class="line">	int size() -&gt; 获取集合元素个数</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//boolean add(E e) -&gt; 将元素添加到集合中（尾部）（之前说过，这个一旦执行，一定成功，所以不需要接收返回值）</span></span><br><span class="line">        list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;赵四&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//void add(int index, E element) -&gt; 在指定位置添加元素</span></span><br><span class="line">        list.add(<span class="number">0</span>,<span class="string">&quot;二柱&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//boolean remove(Object o) -&gt; 删除指定元素，删除成功为true</span></span><br><span class="line">        list.remove(<span class="string">&quot;赵四&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//E remove(int index) -&gt; 删除指定索引位置上的元素，返回值是被删除的哪个元素</span></span><br><span class="line">        list.remove(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//E set(int index, E element) -&gt; 将指定索引位置上的元素，修改为后面的element元素</span></span><br><span class="line">        list.set(<span class="number">1</span>,<span class="string">&quot;法外狂徒张三&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//E get(int index) -&gt; 根据索引获取元素</span></span><br><span class="line">        list.get(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//int size() -&gt; 获取集合元素个数</span></span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240721142831844.png" alt="image-20240721142831844"></p>
<p>遍历集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01for</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;二柱&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;赵四&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------我是分割线------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 快捷键 集合名.fori</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增强for后面再说</span></span><br><span class="line"><span class="comment">// 增强for的快捷键是</span></span><br><span class="line"><span class="comment">//		集合名或者数组名.for</span></span><br></pre></td></tr></table></figure>



<h5 id="remove问题"><a href="#remove问题" class="headerlink" title="remove问题"></a>remove问题</h5><p><img src="/../%E5%9B%BE%E7%89%87/image-20240721144126690.png" alt="image-20240721144126690"></p>
<p>解决方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.remove(Integer.valueOf(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 过时方法</span></span><br><span class="line">list.remove(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>



<h5 id="底层源码"><a href="#底层源码" class="headerlink" title="底层源码"></a>底层源码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构造方法：</span><br><span class="line">	ArrayList() -&gt; 构造一个初始容量为10的空列表</span><br><span class="line">	ArrayList(int initialCapacity) -&gt; 构造具有指定初始容量的空列表</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">ArrayList问题总结：</span><br><span class="line">	容量为10并不是new出来之后容量就是10，而是第一次add方法执行之后，扩容到10</span><br><span class="line">	ArrayList底层为数组，为什么说容量可变呢，因为底层自动扩容 -&gt; Arrays.copyOf()</span><br><span class="line">	扩容1.5倍（原长度+原长度二进制数据右移一位）</span><br></pre></td></tr></table></figure>



<h6 id="无参构造-1"><a href="#无参构造-1" class="headerlink" title="无参构造"></a>无参构造</h6><p><img src="/../%E5%9B%BE%E7%89%87/image-20240721145328684.png" alt="image-20240721145328684"></p>
<blockquote>
<p>可以看到，并没有所谓的容量为10的空列表，长度为0 </p>
<p>注意：</p>
<p>​	说的容量为10是&#x3D;&#x3D;第一次执行add方法后&#x3D;&#x3D;</p>
</blockquote>
<p>那就看一下add方法吧</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240721150000075.png" alt="image-20240721150000075"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240721150616062.png" alt="image-20240721150616062"></p>
<p>超出容量之后，再次执行add时</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240721151802182.png" alt="image-20240721151802182"></p>
<p>SOFT_MAX_ARRAY_LENGTH是数组最大长度2147483639</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240721152244804.png" alt="image-20240721152244804"></p>
<p>返回新数组后执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> Arrays.copyOf(elementData, newCapacity);</span><br></pre></td></tr></table></figure>

<p>将原数组的数据赋值给新数组</p>
<h6 id="有参构造-1"><a href="#有参构造-1" class="headerlink" title="有参构造"></a>有参构造</h6><p><img src="/../%E5%9B%BE%E7%89%87/image-20240721153125484.png" alt="image-20240721153125484"></p>
<blockquote>
<p>ArrayList<String> list &#x3D; new Array&lt;&gt;();  -&gt;  现在都是想用就new</p>
<p>但是将来开发不会想用就new集合，而是调用一个方法，查询出很多数据来，此方法返回一个集合，自动将查询出来的数据放到集合中，我们再在页面上展示数据，遍历集合</p>
<p>而且将来调用方法，返回的集合类型，一般都是接口类型</p>
<p>List<E> list &#x3D; 对象.查询方法()</p>
</blockquote>
<h4 id="LinkedList集合"><a href="#LinkedList集合" class="headerlink" title="LinkedList集合"></a>LinkedList集合</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：是List接口的实现类</span><br><span class="line">特点：</span><br><span class="line">	1、元素有序</span><br><span class="line">	2、元素可重复</span><br><span class="line">	3、有索引 -&gt; 这里说有索引指的是有操作索引的方法，不代表本质上有索引</span><br><span class="line">	4、线程不安全</span><br><span class="line">	</span><br><span class="line">数据结构：双向链表，索引是数组的东西</span><br><span class="line"></span><br><span class="line">方法：有大量操作首尾元素的方法</span><br><span class="line">	public void addFirst(E e) -&gt; 将指定元素插入到列表的开头</span><br><span class="line">	public void addLast(E e) -&gt; 将指定元素添加到列表的结尾</span><br><span class="line">	public E getFirst() -&gt; 返回列表的第一个元素</span><br><span class="line">	public E getLast() -&gt; 返回列表的最后一个元素</span><br><span class="line">	public E removeFirst() -&gt; 删除列表的第一个元素</span><br><span class="line">	public E removeLast() -&gt; 删除列表最后一个元素</span><br><span class="line">	public E pop() -&gt; 从此列表表示的堆栈处弹出一个元素</span><br><span class="line">	public void push(E e) -&gt; 将元素推入此列表所表示的堆栈</span><br><span class="line">	public boolean isEmpty() -&gt; 如果列表没有元素，则返回true</span><br></pre></td></tr></table></figure>



<p>虽然没有索引但是也可以使用get方法配合for循环遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        LinkedList&lt;String&gt; linkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        linkedList.add(<span class="string">&quot;大头儿子&quot;</span>);</span><br><span class="line">        linkedList.add(<span class="string">&quot;大头cs&quot;</span>);</span><br><span class="line">        linkedList.add(<span class="string">&quot;小头爸爸&quot;</span>);</span><br><span class="line">        linkedList.add(<span class="string">&quot;小头孙子&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; iterator = linkedList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; linkedList.size(); i++) &#123;</span><br><span class="line">            System.out.println(linkedList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240721155303756.png" alt="image-20240721155303756"></p>
<p>可以看到底层还是通过iterator来拿到的数据，并不是索引</p>
<p>这几个方法就pop和push稀罕一点，其他的就不演示了，但是其底层还是removeFirst和addFirst。瞬间索然无味</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240721155804211.png" alt="image-20240721155804211"></p>
<h5 id="LinkedList底层成员"><a href="#LinkedList底层成员" class="headerlink" title="LinkedList底层成员"></a>LinkedList底层成员</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 元素个数</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first; <span class="comment">// 第一个节点对象</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last; <span class="comment">// 最后一个节点对象</span></span><br><span class="line"></span><br><span class="line">Node代表的是节点对象</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E item; <span class="comment">// 节点上的元素</span></span><br><span class="line">        Node&lt;E&gt; next; <span class="comment">// 记录着下一个节点地址</span></span><br><span class="line">        Node&lt;E&gt; prev; <span class="comment">// 记录着上一个节点地址</span></span><br><span class="line">        </span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next)&#123;</span><br><span class="line">            <span class="built_in">this</span>.item = element;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h6 id="分析add方法"><a href="#分析add方法" class="headerlink" title="分析add方法"></a>分析add方法</h6><p>创建第一个</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240721161343003.png" alt="image-20240721161343003"></p>
<p>再来一个</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240721161821324.png" alt="image-20240721161821324"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240721161950990.png" alt="image-20240721161950990"></p>
<h6 id="分析get方法"><a href="#分析get方法" class="headerlink" title="分析get方法"></a>分析get方法</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the (non-null) Node at the specified element index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">    	Node&lt;E&gt; x = first;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">     	   x = x.next;</span><br><span class="line">  	  <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  	  Node&lt;E&gt; x = last;</span><br><span class="line">  	  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">    	    x = x.prev;</span><br><span class="line">  	  <span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>虽然说慢，但是给出了优化查找的方法</p>
<blockquote>
<p>index &lt; (size &gt;&gt; 1) 采用二分思想，先将index与长度size的一半比较，如果index &lt; size&#x2F;2，就从位置0往后遍历到位置index处，而如果index &gt; size&#x2F;2，就只从位置size往前遍历到位置index处，这样可以减少一部分不必要的遍历</p>
</blockquote>
<p>这并&#x3D;&#x3D;不是&#x3D;&#x3D;二分法查询，但是利用了二分思想</p>
<h3 id="增强for"><a href="#增强for" class="headerlink" title="增强for"></a>增强for</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基本作用：遍历集合或者数组</span><br><span class="line">格式：</span><br><span class="line">	for(元素类型 变量名:要遍历的集合名或者数组名)&#123;</span><br><span class="line">		变量名代表每一个元素</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">快捷键：</span><br><span class="line">	集合名或者数组名.for</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05for</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;二柱&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;赵六&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s = &quot;</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意：</p>
<p>​	增强for遍历集合时，底层原理是迭代器（因此遍历时不能更改集合长度）</p>
<p>​	增强for遍历数组时，底层原理是普通for</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240722110050634.png" alt="image-20240722110050634"></p>
<p>因此在使用增强for的时候，还是要注意不要触发并发修改异常</p>
</blockquote>
<h3 id="Collections-集合工具类"><a href="#Collections-集合工具类" class="headerlink" title="&#x3D;&#x3D;Collections&#x3D;&#x3D;集合工具类"></a>&#x3D;&#x3D;Collections&#x3D;&#x3D;集合工具类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：集合工具类</span><br><span class="line">特点：构造私有、方法静态</span><br><span class="line"></span><br><span class="line">方法：</span><br><span class="line">	static &lt;T&gt; boolean addAll(Collection&lt;? super Y=T&gt; c, T…… element) -&gt; 批量添加元素</span><br><span class="line">	static void shuffle(List&lt;?&gt; list) -&gt; 将集合的元素顺序打乱</span><br><span class="line">	static &lt;T&gt; void sort(List&lt;T&gt; list) -&gt; 将集合中的元素按照默认规则排序(ASCII码表)</span><br><span class="line">	static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) -&gt; 将集合中的元素按照指定规则排序</span><br></pre></td></tr></table></figure>



<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//static &lt;T&gt; boolean addAll(Collection&lt;? super Y=T&gt; c, T…… element) -&gt; 批量添加元素</span></span><br><span class="line">        Collections.addAll(list,<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;二柱&quot;</span>,<span class="string">&quot;赵六&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//static void shuffle(List&lt;?&gt; list) -&gt; 将集合的元素顺序打乱</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//static &lt;T&gt; void sort(List&lt;T&gt; list) -&gt; 将集合中的元素按照默认规则排序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) -&gt; 将集合中的元素按照指定规则排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>shuffle打乱顺序是随机打乱的，每次运行都不同</p>
<p>sort默认排序是按照ASCII码表排序的，将指定规则拉出来单独说一下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) -&gt; 将集合中的元素按照指定规则排序</span><br><span class="line"></span><br><span class="line">Comparator比较器</span><br><span class="line">	方法：</span><br><span class="line">		int compare(T o1, T o2)</span><br><span class="line">			o1-o2 -&gt; 升序</span><br><span class="line">			o2-o1 -&gt; 降序</span><br></pre></td></tr></table></figure>



<p>示例一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">99</span>,<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">39</span>,<span class="string">&quot;李四&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">29</span>,<span class="string">&quot;王五&quot;</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">69</span>,<span class="string">&quot;二柱&quot;</span>));</span><br><span class="line"></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge()- o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;list = &quot;</span> + list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Person类是手动定义的，也不用看代码了，大部分是快捷键生成的</p>
<p>注意添加对象的时候不能直接添加，需要new，进行一个有参构造</p>
<p>这里的排序规则使用了匿名内部类，重写了compare方法，使用了年龄的升序排序</p>
<p>为啥，默认会是ASCII码排序呢，因为底层实现了一个Comparable接口</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">接口：Comparable接口</span><br><span class="line">方法：int compareTo(T o) -&gt; this-o(升序)  o-this(降序)</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonTest</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;PersonTest&gt;&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">	……………………………………</span><br><span class="line">    <span class="comment">// 省略构造方法getset，toString</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(PersonTest o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getAge()-o.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Comparable需要传入一个泛型，这里传入了PersonTset，所以下面重写方法comparaTo传入的也是PersonTset类型，这样在对象内提前重写好了排序方法，那么在前面使用PersonTset作为泛型的集合，也就可以使用默认排序方法了。这样也可以理解String默认排序方法是ASCII码表了</span></span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;Arrays中的静态方法</span><br><span class="line">static &lt;T&gt; List&lt;T&gt; asList(T……a) -&gt; 直接指定元素，转存到list集合中</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;List&lt;String&gt; list = Arrays.asList(&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">泛型：&lt;&gt;</span><br><span class="line">作用：</span><br><span class="line">	统一数据类型，防止将来的数据转换异常</span><br><span class="line">	</span><br><span class="line">注意：</span><br><span class="line">	1、泛型中的类型必须是引用数据类型</span><br><span class="line">	2、如果不写泛型，默认Object型</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从使用层面来说，防止数据类型转换异常</span><br><span class="line">从定义层面来说，定义带泛型的类，方法等，将来使用的时候给泛型确定什么类型，泛型就会变成什么类型，凡是涉及到泛型的都会变成确定的类型，代码更灵活</span><br></pre></td></tr></table></figure>



<h4 id="含有泛型的类"><a href="#含有泛型的类" class="headerlink" title="含有泛型的类"></a>含有泛型的类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	public class 类名&lt;E&gt;&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">含有泛型的类是new对象的时候确定类型的，参考ArrayList</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo001fx</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">// 定义size代表元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个数组，初始长度为10</span></span><br><span class="line">    <span class="keyword">private</span> Object[] obj = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 定义添加方法</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;</span><br><span class="line">        obj[size] = e;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 定义get方法，根据索引，获取元素</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (E) obj[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.toString(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简简单单自己复现一下类似于ArrayList的代码</span></span><br></pre></td></tr></table></figure>





<h4 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	修饰符 &lt;E&gt; 返回值类型 方法名(E e)&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">含有泛型的方法在调用的时候确定类型</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03addAll</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  &lt;E&gt; <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(ArrayList&lt;E&gt; list, E ... e)</span>&#123;</span><br><span class="line">        <span class="comment">// 注意这里的&lt;E&gt;只是一个声明，并不是返回值类型，不要忘了返回值类型</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (E element : list) &#123;</span><br><span class="line">            <span class="comment">// 这里传入的e是一个数组，不能直接添加，要遍历</span></span><br><span class="line">            list.add(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        Demo03addAll.addAll(list,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里的泛型是通过list这个对象传进去的，因为list是有类型的String，被后面代码ArrayList&lt;E&gt; 接收</span></span><br></pre></td></tr></table></figure>



<h4 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	public interface 接口名&lt;E&gt;&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">确定泛型类型：</span><br><span class="line">	1、在实现类的时候还没有确定类型，在new实现类的时候确定类型 -- ArrayList</span><br><span class="line">	2、在实现类的时候就直接确定类型了 -- Scanner</span><br></pre></td></tr></table></figure>



<p>定义接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">myList</span> &lt;E&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样就定义好了一个泛型接口，使用时需要现有实现类，重写方法，再new实现类传入泛型，这里就不演示了，和上面的操作有点类似</span></span><br></pre></td></tr></table></figure>



<p>ArrayList类型就不演示了，看一下在实现类确定类型的，Scnner</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240722140236041.png" alt="image-20240722140236041"></p>
<p>也不用演示了，这里就可以看到，在实现接口的时候确定了类型</p>
<h4 id="泛型的通配符"><a href="#泛型的通配符" class="headerlink" title="泛型的通配符"></a>泛型的通配符</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list1= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list1.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        list1.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list2.add(<span class="number">1</span>);list2.add(<span class="number">2</span>);</span><br><span class="line">        method(list1);</span><br><span class="line">        method(list2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(ArrayList&lt;?&gt; list)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Object o: list)&#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的method方法就用到了通配符 <code>？</code>  但是这种使用比较基础，不写&lt;?&gt;，直接写ArrayList也是可以运行的，整点狠活</p>
<h5 id="泛型的上限下限"><a href="#泛型的上限下限" class="headerlink" title="泛型的上限下限"></a>泛型的上限下限</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用：可以规定泛型的范围</span><br><span class="line">上限：</span><br><span class="line">	格式：&lt;? extends 类型&gt;</span><br><span class="line">	含义：？只能接收extends后面的本类型以及子类类型</span><br><span class="line">	</span><br><span class="line">下限：</span><br><span class="line">	格式：&lt;? super 类型&gt;</span><br><span class="line">	含义：？只能接收super后面的本类类型和父类类型</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p>使用这个需要搞清楚类型的子父类关系</p>
<blockquote>
<p>应用场景：</p>
<p>​	1、如果我们在定义类、方法、接口的时候，如果类型不确定，我们可以考虑定义含有泛型的类、方法、接口</p>
<p>​	2、如果类型不确定，但是能知道以后只能传递某个类的继承体系中的子类或者父类，就可以使用泛型通配符</p>
</blockquote>
<h3 id="学以致用"><a href="#学以致用" class="headerlink" title="学以致用"></a>学以致用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; color = Arrays.asList(<span class="string">&quot;♥&quot;</span>,<span class="string">&quot;♣&quot;</span>,<span class="string">&quot;♦&quot;</span>,<span class="string">&quot;♠&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; num = Arrays.asList(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;10&quot;</span>,<span class="string">&quot;J&quot;</span>,<span class="string">&quot;Q&quot;</span>,<span class="string">&quot;K&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; obj = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成牌面</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; color.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">0</span>; i1 &lt; num.size(); i1++) &#123;</span><br><span class="line">                obj.add(color.get(i)+num.get(i1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        obj.add(<span class="string">&quot;大王&quot;</span>);</span><br><span class="line">        obj.add(<span class="string">&quot;小王&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化牌堆</span></span><br><span class="line">        <span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">        ArrayList&lt;String&gt; list = demo.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 洗牌</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义玩家</span></span><br><span class="line">        ArrayList&lt;String&gt; p1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; p2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; p3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;ArrayList&lt;String&gt;&gt; rom = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(List.of(p1,p2,p3));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取底牌</span></span><br><span class="line">        ArrayList&lt;String&gt; last = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        last.add(list.remove(<span class="number">53</span>));</span><br><span class="line">        last.add(list.remove(<span class="number">52</span>));</span><br><span class="line">        last.add(list.remove(<span class="number">51</span>));</span><br><span class="line">        System.out.println(last);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发牌</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">3</span>==<span class="number">0</span> || i==<span class="number">0</span>)&#123;</span><br><span class="line">                p1.add(list.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">3</span>==<span class="number">1</span>) &#123;</span><br><span class="line">                p2.add(list.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">3</span>==<span class="number">2</span>)&#123;</span><br><span class="line">                p3.add(list.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机地主</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> num.nextInt(<span class="number">3</span>);</span><br><span class="line">        System.out.println(data);</span><br><span class="line">        System.out.println(<span class="string">&quot;请&quot;</span>+rom.get(data)+<span class="string">&quot;玩家选择是否当地主&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入Y或是F&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> sc.next();</span><br><span class="line">            <span class="keyword">if</span> (content.equals(<span class="string">&quot;Y&quot;</span>) || content.equals(<span class="string">&quot;y&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; last.size(); i++) &#123;</span><br><span class="line">                    rom.get(data).add(last.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (content.equals(<span class="string">&quot;F&quot;</span>) || content.equals(<span class="string">&quot;f&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (data&lt;<span class="number">3</span>)&#123;</span><br><span class="line">                    data++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    data = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;非法输入，请重新输入&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样实现了，斗地主的一个牌面生成，取出底牌，发牌以及获取底牌的过程，这只是对学的集合知识简单的应用，并没有要开发游戏，不过闲的没事可以试试看。</p>
<p>这个生成牌面的过程也可以使用数组来解决，都差不多</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] color = <span class="string">&quot;♠-♣-♦-♥&quot;</span>.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">String[] number = <span class="string">&quot;A-2-3-4-5-6-7-8-9-10-J-Q-K&quot;</span>.split(<span class="string">&quot;-&quot;</span>);</span><br></pre></td></tr></table></figure>





<h3 id="红黑树（了解）"><a href="#红黑树（了解）" class="headerlink" title="红黑树（了解）"></a>红黑树（了解）</h3><p><img src="/../%E5%9B%BE%E7%89%87/image-20240722162134895.png" alt="image-20240722162134895"></p>
<p>先说一下排列树：左子树小，右子树大</p>
<p>红黑树规则：</p>
<p>​	1、每个节点必须是红色或者黑色的</p>
<p>​	2、根节点必须是黑色</p>
<p>​	3、如果一个节点没有子节点或者父节点，则该节点相应的指针属性值为Nil，这些Nil视为叶节点，每个叶节点(Nil)是黑色的</p>
<p>​	4、如果某一个节点是红色，那么它的子节点必须是黑色（不能出现两个红色节点相连的情况）</p>
<p>​	5、对每一个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点</p>
<p>红黑树趋近于平衡树，而且数据存储时按照排序树规则存储，查询速度快</p>
<p><a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack">https://www.cs.usfca.edu/~galles/visualization/RedBlack</a></p>
<p>一个演示红黑树的网站</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">集合加入红黑树的目的：提高查询效率</span><br><span class="line">HashSet集合：</span><br><span class="line">	数据结构：哈希表</span><br><span class="line">		jdk8之前：哈希表 = 数组+链表</span><br><span class="line">		jdk8之后：哈希表 = 数组+链表+红黑树 -&gt; 目的是提高查询效率</span><br></pre></td></tr></table></figure>



<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set接口并没有对collection接口进行功能上的扩充，而且所有的Set集合底层都是依靠Map实现</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240722233753304.png" alt="image-20240722233753304"></p>
<p>set的所有方法，点开都是map</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set和Map是密切相关的</span><br><span class="line">遍历Map需要先变成单列集合，只能变成set集合</span><br></pre></td></tr></table></figure>



<h4 id="HashSet集合"><a href="#HashSet集合" class="headerlink" title="HashSet集合"></a>HashSet集合</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：是set的实现类</span><br><span class="line">特点：</span><br><span class="line">	1、元素唯一</span><br><span class="line">	2、元素无序</span><br><span class="line">	3、无索引</span><br><span class="line">	4、线程不安全</span><br><span class="line"></span><br><span class="line">数据结构：哈希表</span><br><span class="line">	jdk8之前：哈希表 = 数组+链表</span><br><span class="line">	jdk8之后：哈希表 = 数组+链表+红黑树</span><br><span class="line">	</span><br><span class="line">方法：和collection一模一样</span><br><span class="line"></span><br><span class="line">遍历：</span><br><span class="line">	1、增强for（没有普通for因为不能操作索引）</span><br><span class="line">	2、迭代器</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的无序只是和插入的顺序不同，HashSet是将数据插入之后，利用方法根据哈希表生成一个值，然后根据这个值的大小排序，以链表的方式存储</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashSet&lt;String&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        hashSet.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;赵六&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;二柱&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;赵四&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;刘能&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;我&quot;</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;他&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;hashSet = &quot;</span> + hashSet);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; iterator = hashSet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : hashSet) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s = &quot;</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="LinkedHahSet"><a href="#LinkedHahSet" class="headerlink" title="LinkedHahSet"></a>LinkedHahSet</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HashSet的子类</span><br><span class="line">特点：</span><br><span class="line">	1、元素唯一</span><br><span class="line">	2、元素有序</span><br><span class="line">	3、无索引</span><br><span class="line">	4、线程不安全</span><br><span class="line">	</span><br><span class="line">数据结构：哈希表+双向链表</span><br><span class="line">使用：和HashSet一样</span><br></pre></td></tr></table></figure>



<h4 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：是由计算机算出来的一个十进制数，可以看做是对象的地址值</span><br><span class="line">获取对象的哈希值，使用的是Object中的方法</span><br><span class="line">	public native int hashCode()</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240723111733526.png" alt="image-20240723111733526"></p>
<blockquote>
<p>哈希值不一样，内容肯定不一样，但是哈希值一样，内容可能不一样哦</p>
<p>一个特殊案例，“通话”和“重地”哈希值是一样的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240723112136329.png" alt="image-20240723112136329"></p>
</blockquote>
<p>研究一下String重写的hashCode哈希计算源码，看一下 <code>abc</code> 的哈希值是怎么计算出来的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// abc在ASCII码表中分别对应97、98、99</span></span><br><span class="line"><span class="type">byte</span>[] value = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">	<span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; !hashIsZero) &#123;</span><br><span class="line">	    h = isLatin1() ? StringLatin1.hashCode(value)</span><br><span class="line">	                   : StringUTF16.hashCode(value);</span><br><span class="line">	    <span class="keyword">if</span> (h == <span class="number">0</span>) &#123;</span><br><span class="line">	        hashIsZero = <span class="literal">true</span>;</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	        hash = h;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line">==============================</span><br><span class="line">StringLatin1.hashCode(value)底层源码</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">(<span class="type">byte</span>[] value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">byte</span> v : value) &#123;</span><br><span class="line">        h = <span class="number">31</span> * h + (v &amp; <span class="number">0xff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>oxff</code> 是十六进制的255，任何数据和255做与运算都是原值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一圈：</span><br><span class="line">	h = 31 * 0 + 97   (97)</span><br><span class="line">	</span><br><span class="line">第二圈：</span><br><span class="line">	h = 31 * 97(h) + 98  (3105)</span><br><span class="line">	</span><br><span class="line">第三圈：</span><br><span class="line">	h = 31 * 3105 + 99  (96354)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在计算哈希的时候，有一个定值31，为啥</p>
<p>​	31是一个质数，31可以尽量降低内容不同但是哈希值一样的情况（哈希冲突，哈希碰撞）</p>
<p>​	这是一个统计学问题</p>
</blockquote>
<h4 id="HashSet存储去重过程"><a href="#HashSet存储去重过程" class="headerlink" title="HashSet存储去重过程"></a>HashSet存储去重过程</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先计算元素的哈希值(重写hashCode方法)，再比较内容(重写equals方法)</span><br><span class="line"></span><br><span class="line">过程：</span><br><span class="line">	先比较哈希值，如果哈希值不一样，存储</span><br><span class="line">	如果哈希值一样，比较内容，内容不同存储，内容相同，去重</span><br></pre></td></tr></table></figure>



<p>如果hashSet存储自定义类型数据，就没有去重效果了，因为地址值一定不同，还想要有去重效果，就需要重写hashCode和equals</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(name, person.name) &amp;&amp; Objects.equals(age, person.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：</p>
<p>​	1、如果HashSet存储自定义数据类型，需要重写hashcode和equals方法，让HashSet比较属性的哈希值以及属性的内容</p>
<p>​	2、如果不重写hashCode和equals方法，默认调用的是Object中的方法，不同对象，哈希值一定不一样，就不能去重了</p>
</blockquote>
<h3 id="双列集合"><a href="#双列集合" class="headerlink" title="双列集合"></a>双列集合</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map是双列集合的顶级接口</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">map的实现类HashMap：</span><br><span class="line">特点：</span><br><span class="line">	1、key唯一，value可重复</span><br><span class="line">	2、无序</span><br><span class="line">	3、无索引</span><br><span class="line">	4、线程不安全</span><br><span class="line">	5、可以存null键，null值</span><br><span class="line">数据结构：哈希表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HashMap的子类LinkedHashMap:</span><br><span class="line">特点：</span><br><span class="line">	1、key唯一，value可重复</span><br><span class="line">	2、有序</span><br><span class="line">	3、无索引</span><br><span class="line">	4、线程不安全</span><br><span class="line">	5、可以存null键，null值</span><br><span class="line">数据结构：哈希表+双向链表</span><br><span class="line"></span><br><span class="line">map的实现类Hashtable</span><br><span class="line">特点：</span><br><span class="line">	1、key唯一，value可重复</span><br><span class="line">	2、无序</span><br><span class="line">	3、无索引</span><br><span class="line">	4、线程安全</span><br><span class="line">	5、不可以存null键，null值</span><br><span class="line">数据结构：哈希表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Hashtable的子类Properties（主要和配置文件结合使用）</span><br><span class="line">特点：</span><br><span class="line">	1、key唯一，value可重复</span><br><span class="line">	2、无序</span><br><span class="line">	3、无索引</span><br><span class="line">	4、线程安全</span><br><span class="line">	5、可以存null键，null值</span><br><span class="line">	6、key和value都是String型的</span><br><span class="line">数据结构：哈希表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">map的实现类TreeMap:</span><br><span class="line">特点：</span><br><span class="line">	1、key唯一，value可重复</span><br><span class="line">	2、可以对key进行排序</span><br><span class="line">	3、无索引</span><br><span class="line">	4、线程不安全</span><br><span class="line">	5、不能存null键，null值</span><br><span class="line">数据结构：红黑树</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240723124842454.png" alt="image-20240723124842454"></p>
<h4 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：双列集合的顶级接口</span><br><span class="line">元素特点：</span><br><span class="line">	元素由键值对组成(key-value)</span><br></pre></td></tr></table></figure>



<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：Map的实现类</span><br><span class="line">特点：</span><br><span class="line">	1、key唯一，value可以重复 -&gt; 如果key重复，会发生value覆盖</span><br><span class="line">	2、无序（针对整数，不会随意打乱顺序）</span><br><span class="line">	3、无索引</span><br><span class="line">	4、线程不安全</span><br><span class="line">	5、可以存null键，null值</span><br><span class="line">数据结构：哈希表</span><br><span class="line"></span><br><span class="line">// PS：感觉像python里面的字典</span><br><span class="line"></span><br><span class="line">方法：</span><br><span class="line">	V put(K key, V value) -&gt; 添加元素，返回的是被覆盖的value</span><br><span class="line">	V remove(Object key) -&gt; 根据key删除键值对，返回的是被删除的键值对的值(value)</span><br><span class="line">	V get(Object key) -&gt; 根据key获取value</span><br><span class="line">	boolean containsKey(Object key) -&gt; 判断集合中是否包含指定的key</span><br><span class="line">	Collection&lt;V&gt; values() -&gt; 获取集合中所有的value，转存到Collection集合中</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	Set&lt;V&gt; keySet() -&gt; 将Map中的key获取出来，转存到Set集合中</span><br><span class="line">	Set&lt;Map, Entry&lt;K, V&gt;&gt; entrySet() -&gt; 获取Map集合中的键值对，转存到Set集合中</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">注意，因为是键值对，因此新建集合是要传入两个泛型，对应key - value</span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;String,String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// V put(K key, V value) -&gt; 添加元素，返回的是被覆盖的value</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> hashMap.put(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;18&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;s1 = &quot;</span> + s1);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> hashMap.put(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;28&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;s2 = &quot;</span> + s2);</span><br><span class="line"></span><br><span class="line">        hashMap.put(<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;38&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;48&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// V remove(Object key) -&gt; 根据key删除键值对，返回的是被删除的键值对的值(value)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> hashMap.remove(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;s3 = &quot;</span> + s3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// V get(Object key) -&gt; 根据key获取value</span></span><br><span class="line">        System.out.println(hashMap.get(<span class="string">&quot;李四&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// boolean containsKey(Object key) -&gt; 判断集合中是否包含指定的key</span></span><br><span class="line">        System.out.println(hashMap.containsKey(<span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Collection&lt;V&gt; values() -&gt; 获取集合中所有的value，转存到Collection集合中</span></span><br><span class="line">        Collection&lt;String&gt; c1 = hashMap.values();</span><br><span class="line">        System.out.println(c1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：HashMap的子集</span><br><span class="line">特点：</span><br><span class="line">	1、key唯一，value可以重复 -&gt; 如果key重复，会发生value覆盖</span><br><span class="line">	2、有序</span><br><span class="line">	3、无索引</span><br><span class="line">	4、线程不安全</span><br><span class="line">	5、可以存null键，null值</span><br><span class="line"></span><br><span class="line">数据结构：哈希表+双向链表</span><br><span class="line">方法：和HashMap一样</span><br></pre></td></tr></table></figure>



<h5 id="遍历的两种方式"><a href="#遍历的两种方式" class="headerlink" title="遍历的两种方式"></a>遍历的两种方式</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">遍历就需要用到没有演示的两个方法了</span><br><span class="line">	Set&lt;V&gt; keySet() -&gt; 将Map中的key获取出来，转存到Set集合中</span><br><span class="line">	Set&lt;Map, Entry&lt;K, V&gt;&gt; entrySet() -&gt; 获取Map集合中的键值对，转存到Set集合中</span><br><span class="line">	</span><br><span class="line">之前说过，Map是没法遍历的，需要转换成set</span><br></pre></td></tr></table></figure>



<p>第一种方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; set = hashMap.keySet();</span><br><span class="line"><span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">    System.out.println(s + <span class="string">&quot; = &quot;</span> + hashMap.get(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先获取所有的key，遍历key，再查找到对应的value</p>
</blockquote>
<p>第二种方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;String,String&gt;&gt; set1 = hashMap.entrySet();</span><br><span class="line">System.out.println(<span class="string">&quot;set1 = &quot;</span> + set1);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : set1) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    System.out.println(key+<span class="string">&quot;...&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取记录key和value的对象，Map接口中的静态内部接口：Map.Entry</p>
<p>调用Map.Entry中的两个方法</p>
<p>getKey()   getValue()</p>
<p>方法就顾名思义吧</p>
</blockquote>
<h5 id="Map去重"><a href="#Map去重" class="headerlink" title="Map去重"></a>Map去重</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set执行add的时候，首先就是map.put(e, PRESENT) 把要插入的值作为key，而进行对象类型去重时，则是需要重写hashCode和equals方法</span><br><span class="line"></span><br><span class="line">Map对象去重和set一样，都是重写两个方法，原因就是Set的值是保存在Map的key的位置的</span><br></pre></td></tr></table></figure>



<h5 id="Map练习"><a href="#Map练习" class="headerlink" title="Map练习"></a>Map练习</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">经典python二级，字典统计字词个数</span><br><span class="line"></span><br><span class="line">步骤：</span><br><span class="line">	1、创建HashMap</span><br><span class="line">	2、遍历字符串，取出每个字母</span><br><span class="line">	3、判断map中是否有该字母</span><br><span class="line">	4、如果没有，直接存储，如果有获取对应的value，然后加一</span><br><span class="line">	5、重新保存到集合</span><br></pre></td></tr></table></figure>



<p>统计输入的字母个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">fori</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> sc.next();</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] c1 = s1.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : c1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hashMap.containsKey(c)) &#123;</span><br><span class="line">                hashMap.put(<span class="string">&quot;c&quot;</span>,<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> hashMap.get(c);</span><br><span class="line">                value++;</span><br><span class="line">                hashMap.put(c+<span class="string">&quot;&quot;</span>,value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;hashMap = &quot;</span> + hashMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>这个东西让我想到了备考python二级时经常碰见的东西</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tem)):</span><br><span class="line">	d[tem[i]] = d.get([tem[i]] , <span class="number">0</span> ) + <span class="number">1</span></span><br><span class="line">//用于统计数据</span><br><span class="line"></span><br><span class="line">d.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>] , value=<span class="literal">True</span>)</span><br><span class="line">//按照升序排序</span><br></pre></td></tr></table></figure>



<p>所以我感觉应该有精简的方法，于是就问了一把AI</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> sc.next();</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] c1 = s1.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : c1) &#123;</span><br><span class="line">            hashMap.merge(c+<span class="string">&quot;&quot;</span>, <span class="number">1</span>, Integer::sum);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;hashMap = &quot;</span> + hashMap);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里使用了merge方法代替了if-else</p>
<p>merge()方法接受三个参数：键、需要合并的值、以及一个函数</p>
<p>​	c+“”  -&gt;  因为定义的是字符串，c是char类型，简单转换一下</p>
<p>​	1  -&gt;   这个是要操作的值，为1</p>
<p>​	Integer::sum  -&gt;  顾名思义了直接，就是数字求和</p>
<p>这行代码的作用和上面是一样的，如果键不存在，插入键值对，并将值设为1，如果存在+1</p>
</blockquote>
<p>继续操作一下之前的那个斗地主，之前是利用ArrayList集合来实现的，但是还没有排序，扑克牌是用一个符号和数字组成，如果说再拆开排序不是不行，感觉很笨。因为map的key数字是不会打乱的，我们就可以对这些字符串按照牌面的大小，由数字进行一个排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 利用key按牌面大小排序</span></span><br><span class="line">        HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>, <span class="string">&quot;大王&quot;</span>);</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;小王&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String[] color = <span class="string">&quot;♠-♣-♦-♥&quot;</span>.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        String[] number = <span class="string">&quot;2-A-K-Q-J-10-9-8-7-6-5-4-3&quot;</span>.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">0</span>; i1 &lt; number.length; i1++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; color.length; i++) &#123;</span><br><span class="line">                map.put(j, color[i] + number[i1]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;map = &quot;</span> + map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将key值添加到ArrayList集合中，因为有序，可以打乱</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">54</span>; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 洗牌</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义玩家</span></span><br><span class="line">        ArrayList&lt;Integer&gt; p1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; p2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; p3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取底牌</span></span><br><span class="line">        ArrayList&lt;Integer&gt; last = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        last.add(list.remove(<span class="number">53</span>));</span><br><span class="line">        last.add(list.remove(<span class="number">52</span>));</span><br><span class="line">        last.add(list.remove(<span class="number">51</span>));</span><br><span class="line">        System.out.println(last);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发牌</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                p1.add(list.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                p2.add(list.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">2</span>) &#123;</span><br><span class="line">                p3.add(list.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 整理手牌，获得手牌</span></span><br><span class="line">        Collections.sort(p1);</span><br><span class="line">        Collections.sort(p2);</span><br><span class="line">        Collections.sort(p3);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> lookPoker(p1,map);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> lookPoker(p2,map);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> lookPoker(p3,map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备随机玩家</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; rom = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(List.of(p1,p2,p3));</span><br><span class="line">        <span class="type">Random</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> num.nextInt(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;请&quot;</span> + rom.get(data) + <span class="string">&quot;玩家选择是否当地主&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机的玩家开始选择是否需要底牌</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入Y或是F&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> sc.next();</span><br><span class="line">            <span class="keyword">if</span> (content.equals(<span class="string">&quot;Y&quot;</span>) || content.equals(<span class="string">&quot;y&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; last.size(); i++) &#123;</span><br><span class="line">                    rom.get(data).add(last.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (content.equals(<span class="string">&quot;F&quot;</span>) || content.equals(<span class="string">&quot;f&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (data &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                    data++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    data = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;非法输入，请重新输入&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义整理手牌的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">lookPoker</span><span class="params">(ArrayList&lt;Integer&gt; list, HashMap&lt;Integer, String&gt; map)</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (Integer key : list) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            e.append(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> e.toString();</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个程序写的还是有瑕疵的，因为使用了字符串来返回手牌情况，考虑到后面获取底牌和出牌，字符串并不是很好操作</p>
<p>有时间继续优化</p>
</blockquote>
<h3 id="哈希表存储的过程"><a href="#哈希表存储的过程" class="headerlink" title="哈希表存储的过程"></a>哈希表存储的过程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">哈希表存储数据去重复的过程</span><br><span class="line">	1、先比较元素的哈希值hashCode，再比较内容equals</span><br><span class="line">	2、如果哈希值不一样，存</span><br><span class="line">	3、如果内容不一样，存</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240723225734056.png" alt="image-20240723225734056"></p>
<p>计算出 <code>通话</code> 和 <code>重地</code> 的存储位置相同，这个时候两者之间产生了链表关系，jdk版本不同，jdk8之前数据关系是 <code>哈希表 = 数组+链表</code> ，jdk8之后是 <code>哈希表 = 数组+链表+红黑树</code> 了。</p>
<p>同一存储位置，数据过多时会变成红黑树。加快查询速度</p>
<blockquote>
<p>注意：</p>
<p>​	1、哈希表中的数组默认长度为&#x3D;&#x3D;16&#x3D;&#x3D;，但是是第一次put的时候数组才会被初始化为长度为16的数组（和ArrayList中的add一样）</p>
<p>​	2、哈希表中有一个加载因子：&#x3D;&#x3D;0.75F&#x3D;&#x3D;</p>
<p>​		含义是：数组存储达到百分之七十五的时候，扩容</p>
<p>​		&#x3D;&#x3D;扩容两倍&#x3D;&#x3D;</p>
<p>​	3、如果链表长度达到&#x3D;&#x3D;8&#x3D;&#x3D;，并且数组容量大于等于&#x3D;&#x3D;64&#x3D;&#x3D;的时候，链表自动转成红黑树</p>
<p>​	4、如果删除元素，元素个数小于等于&#x3D;&#x3D;6&#x3D;&#x3D;，红黑树自动转回链表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">default_initial_capacity:HashMap默认容量 16</span><br><span class="line">default_1oad_factor:HashMap默认加载因子 0.75F</span><br><span class="line">thresho1d:扩容的临界值  等于  容量*0.75=12  第一次扩容</span><br><span class="line">treeify_thresho1d:链表长度默认值，转为红黑树：8</span><br><span class="line">min_treeify_capacity:链表被树化时最小的数组容量：64</span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="哈希表底层源码"><a href="#哈希表底层源码" class="headerlink" title="哈希表底层源码"></a>哈希表底层源码</h3><p><img src="/../%E5%9B%BE%E7%89%87/image-20240723235751452.png" alt="image-20240723235751452"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240724000911543.png" alt="image-20240724000911543"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240724002151190.png" alt="image-20240724002151190"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240724002356860.png" alt="image-20240724002356860"></p>
<p>举的例子不是很经典，下面换成 <code>abc</code> <code>通话</code> <code>重地</code></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240724004012437.png" alt="image-20240724004012437"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240724004121059.png" alt="image-20240724004121059"></p>
<p>可以看到数组长度小于64的时候不进行树化，先对数组进行扩容。下面的else-if是树化的代码</p>
<p>从底层代码了解了一下数据存储的过程，我们也可以手动指定加载因子和容量，也就是有参构造</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;(5,0.5F);</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240724010223543.png" alt="image-20240724010223543"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tableSizeFor方法，怎么说呢，就是你传入的数字，并不是按你的意愿创造这个大小的容量的，实测，容量大小为大于等于你传入数字的2的倍数</p>
<p>8 4 2 1 规则</p>
<p>目的是为了尽量减少哈希碰撞</p>
<h4 id="索引问题"><a href="#索引问题" class="headerlink" title="索引问题"></a>索引问题</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">问题1：哈希表的组成明明有索引，但是为什么set和map中没有呢</span><br><span class="line"></span><br><span class="line">	哈希表中虽然有索引，但是set和map却没有索引，因为哈希表还有链表的存在，存数据的时候有可能在同一索引下形成链表，这个时候去去索引，就会出现问题，因为不是一一对应的，不知道该取出哪一个</span><br><span class="line">	</span><br><span class="line">问题2：为啥说HashMap是无序的，LinkedHashMap是有序的呢？</span><br><span class="line">	</span><br><span class="line">	HashMap底层哈希表为单向链表</span><br><span class="line">	LinkedHashMap底层在哈希表的基础上加了一条双向链表</span><br></pre></td></tr></table></figure>



<p>单向链表：&#x3D;&#x3D;从索引0开始往后一条链表一条链表的遍历&#x3D;&#x3D;</p>
<p>HashMap，数据存储时有存储位置，，而且存储位置可能是同一个，这样遍历的时候从0索引开始向后遍历，而不是按照存储的顺序遍历，如果遇到一个位置上有多个元素的情况，先把这条链表遍历完，再进入下一个位置，这样就导致了无序，但其实遍历出来的东西还有有一定的顺序的，并不是完全意义上的无序</p>
<p>双向链表：从第一个节点开始遍历，以此遍历后面的元素</p>
<p>这个和双向链表和for循环顺序有关系，因为双向链表是前后相连的。</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240724012739416.png" alt="image-20240724012739416"></p>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：是set的实现类</span><br><span class="line">特点：</span><br><span class="line">	1、对元素进行排序</span><br><span class="line">	2、无索引</span><br><span class="line">	3、不能存null</span><br><span class="line">	4、线程不安全</span><br><span class="line">	5、元素唯一</span><br><span class="line">	</span><br><span class="line">数据结构：红黑树</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构造方法:</span><br><span class="line">	TreeSet() -&gt; 构造一个新的空set，该set根据其元素的自然顺序进行排序 -&gt; ASCII</span><br><span class="line">	TreeSet(Comparator&lt;? super E&gt; comparator) -&gt; 构造一个空TreeSet，它根据比较器进行排序</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeSet&lt;String&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        treeSet.add(<span class="string">&quot;c.qwe&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;a.qwe&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;d.qwe&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;b.qwe&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;treeSet = &quot;</span> + treeSet);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;============================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        TreeSet&lt;person&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(person o1, person o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge()- o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;二柱&quot;</span>,<span class="number">27</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">72</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;张麻子&quot;</span>,<span class="number">19</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;set = &quot;</span> + set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：map的实现类</span><br><span class="line">特点：</span><br><span class="line">	1、对key进行排序</span><br><span class="line">	2、无索引</span><br><span class="line">	3、key唯一</span><br><span class="line">	4、线程不安全</span><br><span class="line">	5、不能存null</span><br><span class="line">	</span><br><span class="line">数据结构：红黑树</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构造方法：</span><br><span class="line">	TreeMap() -&gt; 使用键的自然顺序构造一个新的、空的树映射 -&gt; ASCII</span><br><span class="line">	TreeMap(Comparator&lt;? super E&gt; comparator) -&gt; 构造一个，新的、空的树映射，该映射根据给定比较器进行排序</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeMap&lt;String, String&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        treeMap.put(<span class="string">&quot;c&quot;</span>,<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;d&quot;</span>,<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;b&quot;</span>,<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;treeMap = &quot;</span> + treeMap);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;============================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        TreeMap&lt;person, String&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(person o1, person o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge()-o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>), <span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;二柱&quot;</span>,<span class="number">27</span>), <span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">72</span>), <span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;张麻子&quot;</span>,<span class="number">19</span>), <span class="string">&quot;北京&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;map = &quot;</span> + map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Hashtable和Vector-了解"><a href="#Hashtable和Vector-了解" class="headerlink" title="Hashtable和Vector(了解)"></a>Hashtable和Vector(了解)</h3><h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map的实现类</span><br><span class="line">特点：</span><br><span class="line">	1、key唯一，value可重复</span><br><span class="line">	2、无序</span><br><span class="line">	3、无索引</span><br><span class="line">	4、线程安全</span><br><span class="line">	5、不能存null键，null值</span><br><span class="line">	</span><br><span class="line">数据类型：哈希表</span><br></pre></td></tr></table></figure>

<blockquote>
<p>HashMap和Hashtable的区别：</p>
<p>​	相同点：元素无序，无索引，key唯一</p>
<p>​	不同点：HashMap线程不安全，Hashtable线程安全</p>
<p>​				   HashMap可以存储null键null值，Hashtable不能</p>
<p>Hashtable的一些具体方法和HashMap一样</p>
</blockquote>
<h4 id="Vector集合"><a href="#Vector集合" class="headerlink" title="Vector集合"></a>Vector集合</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：list接口的实现类</span><br><span class="line">特点：</span><br><span class="line">	1、元素有序</span><br><span class="line">	2、有索引</span><br><span class="line">	3、元素可重复</span><br><span class="line">	4、线程安全</span><br><span class="line">	</span><br><span class="line">数据结构：数组</span><br><span class="line"></span><br><span class="line">如果用空参构造创建对象，数组初始容量为10，自动扩容2倍</span><br><span class="line">如果初始容量和容量增量，扩容就是现有容量+容量增量</span><br></pre></td></tr></table></figure>

<p>使用方式和ArrayList相似</p>
<blockquote>
<p>源码分析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vector() 构造一个空向量，使其内部数据数组的大小为10，其标准容量增量为零</span><br><span class="line">Vector(int initialcapacity, int capacityIncrement) 使用指定的初始容量和容量增量构造一个空的向量</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line"> <span class="built_in">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">int</span> capacityIncrement)</span> &#123;</span><br><span class="line"> <span class="built_in">super</span>();</span><br><span class="line"> <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                        initialCapacity);</span><br><span class="line"> <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity]; <span class="comment">// 长度为10的数组</span></span><br><span class="line"> <span class="built_in">this</span>.capacityIncrement = capacityIncrement; <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一点就是和ArrayList不一样的点，ArrayList对象new出来长度为0，只要第一个add的时候才会扩容到10，而Vector新new出来的容量就是10</p>
<p>看一下扩容的具体代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line"> modCount++;</span><br><span class="line"> add(e, elementData, elementCount);</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add方法是同步方法，线程安全的表现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e, Object[] elementData, <span class="type">int</span> s)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">     elementData = grow();</span><br><span class="line"> elementData[s] = e;</span><br><span class="line"> elementCount = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要扩容，调用grow方法 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line"> <span class="keyword">return</span> grow(elementCount + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="type">int</span> minCapacity) &#123;</span><br><span class="line"> <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length; <span class="comment">// 10</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> ArraysSupport.newLength(oldCapacity,</span><br><span class="line">         minCapacity - oldCapacity, <span class="comment">/* minimum growth */</span></span><br><span class="line">         capacityIncrement &gt; <span class="number">0</span> ? capacityIncrement : oldCapacity</span><br><span class="line">                                    <span class="comment">/* preferred growth */</span>);</span><br><span class="line"><span class="comment">// 经过一个三元运算符运算，newCapacity为20</span></span><br><span class="line"> <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>再来看有参构造</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240724121834301.png" alt="image-20240724121834301"></p>
<p>指定容量增量为5之后，再次扩容就会扩容到15</p>
</blockquote>
<h3 id="Properties集合（属性集）"><a href="#Properties集合（属性集）" class="headerlink" title="Properties集合（属性集）"></a>Properties集合（属性集）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：Hashtable的子类</span><br><span class="line">特点：</span><br><span class="line">	1、key唯一，value可重复</span><br><span class="line">	2、无序</span><br><span class="line">	3、无索引</span><br><span class="line">	4、线程安全</span><br><span class="line">	5、不能存null键，null值</span><br><span class="line">	6、Properties的key和value类型默认为String</span><br><span class="line">	</span><br><span class="line">数据结构：哈希表</span><br><span class="line"></span><br><span class="line">特有方法：</span><br><span class="line">	Properties的一套方法和Map很相近，但也有特有方法</span><br><span class="line">	Object setProperty(String key, String value) -&gt; 存键值对</span><br><span class="line">	String getProperty(String key) -&gt; 根据key获取value值</span><br><span class="line">	Set&lt;String&gt; stringPropertyNames() -&gt; 获取所有的key，保存到set集合中，相当于keySet方法</span><br><span class="line">	void load(InputStream inStream) -&gt; 将流中的数据加载到Properties集合中(IO流使用，现在不说)</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">        properties.setProperty(<span class="string">&quot;root&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;123456&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">&quot;root&quot;</span>));</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set = properties.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">            System.out.println(properties.getProperty(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="集合嵌套"><a href="#集合嵌套" class="headerlink" title="集合嵌套"></a>集合嵌套</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">之前写斗地主的时候，问AI就用到这个嵌套了</span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; p1 = new ArrayList&lt;&gt;();</span><br><span class="line">ArrayList&lt;String&gt; p2 = new ArrayList&lt;&gt;();</span><br><span class="line">ArrayList&lt;String&gt; p3 = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">ArrayList&lt;ArrayList&lt;String&gt;&gt; rom = new ArrayList&lt;&gt;(List.of(p1,p2,p3));</span><br></pre></td></tr></table></figure>

<p>这东西就这么存进去了，如果要遍历的话，可以遍历大集合，再遍历小集合取出元素</p>
<p>集合嵌套的样式有点多，但是主要的就是泛型传的对，遍历拿得出就可以了，没啥特别要说的</p>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">计算机常识：</span><br><span class="line">	1、以.jpg结尾的一定是图片吗？</span><br><span class="line">		也可能是文件夹</span><br><span class="line">		</span><br><span class="line">	2、什么是文本文档</span><br><span class="line">		用记事本打开，人能看懂的东西（word打开就看不懂）</span><br><span class="line">		</span><br><span class="line">	3、E:\Idea\io\1.jpg 中的1.jpg的父路径是谁？</span><br><span class="line">		E:\Idea\io 这个是父路径 io 是父级文件夹</span><br><span class="line">		</span><br><span class="line">	4、分隔符</span><br><span class="line">		a.路径名称分隔符</span><br><span class="line">			Windows: \</span><br><span class="line">			Linux： /</span><br><span class="line">		b.路径分隔符：一个路径和其他路径之间的分隔符</span><br><span class="line">			;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：文件和目录路径名的抽象表示</span><br><span class="line">简单理解：</span><br><span class="line">	在创建File对象的时候，需要传入一个路径，这个路径定位到哪个文件夹或者文件上，我们的File就代表哪个对象</span><br></pre></td></tr></table></figure>



<h4 id="File使用"><a href="#File使用" class="headerlink" title="File使用"></a>File使用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File的静态成员：</span><br><span class="line">	static String pathSeparator:与系统有关的路径分隔符，为了方便，它被表示为一个字符串</span><br><span class="line">	static String separator:与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">这俩东西的作用就是为了实现一次编写，导出运行，可以在不同操作系统中运行</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File的构造方法</span><br><span class="line"></span><br><span class="line">File(String parent, String child) 根据所填写的路径创建File对象</span><br><span class="line">	parent：父路径</span><br><span class="line">	child：子路径</span><br><span class="line">	</span><br><span class="line">File(File parent, String child) 根据所填写的路径创建File对象</span><br><span class="line">	parent：父路径，是一个File对象</span><br><span class="line">	child：子路径</span><br><span class="line">	</span><br><span class="line">File(String pathname)  根据所填写的路径创建File对象</span><br><span class="line">	pathname：直接指定路径</span><br></pre></td></tr></table></figure>

<blockquote>
<p>细节，传递的路径可以是不存在的，但是传递不存在的路径，没有什么意义</p>
</blockquote>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><h5 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String getAbsolutePath() -&gt; 获取File的绝对路径-&gt;带盘符的路径</span><br><span class="line">StringgetPath() -&gt; 获取的是封装路径-&gt;newFile对象的时候写的啥路径，获取的就是啥路径</span><br><span class="line">String getName() -&gt; 获取的是文件或者文件夹名称</span><br><span class="line">long length() -&gt; 获取的是文件的长度-&gt;文件的字节数</span><br></pre></td></tr></table></figure>



<h5 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean createNewFile() -&gt; 创建文件</span><br><span class="line">	如果要创建的文件之前有，创建失败，返回false</span><br><span class="line">	如果要创建的文件之前没有，创建成功，返回true</span><br><span class="line"></span><br><span class="line">boolean mkdirs() -&gt; 创建文件夹（目录）既可以创建多级文件夹，还可以创建单级文件夹</span><br><span class="line">	如果要创建的文件夹之前有，创建失败，返回false</span><br><span class="line">	如果要创建的文件夹之前没有，创建成功，返回true</span><br></pre></td></tr></table></figure>



<h5 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean delete -&gt; 删除文件或者文件夹</span><br><span class="line">    1、不会移到回收站，直接删除</span><br><span class="line">    2、只能删除空文件夹</span><br></pre></td></tr></table></figure>



<h5 id="判断方法-1"><a href="#判断方法-1" class="headerlink" title="判断方法"></a>判断方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean isDirectory() -&gt; 判断是否为文件夹</span><br><span class="line">boolean isFile() -&gt; 判断是否为文件</span><br><span class="line">boolean exists() -&gt; 判断文件或者文件夹是否存在</span><br></pre></td></tr></table></figure>



<h5 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String[] 1ist() -&gt; 遍历指定的文件夹，返回的是string数组</span><br><span class="line">File[] listFiles() -&gt; 追历指定的文件夹，返回的是File数组 -&gt; 这个推荐使用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">listFiles方法底层还是list方法</span><br><span class="line">	调用list方法，遍历文件夹，返回一个String数组，遍历数组，将数组中的内容一个一个封装到File对象中，然后再将File对象放到File数组中</span><br><span class="line">	</span><br><span class="line">注意：</span><br><span class="line">	遍历文件夹，只会遍历文件夹内的文件，如果还有子级文件夹不会遍历，但是会遍历出文件夹名</span><br></pre></td></tr></table></figure>



<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 三种构造方法</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\新桌面&quot;</span>,<span class="string">&quot;IO&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\新桌面&quot;</span>),<span class="string">&quot;IO&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\新桌面\\IO\\1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取方法</span></span><br><span class="line">        System.out.println(f1.getAbsoluteFile()); <span class="comment">// 获取绝对路径</span></span><br><span class="line">        System.out.println(f2.getPath()); <span class="comment">// 获取封装路径</span></span><br><span class="line">        System.out.println(f1.getName()); <span class="comment">// 获取文件或者文件夹名称</span></span><br><span class="line">        System.out.println(f3.length()); <span class="comment">// 获取文件长度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建方法</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\新桌面\\IO\\10.txt&quot;</span>);</span><br><span class="line">        System.out.println(f4.createNewFile());</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\新桌面\\IO\\bb&quot;</span>);</span><br><span class="line">        System.out.println(f5.mkdirs());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除方法</span></span><br><span class="line">        System.out.println(f4.delete());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断方法</span></span><br><span class="line">        System.out.println(f5.isDirectory());</span><br><span class="line">        System.out.println(f5.isFile());</span><br><span class="line">        System.out.println(f4.exists());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        String[] s1 = f1.list();</span><br><span class="line">        <span class="keyword">for</span> (String s : s1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s = &quot;</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        File[] s2 = f1.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : s2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;file = &quot;</span> + file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>小练习，遍历目录下的所有txt文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 指定文件夹</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\新桌面\\IO&quot;</span>);</span><br><span class="line">        method(f1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(File f1)</span>&#123;</span><br><span class="line">        File[] f2 = f1.listFiles();</span><br><span class="line">        <span class="comment">// 遍历文件夹</span></span><br><span class="line">        <span class="keyword">for</span> (File file : f2) &#123;</span><br><span class="line">            <span class="comment">// 判断是否是文件，是文件判断是否是txt文件</span></span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> file.getName();</span><br><span class="line">                <span class="keyword">if</span> (name.endsWith(<span class="string">&quot;.txt&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不是文件，即使文件夹，重新调用方法，遍历文件夹</span></span><br><span class="line">                method(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说一下相对路径的写法，要从项目的根目录下面开始写，因为如果直接就创建一个1.txt这个时候文件是生成在项目的根目录下的和out目录同级。</p>
</blockquote>
<h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><h4 id="IO流介绍"><a href="#IO流介绍" class="headerlink" title="IO流介绍"></a>IO流介绍</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单词：</span><br><span class="line">	Output：输出</span><br><span class="line">	Input：输入</span><br><span class="line">	</span><br><span class="line">	write：写入</span><br><span class="line">	read：读取</span><br><span class="line">	</span><br><span class="line">IO流：</span><br><span class="line">	将一个设备上的数据传输到另一个设备上，称为IO流技术</span><br><span class="line">	</span><br><span class="line">学IO流的目的：</span><br><span class="line">	集合和数组都能存储数据，但是这两个都是临时存储（代码运行完毕，集合和数组就从内存中释放了，数据也就不存在了），所以集合和数组不能永久保存数据。这个时候就需要IO流，将数据保存到文件里</span><br></pre></td></tr></table></figure>



<h4 id="IO流的流向"><a href="#IO流的流向" class="headerlink" title="IO流的流向"></a>IO流的流向</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">针对于se阶段的IO</span><br><span class="line">输入流：将数据从硬盘上读到内存中  Input</span><br><span class="line">输出流：从内存出发，将数据写到硬盘上 Output</span><br><span class="line"></span><br><span class="line">要是从电脑和电脑之间做数据传输，就是相对的</span><br><span class="line">	发数据的一方：输出</span><br><span class="line">	收数据的一方：输入</span><br></pre></td></tr></table></figure>



<h4 id="IO流分类"><a href="#IO流分类" class="headerlink" title="IO流分类"></a>IO流分类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字节流：万能流，一切皆字节</span><br><span class="line">	字节输出流： OutputStream 抽象类</span><br><span class="line">	字节输入流： InputStream 抽象类</span><br><span class="line">字符流：专门操作文本文档</span><br><span class="line">	字符输出流： Writer 抽象类</span><br><span class="line">	字符输入流： Reader 抽象类</span><br></pre></td></tr></table></figure>



<h4 id="字节输出流"><a href="#字节输出流" class="headerlink" title="字节输出流"></a>字节输出流</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：OutputStream 抽象类</span><br><span class="line">	子类：FileOutputStream</span><br><span class="line">	</span><br><span class="line">作用：往硬盘上写数据</span><br><span class="line"></span><br><span class="line">构造：</span><br><span class="line">	FileOutputStream(File file);</span><br><span class="line">	FileOutputStream(String name)</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">特点：</span><br><span class="line">	1、指定的文件如果没有，会自动创建</span><br><span class="line">	2、如果有这个文件，会覆盖掉</span><br><span class="line">	</span><br><span class="line">	// python的open(&quot;w&quot;)模式</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">方法：</span><br><span class="line">	void write(int b)  一次写一个字节</span><br><span class="line">	void write(byte[] b)  一次写一个字节数组</span><br><span class="line">	void write(byte[] b,int off，int len) 一次写一个字节数组一部分</span><br><span class="line">			b：写的数组</span><br><span class="line">			off：从数组的哪个索引开始写</span><br><span class="line">			len：写多少个</span><br><span class="line">	void close() -&gt; 手动关闭</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">注意：写是按照字节写的，保存到文件中，用记事本打开，写的数字就会按照ASCII码表翻译</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        method01();</span><br><span class="line">        method02();</span><br><span class="line">        method03();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method01</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;mondeule01\\1.txt&quot;</span>);</span><br><span class="line">        fos.write(<span class="number">97</span>);</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method02</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;mondeule01\\1.txt&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] by = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>,<span class="number">101</span>&#125;;</span><br><span class="line">        fos.write(by);</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method03</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;mondeule01\\1.txt&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] by = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>,<span class="number">101</span>&#125;;</span><br><span class="line">        fos.write(by,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240724223841431.png" alt="image-20240724223841431"></p>
<blockquote>
<p>这样的方法多少有点原始人了，想点流弊的，字符串有一个方法，可以转成byte类型，用它就行了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fos.write(<span class="string">&quot;abcde&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>


</blockquote>
<h5 id="追加模式"><a href="#追加模式" class="headerlink" title="追加模式"></a>追加模式</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FileoutputStream(String name，boolean append)</span><br><span class="line">	append等于true -&gt; 实现续写追加</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">换行：</span><br><span class="line">	1、windows：\r\n 或者 \n  -&gt; 占两个字节</span><br><span class="line">	2、Linux：\n</span><br><span class="line">	3、mac os：\r</span><br></pre></td></tr></table></figure>



<h4 id="字节输入流（只读模式）"><a href="#字节输入流（只读模式）" class="headerlink" title="字节输入流（只读模式）"></a>字节输入流（只读模式）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：InputStream 抽象类</span><br><span class="line">	子类：FileInputStream</span><br><span class="line">	</span><br><span class="line">作用：读数据，将数据从硬盘上读到内存中来</span><br><span class="line"></span><br><span class="line">构造：</span><br><span class="line">	FileInputStream(File file)</span><br><span class="line">	FileInputStream(String path)</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">方法：</span><br><span class="line">	int read()  一次读一个字节，返回的是读取的字节</span><br><span class="line">	int read(byte[] b)  一次读取一个字节数组，返回的是读取的字节个数</span><br><span class="line">	int read(byte[] b, int off, int len)  一次读取一个字节数组的一部分，返回的是读取的字节个数</span><br><span class="line">	void close() 关闭资源文件</span><br></pre></td></tr></table></figure>



<h5 id="一次只读一个"><a href="#一次只读一个" class="headerlink" title="一次只读一个"></a>一次只读一个</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read01</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;mondeule01\\1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*int data1 = fis.read();</span></span><br><span class="line"><span class="comment">    System.out.println(data1);</span></span><br><span class="line"><span class="comment">    int data2 = fis.read();</span></span><br><span class="line"><span class="comment">    System.out.println(data2);</span></span><br><span class="line"><span class="comment">    int data3 = fis.read();</span></span><br><span class="line"><span class="comment">    System.out.println(data3);*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 太慢了，来个循环</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> ((len = fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;len = &quot;</span> + len);</span><br><span class="line">        System.out.println((<span class="type">char</span>) len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有一个点就是，超出字节长度时再次读取也可以读取到，但是读出的数是 <code>-1</code> ，这个时候就利用while来读取内容了，如果遇到-1就停止，因为读出来的是ASCII码的形态，可以强转成char数组，显示字母</p>
<p>注意：</p>
<p>​	1、一个流对象，读完只会就不能再读了；除非再new一个新对象</p>
<p>​	2、流关闭之后，流对象不能继续使用了</p>
</blockquote>
<h5 id="读出-1问题"><a href="#读出-1问题" class="headerlink" title="读出-1问题"></a>读出-1问题</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">每个文件末尾都会有一个“结束标记”，这个“结束标记”看不见，摸不着</span><br><span class="line">而read()方法规定，如果读取到了文件的结束标记，方法返回-1</span><br><span class="line">如果文本中本来有-1，也会拆开出现，先是-再是1</span><br></pre></td></tr></table></figure>



<h5 id="一次读一个数组"><a href="#一次读一个数组" class="headerlink" title="一次读一个数组"></a>一次读一个数组</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;mondeule01\\1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 创建一个数组：byte[]</span></span><br><span class="line"><span class="comment">        *   1.创建的数组相当于一个临时存储区域，我们要读取的内容会临时保存</span></span><br><span class="line"><span class="comment">        *     到数组中然后我们再从数组中将数据获取</span></span><br><span class="line"><span class="comment">        *   2.数组长度定为多少，每次读取多少个，一般情况下数组长度定为1024</span></span><br><span class="line"><span class="comment">        *     或者1024的倍数如果剩下的字节不够数组长度了，那么就最后有多少</span></span><br><span class="line"><span class="comment">        *     读多少</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        byte[] bytes = new byte[2];</span></span><br><span class="line"><span class="comment">//        int len1 = fis.read(bytes);</span></span><br><span class="line"><span class="comment">//        System.out.println(len1);</span></span><br><span class="line"><span class="comment">//        System.out.println(new String(bytes, 0 ,len1));</span></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span> ,len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意这里之所以使用长度为2的数组是想说明一个问题，读取完时候输出成字符串形式的时候</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(new String(bytes, 0 ,len));</span><br></pre></td></tr></table></figure>

<p>一定要使用len来限制长度，因为如果上一个读出cd，这一从读取两个，只拿到了e，这个时候e将c覆盖掉，但是d还在哪里，这个时候输出整个数组的话，就会出现问题，也是一个小细节</p>
</blockquote>
<h4 id="实现文件复制"><a href="#实现文件复制" class="headerlink" title="实现文件复制"></a>实现文件复制</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">复制一个图片吧</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\新桌面\\IO\\1.jpg&quot;</span>);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\新桌面\\IO\\1plus版.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这种形式是边读边写</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(bytes);  <span class="comment">// 读多少，写多少</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 习惯是先开后管</span></span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上面学习字节流的时候并没有用中文，因为涉及中文编码占字节数问题，一个中午在utf-8内占3个字节，如果还是上面的读取俩字节输出一下子，指定乱码，需要读取3个字节，虽然是没问题，因为字节流是万能流，但是有点麻烦，字节流更偏向于文件复制，因此不要边度边看</span><br><span class="line"></span><br><span class="line">但是呢，使用字符操作编码也要保持一致，否则仍然会乱码</span><br><span class="line">字符流在编码一致的情况下边读边看是没啥问题的</span><br><span class="line">字节流即使在编码一致的情况下，边读边看仍然可能出现问题</span><br></pre></td></tr></table></figure>



<h4 id="FileReader（字符输入流）"><a href="#FileReader（字符输入流）" class="headerlink" title="FileReader（字符输入流）"></a>FileReader（字符输入流）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符流是专门用来操作文本文档的，但是进行复制操作的，还是要用字节流</span><br><span class="line"></span><br><span class="line">概述：字符出入流 -&gt; Reader -&gt; 是一个抽象类</span><br><span class="line">作用：将文本文档中的内容读取到内存中来</span><br><span class="line">构造：</span><br><span class="line">	FileReader(File file)</span><br><span class="line">	FileReader(String path)</span><br><span class="line">	</span><br><span class="line">方法：</span><br><span class="line">	int read() -&gt; 一次读取一个字符，返回的是读取字符对应的int值</span><br><span class="line">	int read(char[] cbuf) -&gt; 一次读取一个字符数组，返回的是读取个数</span><br><span class="line">	int read(char[] cbuf, int off, int len) -&gt; 一次读取一个字符数组一部分，返回的是读取个数</span><br><span class="line">	close() -&gt; 关闭资源</span><br></pre></td></tr></table></figure>



<h4 id="FileWriter（字符输出流）"><a href="#FileWriter（字符输出流）" class="headerlink" title="FileWriter（字符输出流）"></a>FileWriter（字符输出流）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：Writer 抽象类</span><br><span class="line">	子类：FileWriter</span><br><span class="line"></span><br><span class="line">作用：将数据写到文件中</span><br><span class="line">构造：</span><br><span class="line">	FileWriter(File file)</span><br><span class="line">	FileWriter(String fileName)</span><br><span class="line">	FileWriter(String fileName, boolean addenp) -&gt; 追加续写</span><br><span class="line">	</span><br><span class="line">方法：</span><br><span class="line">	void writer(int c)</span><br><span class="line">	void writer(char[] cbuf)</span><br><span class="line">	void writer(char[] cbuf, int off, int len) </span><br><span class="line">	void writer(String str) -&gt; 直接写一个字符串</span><br><span class="line">	void close() -&gt; 关闭资源</span><br></pre></td></tr></table></figure>



<p>字符输出流，字符输入流，这俩东西和字节输出流，字节输入流方法是很相近的，就懒得演示了</p>
<blockquote>
<p>有一个细节：</p>
<p>​	FileWriter底层自带一个缓冲区，我们写入的数据会先保存在缓冲区内，所以我们需要将缓冲区的数据刷到文件中。这一点和字节输出流不一样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fw.flush()</span><br><span class="line"></span><br><span class="line">// 当然直接关闭资源，也可以刷入</span><br><span class="line">fw.close()</span><br></pre></td></tr></table></figure>

<p>但是呢，flush只是单纯刷新，如果使用close就关闭流了，后续无法继续使用流对象了</p>
</blockquote>
<h3 id="IO流异常处理方式"><a href="#IO流异常处理方式" class="headerlink" title="IO流异常处理方式"></a>IO流异常处理方式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IO操作的时候是有异常的，之前都是直接上抛，但其实Io异常处理应该try……catch</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;mondeule01\\1.txt&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fr != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fr.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>处理异常还有专门办法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	try(IO对象)&#123;</span><br><span class="line">		可能出现的异常代码</span><br><span class="line">	&#125; catch (异常类型 对象名)&#123;</span><br><span class="line">		处理异常</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">注意这个格式处理IO异常，是自动关流的</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;mondeule\\2.txt&quot;</span>)) &#123;</span><br><span class="line">            fw.write(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为FileWriter不刷新，不关流是不会将缓存区内容添加到文本文档内的，因此可以测试是否自动关闭</span></span><br></pre></td></tr></table></figure>





<h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><h4 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为啥要学字节缓冲流</span><br><span class="line">	之前学的FileOutputStream，FileInputStream，FileReader，Filewriter这都叫做基本类，其中FileInputStream和FileOutputStream的读写方法都是本地方法（方法声明上带native），本地方法是和系统以及硬盘打交道的，也就是说这两个对象的读和写都是在硬盘之间进行读写的，效率不高；缓冲流中底层带一个长度为8192的数组(缓冲区)，此时读和写都是在内存中完成的（在缓冲区完成），内存中的读写效率非常高</span><br><span class="line">	</span><br><span class="line">	使用之前需要将基本流包装成缓冲流，其实就new对象时，传递基本流</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">字节缓冲流：</span><br><span class="line">	1、BufferedOutputStream：字节缓冲输出流</span><br><span class="line">		构造：BufferedOutputStream(OutputStream out)</span><br><span class="line">		使用：和FileOutputStream一样</span><br><span class="line">		</span><br><span class="line">	2、BufferedInputStream：字节缓冲输入流</span><br><span class="line">		构造：BufferedInputStream(FileInputStream in)</span><br><span class="line">		使用：和FileInputStream一样</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用缓冲流复制文件。效率比较高</p>
<p>细节：</p>
<p>​	问题1：使用缓冲流的时候为什么只需要关闭缓冲流，而不需要关闭基本流？</p>
<p>​			原因：缓冲流的close方法底层自动关闭基本流</p>
<p>​	问题2：缓冲流底层有数组（缓冲区），都是在内存之间进行读写，那么缓冲流读写的过程是怎么样的？</p>
<p>​			先依靠基本流将数据读出来，然后交给缓冲流，由于缓冲流缓冲区是8192，所以每次读取8192个字节放到缓冲区中，然后再将输入流缓冲区中的数据交给输出流缓冲区，然后利用基本流将数据写到硬盘上</p>
<p>​			那么在操作代码时len的作用是什么呢？len的主要作用时在两个缓冲区之间倒腾数据，将输入流缓冲区中的数据读到，然后写到输出流缓冲区中，等待输出流缓冲区满了，再依靠基本流写到硬盘上；如果输入流缓冲区中的数据读不到了，重新从硬盘读取8192个字节，进入到输出流缓冲区中，继续利用len在两个缓冲区之间倒腾数据。</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240725152609092.png" alt="image-20240725152609092"></p>
</blockquote>
<p>​	</p>
<h4 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符流的基本流底层是有缓冲区的，所以在效率这一层面不是特别明显，主要学习字符缓冲流的两个特有方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">缓冲输出流</span><br><span class="line">	构造：</span><br><span class="line">		BufferedWriter(Writer w)</span><br><span class="line">	</span><br><span class="line">	方法：</span><br><span class="line">		和FileWriter一样</span><br><span class="line">	</span><br><span class="line">	特有方法：</span><br><span class="line">		newLine()  -&gt;  换行</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">缓冲输入流</span><br><span class="line">	构造：</span><br><span class="line">		BufferedReader(Reader r)</span><br><span class="line">		</span><br><span class="line">	方法：和FileReader一样</span><br><span class="line">	</span><br><span class="line">	特有方法：</span><br><span class="line">		String readLine()  -&gt;  一次读一行，如果读到结束标记，返回null</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;mondeule01\\2.txt&quot;</span>));</span><br><span class="line">        bw.write(<span class="string">&quot;但使龙城飞将在&quot;</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(<span class="string">&quot;不教胡马度阴山&quot;</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(<span class="string">&quot;杨花落尽子规啼&quot;</span>);</span><br><span class="line">        bw.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;mondeule01\\2.txt&quot;</span>));</span><br><span class="line">        <span class="comment">/*System.out.println(br.readLine());</span></span><br><span class="line"><span class="comment">        System.out.println(br.readLine());</span></span><br><span class="line"><span class="comment">        System.out.println(br.readLine());</span></span><br><span class="line"><span class="comment">        System.out.println(br.readLine());</span></span><br><span class="line"><span class="comment">        System.out.println(br.readLine());*/</span></span><br><span class="line"></span><br><span class="line">        String len;</span><br><span class="line">        <span class="keyword">while</span> ((len = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(len);</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.字节流读取中文在编码一致的情况，也不要边读边看，因为如果字节读不准，读不全，输出的内容有可能会出现乱码</span><br><span class="line">2.所以，我们学了字符流，字符流读取文本文档中的内容如果编码一致，就不会出现乱码问题了</span><br><span class="line">3.但是如果编码不一致，即使用字符流读取，仍然会出现乱码</span><br></pre></td></tr></table></figure>



<h4 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：是字节流通向字符流的桥梁 -&gt; 读数据</span><br><span class="line">构造：</span><br><span class="line">	InputStreamReader(InputStream in, String charsetName)</span><br><span class="line">		charsetName:指定编码，不区分大小写</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作用：</span><br><span class="line">	直接指定编码，按照指定编码去读取内容</span><br><span class="line">	</span><br><span class="line">用法：</span><br><span class="line">	基本用法和FileReader一样，因为FileReader继承InputStreamReader</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个东西相当于python中open方法的第三个参数的作用，指定编码集</p>
</blockquote>
<h4 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符流通向字节流的桥梁</span><br><span class="line">构造：</span><br><span class="line">	OutputStreamWriter(OutputStream out, String charsetName)</span><br><span class="line">	</span><br><span class="line">方法和FileWriter一样，因为FileWriter继承了OutputStreamWirter</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;1.txt&quot;</span>),<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">        osw.write(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        osw.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;1.txt&quot;</span>),<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> isr.read();</span><br><span class="line">        System.out.println((<span class="type">char</span>)data);</span><br><span class="line">        isr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="序列化流和反序列化流"><a href="#序列化流和反序列化流" class="headerlink" title="序列化流和反序列化流"></a>序列化流和反序列化流</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用：读写对象</span><br><span class="line">两个对象：</span><br><span class="line">	1、ObjectOutputStream（序列化流） -&gt; 写对象</span><br><span class="line">	2、ObjectInputStream（反序列化流） -&gt; 读对象</span><br><span class="line">	</span><br><span class="line">注意：</span><br><span class="line">	我们将对象序列化到对象中，打开文件，指定看不懂，这就对了，防止数据被随意改动，只需要能读回来即可</span><br><span class="line">	</span><br><span class="line">	</span><br></pre></td></tr></table></figure>



<h4 id="ObjectOutputStream"><a href="#ObjectOutputStream" class="headerlink" title="ObjectOutputStream"></a>ObjectOutputStream</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用：写对象</span><br><span class="line">构造：</span><br><span class="line">	ObjectOutputStream(OutputStream out)</span><br><span class="line">	</span><br><span class="line">方法：</span><br><span class="line">	writeObject(Object obj) -&gt; 写对象</span><br></pre></td></tr></table></figure>



<h4 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用：读对象</span><br><span class="line">构造：</span><br><span class="line">	ObjectInputStream(InputStream in)</span><br><span class="line">	</span><br><span class="line">方法：</span><br><span class="line">	Object readObject()  -&gt;  读对象</span><br></pre></td></tr></table></figure>



<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;mondeule01\\person.txt&quot;</span>));</span><br><span class="line">        <span class="type">person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">19</span>);</span><br><span class="line">        oos.writeObject(p1);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;mondeule01\\person.txt&quot;</span>));</span><br><span class="line">        <span class="type">person</span> <span class="variable">p2</span> <span class="operator">=</span> (person) ois.readObject();</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>定义对象的时候需要实现Serializable才能进行序列化。</p>
<p>问题：如果我有一个值，不想没序列化怎么办？</p>
<p>​		transient关键字，在不想被序列化的数据类型前面加上这个关键字即可</p>
</blockquote>
<h4 id="反序列化时出现的问题"><a href="#反序列化时出现的问题" class="headerlink" title="反序列化时出现的问题"></a>反序列化时出现的问题</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">问题描述：</span><br><span class="line">	序列化之后，修改源码，修改完之后没有重新序列化，直接反序列化了，就会出现序列号冲突问题；</span><br><span class="line">	InvalidClassException</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240725215058436.png" alt="image-20240725215058436"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解决：将序列号定死，后面不管怎么修改代码，序列号都是这一个</span><br><span class="line">	在被序列化的对象中加上一个public static final long 的变量，并为其赋值</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">42L</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>加上这一个就可以固定序列号，这时再更改变量的修饰符，不会影响反序列化</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">42L</span>;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将一个对象实现一个序列化接口，将来才能让这个对象变为二进制，在网络上传输</p>
</blockquote>
<p>反序列化的时候，面对多个对象肯定要使用for循环，但是注意：循环读取的次数和存储对象的个数要对应，否则会出现EOFException异常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解决方法有很多，只说一个：</span><br><span class="line">	创建一个ArrayList对象，将要序列化的对象全部传入集合中，然后，只需要反序列化一个集合即可，出来再for循环，集合的长度可以使用方法确定。</span><br></pre></td></tr></table></figure>





<h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构造：</span><br><span class="line">	PrintStream(String fileName)</span><br><span class="line">	</span><br><span class="line">方法：</span><br><span class="line">	1、println()：原样输出，自带换行效果</span><br><span class="line">	2、print()：原样输出，不换行</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;mondeule01\\1.txt&quot;</span>);</span><br><span class="line">        ps.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="改变流向"><a href="#改变流向" class="headerlink" title="改变流向"></a>改变流向</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">改变流向：</span><br><span class="line">	什么叫做改变流向：</span><br><span class="line">	比如：System.out.println() -&gt; 语法本身是将语句输出到控制台</span><br><span class="line">	改变流向：可以让输出语句从控制台上输出改变成往指定文件中输出</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">方法：System中的方法：</span><br><span class="line">	static void setOut(PrintStream out) -&gt; 改变流向 -&gt; 让输出语句从控制台输出转移到指定文件中</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;mondeule01\\1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.setOut(ps);</span><br><span class="line">        System.out.println(<span class="string">&quot;床前明月光&quot;</span>);</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个时候，本该输出到控制台的语句就转存到PrintStream对象指定的文件中了，主要使用场景就是保存日志文件</p>
</blockquote>
<h4 id="打印流续写"><a href="#打印流续写" class="headerlink" title="打印流续写"></a>打印流续写</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PrintStream(OutputStream out)  -&gt;  可以依靠OutputStream的续写功能完成打印流续写</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;mondeule01\\1.txt&quot;</span>,<span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">        System.setOut(ps);</span><br><span class="line">        System.out.println(<span class="string">&quot;床前明月光&quot;</span>);</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Properties集合"><a href="#Properties集合" class="headerlink" title="Properties集合"></a>Properties集合</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这个集合之前说过，可以配合IO流</span><br><span class="line"></span><br><span class="line">回顾一下：</span><br><span class="line">	概述：Hashtable的子类</span><br><span class="line">	特点：</span><br><span class="line">		1、无序、无索引</span><br><span class="line">		2、key唯一，value可重复</span><br><span class="line">		3、线程安全</span><br><span class="line">		4、key和value的默认值都是String</span><br><span class="line">		</span><br><span class="line">	特有方法：</span><br><span class="line">		map里的方法都能使用</span><br><span class="line">		setProperty(String key, String value) -&gt; 存键值对</span><br><span class="line">		getProperty(String key) -&gt; 根据key获取value</span><br><span class="line">		stringPropertyNames() -&gt; 获取所有的key存放到set集合中</span><br><span class="line">		load(InputStream in) -&gt; 将流中的数据加载到Properties集合中</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用场景：配合配置文件使用</p>
<p>注意：</p>
<p>​	将来我们不能将很多的硬数据放到源码中，比如用户名和密码这些数据，因为将来我们有可能换用户名或者密码，如果一换，我们就需要去源码中修改，将来我们的类和类之间都有联系，有可能牵一发动全身，所以我们需要将这些数据提取出来，放到文件中，改的时候直接去文件中该，源码不需要改动</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建配置文件</span><br><span class="line">	新建文本文档 xxx.properties</span><br><span class="line">	注意事项：</span><br><span class="line">		1、key和value都是key=valie形式</span><br><span class="line">		2、key和value都是String的，但是不要加双引号</span><br><span class="line">		3、每个键值对写完之后，换行写下一个</span><br><span class="line">		4、键值对之间最好不要有空格(可以有，但是不建议)</span><br><span class="line">		5、键值对中建议不要用中文(读取可能乱码，需要用转换流转码)</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">pis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;mondeule01\\student.properties&quot;</span>);</span><br><span class="line">        p.load(pis);</span><br><span class="line">        <span class="comment">// 将数据添加到集合中去，然后转成set集合来遍历</span></span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set = p.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">            System.out.println(s+<span class="string">&quot;...&quot;</span>+p.getProperty(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="IO流工具类-Commons-io"><a href="#IO流工具类-Commons-io" class="headerlink" title="IO流工具类-Commons-io"></a>IO流工具类-Commons-io</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IO开发中，代码量很大，代码重复率高。对应遍历目录，拷贝目录中递归调用，程序就变得复杂</span><br></pre></td></tr></table></figure>



<h4 id="添加第三方jar包"><a href="#添加第三方jar包" class="headerlink" title="添加第三方jar包"></a>添加第三方jar包</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Commons-io工具类属于第三方，需要添加jar包</span><br><span class="line"></span><br><span class="line">jar包：本身是一个压缩包，里面转的都是class文件，我们想使用jar包中的工具类，就需要将相应的jar包解压到当前目录下</span><br><span class="line"></span><br><span class="line">引入jar包：</span><br><span class="line">	1、在当前模块下创建文件夹，取名为lib或者libs</span><br><span class="line">	2、将准备好的jar包放到此文件夹下</span><br><span class="line">	3、右键，添加到库</span><br></pre></td></tr></table></figure>



<h4 id="使用工具包"><a href="#使用工具包" class="headerlink" title="使用工具包"></a>使用工具包</h4><h5 id="IoUtils类"><a href="#IoUtils类" class="headerlink" title="IoUtils类"></a>IoUtils类</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IoUtils类</span><br><span class="line">	静态方法：</span><br><span class="line">		IOUtils.copy(InputStream in, OutputStream out)  -&gt;  传递字节流，实现文件复制</span><br><span class="line">		IOUtils.closeQuietly(任意流对象)悄悄的释放资源，自动处理close()方法抛出的异常</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        IOUtils.copy(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;mondule01\\1.txt&quot;</span>),<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;mondule01\\11.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;mondule01\\1.txt&quot;</span>);</span><br><span class="line">            fw.write(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fw != <span class="literal">null</span>) &#123;</span><br><span class="line">                IOUtils.closeQuietly(fw);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使用closeQuietly方法，就不需要在对close进行try……catch处理了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="FileUtils类"><a href="#FileUtils类" class="headerlink" title="FileUtils类"></a>FileUtils类</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FileUtils类</span><br><span class="line">静态方法：</span><br><span class="line">	FileUtiles.copyDirectoryToDirectory(File src, File dest)</span><br><span class="line">		传递File类型的目录，进行整个目录的复制，自动进行递归遍历</span><br><span class="line">		</span><br><span class="line">		参数：</span><br><span class="line">			src:要复制的文件夹路径</span><br><span class="line">			dest:要将文件夹粘贴到哪里去</span><br><span class="line">			</span><br><span class="line">	writeStringToFile(File file, String str) -&gt; 写字符串到文本文件中</span><br><span class="line">	String readFileToString(File file)  读取文本文件，返回字符串</span><br></pre></td></tr></table></figure>



<blockquote>
<p>IO流总结：</p>
<p>​	写的类名：FileOutputStream、FileWriter、BufferedOutputStream、BufferedWriter、ObjectOutputStream、OutputStreamWriter</p>
<p>​	写的方法：writer、BufferedWriter的特有方法newLine()、ObjectOutputStream -&gt; writerObject、OutputStreamWriter -&gt; new对象时指定编码</p>
<p>​	读的类名：FilelnputStream、FileReader、BufferedlnputStream、BufferedReader、ObjectlnputStream、InputStreamReader</p>
<p>​	读的方法：read()、BufferedReader 特有方法 readLine()、ObjectlnputStream -&gt; readObject()、InputStreamReader new对象的时候指定编码</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240726002053215.png" alt="image-20240726002053215"></p>
</blockquote>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：在网络通信协议下，不同计算机上运行的程序，进行数据传输</span><br><span class="line">	比如：通信，视频通话，网游，邮件等</span><br><span class="line">	只要是计算机之间通过网络进行数据传输，就存在网络编程</span><br></pre></td></tr></table></figure>



<h3 id="软件结构"><a href="#软件结构" class="headerlink" title="软件结构"></a>软件结构</h3><ul>
<li>C&#x2F;S结构：全称为Client&#x2F;Server结构，是指客户端和服务端结构。常见程序有QQ</li>
<li>B&#x2F;S结构：全称为Browser&#x2F;Server结构，是指浏览器和服务器结构。之间通过浏览器访问</li>
</ul>
<p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。网络编程，就是在一定的协议下，实现两台计算机的通信的程序</p>
<h4 id="服务器概念"><a href="#服务器概念" class="headerlink" title="服务器概念"></a>服务器概念</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：安装了服务器软件的计算机</span><br><span class="line">	如：tomcat</span><br></pre></td></tr></table></figure>

<blockquote>
<p>网络通信协议：两台计算机在做数据交互时要遵守的规则，协议会对数据的格式，速率等进行规定，只要遵守了这个协议，才能完成数据交互</p>
</blockquote>
<h4 id="通信三要素"><a href="#通信三要素" class="headerlink" title="通信三要素"></a>通信三要素</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[IP地址]：计算机的唯一标识，用于两台计算机之间的连接</span><br><span class="line">	这东西很熟悉了，也不多说了</span><br><span class="line">	IPV4,IPV6</span><br><span class="line">	ipconfig、ifconfig</span><br><span class="line">	ping</span><br><span class="line"></span><br><span class="line">[协议]：</span><br><span class="line">	TCP：面向连接协议</span><br><span class="line">		需要先确认连接，才能进行数据交互</span><br><span class="line">		三次握手：</span><br><span class="line">			- 第一次握手，客户端向服务器发出连接请求，等待服务器确认</span><br><span class="line">			- 第二次握手，服务端向客户端回送一个响应，通知客户端收到了连接请求</span><br><span class="line">			- 第三次握手，客户端再次向服务器端发送确认信息，确认连接</span><br><span class="line">			</span><br><span class="line">		好处：数据安全，能给数据的传输提供一个安全的传输环境</span><br><span class="line">		坏处：效率低</span><br><span class="line">		</span><br><span class="line">	UDP：面向无连接协议</span><br><span class="line">		好处：效率高</span><br><span class="line">		坏处：传输的数据不安全，容易丢失数据包</span><br><span class="line">		</span><br><span class="line">[端口号]</span><br><span class="line">	每一个应用程序的唯一标识</span><br><span class="line">	</span><br><span class="line">	用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>TCP协议的四次挥手</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">四次挥手，客户端和服务端断开连接的时候进行</span><br><span class="line"></span><br><span class="line">- 第一次挥手：客户端向服务端提出结束连接，让服务端做最后的准备工作，此时，客户端处于半关闭状态，即表示不再向服务器发送数据了。但是还可以接收数据。</span><br><span class="line"></span><br><span class="line">- 第二次挥手：服务器接收到客户端释放连接的请求后，会将最后的数据发送给客户端，并告知上层的应用进程不再接收数据。</span><br><span class="line"></span><br><span class="line">- 第三次挥手：服务器发送完数据后，会给客户端发送一个释放连接的报文。那么客户端接收后就知道可以正式释放连接了。</span><br><span class="line"></span><br><span class="line">- 第四次挥手：客户端接收到服务器最后的释放连接报文后，要回复一个彻底断开的报文。这样服务器收到后才会彻底释放连接。这里客户端，发送完最后的报文后，会等待2MSL，因为有可能服务器没有收到最后的报文，那么服务器迟迟没收到，就会再次给客户端发送释放连接的报文，此时客户端在等待时间范围内接收到，会重新发送最后的报文，并重新计时。如果等待2MSL后，没有收到，那么彻底断开。</span><br></pre></td></tr></table></figure>


</blockquote>
<h4 id="UDP协议编程"><a href="#UDP协议编程" class="headerlink" title="UDP协议编程"></a>UDP协议编程</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DatagramSocket -&gt; 好比寄快递找的快递公司</span><br><span class="line">DatagramPacket -&gt; 好比快递公司打包</span><br></pre></td></tr></table></figure>



<h5 id="客户端（发送端）"><a href="#客户端（发送端）" class="headerlink" title="客户端（发送端）"></a>客户端（发送端）</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建DatagramSocket对象</span><br><span class="line">	1、空参：端口号从可用的端口号随机一个使用</span><br><span class="line">	2、有参：使用指定的端口号</span><br><span class="line">	</span><br><span class="line">创建DatagramPacket对象，将数据进行打包</span><br><span class="line">	1、要发送的数据 -&gt; byte[]</span><br><span class="line">	2、指定接收端的IP</span><br><span class="line">	3、指定接收端的端口号</span><br><span class="line">	</span><br><span class="line">发送数据</span><br><span class="line"></span><br><span class="line">释放资源</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Send</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建DatagramSocket对象</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        创建DatagramPacket对象，将数据进行打包</span></span><br><span class="line"><span class="comment">	        1、要发送的数据 -&gt; byte[]</span></span><br><span class="line"><span class="comment">	        2、指定接收端的IP</span></span><br><span class="line"><span class="comment">	        3、指定接收端的端口号</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="string">&quot;hello,world&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">ip</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">6666</span>;</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length, ip, port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        socket.send(dp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接执行不会报错，UDP协议是面向无连接协议，不管有没有服务端，客户端照发不误</span></span><br></pre></td></tr></table></figure>



<h5 id="服务端（接收端）"><a href="#服务端（接收端）" class="headerlink" title="服务端（接收端）"></a>服务端（接收端）</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、创建DatagramSocket对象，指定服务端的端口号</span><br><span class="line">2、接收数据包</span><br><span class="line">3、解析数据包</span><br><span class="line">4、释放资源</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Send</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建DatagramSocket对象</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        创建DatagramPacket对象，将数据进行打包</span></span><br><span class="line"><span class="comment">	        1、要发送的数据 -&gt; byte[]</span></span><br><span class="line"><span class="comment">	        2、指定接收端的IP</span></span><br><span class="line"><span class="comment">	        3、指定接收端的端口号</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="string">&quot;hello,world&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">ip</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">6666</span>;</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length, ip, port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        socket.send(dp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>先打开服务端（接收端），然后再运行客户端，即可接收到发送的信息</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240726155347084.png" alt="image-20240726155347084"></p>
</blockquote>
<h4 id="TCP协议编程"><a href="#TCP协议编程" class="headerlink" title="TCP协议编程"></a>TCP协议编程</h4><p><img src="/../%E5%9B%BE%E7%89%87/image-20240726160303827.png" alt="image-20240726160303827"></p>
<h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、创建Socket对象，指明服务端的ip以及端口号</span><br><span class="line">2、调用Socket树象中的getOutputStream,获取输出流发送请求</span><br><span class="line">3、调用Socket中的getinputStream,获取输入流读取响应结果</span><br><span class="line">4、关流</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1、创建Socket对象，指明服务端的ip以及端口号</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、调用Socket树象中的getOutputStream,获取输出流发送请求</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        os.write(<span class="string">&quot;我想打视频&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、调用Socket中的getinputStream,获取输入流读取响应结果</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(bytes);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、关流</span></span><br><span class="line">        is.close();</span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.创建ServerSocket对象，设置端口号</span><br><span class="line">2.调用ServerSocket中的accept方法，等待客户端连接（该方法返回的是连接服务端的socket对象）</span><br><span class="line">3.调用socket中的getInputStream，用于读取请求</span><br><span class="line">4.调用socket中的getOutputStream，用于给客户端写响应</span><br><span class="line">5.关流</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.创建ServerSocket对象，设置端口号</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.调用ServerSocket中的accept方法，等待客户端连接（该方法返回的是连接服务端的socket对象）</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">s1</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.调用socket中的getInputStream，用于读取请求</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> s1.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(bytes);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, len));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.调用socket中的getOutputStream，用于给客户端写响应</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> s1.getOutputStream();</span><br><span class="line">        os.write(<span class="string">&quot;打个锤子你打&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.关流</span></span><br><span class="line">        os.close();</span><br><span class="line">        is.close();</span><br><span class="line">        s1.close();</span><br><span class="line">        ss.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="练习：文件上传"><a href="#练习：文件上传" class="headerlink" title="练习：文件上传"></a>练习：文件上传</h4><p>问题代码：可恶本本分分按照思路敲的代码有bug</p>
<h5 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\新桌面\\IO\\服务端复制.jpg&quot;</span>);</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            outputStream.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;以下是给客户端的响应结果&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        os.write(<span class="string">&quot;上传成功&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        os.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        is.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        ss.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送到服务端一张图片，边读边写</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\新桌面\\IO\\1.jpg&quot;</span>);</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            os.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;以下是服务端的响应结果&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收服务端提示</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bytes1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        len = is.read(bytes1);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes1, <span class="number">0</span>, len));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关流</span></span><br><span class="line">        is.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h5><p>图片因为我已经反复执行过了，所以显示上次的字节，如果是第一次执行，应该是显示0 字节</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240726165131748.png" alt="image-20240726165131748"></p>
<p>这个时候就可以推断出，问题出在服务端</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240726165512521.png" alt="image-20240726165512521"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240726170227837.png" alt="image-20240726170227837"></p>
<h6 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">缺少结束标记，给他一个结束标记进行了</span><br><span class="line"></span><br><span class="line">// 给服务端写一个结束标记</span><br><span class="line">socket.shutdownOutput();</span><br></pre></td></tr></table></figure>



<p>只需要在客户端上更改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送到服务端一张图片，边读边写</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\新桌面\\IO\\1.jpg&quot;</span>);</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            os.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给服务端写一个结束标记</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;以下是服务端的响应结果&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收服务端提示</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bytes1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        len = is.read(bytes1);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes1, <span class="number">0</span>, len));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关流</span></span><br><span class="line">        is.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个时候其实还有一个问题，复制的图片位置固定了，那么下一次上传就会覆盖掉，在服务端用一个随机方法，随机一个名字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s = UUID.randomUUID().toString();</span><br><span class="line">// 生成一个十六进制的随机数</span><br></pre></td></tr></table></figure>



<p>服务端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成一个随机id并加上当前时间的毫秒值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span>s + System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 边读边写</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\新桌面\\IO\\&quot;</span>+name+<span class="string">&quot;.jpg&quot;</span>);</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            outputStream.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;以下是给客户端的响应结果&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给客户端的响应</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        os.write(<span class="string">&quot;上传成功&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关流</span></span><br><span class="line">        os.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        is.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        ss.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="多线程处理"><a href="#多线程处理" class="headerlink" title="多线程处理"></a>多线程处理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">serverTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 生成一个随机id并加上当前时间的毫秒值</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">                        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> s + System.currentTimeMillis();</span><br><span class="line">                        outputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\新桌面\\IO\\&quot;</span> + name + <span class="string">&quot;.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 边读边写</span></span><br><span class="line">                        <span class="type">int</span> len;</span><br><span class="line">                        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                        <span class="keyword">while</span> ((len = is.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                            outputStream.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;以下是给客户端的响应结果&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 给客户端的响应</span></span><br><span class="line">                        os = socket.getOutputStream();</span><br><span class="line">                        os.write(<span class="string">&quot;上传成功&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 关流</span></span><br><span class="line">                        <span class="keyword">if</span> (os != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                os.close();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (outputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                outputStream.close();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (is != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                is.close();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (socket != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                socket.close();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>考虑到实际情况，ss对象就不关闭了，保持服务器一直开启，这个close的处理过于恶心，可以封装一个工具类。</p>
</blockquote>
<p>思考题，使用线程池</p>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：具有特殊规则的字符串</span><br><span class="line">作用：检验</span><br><span class="line">	比如：手机号，身份证号，密码，用户名，邮箱等</span><br><span class="line">	</span><br><span class="line">String中有一个校验正则的方法：</span><br><span class="line">	boolean mathes(String regex)  校验字符串是否指定的regex的规则</span><br></pre></td></tr></table></figure>



<p>正则这东西省代码，用着简单，写起来抽象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res01</span> <span class="operator">=</span> method01(data);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res02</span> <span class="operator">=</span> method02(data);</span><br><span class="line">        System.out.println(<span class="string">&quot;res01 = &quot;</span> + res01);</span><br><span class="line">        System.out.println(<span class="string">&quot;res02 = &quot;</span> + res02);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">method02</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data.matches(<span class="string">&quot;[1-9][0-9]&#123;4,14&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">method01</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.startsWith(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] chars = data.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> aChar : chars) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aChar &lt; <span class="string">&#x27;0&#x27;</span> || aChar &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data.length() &lt; <span class="number">5</span> || data.length() &gt; <span class="number">15</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符类</span><br><span class="line">1.[abc]：代表a或者b，或者c字符中的一个。</span><br><span class="line">2.[^abc]：代表除a，b，c以外的任何字符。</span><br><span class="line">3.[a-z]：代表a-z的所有小写字符中的一个。</span><br><span class="line">4.[A-Z]：代表A-Z的所有大写字符中的一个</span><br><span class="line">5.[0-9]：代表0-9之间的某一个数字字符。</span><br><span class="line">6.[a-zA-Z0-9]：代表a-z或者A-Z或者0-9之间的任意一个字符。</span><br><span class="line">7.[a-dm-p]：a到d或m到p之间的任意一个字符</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">逻辑符</span><br><span class="line">1、&amp;&amp;：并且</span><br><span class="line">2、|：或者</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">预定义字符</span><br><span class="line">1、&quot;.&quot;：匹配任何字符。（重点）不能加[]</span><br><span class="line">2、&quot;\\d&quot;：任何数字[0-9]的简写；（重点）</span><br><span class="line">3、&quot;\\D&quot;：任何非数字[^0-9]的简写；</span><br><span class="line">4、&quot;\\s&quot;：空白字符：[\t\n\xOB\f\r]的简写</span><br><span class="line">5、&quot;\\S&quot;：非空白字符：[^\s]的简写</span><br><span class="line">6、&quot;\\w”：单词字符：[a-zA-Z_0-9]的简写（重点）</span><br><span class="line">7、&quot;\\W”：非单词字符：[^\w]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">数量词</span><br><span class="line">1、X? ：X出现的数量为0次或1次</span><br><span class="line">2、X* ：X出现的数量为0次到多次  任意次</span><br><span class="line">3、X+ ：x出现的数量为1次或多次  X&gt;=1次</span><br><span class="line">4、X&#123;n&#125; ：x出现的数量为恰好n次  X=n次</span><br><span class="line">5、X&#123;n,&#125; ：x出现的数量为至少n次  X&gt;=n次  x&#123;3,&#125;</span><br><span class="line">6、x&#123;n,m&#125; ：x出现的数量为n到m次（n和m都是包含的）  n=&lt;x&lt;=m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">分组括号</span><br><span class="line">(abc) -&gt; 表示abc为一组，出现</span><br></pre></td></tr></table></figure>



<h5 id="String中和正则表达式相关的方法"><a href="#String中和正则表达式相关的方法" class="headerlink" title="String中和正则表达式相关的方法"></a>String中和正则表达式相关的方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean matches(String regex)  判断字符串是否匹配给定的正则表达式。</span><br><span class="line"></span><br><span class="line">String[] split(String regex)  根据给定正则表达式的匹配拆分此字符串。</span><br><span class="line"></span><br><span class="line">String replaceAll(String regex, String rep1acement)  把满足正则表达式的字符串，替换为新的字符</span><br></pre></td></tr></table></figure>



<p>放一个生成正则的网址</p>
<p><a href="https://www.sojson.com/regex/generate">https://www.sojson.com/regex/generate</a></p>
<h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设计模式（Designpattern），是一套被反复使用、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、保证代码可靠性、程序的重用性，稳定性。</span><br><span class="line"></span><br><span class="line">1995年，GoF（GangofFour，四人组）合作出版了《设计模式：可复用面向对象软件的基础》一书，共收录了23种设计模式。&lt;大话设计模式&gt;</span><br><span class="line"></span><br><span class="line">总体来说设计模式分为三大类：</span><br><span class="line"></span><br><span class="line">创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。--&gt;  创建对象</span><br><span class="line"></span><br><span class="line">结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。--&gt;  对功能进行增强</span><br><span class="line"></span><br><span class="line">行为型模式，共十一种：策略模式、模板方法模式、观察者模式、选代子模式、贵任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</span><br></pre></td></tr></table></figure>



<h5 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">模板方法（Temp1ateMethod）模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。明确了一部分功能，而另一部分功能不明确。需要延伸到子类中实现</span><br></pre></td></tr></table></figure>

<blockquote>
<p>主要思想是一样的写父类里面，不一样的继承到子类中，然后重写方法，使用时，直接子类点父类中的方法</p>
</blockquote>
<h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">目的：单（一个）例（实例，对象）</span><br><span class="line">	让一个类只产生一个对象，供外界使用</span><br><span class="line"></span><br><span class="line">分类：</span><br><span class="line">	1、饿汉式：迅速new对象</span><br><span class="line">	2、懒汉式：不着急new对象的</span><br></pre></td></tr></table></figure>



<h6 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">e</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *   防止外界随意使用构造方法，先将构造方法私有化</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">e</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *   为了赶紧new对象，我们new对象的时候变成静态的，让其随着类的加载而加载</span></span><br><span class="line"><span class="comment">    *   为了不让外界随便使用类名调用此静态对象，将其变为private</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">e</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">e</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *   还需要将new出来的对象给出去</span></span><br><span class="line"><span class="comment">    *   定义一个方法，让对象作为返回值给出去</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> e <span class="title function_">getE</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">singleton</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *   防止外界随意使用构造方法，先将构造方法私有化</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">singleton</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *   不着急new对象</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">singleton</span> <span class="variable">e</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *   还需要将new出来的对象给出去</span></span><br><span class="line"><span class="comment">    *   定义一个方法，让对象作为返回值给出去</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> singleton <span class="title function_">getE</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 直接进行if判断是有线程安全问题的，加上一个锁，但是呢，老是去抢锁，影响速率，再外面套一个判断，看需不需要去抢锁</span></span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                    e = <span class="keyword">new</span> <span class="title class_">singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Lombok使用"><a href="#Lombok使用" class="headerlink" title="Lombok使用"></a>Lombok使用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用：简化javabean开发</span><br><span class="line">使用：</span><br><span class="line">	下载插件idea中下载即可</span><br><span class="line">	导jar包</span><br><span class="line">	设置</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240726204949047.png" alt="image-20240726204949047"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240726205010962.png" alt="image-20240726205010962"></p>
<h5 id="Getter和-Setter"><a href="#Getter和-Setter" class="headerlink" title="@Getter和@Setter"></a>@Getter和@Setter</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240726210940683.png" alt="image-20240726210940683"></p>
<h5 id="ToString"><a href="#ToString" class="headerlink" title="@ToString"></a>@ToString</h5><p>作用：生成toString()方法。</p>
<h5 id="NoArgsConstructor和-AllArgsConstructor"><a href="#NoArgsConstructor和-AllArgsConstructor" class="headerlink" title="@NoArgsConstructor和@AllArgsConstructor"></a>@NoArgsConstructor和@AllArgsConstructor</h5><ul>
<li>@NoArgsConstructor：无参数构造方法。</li>
<li>@AllArgsConstructor：满参数构造方法。</li>
</ul>
<h5 id="EgualsAndHashCode"><a href="#EgualsAndHashCode" class="headerlink" title="@EgualsAndHashCode"></a>@EgualsAndHashCode</h5><p>生成hashCode()和equals()方法。</p>
<h5 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h5><p>作用：生成get&#x2F;set，toString，hashcode，equals，无参构造方法</p>
<p>注解只能写在类上。</p>
<p>不包含有参构造</p>
<h2 id="jdk新特性"><a href="#jdk新特性" class="headerlink" title="jdk新特性"></a>jdk新特性</h2><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="&#x3D;&#x3D;Lambda表达式&#x3D;&#x3D;"></a>&#x3D;&#x3D;Lambda表达式&#x3D;&#x3D;</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">面向对象思想是Java的核心编程思想</span><br><span class="line">	强调的是对象，然后使用对象中实现好的功能</span><br><span class="line">	比如：去北京，强调的是怎么去</span><br><span class="line">	</span><br><span class="line">jdk8开始，出现了新的思想：函数式编程思想：</span><br><span class="line">	强调的是结果，不强调过程</span><br><span class="line">	比如：去北京，强调去了还是没去</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">Lambda表达式</span><br><span class="line">	格式：</span><br><span class="line">		()-&gt;&#123;&#125;</span><br><span class="line">		</span><br><span class="line">	解释：</span><br><span class="line">		() ：参数位</span><br><span class="line">		-&gt; ：将参数传递到方法体中</span><br><span class="line">		&#123;&#125; ：重写方法的方法体</span><br></pre></td></tr></table></figure>



<p>lambda表达式在js中很常见啊，在Java中的一个示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;执行了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行了&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; System.out.println(<span class="string">&quot;执行了&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>主要是利用了jvm虚拟机的反推能力，让代码更加简洁、高级，可读性也变差了</p>
</blockquote>
<h4 id="使用前提"><a href="#使用前提" class="headerlink" title="使用前提"></a>使用前提</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">必须是函数式接口做方法传递</span><br><span class="line">函数式接口：</span><br><span class="line">	有且只有一个抽象方法的接口，用@FuncitionalInterface去检测</span><br><span class="line">	</span><br><span class="line">比如：Runnable接口，只要一个run抽象方法，就可以使用lambda表达式</span><br></pre></td></tr></table></figure>



<h4 id="省略规则"><a href="#省略规则" class="headerlink" title="省略规则"></a>省略规则</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先观察，后改造</span><br><span class="line">1、观察是否是函数式接口做方法参数传递</span><br><span class="line">2、如果是，考虑使用Lambda表达式</span><br><span class="line">3、调用方法，以匿名内部类的形式传递实参</span><br><span class="line">4、从new接口开始到重写方法的方法名结束，选择，删除</span><br><span class="line">5、在重写方法的参数后面，后面大括号前面加上 -&gt;</span><br><span class="line">（过于新手了）</span><br><span class="line"></span><br><span class="line">省略规则：</span><br><span class="line">	1、重写方法的参数结果可以干掉</span><br><span class="line">	2、如果重写方法只要一个参数，所在小括号可以干掉</span><br><span class="line">	3、如果方法体只有一句话，那么所在的大括号以及分号可以干掉</span><br><span class="line">	4、如果方法体中只有一句话并且带return的，那么所在的大括号，分号以及return可以干掉</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">19</span>);</span><br><span class="line">        <span class="type">person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">9</span>);</span><br><span class="line">        <span class="type">person</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">person</span>(<span class="string">&quot;王五&quot;</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(person o1, person o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge()- o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Collections.sort(list, (person o1, person o2) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge()- o2.getAge();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Collections.sort(list, (o1, o2) -&gt; o1.getAge()- o2.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：有且仅有一个抽象方法的接口</span><br><span class="line">检测方法：</span><br><span class="line">	@FunctionalInterface</span><br></pre></td></tr></table></figure>



<p>介绍四个函数式接口</p>
<h4 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Supplier&lt;T&gt; 它意味着“供给” -&gt; 想要什么，就返回什么</span><br><span class="line">方法：</span><br><span class="line">	T get()</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method01(<span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">int</span>[] ints = &#123;<span class="number">4</span>,<span class="number">65</span>,<span class="number">21</span>,<span class="number">84</span>,<span class="number">25</span>&#125;;</span><br><span class="line">                Arrays.sort(ints);</span><br><span class="line">                <span class="keyword">return</span> ints[ints.length-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        method01(() -&gt; &#123;</span><br><span class="line">                <span class="type">int</span>[] ints = &#123;<span class="number">4</span>,<span class="number">65</span>,<span class="number">21</span>,<span class="number">84</span>,<span class="number">25</span>&#125;;</span><br><span class="line">                Arrays.sort(ints);</span><br><span class="line">                <span class="keyword">return</span> ints[ints.length-<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method01</span><span class="params">(Supplier&lt;Integer&gt; supplier)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> supplier.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240726224857001.png" alt="image-20240726224857001"></p>
<h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Consumer&lt;T&gt;  -&gt;  消费性接口 -&gt; 操作</span><br><span class="line">方法：</span><br><span class="line">	void accept(T t)  意为消费一个指定泛型的数据</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                System.out.println(s.length());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;asdfghjkl&quot;</span>);</span><br><span class="line"></span><br><span class="line">        method(s-&gt; System.out.println(s.length()),<span class="string">&quot;asdfghjkl&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Consumer&lt;String&gt; consumer, String s)</span> &#123;</span><br><span class="line">        consumer.accept(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240726230110401.png" alt="image-20240726230110401"></p>
<h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Function&lt;T,R&gt; 接口用来根据一个类型数据得到另一个类型数据</span><br><span class="line">方法：</span><br><span class="line">	R apply(T t)  根据类型T参数获取类型R的结果</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        method(integer -&gt; integer+<span class="string">&quot;&quot;</span>,<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Function&lt;Integer, String&gt; function, Integer number)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> function.apply(number);</span><br><span class="line">        System.out.println(s+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240726230547130.png" alt="image-20240726230547130"></p>
<h4 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">判断型接口 Predicate&lt;T&gt;</span><br><span class="line">	boolean test(T t) -&gt; 用于判断方法，返回布尔型</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method(s -&gt; s.length()==<span class="number">7</span>,<span class="string">&quot;qwertyu&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Predicate&lt;String&gt; predicate, String s)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">test</span> <span class="operator">=</span> predicate.test(s);</span><br><span class="line">        System.out.println(<span class="string">&quot;test = &quot;</span> + test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>但是这个四个函数式接口，毫无用处，绕了一圈使用Lambda表达式解决问题罢了。但其实，这四个函数式接口主要配合Stream流使用的</p>
</blockquote>
<h3 id="Stream流"><a href="#Stream流" class="headerlink" title="&#x3D;&#x3D;Stream流&#x3D;&#x3D;"></a>&#x3D;&#x3D;Stream流&#x3D;&#x3D;</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">流不是指IO流，是一种编程方式--“流式编程”，可以看作流水线</span><br></pre></td></tr></table></figure>



<p>演示一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demobig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;翠花&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;翠花&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;赵正&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;潘金莲&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;武大郎&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张辽&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张八百&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求1，筛选出张姓</span></span><br><span class="line">        ArrayList&lt;String&gt; list1Zhang = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.startsWith(<span class="string">&quot;张&quot;</span>)) &#123;</span><br><span class="line">                list1Zhang.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求2，筛选出张姓，三字的人</span></span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : list1Zhang) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.length() == <span class="number">3</span>) &#123;</span><br><span class="line">                list1.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需求3，遍历</span></span><br><span class="line">        <span class="keyword">for</span> (String s : list1) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;使用Stream流&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stream = list.stream();</span><br><span class="line">        <span class="comment">/*stream.filter(new Predicate&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public boolean test(String s) &#123;</span></span><br><span class="line"><span class="comment">                return s.startsWith(&quot;张&quot;);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;).filter(new Predicate&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public boolean test(String s) &#123;</span></span><br><span class="line"><span class="comment">                return s.length()==3;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;).forEach(new Consumer&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void accept(String s) &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(s);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;使用Lambda表达式&quot;</span>);</span><br><span class="line"></span><br><span class="line">        stream.filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).filter(s -&gt; s.length()==<span class="number">3</span>).forEach(s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Stream流的获取"><a href="#Stream流的获取" class="headerlink" title="Stream流的获取"></a>Stream流的获取</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">针对集合：Collection中的方法</span><br><span class="line">	Stream&lt;E&gt; stream()</span><br><span class="line">	</span><br><span class="line">针对集合：Stream接口中的静态方法</span><br><span class="line">	static &lt;T&gt; Stream&lt;T&gt; of(T...values)</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">steam</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stream = list.stream();</span><br><span class="line">        System.out.println(stream);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stream1 = Stream.of(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        System.out.println(stream1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Stream方法"><a href="#Stream方法" class="headerlink" title="Stream方法"></a>Stream方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">forEach：逐一处理 -&gt; 遍历</span><br><span class="line">	void forEach(Consumer&lt;? super T&gt; action);</span><br><span class="line">	</span><br><span class="line">	注意：forEach方法是一个[终结方法]，使用完之后，Stream流不能用了</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">count：统计元素个数</span><br><span class="line">	long count();</span><br><span class="line">	注意：count方法也是终结方法</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">filter：根据某个条件进行元素过滤</span><br><span class="line">	Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</span><br><span class="line">	返回一个新的stream流对象</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">limit：获取前n个元素</span><br><span class="line">	Stream&lt;T&gt; 1imit(long maxSize)</span><br><span class="line">	获取Stream流对象中的前n个元素，返回一个新的stream流对象</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">skip：跳过Stream流中的前n个元素</span><br><span class="line">	Stream&lt;T&gt; skip(long n)</span><br><span class="line">	跳过stream流对象中的前n个元素，返回一个新的stream流对象</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">concat：流合并</span><br><span class="line">	static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;?extends T&gt;b)</span><br><span class="line">	两个流合成一个流</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">collect：Stream流转换成集合</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">dinstinct：元素去重，依赖hashCode和equals方法</span><br><span class="line">	如果是自定义对象类型，需要重写两个方法</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">map：转化流中的数据类型</span><br><span class="line">	Stream&lt;R&gt; map(Function&lt;T，R&gt; mapper)</span><br></pre></td></tr></table></figure>



<p>小练习</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.第一个队伍只要名字为3个字的成员姓名</span><br><span class="line"></span><br><span class="line">2.第一个队伍筛选之后只要前3个人；</span><br><span class="line"></span><br><span class="line">3.第二个队伍只要姓张的成员姓名；</span><br><span class="line"></span><br><span class="line">4.第二个队伍筛选之后不要前2个人；</span><br><span class="line"></span><br><span class="line">5.将两个队伍合并为一个队伍；</span><br><span class="line"></span><br><span class="line">6.打印整个队伍的姓名信息。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; one = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        one.add(<span class="string">&quot;迪丽热巴&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;宋远桥&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;苏星河&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;老子&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;庄子&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;孙子&quot;</span>);</span><br><span class="line">        one.add(<span class="string">&quot;洪七公&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; two = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        two.add(<span class="string">&quot;古力娜扎&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;赵丽颖&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张二狗&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张天爱&quot;</span>);</span><br><span class="line">        two.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stream = one.stream();</span><br><span class="line">        Stream&lt;String&gt; s1 = stream.filter(s -&gt; s.length()==<span class="number">3</span>).limit(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stream1 = two.stream();</span><br><span class="line">        Stream&lt;String&gt; s2 = stream1.filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).skip(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Stream.concat(s1,s2).forEach(s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>代码还可以更恶心</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = one.stream();</span><br><span class="line">Stream&lt;String&gt; stream1 = two.stream();</span><br><span class="line"></span><br><span class="line">Stream.concat(stream.filter(s -&gt; s.length()==3).limit(3),stream1.filter(s -&gt; s.startsWith(&quot;张&quot;)).skip(2)).forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>



<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：引用方法</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line">	1、被引用的方法要写在重写方法内</span><br><span class="line">	2、被引用的方法从参数上，返回值上要和所在重写方法一致，而且引用的方法最好是操作重写方法的参数值的</span><br><span class="line">	3、干掉重写方法的参数： 干掉-&gt;、干掉被引用方法的参数、被引用方法的.改成::</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;三上&quot;</span>,<span class="string">&quot;八下&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Lambda表达式&quot;</span>);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        stream.forEach(s -&gt; System.out.println(s));</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;方法引用&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="对象名引用成员方法"><a href="#对象名引用成员方法" class="headerlink" title="对象名引用成员方法"></a>对象名引用成员方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	对象::成员方法名</span><br><span class="line">	</span><br><span class="line">需求：</span><br><span class="line">	Supplier&lt;T&gt; 接口</span><br><span class="line">	</span><br><span class="line">方法：</span><br><span class="line">	T get()</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Lambda</span></span><br><span class="line">        method(()-&gt; <span class="string">&quot;  abc  &quot;</span>.trim());</span><br><span class="line">        <span class="comment">// 引用方法</span></span><br><span class="line">        method(<span class="string">&quot;  abc  &quot;</span>::trim);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Supplier&lt;String&gt; supplier)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> supplier.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;s = &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="类名引用静态方法"><a href="#类名引用静态方法" class="headerlink" title="类名引用静态方法"></a>类名引用静态方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	类名::静态方法名</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method(()-&gt;Math.random());</span><br><span class="line">        method(Math::random);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Supplier&lt;Double&gt; supplier)</span> &#123;</span><br><span class="line">        <span class="type">Double</span> <span class="variable">aDouble</span> <span class="operator">=</span> supplier.get();</span><br><span class="line">        System.out.println(aDouble);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="类-构造引用"><a href="#类-构造引用" class="headerlink" title="类-构造引用"></a>类-构造引用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	构造方法名::new</span><br><span class="line">	</span><br><span class="line">Function&lt;T, R&gt;接口</span><br><span class="line">	R apply(T t)  用于数据类型转换</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method(s -&gt; <span class="keyword">new</span> <span class="title class_">person</span>(s),<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        method(person::<span class="keyword">new</span>,<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Function&lt;String,person&gt; function, String name )</span> &#123;</span><br><span class="line">        <span class="type">person</span> <span class="variable">person</span> <span class="operator">=</span> function.apply(name);</span><br><span class="line">        System.out.println(<span class="string">&quot;person = &quot;</span> + person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	数组的数据类型[]::new</span><br><span class="line">	int[]::new -&gt; 创建一个int型数组</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, <span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span>[] apply(Integer integer) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[integer];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        method(integer -&gt; <span class="keyword">new</span> <span class="title class_">int</span>[integer],<span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        method(<span class="type">int</span>[]::<span class="keyword">new</span>,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Function&lt;Integer, <span class="type">int</span>[]&gt; function, Integer len)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = function.apply(len);</span><br><span class="line">        System.out.println(<span class="string">&quot;arr = &quot;</span> + arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>jdk10更新了局部变量类型推断，可以想前端一样写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var 变量名 = 值</span><br></pre></td></tr></table></figure>





<p>文本块 jdk15</p>
<p>三引号“”“ ”“” 自动给文本保持格式，不需要手动的&#x2F;n</p>
<p>jdk16  instanceof匹配</p>
<p>instanceof这个关键字是强转时使用的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void method(Animal animal) &#123;</span><br><span class="line"> /*if (animal instanceof Dog)&#123;</span><br><span class="line">     Dog dog =(Dog) animal;</span><br><span class="line">     dog.eat();</span><br><span class="line">     dog.1ookDoor;</span><br><span class="line">     &#125;*/</span><br><span class="line"></span><br><span class="line"> if (animal instanceof Dog dog) &#123;</span><br><span class="line">     dog.eat();</span><br><span class="line">     dog.lookDoor();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需要多给一个变量名，就省略了强转的过程</p>
<p>Record类</p>
<p>是一种全新的类型，本质上是一个final类，同时所有的类型都是final修饰，它会自动编译出get,set,hashCode,toString,以及比较所有属性值的equals。</p>
<p>注意：</p>
<ul>
<li>Record只会有一个全参构造</li>
<li>重写的equals方法比较所以的属性值</li>
<li>可以在Record声明的类中定义静态字段、静态方法或实例方法(非静态成员方法)</li>
<li>不能在Record声明的类中定义实例字段(非静态成员变量)</li>
<li>类不能声明为abstract</li>
<li>不能显式的声明父类，默认父类是java.lang.Record类</li>
<li>因为Record是final类，所以没有子类</li>
</ul>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240727125831744.png" alt="image-20240727125831744"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Test</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="comment">// 不能声明实例变量</span></span><br><span class="line">    <span class="comment">//int i;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 可以声明静态变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* // 不能声明空参构造</span></span><br><span class="line"><span class="comment">    public Test()&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以声明静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以声明非静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method01</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>密封类</p>
<p>密封的类和接口限制其他可能继承或实现它们的其他类或接口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【修饰符】 sealed class 密封类 【extends父类】 【implements父接口】 permits 子类&#123;</span><br><span class="line">&#125;</span><br><span class="line">【修饰符】 sealed interface 接口 【extends父接口们】 permits 实现类&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>密封类使用sealed修饰符</li>
<li>使用permits关键字来指定可以继承或实现该类的类型</li>
<li>一个类继承密封类或实现密封接口，该类必须是sealed、non-sealed、final修饰的</li>
<li>sealed修饰的类或接口必须有子类或实现类</li>
</ul>
</blockquote>
<h3 id="Junit单元测试"><a href="#Junit单元测试" class="headerlink" title="Junit单元测试"></a>Junit单元测试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Junit是单元测试框架，可以替代main方法去执行其他方法</span><br><span class="line">作用：可以单独执行一个方法，测试该方法是否能抛通</span><br><span class="line">注意：Junit是第三方工具</span><br></pre></td></tr></table></figure>



<blockquote>
<p>jar包下载地址</p>
<p><a href="https://github.com/junit-team/junit4/wiki/Download-and-Install">https://github.com/junit-team/junit4/wiki/Download-and-Install</a></p>
<p>配置下载地址</p>
<p><a href="https://repo1.maven.org/maven2/org/hamcrest/hamcrest-core/1.3/">https://repo1.maven.org/maven2/org/hamcrest/hamcrest-core/1.3/</a></p>
</blockquote>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240727212633731.png" alt="image-20240727212633731"></p>
<h4 id="JUnit的注意事项"><a href="#JUnit的注意事项" class="headerlink" title="JUnit的注意事项"></a>JUnit的注意事项</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、@Test不能修饰static方法</span><br><span class="line">2、@Test不能修饰带参数的方法</span><br><span class="line">3、@Test不能修饰带返回值的方法</span><br><span class="line"></span><br><span class="line">这个很好理解测试方法，只测试一个方法，带参数，带返回值就需要进行传参和返回了，就超出了这个方法的范围</span><br></pre></td></tr></table></figure>



<h4 id="相关注解"><a href="#相关注解" class="headerlink" title="相关注解"></a>相关注解</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Before：在@Test之前执行，有多少个@Test执行，@Before就执行多少次 -&gt; 都是用作初始化一些数据</span><br><span class="line"></span><br><span class="line">@After：在@Test之前执行，有多少个@Test执行，@After就执行多少次 -&gt; 用作释放资源</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">还有两个注解</span><br><span class="line">@Beforecass：在@Test之前执行，只执行一次，只能修饰静态方法</span><br><span class="line">@Afterclass：在@Test之后执行，只执行一次，只能修饰静态方法</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240727215416205.png" alt="image-20240727215416205"></p>
<blockquote>
<p>@Test主要是用来测试的，用来代替main方法，分来测试模块的功能。</p>
</blockquote>
<h3 id="类的加载机制"><a href="#类的加载机制" class="headerlink" title="类的加载机制"></a>类的加载机制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、new对象</span><br><span class="line">2、new子类对象（new子类对象先初始化父类）</span><br><span class="line">3、执行main方法</span><br><span class="line">4、调用静态成员</span><br><span class="line">5、反射，创建class对象</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240727221033472.png" alt="image-20240727221033472"></p>
<h4 id="类加载器（了解）ClassLoader"><a href="#类加载器（了解）ClassLoader" class="headerlink" title="类加载器（了解）ClassLoader"></a>类加载器（了解）ClassLoader</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基于jdk8</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.概述：</span><br><span class="line">	在jvm中，负责将本地上的c1ass文件加载到内存的对象ClassLoader</span><br><span class="line"></span><br><span class="line">2.分类：</span><br><span class="line">	BootstrapclasLoader：根类加教器 -&gt; C语言写的，我们是获取不到的</span><br><span class="line">			也称之为引导类加载器，负责Java的核心类加载的</span><br><span class="line">			比如：System，String等</span><br><span class="line">			jre/lib/rt.jar下的类都是核心类</span><br><span class="line">			</span><br><span class="line">	ExtclassLoader：扩展类加载器</span><br><span class="line">			负责jre的扩展目录中的jar包的加载</span><br><span class="line">			在jdk中jre的lib目录下的ext目录</span><br><span class="line">			</span><br><span class="line">	AppclassLoader：系统类加载器</span><br><span class="line">			负责在jvm启动时加载来自java命令的c1ass文件（自定义类），以及classPath环境变量所指定的jar包（第三方jar包）</span><br><span class="line">			</span><br><span class="line">	不同的类加载器负责加载不同的类</span><br><span class="line">	</span><br><span class="line">3.三者的关系（从类加载机制层面）：</span><br><span class="line">	Appc1assLoader的父类加载器是ExtClassLoader</span><br><span class="line">	ExtclassLoader的父类加载器是BootStrapclassLoader</span><br><span class="line">	</span><br><span class="line">	但是：他们从代码级别上来看，没有子父类继承关系-&gt;他们都有一个共同的父类-&gt;ClassLoader</span><br><span class="line">	</span><br><span class="line">4.获取类加载器对象：getclassLoaderQ是class对象中的方法</span><br><span class="line">	类名.class.getclassLoader()</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">5.获取类加教器对象对应的父类加教器</span><br><span class="line">	ClassLoader类中的方法：classLoader</span><br><span class="line">	getParent（）-&gt; 没啥用</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">6.双亲委派（全盘负责委托机制）</span><br><span class="line"></span><br><span class="line">	a.Person类中有一个string</span><br><span class="line">	  Person本身是AppclassLoader加载</span><br><span class="line">	  String是BootStrapclassLoader加较</span><br><span class="line">	  </span><br><span class="line">	b.加载顺序：</span><br><span class="line">	  Person本身是App加载，按道理来说string也是App加载</span><br><span class="line">	  但是App加载String的时候，先问一问Ext，说：Ext你加载这个string吗？</span><br><span class="line">	  Ext说：我不加载，我负贵加载的是扩展类，但是app你别着急，我问问我爹去-&gt;boot</span><br><span class="line">	  Ext说：boot，你加载string吗？</span><br><span class="line">	  boot说：正好我加载核心类，行吧，我加载吧！</span><br><span class="line">	  </span><br><span class="line">	  </span><br><span class="line">7.类加载器的cache（缓存）机制（扩展）：一个类加载到内存之后，缓存中也会保存一份儿，后面如果再使用此类，如果缓存中保存了这个类，就直接返回他，如果没有才加载这个类，下一次如果有其他类在使用的时候就不会重新加载了，直接去缓存中拿，保证了类在内存中的唯一性</span><br><span class="line"></span><br><span class="line">8.所以：类加载器的双亲委派和缓存机制共同造就了加载类的特点：保证了类在内存中的唯一性</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240727222521344.png" alt="image-20240727222521344"></p>
<blockquote>
<p>缓存内有就开始加载，如果没有向上询问，直到boot，如果也没有去规定的目录内寻找，如果没有再向下查找</p>
</blockquote>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.反射概述：解剖c1ass对象的一个技术</span><br><span class="line">2.问题：能解剖c1ass对象的啥呢？</span><br><span class="line">	a.解剖出成员变量：赋值</span><br><span class="line">	b.解剖出成员方法：调用</span><br><span class="line">	c.解剖出构造方法：new对象</span><br><span class="line">	</span><br><span class="line">3.用反射的好处：让代码变的更通用，更灵活</span><br><span class="line"></span><br><span class="line">4.怎么学反射：</span><br><span class="line">	a.将反射看成是一套API来学</span><br><span class="line">	b.通过案例，体会反射的好处</span><br><span class="line">	</span><br><span class="line">5.问题：玩儿反射，最开始的一步是干啥？</span><br><span class="line">	获取class对象</span><br><span class="line">	</span><br><span class="line">6.c1ass对象：c1ass文件对应的对象</span><br><span class="line">	c1ass类：描述class对象的类</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240727223441205.png" alt="image-20240727223441205"></p>
<h4 id="获取class对象"><a href="#获取class对象" class="headerlink" title="获取class对象"></a>获取class对象</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方式一：调用Object中的getClass方法：</span><br><span class="line">	class&lt;?&gt; getClass()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方式二：不管是基本类型还是引用类型，jvm都为其提供了一个静态成员：c1ass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方式三：C1ass类中的静态方法：</span><br><span class="line">	static Class&lt;?&gt; forName(String className)</span><br><span class="line">			className：传递的是类的全限定名（说的很高级，其实就是 包名.类名 ）</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 方式一</span></span><br><span class="line">        <span class="type">person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">person</span>();</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">person</span>&gt; class1 = person.getClass();</span><br><span class="line">        System.out.println(class1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式二</span></span><br><span class="line">        Class&lt;person&gt; class2 = person.class;</span><br><span class="line">        System.out.println(class2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式三</span></span><br><span class="line">        Class&lt;?&gt; class3 = Class.forName(<span class="string">&quot;com.sjjws.h_001.person&quot;</span>);</span><br><span class="line">        System.out.println(class3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240727225026712.png" alt="image-20240727225026712"></p>
<blockquote>
<p>forName是最通用的，因为参数是String，可以和properties文件，通过IO流的一番操作，就可以获取到class对象</p>
<p>类名.class是最常用的，因为方便</p>
</blockquote>
<h4 id="获取构造方法"><a href="#获取构造方法" class="headerlink" title="获取构造方法"></a>获取构造方法</h4><h5 id="获取所有public的构造方法"><a href="#获取所有public的构造方法" class="headerlink" title="获取所有public的构造方法"></a>获取所有public的构造方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class类中的方法：</span><br><span class="line">	Constructor&lt;?&gt;[] getConstructors() -&gt; 获取所有public的构造</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;person&gt; aClass = person.class;</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : aClass.getConstructors()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;constructor = &quot;</span> + constructor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="获取空参构造"><a href="#获取空参构造" class="headerlink" title="获取空参构造"></a>获取空参构造</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取：</span><br><span class="line">Class类中的方法：</span><br><span class="line">	Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) -&gt; 获取指定的public的构造</span><br><span class="line">			parameterTypes：可变参数，可以传递0-多个参数</span><br><span class="line">			</span><br><span class="line">	1、如果获取空参构造，参数不用写</span><br><span class="line">	2、如果获取有参构造：参数写参数类型的class对象</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">调用：</span><br><span class="line">Constructor类中的方法：</span><br><span class="line">	T newInstance(Object...initargs) -&gt; 创建对象</span><br><span class="line">		initargs:传递的是构造方法的实参</span><br><span class="line">		</span><br><span class="line">	a.如果根据无参构造new对象，initargs不写了</span><br><span class="line">	b.如果根据有参构造new对象，initargs传递实参</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        Class&lt;person&gt; aClass =  person.class;</span><br><span class="line">        Constructor&lt;person&gt; constructor = aClass.getConstructor();</span><br><span class="line">        System.out.println(<span class="string">&quot;constructor = &quot;</span> + constructor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        就好比 person person = new person();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">person</span> <span class="variable">person</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;person = &quot;</span> + person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的代码是先获取空参构造的方法，然后再用这个方法来new对象</p>
<p>利用空参new对象，有更简单的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class类中的方法：</span><br><span class="line">	T newInstance() -&gt; 根据空参构造创建对象</span><br><span class="line"></span><br><span class="line">前提：被反射的类中必须有public修饰的空参构造。</span><br><span class="line"></span><br><span class="line">注意：这个方法以及过时了</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="获取有参构造"><a href="#获取有参构造" class="headerlink" title="获取有参构造"></a>获取有参构造</h5><p>和无参构造相差无几</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        Class&lt;person&gt; aClass =  person.class;</span><br><span class="line">        Constructor&lt;person&gt; constructor = aClass.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;constructor = &quot;</span> + constructor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        就好比 person person = new person(&quot;张三&quot;,19);</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">person</span> <span class="variable">person</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;张三&quot;</span>,<span class="number">19</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;person = &quot;</span> + person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="获取私有构造"><a href="#获取私有构造" class="headerlink" title="获取私有构造"></a>获取私有构造</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">constructor&lt;?&gt;[] getDeclaredconstructors() -&gt; 获取所有构造方法，包括private</span><br><span class="line"></span><br><span class="line">onstructor&lt;T&gt; getDeclaredconstructor(类&lt;?&gt;...parameterTypes) -&gt; 获取指定构造，包括private</span><br><span class="line">	parameterTypes：参数类型的class对象</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">获取到的私有构造方法是不能直接使用的，但是反射是流氓啊</span><br><span class="line">Constructor的父类AccessibleObject内有一个方法</span><br><span class="line">	void setAccessible(boolean flag) -&gt; 修改访问权限</span><br><span class="line">			flag为true：解除私有权限</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Class&lt;person&gt; aClass = person.class;</span><br><span class="line">        Constructor&lt;person&gt; constructor = aClass.getDeclaredConstructor(String.class);</span><br><span class="line"></span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">person</span> <span class="variable">person</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="反射成员方法"><a href="#反射成员方法" class="headerlink" title="反射成员方法"></a>反射成员方法</h4><h5 id="获取所有public的成员方法"><a href="#获取所有public的成员方法" class="headerlink" title="获取所有public的成员方法"></a>获取所有public的成员方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class类中的方法：</span><br><span class="line">	Method[] getMethods() -&gt; 获取所有public方法，包括父类中的public方法</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;person&gt; aClass = person.class;</span><br><span class="line">        Method[] methods = aClass.getMethods();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="../图片/image-20240728000014776.png" alt="image-20240728000014776" style="zoom:67%;" />



<h5 id="获取public方法（有参、无参）"><a href="#获取public方法（有参、无参）" class="headerlink" title="获取public方法（有参、无参）"></a>获取public方法（有参、无参）</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class类中的方法：</span><br><span class="line">	Method getMethod(String name,Class&lt;?&gt;...parameterTypes) -&gt; 获取指定的public的成员方法</span><br><span class="line">		name:传递方法名</span><br><span class="line">		parameterTypes:方法参数类型的class对象（因为是存在重载方法这个东西的）</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">调用方法：</span><br><span class="line">Method对象中的方法：</span><br><span class="line">	Object invoke(Object obj, Object... arges)  -&gt; 执行方法</span><br><span class="line">			obj:根据构造new出来的对象</span><br><span class="line">			arges:方法实参 -&gt; 如果有参数直接传</span><br><span class="line">			返回值：Object -&gt; 接收被执行方法的返回值，如果方法没有返回值，不接受</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        <span class="comment">// 获取class对象</span></span><br><span class="line">        Class&lt;person&gt; aClass = person.class;</span><br><span class="line">        <span class="comment">// 迅速new一个对象出来</span></span><br><span class="line">        <span class="type">person</span> <span class="variable">person</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 传递参数，无返回值</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> aClass.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line">        method.invoke(person, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        System.out.println(person);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 带返回值</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">get</span> <span class="operator">=</span> aClass.getMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> get.invoke(person);</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="获取私有方法"><a href="#获取私有方法" class="headerlink" title="获取私有方法"></a>获取私有方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Method[] getDeclaredMethods()  -&gt;  获取所有的成员方法，包括private的</span><br><span class="line"></span><br><span class="line">Method getDeclaredMethod(String name, class&lt;?&gt;... parameterTypes) -&gt; 获取执行成员方法，包括private</span><br><span class="line">		name:传递方法名</span><br><span class="line">		parameterTypes：方法参数类型的class对象</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">解除私有权限：void setAccessible(boolean flag)</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        Class&lt;person&gt; aClass = person.class;</span><br><span class="line">        <span class="type">person</span> <span class="variable">person</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> aClass.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">        method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        method.invoke(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="反射成员变量"><a href="#反射成员变量" class="headerlink" title="反射成员变量"></a>反射成员变量</h4><h5 id="获取所有属性"><a href="#获取所有属性" class="headerlink" title="获取所有属性"></a>获取所有属性</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class类中的方法：</span><br><span class="line">	Field[] getFileds() -&gt; 获取所有public的属性</span><br><span class="line">	</span><br><span class="line">	Field[] getDeclaredFields()  -&gt;  获取所有属性，包括priavte的</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;person&gt; aClass = person.class;</span><br><span class="line">        Field[] fields = aClass.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;field = &quot;</span> + field);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Field[] fields1 = aClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;field = &quot;</span> + field);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="获取指定属性"><a href="#获取指定属性" class="headerlink" title="获取指定属性"></a>获取指定属性</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class类中的方法：</span><br><span class="line">	Field getFiled(String name) -&gt; 获取指定public的属性</span><br><span class="line">	</span><br><span class="line">	Field getDeclaredField(String name)  -&gt;  获取指定属性，包括priavte的</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">Field类中的方法：</span><br><span class="line">	void set(Object obj, Object value) -&gt; 为属性赋值，相当于JavaBean中的set方法</span><br><span class="line">			obj:对象</span><br><span class="line">			value:赋予的值</span><br><span class="line">			</span><br><span class="line">	Object get(Object obj)  -&gt;  获取属性值</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取public成员</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        Class&lt;person&gt; aClass = person.class;</span><br><span class="line">        <span class="type">person</span> <span class="variable">person</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">fields</span> <span class="operator">=</span> aClass.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">        fields.set(person, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> fields.get(person);</span><br><span class="line">        System.out.println(<span class="string">&quot;o = &quot;</span> + o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取、操作私有成员</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo09</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        Class&lt;person&gt; aClass = person.class;</span><br><span class="line">        <span class="type">person</span> <span class="variable">person</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">fields</span> <span class="operator">=</span> aClass.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line">        fields.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        fields.set(person, <span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> fields.get(person);</span><br><span class="line">        System.out.println(<span class="string">&quot;o = &quot;</span> + o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="反射练习"><a href="#反射练习" class="headerlink" title="反射练习"></a>反射练习</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以看到反射操作class对象的方法都不是很简单（相比直接new对象来说），反射的主要作用是编写框架</span><br><span class="line"></span><br><span class="line">public interface 接口名&#123;</span><br><span class="line">	public Employee find()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select id=&quot;find&quot; resultType=&quot;Employee的全限定名&quot;&gt;</span><br><span class="line">	select 列名 from 表名 where 条件</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">根据接口的class对象，创建一个实现类对象，然后通过配置文件中的方法名反射这个方法，invoke执行这个方法</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">练习需求：在配置文件中。配置类的全限定名，以及配置一个方法名，通过解析配置文件，让配置好的方法执行起来</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">步骤：</span><br><span class="line">	1.创建properties配置文件，配置信息</span><br><span class="line">		问题一：配置文件放在那里</span><br><span class="line">			开发完给用户的是out路径下的class文件，将class文件打包，如果配置文件在模块下，out路径下是不会生成这个配置文件的</span><br><span class="line">		解决：将配置文件放到src目录下	</span><br><span class="line">		</span><br><span class="line">		问题二：将配置文件放到src下，out路径下会自动生成配置文件，但是如果我们将来将所有的配置文件都放到src下，那么src下面会显得特别乱</span><br><span class="line">		解决：我们可以单独创建一个文件夹，将所有的配置文件放到此文件夹下，将此文件夹改成资源目录，取名为resources</span><br><span class="line">		</span><br><span class="line">	2.读取配置文件，解析配置文件</span><br><span class="line">		问题一：如果将配置文件放到resources资源目录下，我们怎么读取</span><br><span class="line">			new FileInputstream(&quot;模块名\\resources\\properties文件名&quot;) -&gt; 这样不行，因为out路径下没有resources-&gt;相当于写死了</span><br><span class="line">		</span><br><span class="line">		问题解决：用类加载器</span><br><span class="line">		classLoader  classLoader = 当前类.class.getclassLoader()</span><br><span class="line">		Inputstream in = classLoader.getResourceAsStream(&quot;文件名&quot;)//自动扫描resources下的文件-&gt;可以简单理解为扫描out路径下的配置文件</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	3.根据解析出来的c1assName，创建c1ass对象</span><br><span class="line">	4.根据解析出来的methodName，获取对应的方法</span><br><span class="line">	5.执行方法</span><br></pre></td></tr></table></figure>



<p>配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">className=com.sjjws.aa_kj.Person</span><br><span class="line">methodName=eat</span><br></pre></td></tr></table></figure>



<p>定义方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狠狠干饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1.创建properties集合</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.读取配置文件，解析配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Demo.class.getClassLoader().getResourceAsStream(<span class="string">&quot;student.properties&quot;</span>);</span><br><span class="line">        properties.load(in);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.根据解析出来的c1assName，创建c1ass对象</span></span><br><span class="line">        <span class="comment">//4.根据解析出来的methodName，获取对应的方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取创建class对象</span></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(className);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取相应方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> aClass.getMethod(methodName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.执行方法</span></span><br><span class="line">        method.invoke(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种方法看似很麻烦，但是体现了框架架构思想</p>
</blockquote>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">引用数据类型：</span><br><span class="line">	类 数组 接口 枚举 注解</span><br><span class="line">	</span><br><span class="line">作用：</span><br><span class="line">	说明：对代码进行说明，生成doc文档（API文档）</span><br><span class="line">	检查：老朋友 @Override 检查是否为重写方法、 @FunctionalInterface 检查是否为函数式接口</span><br><span class="line">	分析：对代码进行分析，起到配置文件的作用</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240728104917624.png" alt="image-20240728104917624"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JDK中的注解：</span><br><span class="line">	@override -&gt; 检测此方法是否为重写方法</span><br><span class="line">	@Deprecated -&gt; 提示方法已经过时，不推荐使用调用方法的时候，方法上会有横线，但是能用</span><br><span class="line">	@suppresswarnings -&gt; 消除警告@Suppresswarnings(&quot;a11&quot;)</span><br></pre></td></tr></table></figure>



<h4 id="注解的定义以及属性的定义格式"><a href="#注解的定义以及属性的定义格式" class="headerlink" title="注解的定义以及属性的定义格式"></a>注解的定义以及属性的定义格式</h4><p>注意，这里说的注解属性，其实本质上是抽象方法，但是我们按照属性来理解，好理解，因为到时候使用注解的时候，需要用&#x3D;为其赋值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义：</span><br><span class="line">	public @interface 接口名&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">定义属性（抽象方法）：</span><br><span class="line">	数据类型 属性名() -&gt; 在使用注解的时候为其赋值</span><br><span class="line">	数据类型 属性名() default 值 -&gt;  有默认值，如果需要可以二次赋值</span><br><span class="line">	</span><br><span class="line">注解可以定义的类型：</span><br><span class="line">	1、8种基本数据类型</span><br><span class="line">	2、String类型、class类型、枚举类型、注解类型</span><br><span class="line">	3、以及以上类型的一维数组</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Book &#123;</span><br><span class="line">    String <span class="title function_">bookName</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    String[] author();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">price</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用：</span><br><span class="line">	本质上就是为注解中的属性赋值</span><br><span class="line">	</span><br><span class="line">使用位置：</span><br><span class="line">	在类上使用、在方法上使用、成员变量上使用、局部变量上使用、参数位置使用等</span><br><span class="line">	</span><br><span class="line">使用格式：</span><br><span class="line">	1、@注解名(属性名 = 值...)</span><br><span class="line">	2、如果属性中有数组：</span><br><span class="line">		@注解名(属性名 = &#123;元素1,元素2...&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意事项：</p>
<p>​	1、空注解可以直接使用 -&gt; 空注解就是注解中没有任何的属性</p>
<p>​	2、不同的位置可以使用一样的注解，同一位置不可以</p>
<p>​	3、使用注解时，如果此注解中有属性，注解中的属性一定要赋值，如果有多个属性，用,隔开，如果有数组使用{}</p>
<p>​	4、如果注解中的属性有默认值，那么我们不必要写，也不要重新赋值，反之必须写</p>
<p>​	5、如果注解中只有一个属性，并且属性名为value，那么使用的时候可以不写属性名，只写值</p>
</blockquote>
<h4 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：获取注解中的属性值</span><br><span class="line"></span><br><span class="line">AnnotatedElement接口</span><br><span class="line">	实现类：Accessibleobject，Class，Constructor，Executable，Field，Method，Package，Parameter</span><br><span class="line">	（可以看出这些实现类和反射密切相关）</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">先判断位置上有没有使用指定的注解，如果有，获取指定的注解，获取注解中的属性值</span><br><span class="line">	boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) -&gt; 判断指定位置上有没有指定的注解</span><br><span class="line">	  比如：判断BookShe1f上有没有Book注解</span><br><span class="line">	  	Class bookshelf = Bookshelf.class</span><br><span class="line">	  	bookShelf.isAnnotationPresent(Book.class)</span><br><span class="line">	</span><br><span class="line">	getAnnotation(Class&lt;T&gt; annotationClass) -&gt; 获取指定是注解</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取BookShelf的class对象</span></span><br><span class="line">        Class&lt;BookShelf&gt; bookShelfClass = BookShelf.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断bookShelf上有没有book注解</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> bookShelfClass.isAnnotationPresent(Book.class);</span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断，如果是true，就获取属性值</span></span><br><span class="line">        <span class="keyword">if</span> (b)&#123;</span><br><span class="line">            <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> bookShelfClass.getAnnotation(Book.class);</span><br><span class="line">            System.out.println(book.bookName());</span><br><span class="line">            System.out.println(Arrays.toString(book.author()));</span><br><span class="line">            System.out.println(book.price());</span><br><span class="line">            System.out.println(book.count());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是这个代码并没有获取到，输出 b 输出结果为false</p>
<p>原因是Book注解没有被加载到内存</p>
</blockquote>
<h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概述：元注解就是管理注解的注解</span><br><span class="line"></span><br><span class="line">管理：</span><br><span class="line">	1、控制注解的使用位置</span><br><span class="line">		控制注解是否能在类上使用</span><br><span class="line">		控制注解是否能在方法上使用</span><br><span class="line">		控制注解是否能在构造上使用等</span><br><span class="line">		</span><br><span class="line">	2、控制注解的生命周期（加载位置）</span><br><span class="line">		控制注解是否能在源码中出现</span><br><span class="line">		控制注解能否在class文件中出现</span><br><span class="line">		控制注解能否在内存中出现</span><br><span class="line">		</span><br><span class="line">	3、怎么使用：</span><br><span class="line">		a.@Target：控制注解的使用位置</span><br><span class="line">			属性：ElementType[] value()</span><br><span class="line">				ElementType是一个枚举，里面的成员可以类名直接调用</span><br><span class="line">			ElementType中的成员：</span><br><span class="line">				TYPE：控制注解能使用在类上</span><br><span class="line">				FIELD：控制注解能使用在属性上</span><br><span class="line">				METHOD：控制注解能使用在方法上</span><br><span class="line">				PARAMETER：控制注解能使用在参数上</span><br><span class="line">				CONSTRUCTOR：控制注解能使用在构造上</span><br><span class="line">				LOCAL_VARIABLE：控制注解能使用在局部变量上</span><br><span class="line">				</span><br><span class="line">		不写@Target的情况下哪都能写，如果写了@Target那么就只能按照控制的位置写</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		b.@Retention：控制注解的生命周期（加载位置）</span><br><span class="line">			属性：RetentionPolicy value();</span><br><span class="line">				RetentionPolicy也是枚举</span><br><span class="line">				</span><br><span class="line">			RetentionPolicy中的成员：</span><br><span class="line">				SOURCE：控制注解能在源码中出现-&gt;默认</span><br><span class="line">				CLASS：控制注解能在c1ass文件中出现</span><br><span class="line">				RUNTIME：控制注解能在内存中出现</span><br></pre></td></tr></table></figure>



<p>将Book加载到内存，再次运行就出现了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Book &#123;</span><br><span class="line">    String <span class="title function_">bookName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String[] author();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">price</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240728172518571.png" alt="image-20240728172518571"></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、概述：五大引用数据类型</span><br><span class="line">	类 数组 接口 注解 枚举</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">2、定义：</span><br><span class="line">	public enum 枚举类名&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	所有的枚举类都有一个共同的父类Enum</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">3、定义枚举值：</span><br><span class="line">	特点：</span><br><span class="line">		都是static final，但是定义的时候不要写出来，写出来会报错</span><br><span class="line">		写完所有的枚举值之后，最后加个;</span><br><span class="line">		枚举值的名字大写 -&gt; 开发习惯</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	使用：类名直接调用</span><br><span class="line">	</span><br><span class="line">	注意：每一个枚举值都是当前枚举类的对象</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">4、问题：枚举类中的枚举值都是什么类型？</span><br><span class="line">	本类型</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">5、枚举类中的其他成员：构造</span><br><span class="line">	在枚举类中定义的构造，默认都是private的</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">6、枚举的使用场景：</span><br><span class="line">	表示对象的状态</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240728175705980.png" alt="image-20240728175705980"></p>
<blockquote>
<p>枚举还可以设置值，设置了值的枚举值，相当于进行了一个有参构造</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">state</span> &#123;</span><br><span class="line"> <span class="comment">//static WEIFUKUAN = new state();</span></span><br><span class="line"> WEIFUKUAN(<span class="string">&quot;未付款&quot;</span>),</span><br><span class="line"></span><br><span class="line"> <span class="comment">//static YIFUKUAN = new state();</span></span><br><span class="line"> YIFUKUAN,</span><br><span class="line"></span><br><span class="line"> <span class="comment">//static WEIFAHUO = new state();</span></span><br><span class="line"> WEIFAHUO,</span><br><span class="line"></span><br><span class="line"> <span class="comment">//static YIFAHUO = new state();</span></span><br><span class="line"> YIFAHUO;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"> state(String name)&#123;</span><br><span class="line">     <span class="built_in">this</span>.name = name;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> state()&#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> name;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240728180710086.png" alt="image-20240728180710086"></p>
<p>在后面传入参数，还方便调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">state</span> <span class="variable">state0</span> <span class="operator">=</span> com.sjjws.aa_kj.state.WEIFAHUO;</span><br><span class="line">     System.out.println(state0);</span><br><span class="line">     System.out.println(state0.getName());</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="枚举的方法"><a href="#枚举的方法" class="headerlink" title="枚举的方法"></a>枚举的方法</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String toString()</td>
<td>返回枚举值的名字</td>
</tr>
<tr>
<td>values()</td>
<td>返回所有与的枚举值</td>
</tr>
<tr>
<td>valueof(String str)</td>
<td>将一个字符串转成枚举类型</td>
</tr>
</tbody></table>
<p>注意，valueOf内的字符串必须和定义好的枚举值一模一样，包括大小写，感觉很多此一举啊</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> state.WEIFUKUAN.toString();</span><br><span class="line">        System.out.println(<span class="string">&quot;s = &quot;</span> + s);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        state[] states = state.values();</span><br><span class="line">        <span class="keyword">for</span> (state state : states) &#123;</span><br><span class="line">            System.out.println(state);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">state</span> <span class="variable">s2</span> <span class="operator">=</span> state.valueOf(<span class="string">&quot;YIFAHUO&quot;</span>);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>逆向学习</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>认识Vue3</title>
    <url>/2024/07/13/%E8%AE%A4%E8%AF%86Vue3/</url>
    <content><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p>在vue中</p>
<p>编程语言：JS、TS                           主要是TS</p>
<p>代码风格：组合式API 、 选项式API        官方推荐组合式</p>
<p>生态系统逐渐向Vue3倾斜，主流库和擦火箭都在向Vue3迁移</p>
<span id="more"></span>

<p>这边建议直接下载一个 <code>Hbuilder X</code> ，可以直接创建vue项目，不用准备脚手架，和输入命令</p>
<p>默认使用Vite，是直接准备完成，看哪部分渲染哪部分，更加快捷</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240520204027444.png" alt="image-20240520204027444"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240520204544002.png" alt="image-20240520204544002"></p>
<p>这里的creaApp相当于一个花盆，APP相当于根，第四行相当于把根放进花盆里</p>
<p>index.html内</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240520210332091.png" alt="image-20240520210332091"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240520210551468.png" alt="image-20240520210551468"></p>
<p>总结</p>
<ul>
<li>Vite项目中，index.html 是项目入口文件，在项目最外层</li>
<li>加载 <code>index.html</code> 后，vite解析 <code>&lt;script type=&quot;module&quot; src=&quot;xxx&quot;&gt; </code> 指向 <code>JavaScript</code> </li>
<li>Vue3中是通过 <code>createApp</code> 函数创建一个应用实例</li>
</ul>
<h2 id="引入组件"><a href="#引入组件" class="headerlink" title="引入组件"></a>引入组件</h2><p>如果想要封装组件，可以在components目录下新建一个Vue文件，然后引入使用</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521152100322.png" alt="image-20240521152100322"></p>
<p>三步走</p>
<p>一、import引入</p>
<p>引入组件的路径</p>
<p>二、component引入</p>
<p>将组件名称放入export default中</p>
<p>三、使用方法</p>
<p>如下图：组件名称为 <code>Person</code> 使用是则为 <code>person</code> </p>
<p>如组件名称为 <code>MyComponents</code> 使用时写作 <code>my-components</code></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521152203856.png" alt="image-20240521152203856"></p>
<h2 id="Vue3核心"><a href="#Vue3核心" class="headerlink" title="Vue3核心"></a>Vue3核心</h2><ul>
<li><p>vue2 的 API 设计是 Options（配置）风格的</p>
</li>
<li><p>vue3 的 API 设计是 Composition（组合）风格的</p>
</li>
</ul>
<p>这些框住的都是配置，选项式</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521153927852.png" alt="image-20240521153927852"></p>
<h3 id="Options-API-的弊端"><a href="#Options-API-的弊端" class="headerlink" title="Options API 的弊端"></a>Options API 的弊端</h3><p>Options 类型的 API ，数据、方法、计算属性等，是分散在 <code>data</code>  <code>methods</code>  <code>computed</code> 中的，若想更改需求，需要分别修改 <code>data</code>  <code>methods</code>  <code>computed</code> ，不便于维护和复用</p>
<p>查看效果动画</p>
<p><a href="https://www.bilibili.com/read/cv10685553/?spm_id_from=333.999.0.0">https://www.bilibili.com/read/cv10685553/?spm_id_from=333.999.0.0</a></p>
<img src="../图片/image-20240521160504513.png" alt="image-20240521160504513" style="zoom:50%;" />

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521160547233.png" alt="image-20240521160547233"></p>
<h3 id="Composition-API-的优势"><a href="#Composition-API-的优势" class="headerlink" title="Composition API 的优势"></a>Composition API 的优势</h3><p>用函数的方式，更加优雅的组织代码，让相关功能的代码更加有序的组织在一起。将数据、方法、监视等组合在一起</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521160616293.png" alt="image-20240521160616293"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521160637568.png" alt="image-20240521160637568"></p>
<h3 id="拉开序幕的setup"><a href="#拉开序幕的setup" class="headerlink" title="拉开序幕的setup"></a>拉开序幕的setup</h3><h4 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h4><p>setup中的this是undefined，不要尝试在setup中写this.xxx，Vue3在尝试弱化this</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521162756473.png" alt="image-20240521162756473"></p>
<p><strong>注意看注释</strong></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521162917455.png" alt="image-20240521162917455"></p>
<h4 id="setup返回值"><a href="#setup返回值" class="headerlink" title="setup返回值"></a>setup返回值</h4><p>上图的return就是一个返回值</p>
<p>setup的返回值也可以是一个渲染函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return () =&gt; 是一个箭头函数，百度一下即可</span><br></pre></td></tr></table></figure>

<p>通过这个渲染函数，将哈哈渲染到页面中去了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521163256642.png" alt="image-20240521163256642"></p>
<h4 id="setup与Opyions-API-的关系"><a href="#setup与Opyions-API-的关系" class="headerlink" title="setup与Opyions API 的关系"></a>setup与Opyions API 的关系</h4><p>setup可以和data、methods共存，注意一下细节，setup是先执行的，也就是说，data是可以读取到setup的数据的</p>
<p>原写法可以读取到新写法的数据，新写法读取不到旧写法（data）的数据</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521165113768.png" alt="image-20240521165113768"></p>
<h4 id="setup语法糖"><a href="#setup语法糖" class="headerlink" title="setup语法糖"></a>setup语法糖</h4><p><img src="/../%E5%9B%BE%E7%89%87/image-20240521171120014.png" alt="image-20240521171120014"></p>
<p>这两个script同时存在很正常，第一个script仍然有存在的必要，因为需要export名称，如果文件名和组件名相同的话也可以不写</p>
<p>用以下方法可以只写一个script但是仍然可以定义组件名</p>
<p>终端下载插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i vite-plugin-vue-setup-extend -D</span><br></pre></td></tr></table></figure>



<p>vite.config.js中引入</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521172728045.png" alt="image-20240521172728045"></p>
<p>在文件中的script中输入name</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521172651664.png" alt="image-20240521172651664"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521172430585.png" alt="image-20240521172430585"></p>
<h3 id="响应式数据"><a href="#响应式数据" class="headerlink" title="响应式数据"></a>响应式数据</h3><p>Vue2的数据在data中就是响应式数据，但是Vue3没有data，他的响应式需要通过其他的方式</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521200546270.png" alt="image-20240521200546270"></p>
<h4 id="ref创建基本类型的响应式"><a href="#ref创建基本类型的响应式" class="headerlink" title="ref创建基本类型的响应式"></a>ref创建基本类型的响应式</h4><p><img src="/../%E5%9B%BE%E7%89%87/image-20240521201837488.png" alt="image-20240521201837488"></p>
<p>这个实例对象是可以改变的，内的数据只看无下划线部分的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521201324842.png" alt="image-20240521201324842"></p>
<p>这里需要更改一下方法为name.value但是前端仍为不需要更改，其自动选定value</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521201438804.png" alt="image-20240521201438804"></p>
<h4 id="reactive创建对象类型的响应式"><a href="#reactive创建对象类型的响应式" class="headerlink" title="reactive创建对象类型的响应式"></a>reactive创建对象类型的响应式</h4><p>打印出来的数据，数据在target中</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521203519086.png" alt="image-20240521203519086"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521212701383.png" alt="image-20240521212701383"></p>
<h4 id="ref创建对象类型响应式数据"><a href="#ref创建对象类型响应式数据" class="headerlink" title="ref创建对象类型响应式数据"></a>ref创建对象类型响应式数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ref &gt;&gt;&gt;  可以定义基本类型、对象类型的响应式数据</span><br><span class="line">reactive &gt;&gt;&gt; 只能定义对象类型的响应式数据</span><br></pre></td></tr></table></figure>



<p>ref定义响应式数据，只需要在调用对象的时候加一个value即可正常调用</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521213448544.png" alt="image-20240521213448544"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240521213820263.png" alt="image-20240521213820263"></p>
<h4 id="ref对比reactive"><a href="#ref对比reactive" class="headerlink" title="ref对比reactive"></a>ref对比reactive</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">////从宏观角度来看</span><br><span class="line">1、ref用来定义：基本类型数据、对象类型数据</span><br><span class="line">2、reactive用来定义：对象类型数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">////区别</span><br><span class="line">1、ref创建变量必须使用 .value （可以使用 volar 插件自动添加 .value ）</span><br><span class="line">2、reactive重新分配一个新对象，会失去响应式 （可以使用 Object.assign 去整体替换）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">////使用原则</span><br><span class="line">1、若需要一个基本类型的响应式数据，必须使用ref</span><br><span class="line">2、若需要一个响应式对象，层级不深，ref、reactive 都可以</span><br><span class="line">3、若需要一个响应式对象，且层级很深，推荐使用reactive</span><br></pre></td></tr></table></figure>



<p>volar插件在Hbuilder X中没有找到，VSCode中有</p>
<p>reactive有一个局限性，无法被整体替代</p>
<p>解决方法</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240522152618838.png" alt="image-20240522152618838"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">car = &#123;brand:&#x27;雅迪&#x27;,price:&#x27;1&#x27;&#125;</span><br><span class="line">car = reactive(&#123;brand:&#x27;雅迪&#x27;,price:&#x27;1&#x27;&#125;)</span><br><span class="line">//这么写页面是不会更新的</span><br></pre></td></tr></table></figure>



<p>如果是定义的ref对象数据，就可以直接整体替换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">car.value = &#123;brand:&#x27;雅迪&#x27;,price:&#x27;1&#x27;&#125;</span><br><span class="line">//页面会更新渲染</span><br></pre></td></tr></table></figure>



<p>我的理解在于，ref定义的一个对象，数据在value中，更改整个value，仍然是在响应式数据内更改，而reactive定义的对象，如果要整体替换的话就不再是响应式的数据，虽然数据成功更改了，但是无法在页面显示，使用Object.assgin()算是巧妙的保留了reactive的响应式，在更新数据之后更新到页面。</p>
<p>简单来说捏，ref整体替换相当于换了个女朋友，reactive的替换相当于女朋友换了身衣服</p>
<h4 id="toRefs和toRef"><a href="#toRefs和toRef" class="headerlink" title="toRefs和toRef"></a>toRefs和toRef</h4><p>举个例子</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240522162105083.png" alt="image-20240522162105083"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240522162339468.png" alt="image-20240522162339468"></p>
<p>通过toRefs可以将reactive解构的数据变为响应式数据，通过输出可以发现，更改数据的时候，<strong>content.name的内容也发生了改变</strong></p>
<p>说明这里解构出来的name是和content.name相关联的，所以前端渲染写name或者conten.name都是可以的。非常nb。</p>
<p><strong>toRefs接收一个有reactive定义的响应式对象，将响应式对象的每一组key value都拿出来，形成一个新的对象，对象中有值，但是这个值是和原响应式相关联的，非常有作用</strong></p>
<p>toRef看名字知道和toRefs的关系，toRef是将响应式数据内的一个变量拿出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let name =toRef(content,&#x27;name&#x27;)</span><br></pre></td></tr></table></figure>

<p>作用和toRefs相同</p>
<h4 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性"></a>computed计算属性</h4><p>写一个输入框</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240522164255754.png" alt="image-20240522164255754"></p>
<p>使用v-model:value可以实现双向绑定，value可以省略</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240522164545945.png" alt="image-20240522164545945"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240522164457116.png" alt="image-20240522164457116"></p>
<p>虽然，可以直接把数据拿过来用，但是如果有别的需求的话，代码将变得复杂</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240522164839272.png" alt="image-20240522164839272"></p>
<p>如：姓名为英文，我需要首字母大写</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240522165326461.png" alt="image-20240522165326461"></p>
<p>很不优雅，把他移到后端</p>
<p>这个时候需要一个computer计算属性，computer有一个属性，只要计算所依赖的数据发生变化就重新计算</p>
<p>Vue2中使用computer是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        computer : &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">//computer在Vue2中是一个配置项，在Vue3则发生改变</span><br></pre></td></tr></table></figure>



<p>Vue3</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240522170439226.png" alt="image-20240522170439226"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240522171227394.png" alt="image-20240522171227394"></p>
<p>上图定义的fullName是一个计算属性，且是<strong>只读</strong>的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240522171917700.png" alt="image-20240522171917700"></p>
<p>修改一下试试</p>
<p>可以看到这是一个响应式数据</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240522172322486.png" alt="image-20240522172322486"></p>
<p>点击后页面也没有什么变化，这里有个bug，懒得换截图了，fullName.value 点击后数据不会更改</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240522172550613.png" alt="image-20240522172550613"></p>
<p>写一个可以改变的computer，get() get 到的是自己输入的只读，set() set是通过点击事件出发更改，然后将数据解构，再去 get 计算的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240522173705139.png" alt="image-20240522173705139"></p>
<h4 id="如何应用到微信小程序"><a href="#如何应用到微信小程序" class="headerlink" title="如何应用到微信小程序"></a>如何应用到微信小程序</h4><p>我的思考：</p>
<p>我认为上面的set方法严格来说也不算是改变了计算结果，而是通过改变计算的两个数据，引起computed重新计算而已，这个功能在微信小程序中也可以复现</p>
<p><strong>简单说一下原理：微信小程序中并没有直接的API写法，需要npm一个组件，然后再自己封装一个component页面组件，然后调用</strong></p>
<h5 id="首先：引入组件"><a href="#首先：引入组件" class="headerlink" title="首先：引入组件"></a>首先：引入组件</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install mobx-miniprogram mobx-miniprogram-bindings</span><br><span class="line">//使用npm引入mobx-miniprogram和mobx-miniprogram-bindings两个组件到微信小程序，然后构建npm（我成功的时候是引入到了page的同级目录下）</span><br></pre></td></tr></table></figure>



<p>简单介绍一下组件</p>
<ul>
<li><code>mobx-miniprogram</code> 的作用：创建 <code>Store</code> 对象，用于存储应用的数据</li>
<li><code>mobx-miniprogram-bindings</code> 的作用：将状态和组件、页面进行绑定关联，从而在组件和页面中操作数据</li>
</ul>
<h5 id="其次：封装组件"><a href="#其次：封装组件" class="headerlink" title="其次：封装组件"></a>其次：封装组件</h5><p>这一步需要在page的同级目录下创建一个component文件夹，因为是.js文件内不是 <code>page(&#123;&#125;)</code> 而是 <code>Compontent(&#123;&#125;)</code> </p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240523212900937.png" alt="image-20240523212900937"></p>
<p>注意检查一下json文件中是否有 <code>&quot;component&quot;: true,</code></p>
<p>然后</p>
<p>在 <code>numstore/numstore.js</code> 中创建一个 Store 对象，来储存数据，函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* compontents/numstore/numstore.js */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; observable, action, set &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-miniprogram&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 observable 创建一个被监测的对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> numStore = <span class="title function_">observable</span>(&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建应用状态</span></span><br><span class="line">  <span class="attr">numA</span>: <span class="string">&#x27;zhang&#x27;</span>,</span><br><span class="line">  <span class="attr">numB</span>: <span class="string">&#x27;san&#x27;</span>,</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 使用 action 更新 numA 以及 numB</span></span><br><span class="line">  <span class="attr">update</span>: <span class="title function_">action</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">numA</span>+=<span class="number">1</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">numB</span>+=<span class="number">1</span></span><br><span class="line">  &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="attr">changesum</span>: <span class="title function_">action</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">sum</span> = <span class="string">&#x27;li-si&#x27;</span></span><br><span class="line">  &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算属性，使用 get 修饰符，</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">sum</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">numA</span> + <span class="variable language_">this</span>.<span class="property">numB</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">sum</span>(<span class="params">VaL</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> [val1,val2] = <span class="title class_">VaL</span>.<span class="title function_">split</span>(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(set,val2,val1)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">numA</span> = val1</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">numB</span> = val2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240523214058666.png" alt="image-20240523214058666"></p>
<p>注意蓝字是问号，我并没有真的去尝试，因为感觉很麻烦，封装着用呗，蛮好的</p>
<h5 id="然后：使用组件"><a href="#然后：使用组件" class="headerlink" title="然后：使用组件"></a>然后：使用组件</h5><p>在要引用组件的页面引用 <code>mobx-miniprogram-bindings</code> </p>
<p>如果需要 Page 或者 Component 中对共享的数据进行读取、更新操作，需要使用 mobx-miniprogram-bindings </p>
<p>mobx-miniprogram-bindings 的作用就是将 Store 和 页面或组件进行绑定关联</p>
<p>如果需要在组件中使用状态，需要 mobx-miniprogram-bindings 库中导入 ComponentWithstore 方法</p>
<p>在使用时：需要将 &#x3D;&#x3D;component 方法替换成 Componentwithstore 方法&#x3D;&#x3D;，原本组件配置项也需要写到该方法中,在替换以后，就会新增一个&#x3D;&#x3D;storeBindings&#x3D;&#x3D; 配置项，配置项常用的属性有以下三个：</p>
<ul>
<li>store：指定要绑定的store对象，这里是绑定的封装组件的位置</li>
<li>fields：指定要绑定的data字段，这里的字段，是封装组件内的字段，而且绑定后，不需要在index中的data再进行定义，直接再前端就可以使用拿到数据</li>
<li>actions：指定需要映射的 action 方法，之前封装组件时，引用了action方法，而且在定义函数时也写到了action，这里只需要写需要用到的方法名，即可从封装的组件内获取到对应方法，直接在前端使用即可</li>
</ul>
<p>以为大部分组件被封装起来了，在index页面也就没什么好说的了，只需要注意一下storeBindings这个配置项获取方法即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* pages/index/index.js */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ComponentWithStore</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-miniprogram-bindings&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; numStore &#125; <span class="keyword">from</span> <span class="string">&#x27;../../components/store/numstore&#x27;</span></span><br><span class="line"><span class="comment">//两行import分别引入mobx-miniprogram-bindings组件和刚刚封装的numstore组件</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">ComponentWithStore</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">someData</span>: <span class="string">&#x27;...&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">storeBindings</span>: &#123;</span><br><span class="line">    <span class="attr">store</span>: numStore,</span><br><span class="line">    <span class="attr">fields</span>: [<span class="string">&#x27;numA&#x27;</span>, <span class="string">&#x27;numB&#x27;</span>, <span class="string">&#x27;sum&#x27;</span>],</span><br><span class="line">    <span class="attr">actions</span>: [<span class="string">&#x27;update&#x27;</span>,<span class="string">&#x27;changesum&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果原页面有需要新定义的方法，只需要在methods中定义，参考vue2</p>
<h5 id="最后：前端渲染"><a href="#最后：前端渲染" class="headerlink" title="最后：前端渲染"></a>最后：前端渲染</h5><p>写个丑陋的前端渲染一下</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240523215936991.png" alt="image-20240523215936991"></p>
<p>掌握了这些东西，可以尝试一下弄计算属性了</p>
<p>引入组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install miniprogram-computed</span><br></pre></td></tr></table></figure>



<p>开始使用组件复现计算属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// component.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入 miniprogram-computed</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ComponentWithComputed</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;miniprogram-computed&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">ComponentWithComputed</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="title function_">total</span>(<span class="params">data</span>) &#123;</span><br><span class="line">      <span class="comment">// 注意： </span></span><br><span class="line">      <span class="comment">// computed 函数中不能访问 this ，只有 data 对象可供访问</span></span><br><span class="line">      <span class="comment">// 这个函数的返回值会被设置到 this.data.sum 字段中</span></span><br><span class="line">      <span class="comment">// 计算属性具有缓存，计算属性使用多次，但是计算属性方法只会执行一次</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;~~~~~&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> data.<span class="property">a</span> + data.<span class="property">b</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">     <span class="attr">change</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">         <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">             numA : <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">numA</span> + <span class="number">1</span></span><br><span class="line">         &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>前端吓唬写一下，达到计算属性目的</p>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>监视，谁谁谁变了，我要怎样怎样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue3中的watch只能监视以下四种数据：</span><br><span class="line"></span><br><span class="line">1、ref 定义的数据</span><br><span class="line">2、reactive 定义的数据</span><br><span class="line">3、函数返回一个值（ getter函数 ）</span><br><span class="line">4、一个包含上述内容的数组</span><br></pre></td></tr></table></figure>



<h4 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h4><p>监听 ref 定义的数据</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240522210655285.png" alt="image-20240522210655285"></p>
<p>在Vue3中，watch函数返回一个停止监听器的函数，因此定义的stopWatch实际上是一个函数，当呢调用他是，他会停止对sum响应式数据的监听</p>
<h4 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h4><p>监听ref定义的【对象类型】数据：直接写数据名，监听的是对象的【地址值】，若想监视对象内部的数据，要开启深度监视。</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240524105415300.png" alt="image-20240524105415300"></p>
<p>deep开启深度监视</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240524111542504.png" alt="image-20240524111542504"></p>
<p>为了帮助理解可以当个比方</p>
<p>更改地址值相当于搬家，可以找到newValue和oldValue，更改属性相当于家里换家具，console时已经更换完了，获取到的地址值是同一个，看到的数据也是一样的</p>
<h4 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h4><p>监视reactive定义的【对象类型】数据，且默认开启了深度监视</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240524143721719.png" alt="image-20240524143721719"></p>
<h4 id="情况四"><a href="#情况四" class="headerlink" title="情况四"></a>情况四</h4><p>监视ref或者reactive定义的【对象类型】数据中的某个属性</p>
<p>注意点如下</p>
<ul>
<li>若该属性不是【对象类型】，需要写成函数形式</li>
<li>若该属性仍然是【对象类型】，可以直接编，也可以写成函数，不过建议写成函数</li>
</ul>
<p>监视对象类型中的某个基本类型数据，写成函数式</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240524153323683.png" alt="image-20240524153323683"></p>
<p>蓝字错误，写为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">()=&gt;person.name</span><br></pre></td></tr></table></figure>





<p>监视对象类型中的某个对象类型数据，可以直接写（但是有问题），建议写成函数式</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240524154850969.png" alt="image-20240524154850969"></p>
<p>函数式</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240524155233716.png" alt="image-20240524155233716"></p>
<p>总结，如果要侦听对象内的某个属性，无脑函数，对象类型数据在加上一个deep</p>
<h4 id="情况五"><a href="#情况五" class="headerlink" title="情况五"></a>情况五</h4><p>监视上述的多个数据</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240524160732396.png" alt="image-20240524160732396"></p>
<h4 id="如何应用到微信小程序-1"><a href="#如何应用到微信小程序-1" class="headerlink" title="如何应用到微信小程序"></a>如何应用到微信小程序</h4><p>自己的话：</p>
<p>使用和computed同一个组件引入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ComponentWithComputed</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;miniprogram-computed&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">ComponentWithComputed</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="attr">b</span>:<span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">computed</span>: &#123;</span><br><span class="line">        <span class="title function_">total</span>(<span class="params">data</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> data.<span class="property">a</span> + data.<span class="property">b</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">watch</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;a,b&#x27;</span>:<span class="keyword">function</span> (<span class="params">a,b</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">                <span class="attr">total</span>: a + b</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="title function_">updateDate</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">                <span class="attr">a</span>:<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">a</span> + <span class="number">1</span>,</span><br><span class="line">                <span class="attr">b</span>:<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">b</span> + <span class="number">1</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>





<h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h3><p>官网描述：立即运行一个函数，同时响应式地追踪其依赖，并在依赖更新时重新执行该函数</p>
<p><code>watch</code> 对比 <code>watchEffect</code> </p>
<ul>
<li>都能监听响应式数据的变化，不同的是监听数据变化的方式不同</li>
<li><code>watch</code> ：要明确指出监视的数据</li>
<li><code>watchEffect</code> ：不用明确指出监视的数据（函数中用到哪些属性，就监视哪些属性）</li>
</ul>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240525102510968.png" alt="image-20240525102510968"></p>
<h3 id="标签的ref属性"><a href="#标签的ref属性" class="headerlink" title="标签的ref属性"></a>标签的ref属性</h3><p><img src="/../%E5%9B%BE%E7%89%87/image-20240525105645472.png" alt="image-20240525105645472"></p>
<p>这种查询id的方法不建议使用，因为id是不可重复的，id取名难，一旦重复了不好找错</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240525114656049.png" alt="image-20240525114656049"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240525115912353.png" alt="image-20240525115912353"></p>
<p>上方这些东西是在HTML的标签上写的ref，如果在组件标签上写ref就有事了</p>
<p>&#x3D;&#x3D;二编&#x3D;&#x3D;：这里的截图有点含糊，在App.vue中给person逐渐添加了一个ref标签，然后点击打印标签的value，但是发现可以打印出来，但是看不到数据，如果想要看到数据，需要在person组件中添加defineExpose，指定可以获取到的变量名称。而且这个defineExpose可以不引入，因为其是宏函数，宏函数在Vue3内不引用也可以使用</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240525121116370.png" alt="image-20240525121116370"></p>
<p>总结：ref用在普通的DOM标签上，获取的是DOM节点；用在组件标签上，获取的是实例对象</p>
<p>尝试在小程序中实现，发现小程序中虽然有这种写法的提示词，但是并不支持这种查询，因为这是web的API</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wx.<span class="title function_">createSelectorQuery</span>().<span class="title function_">select</span>(<span class="string">&#x27;.title&#x27;</span>).<span class="title function_">boundingClientRect</span>(<span class="keyword">function</span>(<span class="params">rect</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(rect)</span><br><span class="line">        &#125;).<span class="title function_">exec</span>()</span><br></pre></td></tr></table></figure>





<h3 id="TS中的接口、泛型、自定义类型"><a href="#TS中的接口、泛型、自定义类型" class="headerlink" title="TS中的接口、泛型、自定义类型"></a>TS中的接口、泛型、自定义类型</h3><p>先看一下TS文件</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240525195139100.png" alt="image-20240525195139100"></p>
<p>结合看一下</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240525194601451.png" alt="image-20240525194601451"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240525200151911.png" alt="image-20240525200151911"></p>
<p>定义接口时 <code>？</code> 表示可选</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240525200436120.png" alt="image-20240525200436120"></p>
<h3 id="props的使用"><a href="#props的使用" class="headerlink" title="props的使用"></a>props的使用</h3><p>接受父页面的传参</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240525201909744.png" alt="image-20240525201909744"></p>
<p>简单介绍一下Vue中的属性问题</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240525203322432.png" alt="image-20240525203322432"></p>
<p>简单看一下for循环吧，和小程序有点不一样</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240525204531540.png" alt="image-20240525204531540"></p>
<p>限制类型+限制必要性</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240525210047384.png" alt="image-20240525210047384"></p>
<p>指定默认值</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240525211104015.png" alt="image-20240525211104015"></p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Vue组件实例在创建时要经历一系列的初始化步骤，在此过程中Vue在合适时机，调用特定的函数，从而让开发者有机会在特定的时期运行自己的代码。</p>
<p>生命周期、生命周期函数、生命周期钩子</p>
<p>组件的一生：&#x3D;&#x3D;创建、挂载、更新、销毁&#x3D;&#x3D;</p>
<ul>
<li>创建————调用特定的函数（created）</li>
<li>挂载————调用特定的函数（mounted）</li>
<li>更新</li>
<li>销毁</li>
</ul>
<h4 id="Vue2的生命周期"><a href="#Vue2的生命周期" class="headerlink" title="Vue2的生命周期"></a>Vue2的生命周期</h4><p>不包括路由的话是有八个生命周期钩子，但是真实情况是大于八个的</p>
<ul>
<li>创建——（创建前 beforeCreate，创建完毕 Created）</li>
<li>挂载——（挂载前 beforeMount，挂载完毕 Mounted）</li>
<li>更新——（更新前 beforeUpdate，更新完毕 Updated）</li>
<li>销毁——（销毁前 beforeUnmount，销毁完毕 Unmounted）</li>
</ul>
<p>因为我的Hbuilder X没有成功运行Vue2，这里不做图片演示，只有文字说明，创建和挂载组件是只能执行一次的，但是可以更新很多次，如果想要看销毁的话，可以在App.vue中使用</p>
<p>这里解释了一下v-if和v-show的区别</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240525222800323.png" alt="image-20240525222800323"></p>
<h4 id="Vue3的生命周期"><a href="#Vue3的生命周期" class="headerlink" title="Vue3的生命周期"></a>Vue3的生命周期</h4><ul>
<li>创建——（创建 setup）</li>
<li>挂载——（挂载前 onBeforeMount，挂载完毕 onMounted）</li>
<li>更新——（更新前 onBeforeUpdate，更新完毕 onUpdated）</li>
<li>销毁——（销毁前 onBeforeUnmount，销毁完毕 onUnmounted）</li>
</ul>
<p>Vue3常用的钩子挂在完毕、更新完毕、卸载之前</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240526093208019.png" alt="image-20240526093208019"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240526093444459.png" alt="image-20240526093444459"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240526094106548.png" alt="image-20240526094106548"></p>
<p>App.vue的挂载要在person组件的创建之前，很好理解吧</p>
<h4 id="补课微信小程序生命周期"><a href="#补课微信小程序生命周期" class="headerlink" title="补课微信小程序生命周期"></a>补课微信小程序生命周期</h4><p>小程序从启动到销毁的过程</p>
<p>一个小程序完整的生命周期由 &#x3D;&#x3D;应用生命周期&#x3D;&#x3D;、&#x3D;&#x3D;页面生命周期&#x3D;&#x3D; 和 &#x3D;&#x3D;组件生命周期&#x3D;&#x3D; 三部分组成的</p>
<h5 id="应用生命周期"><a href="#应用生命周期" class="headerlink" title="应用生命周期"></a>应用生命周期</h5><p>应用生命周期函数需要在app.js文件的App()方法中进行定义，App()方法必须在app.js中进行调用，主要用来注册小程序</p>
<p>应用生命周期函数由 <code>onLaunch</code> <code>onShow</code> <code>onHide</code> 三个函数组成</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240526102014503.png" alt="image-20240526102014503"></p>
<h5 id="页面生命周期"><a href="#页面生命周期" class="headerlink" title="页面生命周期"></a>页面生命周期</h5><p>访问页面——onLoad（监听页面加载）——onShow（监听初次渲染完成）——onUnload（监听页面卸载）</p>
<p>注意跳转到其他页面是是否关闭本页面，不同的路由，再次返会后，触发的生命周期函数不同，自己get一下</p>
<p>补充一个细节</p>
<ul>
<li>tabber页面之间的跳转并不会销毁页面</li>
<li>如果是左上角的返回键，返回上一个页面，会销毁当前页面</li>
</ul>
<p>之所以补课微信小程序的生命周期是因为，当时看课没有这个，其实也不是很难，平时开发的时候多少也都了解了一下</p>
<h5 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h5><p>组件的生命周期函数需要在 <code>lifetimes</code> 字段内进行声明</p>
<p>组件的生命周期函数有五个：<code>created</code> <code>attached</code> <code>ready</code> <code>moved</code> <code>detached</code></p>
<ul>
<li>组件创建完毕——created</li>
<li>组件解析完成，挂载到页面后——attached</li>
<li>组件被销毁——detached</li>
</ul>
<p>组件的生命周期主要用于component自定义组件，因为component自定义组件不太了解，先按下不表</p>
<p>但是一下原生组件，如view是没有生命周期的，如果view在组件内，其生命周期会受到外在组件的影响</p>
<h3 id="自定义Hooks"><a href="#自定义Hooks" class="headerlink" title="自定义Hooks"></a>自定义Hooks</h3><p>hooks的命名规范 <code>useXxxx</code></p>
<p>先写一个获取狗图片的功能，这个网站，每次打开获取到的狗都不同，利用这个来写</p>
<p><a href="https://dog.ceo/api/breed/pembroke/images/random">https://dog.ceo/api/breed/pembroke/images/random</a></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240526153051669.png" alt="image-20240526153051669"></p>
<p>现在解决蓝字问题，真正扣题了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240526154703753.png" alt="image-20240526154703753"></p>
<h2 id="路由（route）"><a href="#路由（route）" class="headerlink" title="路由（route）"></a>路由（route）</h2><ul>
<li>路由就是一组 &#x3D;&#x3D;key、value&#x3D;&#x3D; 的对应关系</li>
<li>多个路由，需要经过 &#x3D;&#x3D;路由器&#x3D;&#x3D; 的管理</li>
</ul>
<p>前端路由可以实现 SPA（单页面） 应用，从始至终只有一个HTML，如果这个HTML还想实现炫酷的切换，这个时候就要用到路由了</p>
<p>SPA一般有一个左边的导航区，和右边的展示区，点击左边导航区的内容展示区发生相应的变化，且页面不抖动</p>
<p>原理：</p>
<p>点击某个导航项时，上方路径发生变化，然后被路由器监视到变化，然会路由器进行规则匹配，如果匹配成功，组件展示在展示区，重新匹配后，将原组件卸载，挂载新匹配的组件</p>
<p>&#x3D;&#x3D;路径至关重要，如果不能引起路径的变化，路由器无法变化&#x3D;&#x3D;</p>
<h3 id="写一个路由"><a href="#写一个路由" class="headerlink" title="写一个路由"></a>写一个路由</h3><p><strong>写路由要做的事</strong></p>
<ol>
<li>导航区、展示区</li>
<li>请来路由器</li>
<li>制定路由的具体规则（什么路径对应什么组件）</li>
<li>形成一个一个的【???.vue】</li>
</ol>
<p>一、导航区、展示区</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240526165939915.png" alt="image-20240526165939915"></p>
<p>二、请来路由器</p>
<p>安装路由器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i vue-router</span><br></pre></td></tr></table></figure>

<p>在Vue3的环境中，不用加router的版本号，用最新的即可</p>
<p>创建，使用路由器</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240526171219169.png" alt="image-20240526171219169"></p>
<p>写完这个这里多了应该routes</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240526171740303.png" alt="image-20240526171740303"></p>
<p>三、</p>
<p>三四一起写</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240526173847185.png" alt="image-20240526173847185"></p>
<h3 id="两个注意点"><a href="#两个注意点" class="headerlink" title="两个注意点"></a>两个注意点</h3><ol>
<li>路由组件通常放在 <code>pages</code> 或者 <code>views</code> 文件夹，一般组件通常放在 <code>components</code> 文件夹</li>
<li>通过点击导航，视觉效果上消失的路由组件，是被卸载了的，需要的时候再去挂载</li>
</ol>
<p>区分路由组件和一般组件：如果有一个 Demo.vue </p>
<p>一般组件：亲手写标签出来 <code>&lt;demo&gt;&lt;/demo&gt;</code></p>
<p>路由组件：靠路由的规则渲染出来的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">routes:[</span><br><span class="line">    &#123;path:&#x27;/demo&#x27; , components:Demo&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>





<h3 id="路由器的工作模式"><a href="#路由器的工作模式" class="headerlink" title="路由器的工作模式"></a>路由器的工作模式</h3><p>一般来说给用户使用的要考虑美观需要使用history模式，后台管理使用hash</p>
<h4 id="history模式"><a href="#history模式" class="headerlink" title="history模式"></a>history模式</h4><ul>
<li>优点：URL更加美观，不带有 <code>#</code> ，更接近传统网站的URL</li>
<li>缺点：后期项目上线，&#x3D;&#x3D;需要服务器配合处理路径问题&#x3D;&#x3D;，否则刷新会有404错误</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//写法</span><br><span class="line">Vue2：mode:&#x27;history&#x27;</span><br><span class="line">Vue3：</span><br><span class="line">const router = createRouter(&#123;</span><br><span class="line">    history:createWebHistory()</span><br><span class="line">    router:[]</span><br><span class="line">&#125;)</span><br><span class="line">React：BrowserRouter</span><br></pre></td></tr></table></figure>



<h4 id="hash模式"><a href="#hash模式" class="headerlink" title="hash模式"></a>hash模式</h4><ul>
<li>优点：兼容性更好，因为不需要服务器端处理路径</li>
<li>缺点：URL带有 <code>#</code> 不太美观，且在 <code>SEO</code> 优化方面相对较差</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//别忘了引用</span><br><span class="line">const router = createRouter(&#123;</span><br><span class="line">    history:createWebHashHistory()</span><br><span class="line">    /****/</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>





<h3 id="to的两种写法"><a href="#to的两种写法" class="headerlink" title="to的两种写法"></a>to的两种写法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link to=&quot;/news&quot; active-class=&quot;active&quot;&gt;新闻&lt;/router-link&gt;</span><br><span class="line">&lt;router-link :to=&quot;&#123;path:&#x27;/about&#x27;&#125;&quot; active-class=&quot;active&quot;&gt;关于&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240526203416484.png" alt="image-20240526203416484"></p>
<h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><p>rt</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240526204529640.png" alt="image-20240526204529640"></p>
<h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p>准备路由</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240526212435860.png" alt="image-20240526212435860"></p>
<p>前端搞上</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240526212829763.png" alt="image-20240526212829763"></p>
<p>如果直接写 detail 或者 &#x2F;detail 的话，会匹配不到路由，匹配失败</p>
<h3 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h3><h4 id="query参数"><a href="#query参数" class="headerlink" title="query参数"></a>query参数</h4><p><img src="/../%E5%9B%BE%E7%89%87/image-20240527104116519.png" alt="image-20240527104116519"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527110436396.png" alt="image-20240527110436396"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527112057014.png" alt="image-20240527112057014"></p>
<h4 id="params参数"><a href="#params参数" class="headerlink" title="params参数"></a>params参数</h4><p>个人感觉params参数很一般，建议query一般梭</p>
<ul>
<li>传递params参数时，若使用to对象写法，请务必使用 name 配置项，不能使用 path</li>
<li>传递params参数时，需要提前在规则中占位</li>
</ul>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527114235375.png" alt="image-20240527114235375"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527115140815.png" alt="image-20240527115140815"></p>
<h3 id="路由的props配置"><a href="#路由的props配置" class="headerlink" title="路由的props配置"></a>路由的props配置</h3><p>用来解决之前说过的很长，很不美观的问题</p>
<p>props有三种写法</p>
<p>一、</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527121219010.png" alt="image-20240527121219010"></p>
<p>红字打错了，是&#x3D;&#x3D;占位的三个params参数&#x3D;&#x3D;，</p>
<p>这种写法有局限性只是params参数，如果是query参数这个写法是不可以的</p>
<p>二、函数写法</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527122501118.png" alt="image-20240527122501118"></p>
<p>query和params传参都行</p>
<p>三、对象写法</p>
<p>没意义</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527122814484.png" alt="image-20240527122814484"></p>
<p>这里主要是路由的props，为什么不说组件的props呢，因为没必要，路由组件是没有机会写标签的 <code>&lt;Detail/&gt;</code> 这个标签不会出现，而组件可以，爱怎么写怎么写，组件的props就是  <code>&lt;Person a=&quot;100&quot; /&gt;</code> 的那个a，一般组件直接写在标签上就行了</p>
<h3 id="replace属性"><a href="#replace属性" class="headerlink" title="replace属性"></a>replace属性</h3><p>路由跳转的时候会操作浏览器的历史记录，路由操作浏览器的历史记录有两个动作，一个是push，另一个是replace</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527135958523.png" alt="image-20240527135958523"></p>
<p>设置路由的replace也很简单，在导航栏加一个 replace 即可</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527140206218.png" alt="image-20240527140206218"></p>
<h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><p>编程式导航：脱离 <code>&lt;route-link&gt;</code> 进行路由跳转， <code>&lt;route-link&gt;</code> 本质是一个 <code>&lt;a&gt;</code> 标签</p>
<p>需求：写一个按钮点击也可以跳转到对应路由</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527150003235.png" alt="image-20240527150003235"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527151158558.png" alt="image-20240527151158558"></p>
<p>在最后说一下编程式路由导航的作用吧</p>
<p>如果我想实现登录成功后自动跳转、打开三秒后跳转、鼠标滑动跳转等等功能，这显然是一个a标签无法做到的，这个时候就需要编程式导航了</p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>重定向，让指定的路径重新定位到另一个路径</p>
<p>之前一直没说，一个很恶心的地方，就是页面打开是没有默认项的，现在就需要重定向解决</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527151549602.png" alt="image-20240527151549602"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527152221423.png" alt="image-20240527152221423"></p>
<p>这里是为了方便观察层级放到上面来到，一般写在路由下面</p>
<h3 id="小程序一些思考"><a href="#小程序一些思考" class="headerlink" title="小程序一些思考"></a>小程序一些思考</h3><p>如果是只看样式的话，路由有点像微信小程序的tabBer，但是又有区别tabBer切换页面的时候不会卸载掉，而路由切换组件的时候是要卸载掉的，于是我有想到了另一个东西，也是我经常写的，其视觉效果是相同的。单纯的view是没有生命周期的。但是这里是wx:if来控制显示的，并不是hidden隐藏，if来控制显示是进行销毁的，而hidden不销毁。</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240526200730897.png" alt="image-20240526200730897"></p>
<p>先定义一个这么个导航区，然后在后端定义一个 status ，通过点击事件来改变 status 的值，利用三元判断来定义选中后的样式，达到视觉上的选中效果，然后利用 <code>&lt;block wx:if=&quot;&#123;&#123;status==1&#125;&#125;&quot;&gt;&lt;/block&gt;</code> 这个小判断来控制元素的显示</p>
<p>码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//wxml</span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;nav&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;slike1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;slike2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;nav-view&#123;&#123;status==1 ? &#x27;status&#x27;:&#x27;&#x27;&#125;&#125;&quot;</span> <span class="attr">bind:tap</span>=<span class="string">&quot;cells1&quot;</span>&gt;</span>宣传文章<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;nav-view&#123;&#123;status==2 ? &#x27;status&#x27;:&#x27;&#x27;&#125;&#125;&quot;</span> <span class="attr">bind:tap</span>=<span class="string">&quot;cells2&quot;</span>&gt;</span>公安文件<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;nav-view&#123;&#123;status==3 ? &#x27;status&#x27;:&#x27;&#x27;&#125;&#125;&quot;</span> <span class="attr">bind:tap</span>=<span class="string">&quot;cells3&quot;</span>&gt;</span>线上讲座<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;nav-view&#123;&#123;status==4 ? &#x27;status&#x27;:&#x27;&#x27;&#125;&#125;&quot;</span> <span class="attr">bind:tap</span>=<span class="string">&quot;cells4&quot;</span>&gt;</span>知识竞赛<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;status==1&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>1<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;status==2&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>2<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;status==3&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>3<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;status==4&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>4<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//js</span></span><br><span class="line"><span class="title function_">page</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">status</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">cells1</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="number">1</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">cells2</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="number">2</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">cells3</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="number">3</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">cells4</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="number">4</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>随着继续的学习，我感觉嵌套的路由在小程序中实现类似效果似乎也不是很难，但是，到传参这里，没有了上面头绪，因为我这种方式虽然也是不同组件的切换，但是不需要去找组件的路径，那么就没有url来提供给我传参的机会，那么对于实现前端的变化我的想法是这样的，取消 <code>&lt;block&gt;</code> 标签，只写一个 view 标签，定义一个demolist来显示数据，通过不同点击事件来改变demolist的值，来达到相同的效果，但是我思考了一下这似乎并不算传参，只是效果与其类似而已。也可以参考vue的编程式导航的内容，给点击事件传一个参，然后那这个参去拿写好的数据，但是这样感觉还不是很像。</p>
<p>至于编程式导航，一开始就是了，通过各种事件来实现效果，重定向也是有的，在data中默认了status为1</p>
<h2 id="Pinia"><a href="#Pinia" class="headerlink" title="Pinia"></a>Pinia</h2><p>集中式状态（数据）管理  redux   vuex   pinia</p>
<p>集中式状态管理：当写App的时候，会有各种各样的组件，还会有组件嵌套啊什么的，这个时候如果我在抽奖页面想用到登录页面的登录信息，这个时候就需要集中式状态管理了。但是不要是一个数据都交给数据管理，要把那些共享的数据交给集中式状态管理，而不是组件自身的数据</p>
<h3 id="准备一个效果"><a href="#准备一个效果" class="headerlink" title="准备一个效果"></a>准备一个效果</h3><p>先敲一个加减效果吧</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527163724136.png" alt="image-20240527163724136"></p>
<p>再敲一个与之前生成随机狗类似的生成随机土味情话</p>
<p>网站地址：<a href="https://api.uomg.com/api/rand.qinghua?format=json">https://api.uomg.com/api/rand.qinghua?format=json</a></p>
<p>注意一下这里下载了一个随即库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i nanoid</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527172117573.png" alt="image-20240527172117573"></p>
<h3 id="搭建pinia环境"><a href="#搭建pinia环境" class="headerlink" title="搭建pinia环境"></a>搭建pinia环境</h3><p>下载pinia</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i pinia</span><br></pre></td></tr></table></figure>

<p>在main.js文件中引入</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527173739270.png" alt="image-20240527173739270"></p>
<p>成功后插件内多了一个菠萝</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527173608462.png" alt="image-20240527173608462"></p>
<h3 id="存储、读取数据"><a href="#存储、读取数据" class="headerlink" title="存储、读取数据"></a>存储、读取数据</h3><ul>
<li>Store是一个保存：状态、业务逻辑 的实体，每个组件都可以读取、写入它</li>
<li>它有三个概念：<code>state</code> <code>getter</code> <code>action</code> ，相当于组件中的 <code>data</code> <code>computed</code> <code>methods</code></li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入defineStore用于创建store</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&quot;pinia&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并暴露一个store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCountStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;count&#x27;</span>,&#123;</span><br><span class="line">    <span class="comment">// 动作</span></span><br><span class="line">    <span class="attr">actions</span>: &#123;&#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 状态</span></span><br><span class="line">    <span class="title function_">state</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">           <span class="comment">// 数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算</span></span><br><span class="line">    <span class="attr">getters</span>:&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>按照规范，要在src目录下创建一个store目录，store可以理解为pinia世界的老大</p>
<p>这里注意一下书写规范，和hooks很像，命名为use+组件名+Store</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527175925942.png" alt="image-20240527175925942"></p>
<p>在组件中引用，说一下关于ref的一个注意点</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527175800749.png" alt="image-20240527175800749"></p>
<p>store在插件中显示，但是有一点，只要使用了的才会显示，没使用过的不会显示，成功了还有小菠萝</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527200157778.png" alt="image-20240527200157778"></p>
<h3 id="修改数据的三种方式"><a href="#修改数据的三种方式" class="headerlink" title="修改数据的三种方式"></a>修改数据的三种方式</h3><p>pinia官网的话——Pinia符合直觉的 Vue.js 状态管理库</p>
<p>其实在写存储的时候，我已经按照我的直觉更改了，这是一种简单的方式，可以看到后端改的插件已经认可了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527201144046.png" alt="image-20240527201144046"></p>
<p>感觉方式和hooks类似啊</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527203540093.png" alt="image-20240527203540093"></p>
<h3 id="storeToRefs"><a href="#storeToRefs" class="headerlink" title="storeToRefs"></a>storeToRefs</h3><p>张的就像toRefs，解构使用的，toRefs解构store数据会把所以的方法、数据等等，所有的东西都变成ref响应式数据，很不合理。这个时候就需要storeToRefs了</p>
<p>值得注意的是storeToRefs这个API 是pinia提供的，因此引入需要</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; storeToRefs &#125; from &quot;pinia&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527210507661.png" alt="image-20240527210507661"></p>
<h3 id="getters的使用"><a href="#getters的使用" class="headerlink" title="getters的使用"></a>getters的使用</h3><p><img src="/../%E5%9B%BE%E7%89%87/image-20240527211537238.png" alt="image-20240527211537238"></p>
<h3 id="subscribe的使用"><a href="#subscribe的使用" class="headerlink" title="$subscribe的使用"></a>$subscribe的使用</h3><p><code>subscribe</code> 订阅  他的作用很像watch监视</p>
<p>这里写一个很重要的功能</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527213856073.png" alt="image-20240527213856073"></p>
<p>这里传的字符串严格来说叫密钥，可以在本地储存空间找到</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527214017213.png" alt="image-20240527214017213"></p>
<p>看一下ts中</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527215225761.png" alt="image-20240527215225761"></p>
<h3 id="store组合式写法"><a href="#store组合式写法" class="headerlink" title="store组合式写法"></a>store组合式写法</h3><p>有点类似hooks的形式，自己体会一下。</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240527220044203.png" alt="image-20240527220044203"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return &#123;talkList,getlove&#125;</span><br></pre></td></tr></table></figure>





<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><p>组件之间互相传递数据</p>
<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>和路由的props类似</p>
<p>概述：props是使用频率最高的一种通信方式，常用于 父&lt;—&gt;子</p>
<ul>
<li>若父传子：属性值是非函数</li>
<li>若子传父：属性值是函数</li>
</ul>
<p>尽量不要在嵌套使用props。例如父要传孙，不要父传子、子传孙的</p>
<p>上面的说法多少有点抽象，看一下下面代码，父传子是定义的car，显然这不是一个函数，就可以把数据传到子组件。而子传父需要父组件内定义一个方法，将函数传给子，通过子组件的调用函数将数据传给父组件</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240528211804113.png" alt="image-20240528211804113"></p>
<p>昂，还有一个小的点 h4 标签上有一个 v-show 把toy的值给他，没来的时候是空字符串，会被当作false算，来了是toy就相当于true了，一个小把戏</p>
<h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><p>简单介绍一下 <code>$event</code> </p>
<p>懒得弄了，直接敲代码在这吧</p>
<p>&#x3D;&#x3D;自定义事件专门用来子传父&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;&lt;/h3&gt;</span><br><span class="line">        &lt;button @click=&quot;test&quot;&gt;点我&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function test(a) &#123;</span><br><span class="line">        console.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">    //如果是这样不传递任何参数，但是接受了一个参数，就会出现一个事件对象event。</span><br><span class="line">    //如果说呢，我传递了参数a,b，c这个时候就接收不到事件对象了，需要手动在传参的位置添加 $event ，然后再把这个 $event 传递给某一个参数。</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//说一个骚一点的赋值操作</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;&#123;&#123; str &#125;&#125;&lt;/h3&gt;</span><br><span class="line">        &lt;button @click=&quot;str = 哈哈&quot;&gt;点我&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line">    </span><br><span class="line">    let str = ref(&#x27;你好&#x27;)</span><br><span class="line">    // 这个时候也是实现了点击按钮进行更改赋值的操作</span><br><span class="line">    </span><br><span class="line">    //如果呢，贱一点，把str变为 $event 还是可以成功的，但是前面数据很变得很奇怪，试一下就知道了</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>





<p><img src="/../%E5%9B%BE%E7%89%87/image-20240528220430557.png" alt="image-20240528220430557"></p>
<p>这里说一下自定义事件的命名规范，HTML文件对大小写是不敏感的，因此驼峰式命名法 SendToy 将会变成 sendtoy 再到后端使用的时候会出问题，因此，自定义事件的命名推荐使用 kebab-case 羊肉串式命名法 send-toy</p>
<h3 id="mitt"><a href="#mitt" class="headerlink" title="mitt"></a>mitt</h3><p>mitt可以实现&#x3D;&#x3D;任意组件通讯&#x3D;&#x3D;，大小只有200b</p>
<p>首先安装mitt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i mitt</span><br></pre></td></tr></table></figure>

<p>一般按照规范会有tools或者utils目录</p>
<p>简单写一个emitter</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240528222059030.png" alt="image-20240528222059030"></p>
<p>在main中引入一下，一行就行</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240528222305087.png" alt="image-20240528222305087"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240528223422399.png" alt="image-20240528223422399"></p>
<p>感受一下任意组件通讯</p>
<p>父组件没啥用，截图也放不下了，代码贴这吧</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;father&quot;&gt;</span><br><span class="line">    &lt;h3&gt;父组件&lt;/h3&gt;</span><br><span class="line">    &lt;Child1/&gt;</span><br><span class="line">    &lt;Child2/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Father&quot;&gt;</span><br><span class="line">  import Child1 from &#x27;./Child1.vue&#x27;</span><br><span class="line">  import Child2 from &#x27;./Child2.vue&#x27;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240528225437649.png" alt="image-20240528225437649"></p>
<h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><p>不冷不热的知识：开发有一个UI组件库，在UI组件库中大量使用了v-model进行组件通信</p>
<p>v-model&#x3D;&#x3D;既能父传子，也能子传父&#x3D;&#x3D;</p>
<p>写一个简单的双向绑定，这是HTML标签上的v-model</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//使用v-model来实现绑定</span><br><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;username&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line">    let username = ref(0)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">//以上呢是一个简单的v-model的双向绑定，但是不够清楚明白，写一下他的逻辑</span><br><span class="line"></span><br><span class="line">&lt;input type=&quot;text&quot; :value=&quot;username&quot; @input=&quot;username = $event.target.value&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line">    let username = ref(0)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">//这两种方式是等价的</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529140752820.png" alt="image-20240529140752820"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@input=&quot;username = (&lt;HTMLInputElement&gt;$event.target).value&quot;</span><br><span class="line">//断言方法</span><br></pre></td></tr></table></figure>



<p>v-model用于组件标签上</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529142419824.png" alt="image-20240529142419824"></p>
<p>注释的第一个是语法糖，第二个是原理，但是组件内的代码还是都要写的</p>
<p>注意这里的事件直接就username &#x3D; $event 了，原因是，之前的HTML标签中 $event 是标准的DOM元素，需要.target 但是这个是在组件内的自定义事件，$event 只是数据，因此不需要.target</p>
<p>对于原生事件，$event 就是事件对象 ，所以能.target</p>
<p>对于自定义事件，$event 就是触发事件时，所传递的数据，不能.target</p>
<p>也可以更改value，既然value可以更改那么就意味着组件标签&#x3D;&#x3D;可以使用多个v-model&#x3D;&#x3D;</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529144454933.png" alt="image-20240529144454933"></p>
<p>这个飘红是以为使用了props传参，可以是软件不认可这种写法，懒得再给他接受定义一下了</p>
<h3 id="attrs"><a href="#attrs" class="headerlink" title="$attrs"></a>$attrs</h3><p>概述：$attrs 用于实现当前父组件，向当前子组件的通讯（祖——孙）</p>
<p>一个小的点：</p>
<p>父给子传数据，子是需要接受的对吧，父子之间一般为props通信，因此呢，如果接受了插件中可以看到一个props，如果没接受的话，数据会存放在attrs中</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529145801542.png" alt="image-20240529145801542"></p>
<p>如果说呢，父给子传递数据了，但是没有接收，还想使用应该怎么办呢，这个时候就要用到$attrs了，如果说在前端直接写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;&#123;&#123; $attrs &#125;&#125;&lt;/h2&gt;</span><br><span class="line">//这样就可以直接打印出来所有未接受的数据的key-value键值对</span><br></pre></td></tr></table></figure>



<p>简单说一下v-bind 单向绑定，v-bind内也可以写对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Child :a=&quot;a&quot; :b=&quot;b&quot; v-bind=&quot;&#123;x:100,y:200&#125;&quot;/&gt;</span><br><span class="line"></span><br><span class="line">//这里的v-bind内的对象相当于</span><br><span class="line">&lt;Child :a=&quot;a&quot; :b=&quot;b&quot; :x=&quot;100&quot; :y=&quot;200&quot;/&gt;</span><br></pre></td></tr></table></figure>



<p>祖传孙，传数据，孙传祖传方法，老套路了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529155221912.png" alt="image-20240529155221912"></p>
<h3 id="refs-与-parent"><a href="#refs-与-parent" class="headerlink" title="$refs 与 $parent"></a>$refs 与 $parent</h3><p>概述：</p>
<ul>
<li>$refs 用于父——子</li>
<li>$parent 用于子——父</li>
</ul>
<p>$refs</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529163122158.png" alt="image-20240529163122158"></p>
<p>$parent</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529163403963.png" alt="image-20240529163403963"></p>
<p>源代码父组件内有一个多行注释，说明的是ref数据生么时候.value的问题，这个问题之前有说过，不在赘述</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    let obj = reactive(&#123;</span><br><span class="line">		a:1,</span><br><span class="line">		b:2,</span><br><span class="line">		c:ref(3)</span><br><span class="line">	&#125;)</span><br><span class="line">	let x = ref(4)</span><br><span class="line"></span><br><span class="line">	console.log(obj.a)</span><br><span class="line">	console.log(obj.b)</span><br><span class="line">	console.log(obj.c)</span><br><span class="line">	console.log(x.value)</span><br><span class="line">	</span><br><span class="line">// reactive响应式数据会自动解包，但是ref不会，所以需要.value，reactive内的ref数据已经被解包，不需要再进行.value解包。</span><br><span class="line">// 注意点：当访问obj.c的时候，底层会自动读取value属性，因为c是在obj这个响应式对象中的</span><br></pre></td></tr></table></figure>





<h3 id="provide-与-inject"><a href="#provide-与-inject" class="headerlink" title="provide 与 inject"></a>provide 与 inject</h3><p>概述：实现祖孙之间的数据传输，虽然attrs也可以做到祖孙之间的数据传输，但是会打扰到父组件，尽管代码很少</p>
<p>provide和inject实现的隔代通信不会打扰到中间的组件</p>
<p>中间还有一个子组件，正常引用即可，用不着子组件</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529165404011.png" alt="image-20240529165404011"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529170315154.png" alt="image-20240529170315154"></p>
<h3 id="pinia"><a href="#pinia" class="headerlink" title="pinia"></a>pinia</h3><p>之前说过，不再赘述</p>
<h3 id="slot插槽"><a href="#slot插槽" class="headerlink" title="slot插槽"></a>slot插槽</h3><h4 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h4><p><img src="/../%E5%9B%BE%E7%89%87/image-20240529175423402.png" alt="image-20240529175423402"></p>
<h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><p>默认插槽是说了萝卜和坑的概念，但是如果我需要写多个标签的时候，那么就需要用到具名插槽了</p>
<p>默认插槽是没有name配置项的，所以无论什么标签到都可以放到默认插槽内，但是具名插槽不行</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529180331882.png" alt="image-20240529180331882"></p>
<p>这里v-slot还有一个小的语法糖，就是直接写 <code>#名称</code> ，如上图</p>
<p>其实默认插槽也是有名字的叫做 <code>default</code> ，一般不会写</p>
<h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><p>作用域插槽的写法很多，所以感觉很乱，习惯就好</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529191723787.png" alt="image-20240529191723787"></p>
<p>总结梳理一下：</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529192635795.png" alt="image-20240529192635795"></p>
<h2 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h2><p>API很多，说几个实用的</p>
<h3 id="shallowRef-和-shallowReactive"><a href="#shallowRef-和-shallowReactive" class="headerlink" title="shallowRef 和 shallowReactive"></a>shallowRef 和 shallowReactive</h3><p>shallowRef 即浅层次的ref 深层次就不是响应式了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529194707481.png" alt="image-20240529194707481"></p>
<p>shallowReactive 基本同理</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529195827949.png" alt="image-20240529195827949"></p>
<h3 id="readonly-与-shallowReadonly"><a href="#readonly-与-shallowReadonly" class="headerlink" title="readonly 与 shallowReadonly"></a>readonly 与 shallowReadonly</h3><p>readonly 创建一个只读副本。</p>
<p>特点：</p>
<ul>
<li>对象的所以属性都为只读</li>
<li>任何尝试更改的操作都会报错</li>
</ul>
<p>应用场景：</p>
<ul>
<li>创建不可变的状态快照</li>
<li>保护全局状态或配置不可更改</li>
</ul>
<p>shallowReadonly 只作用域顶层属性</p>
<p>特点：</p>
<ul>
<li>只将对象的顶层属性设置为可读，对象内部的嵌套属性仍然是可变的</li>
<li>适用于只需保护对象顶层属性的场景</li>
</ul>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529202813553.png" alt="image-20240529202813553"></p>
<p>使用谷歌插件也可以通过图标看到是否可以修改</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529202427375.png" alt="image-20240529202427375"></p>
<h3 id="toRaw-与-markRaw"><a href="#toRaw-与-markRaw" class="headerlink" title="toRaw 与 markRaw"></a>toRaw 与 markRaw</h3><p>toRaw</p>
<p> 获取一个响应式对象的原始对象，toRaw返回的对象不再是响应式的，不会触发视图更新</p>
<p>官网描述：这是一个可以用于临时读取而不引起代理访问&#x2F;跟踪开销，或是写入而不触发更新的特殊方法，&#x3D;&#x3D;不建议保存对原始对象的持久引用，请谨慎使用&#x3D;&#x3D;。</p>
<p>何时使用？——在需要将响应式对象传递给非 Vue 库或外部系统时，使用 toRaw 可以确保它们收到的是普通对象</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529205852348.png" alt="image-20240529205852348"></p>
<p>toRaw 去除响应式</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529204605021.png" alt="image-20240529204605021"></p>
<p>markRaw</p>
<p>标记一个对象，使其永远不会变成响应式对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; markRaw,car &#125; from &#x27;vue&#x27;</span><br><span class="line">let car = markRaw(&#123;brand:&#x27;奔驰&#x27;,price:100&#125;)</span><br><span class="line">let car2 = reactive(car)</span><br><span class="line">// 如果car没有使用markRaw包裹，car2会把car数据拿走成为响应式数据，但是标记car为不可响应后，car2也会失去响应式。</span><br></pre></td></tr></table></figure>



<p>例如呢使用一些第三方库时，为了避免把一些第三方库的数据变成响应式对象，可以使用markRaw标记一下</p>
<h3 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a>customRef</h3><h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h4><p>作用：创建一个自定义的ref，并对其依赖项跟踪和更新触发进行逻辑控制。</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529212806137.png" alt="image-20240529212806137"></p>
<p>如果说呢，我实现新输入一个内容后1s之后再在页面中显示，显然这个需要自定义ref</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529213236876.png" alt="image-20240529213236876"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529214226758.png" alt="image-20240529214226758"></p>
<p>一般这种代码会写为自定义hooks，小写一下</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; customRef &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不将数据写死，找前端要两个参数，一个是初始值，另一个个是事件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params">initValue:<span class="built_in">string</span>,delay:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> timer : <span class="built_in">any</span></span><br><span class="line">	<span class="comment">// track含义是追踪 trigger含义是触发</span></span><br><span class="line">	<span class="keyword">let</span> msg = <span class="title function_">customRef</span>(<span class="function">(<span class="params">track, trigger</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="comment">// get何时调用：msg被读取时调用</span></span><br><span class="line">			<span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">				<span class="title function_">track</span>()</span><br><span class="line">				<span class="keyword">return</span> initValue</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="comment">// set何时调用：msg被修改时调用</span></span><br><span class="line">			<span class="title function_">set</span>(<span class="params">value</span>) &#123;</span><br><span class="line">				<span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">				timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">					initValue = value</span><br><span class="line">					<span class="title function_">trigger</span>()</span><br><span class="line">				&#125;, delay);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> &#123;msg&#125;</span><br><span class="line">    <span class="comment">//返回方法msg</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>定义好hooks调用十分清爽</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529215059500.png" alt="image-20240529215059500"></p>
<p>这个API的难点就在于理解 <code>track</code> 和 <code>trigger</code> 两个底层为自定义ref准备好的方法</p>
<h2 id="Vue3-新组件"><a href="#Vue3-新组件" class="headerlink" title="Vue3 新组件"></a>Vue3 新组件</h2><h3 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h3><p>翻译：传送，游戏中TP就是他的缩写</p>
<p>Teleport是一种能够将我们的组件HTML结构移动到指定位置的技术</p>
<p>举个例子吧：</p>
<p>这里有个问题，我想在页面上写一个弹窗，但是呢这个弹窗想要按照屏幕大小定位在中间，通过css调整位置</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529222020479.png" alt="image-20240529222020479"></p>
<p>这里是通过position：fixed;  将弹窗对于浏览器窗口进行定位，而不是相对于其父组件，但是呢，这个时候有一个有意思的问题，如果我在父组件内使用了 <code>filter</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filter: saturate(100%);</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529222230109.png" alt="image-20240529222230109"></p>
<p>这个时候呢，弹窗就又会变为根据父组件大小来定位</p>
<p>这样的可以影响fixed的css还有其他的可以查一下，但是呢这个问题可以使用teleport来解决</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529222946838.png" alt="image-20240529222946838"></p>
<p>这就是teleport的作用——将HTML标签传送到指定位置</p>
<p>只是将结构传送出去，逻辑没影响</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240529222714543.png" alt="image-20240529222714543"></p>
<p>即，我将饱和度设置为0，弹窗的颜色依旧是鲜艳的，因为弹窗的父组件已经改变了</p>
<p>teleport不止在这里使用，只是举个例子，可以大胆发挥想象搞事情</p>
<h3 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h3><p>概述：等待异步组件时渲染一些额外的内容，让应用有更好的体验。</p>
<p> <a href="https://api.uomg.com/api/rand.qinghua?format=json">https://api.uomg.com/api/rand.qinghua?format=json</a></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240530142221122.png" alt="image-20240530142221122"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240530143555487.png" alt="image-20240530143555487"></p>
<p>等数据请求完成后，再渲染子组件，替换掉h2标签</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240530143727780.png" alt="image-20240530143727780"></p>
<h3 id="全局API转移到对象"><a href="#全局API转移到对象" class="headerlink" title="全局API转移到对象"></a>全局API转移到对象</h3><ul>
<li>app.component</li>
<li>app.config</li>
<li>app.directive</li>
<li>app.mount</li>
<li>app.unmount</li>
<li>app.use</li>
</ul>
<p>之前在Vue2 中可以vue.xxx 的内容已经变为了 app.xxx</p>
<h4 id="app-component-全局组件"><a href="#app-component-全局组件" class="headerlink" title="app.component 全局组件"></a>app.component 全局组件</h4><p>在main.js文件中注册，在任意页面都可以使用</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240530144644628.png" alt="image-20240530144644628"></p>
<h4 id="app-config-全局变量"><a href="#app-config-全局变量" class="headerlink" title="app.config  全局变量"></a>app.config  全局变量</h4><p><img src="/../%E5%9B%BE%E7%89%87/image-20240530145954859.png" alt="image-20240530145954859"></p>
<p>在main.js内输入注释内的内容会使页面无法正常加载，但是没有这个的话，前端 x 处会飘红</p>
<p>这个全局变量不推荐大量使用</p>
<h4 id="app-directive-全局指令"><a href="#app-directive-全局指令" class="headerlink" title="app.directive  全局指令"></a>app.directive  全局指令</h4><p>注册全局指令</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240530152446862.png" alt="image-20240530152446862"></p>
<h4 id="app-mount"><a href="#app-mount" class="headerlink" title="app.mount"></a>app.mount</h4><p>mount不用说，很重要，挂载整个应用的</p>
<h4 id="app-unmount"><a href="#app-unmount" class="headerlink" title="app.unmount"></a>app.unmount</h4><p>unmount卸载mount</p>
<h4 id="app-use"><a href="#app-use" class="headerlink" title="app.use"></a>app.use</h4><p>这个之前就使用过，作用是安装插件</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240530152740768.png" alt="image-20240530152740768"></p>
<h2 id="Vue3的非兼容性改变"><a href="#Vue3的非兼容性改变" class="headerlink" title="Vue3的非兼容性改变"></a>Vue3的非兼容性改变</h2><p>这个是Vue3和Vue2改变的地方，可以直接上官网看非兼容性改变</p>
<ul>
<li>过渡类名 v-enter 修改为 v-enter-from 、过度类名 v-leave 更改为 v-leave-from</li>
<li>keyCode 作为 v-on 的修饰符支持</li>
<li>v-model 指令在组件上的使用已经被重新设计，替换掉了 v-bind.sync</li>
<li>v-if 和 v-for 在同一级元素身上使用的优先级发生了变化</li>
<li>移除了 $on、$off 和 $once 的实例方法</li>
<li>移除了过滤器 filter</li>
<li>移除了 $children 实例 propert</li>
<li>……</li>
</ul>
<p>Vue2中v-for的优先级比v-if的优先级高，不能同时用在一个标签上，但是在Vue3中把v-if的优先级调整的比v-for的优先级高</p>
<p>完结撒花，中间也有不少关于微信小程序的思考，这里记录一下</p>
<p>土味情话网址：<a href="https://api.uomg.com/api/rand.qinghua?format=json">https://api.uomg.com/api/rand.qinghua?format=json</a></p>
<p>随机狗子网址：<a href="https://dog.ceo/api/breed/pembroke/images/random">https://dog.ceo/api/breed/pembroke/images/random</a></p>
]]></content>
      <categories>
        <category>VUE框架</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向学习 0x01安卓基础</title>
    <url>/2024/10/09/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-0x01-%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>windows配置</p>
<p>开启开发者人员模式</p>
<span id="more"></span>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240917130613989-1728459407955-1.png" alt="image-20240917130613989"></p>
<p>cmd命令</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">dir</td>
<td align="center">查看目录下的文件</td>
</tr>
<tr>
<td align="center">cls</td>
<td align="center">清屏</td>
</tr>
<tr>
<td align="center">cd &#x2F;d</td>
<td align="center">从根目录下开始进入</td>
</tr>
<tr>
<td align="center">cd ..</td>
<td align="center">到上级目录</td>
</tr>
<tr>
<td align="center">右键复制粘贴</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>jed不能有中文路径</p>
<p>在使用国外的软件时路径最好不要有中文、空格、特殊符号，计算机名不要是中文</p>
<p>android studio</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240917211606975-1728459407956-2.png" alt="image-20240917211606975"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240917211626133-1728459407956-3.png" alt="image-20240917211626133"></p>
<h3 id="真机环境配置"><a href="#真机环境配置" class="headerlink" title="真机环境配置"></a>真机环境配置</h3><h4 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h4><p>刷机分为线刷和卡刷</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线刷		刷的比较彻底，可以刷bootloader、radio</span><br><span class="line">卡刷		刷完之后需要双清、三清、四清</span><br></pre></td></tr></table></figure>



<p>同样的刷机包也有两种</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线刷包/工厂镜像包</span><br><span class="line">卡刷包/OTA全量包/OTA增量包</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">谷歌手机工厂镜像</span><br><span class="line">https://developers.google.com/android/images</span><br><span class="line"></span><br><span class="line">线刷包的组成：</span><br><span class="line">	bootloader、radio、Android系统</span><br></pre></td></tr></table></figure>



<p>刷机教程</p>
<p><a href="https://source.android.com/source/running.html">https://source.android.com/source/running.html</a></p>
<p><a href="https://mp.weixin.qq.com/s/1EySfXSucGdiuEBTfLsymA">https://mp.weixin.qq.com/s/1EySfXSucGdiuEBTfLsymA</a></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240919141352776-1728459407956-4.png" alt="image-20240919141352776"></p>
<p>使用flash-all.bat文件批量处理是一键刷机，其实是可以分开刷的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb reboot bootloader</span><br><span class="line">fastboot flash boot boot.img</span><br><span class="line">fastboot flash recovery recovery.img	// 卡刷分区</span><br><span class="line">fastboot flash system system.img</span><br><span class="line">fastboot flash bootloader bootloader.img</span><br><span class="line">fastboot boot &lt;recovery_filename&gt;. img</span><br><span class="line"></span><br><span class="line">// 分开刷时，注意各分区镜像是否兼容</span><br></pre></td></tr></table></figure>



<p>fastboot devices无法识别设备问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">安装GoogleUSB驱动（AndroidStudio中即可下载)</span><br><span class="line">此电脑 -&gt;右键管理 -&gt;设备管理器-&gt;选中没有驱动的Android设备 -&gt;右键更新驱动程序-&gt;选择浏览我的电脑以查找驱动程序-&gt;找到驱动所在目录-&gt;确定安装即可</span><br></pre></td></tr></table></figure>





<h4 id="root"><a href="#root" class="headerlink" title="root"></a>root</h4><p>检测是否开启root</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">手机连接电脑后，进入命令行</span><br><span class="line"></span><br><span class="line">adb shell</span><br><span class="line"></span><br><span class="line">如果出现 $说明目前不是root权限，#则为root</span><br><span class="line"></span><br><span class="line">执行</span><br><span class="line"></span><br><span class="line">su</span><br><span class="line"></span><br><span class="line">出现 路径 :su:inaccessible or not found，则说明无法获取root权限，这个时候就需要刷入一些东西才能开启root了</span><br></pre></td></tr></table></figure>



<p>Magisk下载：<a href="https://github.com/topjohnwu/Magisk/releases">https://github.com/topjohnwu/Magisk/releases</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb install (Magisk所在的路径)</span><br><span class="line"></span><br><span class="line">// 安装的是一个apk软件，在手机里打开这个软件，选择修复一个文件</span><br><span class="line">// 然后将谷歌刷机包内的 boot.img 镜像推到手机中</span><br><span class="line"></span><br><span class="line">adb push (boot.img路径) /sdcard/</span><br><span class="line"></span><br><span class="line">// 选择这个镜像进行修补</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240919143537216-1728459407956-9.png" alt="image-20240919143537216"></p>
<p>找到重新打包的这个镜像，将其pull到电脑上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb pull (镜像路径)</span><br></pre></td></tr></table></figure>



<p>然后进入bootloader模式，将镜像刷入手机</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb reboot bootloader</span><br><span class="line"></span><br><span class="line">// 将镜像刷入boot分区</span><br><span class="line">fasboot flash boot (镜像路径)</span><br></pre></td></tr></table></figure>



<p>重启，打开shell，即可使用电脑root</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240919144322321-1728459407956-5.png" alt="image-20240919144322321"></p>
<p>注意设置时间，时间不对无法正常访问互联网</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240919145047364-1728459407956-6.png" alt="image-20240919145047364"></p>
<h3 id="adb工作原理"><a href="#adb工作原理" class="headerlink" title="adb工作原理"></a>adb工作原理</h3><h4 id="adb构成"><a href="#adb构成" class="headerlink" title="adb构成"></a>adb构成</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、client端，在电脑上，负责发送adb命令</span><br><span class="line">2、daemon守护进程adbd，在手机上，负责接收和执行adb命令</span><br><span class="line">3、server端，在电脑上，负责管理client和daemon之间的通信</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240917212918671-1728459407956-8.png" alt="image-20240917212918671"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client端将命令发送给server端</span><br><span class="line">server端将命令发送给daemon端</span><br><span class="line">daemon端进行执行</span><br><span class="line">将执行结果，返回给server端</span><br><span class="line">server端将结果再返回给client端</span><br></pre></td></tr></table></figure>



<h4 id="超级adbd"><a href="#超级adbd" class="headerlink" title="超级adbd"></a>超级adbd</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有两个命令可以使用：</span><br><span class="line">	adb root</span><br><span class="line">	adb remount</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个很容易分辨，adb servber进去的时候之间就是root权限</p>
</blockquote>
<h4 id="配置adb"><a href="#配置adb" class="headerlink" title="配置adb"></a>配置adb</h4><p>adb.exe在SDK的platform-tools下</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240917215155344-1728459407956-7.png" alt="image-20240917215155344"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240917215134001-1728459407956-11.png" alt="image-20240917215134001"></p>
<p>adb.exe在SDK的platform-tools下，如果嫌麻烦就需要配置环境变量</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240917215015286-1728459407956-10.png" alt="image-20240917215015286"></p>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">adb &#x2F; adb help &#x2F; adb –help</td>
<td align="center">顾名思义</td>
</tr>
<tr>
<td align="center">adb version</td>
<td align="center">显示adb版本和路径</td>
</tr>
<tr>
<td align="center">adb start-server</td>
<td align="center">启动server</td>
</tr>
<tr>
<td align="center">adb kill-server</td>
<td align="center">停止server</td>
</tr>
<tr>
<td align="center">adb devices</td>
<td align="center">显示连接的设备列表</td>
</tr>
<tr>
<td align="center">adb install || xxx.apk</td>
<td align="center">通过adb安装app</td>
</tr>
<tr>
<td align="center">adb install || -r xxx.apk</td>
<td align="center">覆盖安装</td>
</tr>
<tr>
<td align="center">adb uninstall 包名</td>
<td align="center">通过adb卸载app</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">adb push xxx xxx</td>
<td align="center">推送电脑的文件到手机</td>
</tr>
<tr>
<td align="center">adb pull xxx xxx</td>
<td align="center">拉取手机文件到电脑</td>
</tr>
<tr>
<td align="center">adb pull xxx</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">adb shell</td>
<td align="center">进入到手机的Linux控制台</td>
</tr>
<tr>
<td align="center">adb -s 设备名 shell</td>
<td align="center">多设备时，指定设备</td>
</tr>
</tbody></table>
<h4 id="logcat常用选项"><a href="#logcat常用选项" class="headerlink" title="logcat常用选项"></a>logcat常用选项</h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">用法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">adb logcat -help</td>
<td align="center">查看帮助</td>
</tr>
<tr>
<td align="center">adb logcat</td>
<td align="center">常规显示</td>
</tr>
<tr>
<td align="center">adb logcat -c</td>
<td align="center">清除日志</td>
</tr>
<tr>
<td align="center">adb logcat -g</td>
<td align="center">显示缓冲区大小</td>
</tr>
<tr>
<td align="center">adb logcat -G 256M</td>
<td align="center">修改缓冲区大小</td>
</tr>
<tr>
<td align="center">adb logcat -v time</td>
<td align="center">设置不同的显示格式</td>
</tr>
<tr>
<td align="center">adb logcat -v color</td>
<td align="center">带颜色的显示</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">adb logcat -s [tagName]</td>
<td align="center">根据标签名过滤日志</td>
</tr>
<tr>
<td align="center">ps -A |grep</td>
<td align="center">获取进程pid</td>
</tr>
<tr>
<td align="center">adb logcat |findstr [pid]</td>
<td align="center">根据pid过滤日志</td>
</tr>
</tbody></table>
<p>android studio内也带有logcat，而且是页面化的logcat，更加方便</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240919153642610-1728459407956-12.png" alt="image-20240919153642610"></p>
<h3 id="Android扫盲"><a href="#Android扫盲" class="headerlink" title="Android扫盲"></a>Android扫盲</h3><p>Android历史版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Android 4.4以前，采用dalvik/dvm虚拟机 有一个libdvm.so 来执行Java代码</span><br><span class="line">Android 4.4，里面有dvm和art虚拟机，可以切换 libdvm.so 和 libart.so  art虚拟机加快了代码运行速度，在Android 4.4是可以切换的</span><br><span class="line">Android 5.0及以后，使用art虚拟机，Android系统开始区分32位和64位</span><br><span class="line">	nexus5 32 6.0 -&gt; 32位 (最后一款32位cpu的手机力)</span><br><span class="line">	nexus6p 64 6.0 -&gt; 64位</span><br></pre></td></tr></table></figure>



<h5 id="apk基本结构"><a href="#apk基本结构" class="headerlink" title="apk基本结构"></a>apk基本结构</h5><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>assets</td>
<td>资源文件（图片、音频、数据库、网页、配置文件、dll、so等）</td>
</tr>
<tr>
<td>res</td>
<td>资源文件（编译后的布局文件、程序图标）</td>
</tr>
<tr>
<td>lib</td>
<td>各种平台下使用的对应的so文件</td>
</tr>
<tr>
<td>META-INF</td>
<td>签名文件</td>
</tr>
<tr>
<td>resources.arsc</td>
<td>资源加密（语言包）</td>
</tr>
<tr>
<td>AndroidManifest.xml</td>
<td>清单文件（图标、界面、权限、代码执行入口）</td>
</tr>
<tr>
<td>classes.dex</td>
<td>源代码</td>
</tr>
</tbody></table>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240919155937298-1728459407956-13.png" alt="image-20240919155937298"></p>
<h5 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h5><p>安卓是在Linux的基础上的执行的，所以说在Linux上可以执行的命令在安卓上也可以执行，但是在用法上可能会有一些细微的差别</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240919161358076-1728459407956-14.png" alt="image-20240919161358076"></p>
<p>Linux的目录结构是层级式的树状目录结构，最上层是根目录 &#x2F; ，以 <code>/</code> 开头的表示绝对路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">// 在Linux中是切换到根目录，在安卓中是切换到自己的用户目录</span><br></pre></td></tr></table></figure>



<p>1、在Linux内一切皆文件（包括硬件），命令实际上是系统中的一个二进制文件，在 <code>system/bin</code> 目录下</p>
<p>2、Linux中不存在扩展名，有时候为了区分才人为的添加扩展名</p>
<p>3、隐藏文件以 <code>.</code> 开头</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -a</span><br><span class="line">// 查看所有文件，包括隐藏文件</span><br><span class="line"></span><br><span class="line">ls -l</span><br><span class="line">// 显示详情信息</span><br><span class="line">看下面的详情信息</span><br><span class="line"></span><br><span class="line">drwxrwx--x 2 root sdcard_rw 4096 2019-10-29 07:33 Ringtones</span><br><span class="line">-rw-rw---- 1 root sdcard_rw 31532262 2009-01-01 00:00 boot.img</span><br><span class="line"></span><br><span class="line">第一个</span><br><span class="line">第一位是文件形式，d代表文件夹，-代表是文件，l代表软连接，后九位，三个为一组代表不同用户操作的权限</span><br><span class="line">// 软连接相当于Windows中的快捷方式</span><br><span class="line"></span><br><span class="line">第二个表示文件个数</span><br><span class="line"></span><br><span class="line">第三个表示创建用户</span><br><span class="line"></span><br><span class="line">第三个表示创建用户的用户组</span><br><span class="line"></span><br><span class="line">第四个表示文件大小，如果是文件夹就显示4096，文件就是实际大小</span><br><span class="line"></span><br><span class="line">第五个是创建时间</span><br><span class="line"></span><br><span class="line">第六个名字</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ls -l -h</span><br><span class="line">// 统计大小，将第四个文件大小的字节数转化成MB或者KB的形式</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file</span><br><span class="line">// 查看文件类型，支持使用通配符*</span><br><span class="line"></span><br><span class="line">du</span><br><span class="line">// 查看文件大小</span><br></pre></td></tr></table></figure>



<p>在Linux中文件是区分大小写的，A和a这是两个不同的文件，但是在安卓中是不区分大小写的</p>
<p>增删改查</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建</span><br><span class="line">	touch xxx</span><br><span class="line">	// 创建空文件/更新文件状态</span><br><span class="line">	</span><br><span class="line">	mkdir aaa</span><br><span class="line">	mkdir aaa bbb</span><br><span class="line">	// 同时创建多个目录</span><br><span class="line">	</span><br><span class="line">	mkdir -p aaa/bbb</span><br><span class="line">	// 递归创建</span><br><span class="line">	</span><br><span class="line">删除</span><br><span class="line">	rmdir xxx</span><br><span class="line">	// 删除空目录</span><br><span class="line">	</span><br><span class="line">	rm xxx</span><br><span class="line">	// 删除空文件</span><br><span class="line">	</span><br><span class="line">	rm -rf</span><br><span class="line">	// -r 递归删除整个目录</span><br><span class="line">	// -f 强制删除且不提示确认信息</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">复制</span><br><span class="line">	cp a /sdcard/</span><br><span class="line">	// 复制文件不需要选项</span><br><span class="line">	</span><br><span class="line">	cp a b /sdcard/</span><br><span class="line">	// 复制多个文件</span><br><span class="line">	</span><br><span class="line">	cp -r a b</span><br><span class="line">	// 复制目录需要加 -r</span><br><span class="line">	// -r： 递归复制整个文件夹</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">移动</span><br><span class="line">	mv oldName newName</span><br><span class="line">	// 移动文件同时重命名</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">输出文件内容</span><br><span class="line">	cat /proc/version</span><br></pre></td></tr></table></figure>



<p>其他</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep</span><br><span class="line">	-n 显示匹配行及行号</span><br><span class="line">	-i 忽略字母大小写</span><br><span class="line">	-r 递归查找</span><br><span class="line">	</span><br><span class="line">一般是和其他命令结合使用</span><br><span class="line">ps -A |grep xxx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查找文件或目录</span><br><span class="line">	find /home -name hello</span><br><span class="line">	// 指定目录，递归查找文件</span><br><span class="line">	// 不加-name可以检索文件的内容</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">输出</span><br><span class="line">	echo</span><br><span class="line">	// 可以使用 echo &quot;hello&quot; &gt; text 将输出内容写入文件中，这是重定向</span><br><span class="line">	</span><br><span class="line">	echo &quot;hello&quot; &gt;&gt; text</span><br><span class="line">	// 追加+重定向</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">创建软连接</span><br><span class="line">	ln -s aaa/bbb.txt ccc</span><br><span class="line">	// 这个就相当于在当前文件夹下，创建了一个快捷方式，这个快捷方式叫ccc，快捷方式指向aaa/bbb.txt</span><br></pre></td></tr></table></figure>





<h4 id="Android常用目录"><a href="#Android常用目录" class="headerlink" title="Android常用目录"></a>Android常用目录</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、data/data目录</span><br><span class="line">	存放用户apk数据的目录，每个apk都有自己的目录，以包名命名就是放在data/data目录下，会产生一个跟Package一样的目录，这是一个私有目录，存放使用app产生的一些数据，app只能访问各自的目录，除非root权限。</span><br><span class="line">	</span><br><span class="line">2、data/app目录</span><br><span class="line">	用户安装的app存放在这个目录下，也是以apk的包名命名，一般文件夹内存放的是该app的apk文件</span><br><span class="line">	</span><br><span class="line">3、data/local/tmp目录</span><br><span class="line">	临时目录，权限比较大</span><br><span class="line">	</span><br><span class="line">4、system/app目录</span><br><span class="line">	存放系统自带的app</span><br><span class="line">	</span><br><span class="line">5、system/lib目录、system/lib64目录</span><br><span class="line">	存放app需要的so文件，lib目录下存放的是32位运行需要的so，lib64目录存放的是64位运行所需要的so文件</span><br><span class="line">	</span><br><span class="line">6、system/bin目录</span><br><span class="line">	存放shell命令</span><br><span class="line">	</span><br><span class="line">7、system/framework目录</span><br><span class="line">	Android系统所用到框架，如jar文件，XposedBridgr.jar</span><br><span class="line">	</span><br><span class="line">8、sd卡目录，不管手机有没有存储卡都会有这个目录，app操作sd卡目录需要申请权限</span><br><span class="line">	sd卡目录 /sdcard</span><br><span class="line">	这个目录有三个软连接，也就是说有四个文件夹可以访问到sd卡目录</span><br><span class="line">	/sdcard</span><br><span class="line">	/storage/self/primary</span><br><span class="line">	/mnt/sdcard</span><br><span class="line">	/storage/emulated/0</span><br></pre></td></tr></table></figure>





<h4 id="Linux权限"><a href="#Linux权限" class="headerlink" title="Linux权限"></a>Linux权限</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用 ls -l 会输出详细信息，第一个参数就是该文件的权限</span><br><span class="line"></span><br><span class="line">drwxrwx--x 2 root sdcard_rw 4096 2019-10-29 07:33 Ringtones</span><br><span class="line">-rw-rw---- 1 root sdcard_rw 31532262 2009-01-01 00:00 boot.img</span><br><span class="line"></span><br><span class="line">1、权限：</span><br><span class="line">	a、第0位确定文件类型</span><br><span class="line">		-	代表普通文件</span><br><span class="line">		l	代表链接，后面会使用 -&gt; 打印出指向的真实</span><br><span class="line">		d	代表目录，相当于Windows的文件夹</span><br><span class="line">		c	代表设备文件，鼠标、键盘 /dev</span><br><span class="line">		b	代表是块设备，比如硬盘 /dev</span><br><span class="line">	b、第1-3位确定所有者拥有该文件的权限</span><br><span class="line">	c、第4-6位确定所属组拥有该文件的权限</span><br><span class="line">	d、第7-9位确定其他用户组拥有该文件的权限</span><br><span class="line">	</span><br><span class="line">2、权限的表示方式：</span><br><span class="line">	rwx可读可写可执行  -代表没有权限</span><br><span class="line">	权限还可以用数字来表示  r=4,w=2,x=1</span><br><span class="line">	目录和文件都是有权限的，操作目录和文件都需要有对应权限才能操作</span><br><span class="line">	</span><br><span class="line">3、其他说明</span><br><span class="line">	1 ：硬连接数（有多少种方式可以访问他），文件一般是1，目录至少是2</span><br><span class="line">	root : 用户</span><br><span class="line">	root : 组</span><br><span class="line">	8 ： 文件大小（字节），如果是文件夹，显示4096字节</span><br><span class="line">	2009-01-01 00:00 ： 最后修改时间</span><br><span class="line">	boot.img ： 文件名/软连接名</span><br><span class="line">	-&gt; 软连接指向的真是文件或目录</span><br><span class="line">	</span><br><span class="line">4、chmod可以修改文件或者目录的权限</span><br><span class="line">	第一种方式： +、-、= 变更权限</span><br><span class="line">		u：所有者  g：所有组  o：其他人  a：所有人（u、g、o的总和）</span><br><span class="line">		1） chmod u=rwx,g=rx,o=x 文件/目录名</span><br><span class="line">		2） chmod o+w 文件/目录名</span><br><span class="line">		3） chmod a-x 文件/目录名</span><br><span class="line">			// a去除x权限</span><br><span class="line">	第二种方式：通过数字变更权限</span><br><span class="line">		chmod 777 xxx</span><br><span class="line">		</span><br><span class="line">	// 不是所有的目录都可以这样修改的，有些需要修改selinux策略</span><br><span class="line">	// 自己创建的文件和目录一般可以这样修改，但是系统内置文件大概率不会被修改成功</span><br><span class="line">	</span><br><span class="line">5、权限测试</span><br><span class="line">	/data/datapkgName</span><br><span class="line">		app的私有目录，该路径下的文件，通常拷贝到sdcard目录，再pull出来</span><br><span class="line">		</span><br><span class="line">	/data/local/tmp</span><br><span class="line">		一个权限比较大的临时目录，一般逆向人员喜欢保存文件在这里</span><br><span class="line">		</span><br><span class="line">	/sdcard</span><br><span class="line">		6.0以下需要清单文件里申请权限</span><br><span class="line">		6.0以上还需要代码里动态申请权限</span><br><span class="line">		10.0以后还需要清单文件里做额外设置</span><br><span class="line">		别看adb访问sdcard很容易，其实app访问这个目录还是挺麻烦的</span><br></pre></td></tr></table></figure>



<h3 id="Android开发入门"><a href="#Android开发入门" class="headerlink" title="Android开发入门"></a>Android开发入门</h3><h4 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h4><p>文字描述一下先</p>
<p>gradle -&gt; wrapper -&gt; radle-wrapper. properties 		   配置项目gradle版本</p>
<p>bui ld. gradle																		描述工程整体的编译规则</p>
<p>gradle. properties																gradle配置文件，一般无须改动</p>
<p>local.properties																	本机环境配置，SDK、NDK路径等，一般无须改动</p>
<p>settings. gradle																	 配置哪些模块在一起编译include‘:app’只编译app</p>
<p>app -&gt; build. gradle															  								描述当前模块的编译规则</p>
<p>app -&gt; build -&gt; outputs -&gt; apk -&gt; debug&#x2F;release			 								生成的apk的存储目录</p>
<p> app -&gt; build -&gt; intermediates -&gt; cmake -&gt; debug&#x2F;release -&gt; obj				 生成的so存储目录</p>
<p>libs																														   模块中使用了第三方jar的时候，会放这里快<br>src -&gt; main -&gt; cpp                                      C&#x2F;C++代码点<br>                          java									 Java代码</p>
<p>src -&gt; proguard-rules. pro						Java代码混淆规则</p>
<p>res -&gt; drawable										  用来放图片</p>
<p>res -&gt; layout											    用来放布局文件</p>
<p>res -&gt; mipmap-hdpi								   用来放应用图片，不同屏幕的适配图标</p>
<p>res -&gt; values												strings. xml、 public. xml</p>
<p>AndroidManifest. xml								清单文件，app的icon图标、四大组件的注册、权限申请</p>
<h5 id="第一级目录下的文件"><a href="#第一级目录下的文件" class="headerlink" title="第一级目录下的文件"></a>第一级目录下的文件</h5><p>外面的 <code>build.gradle</code> 是整个工程的配置，app模块内还有一个 <code>build.gradle</code></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240920165930965-1728459407956-15.png" alt="image-20240920165930965"></p>
<p>交叉编译工具 NDK</p>
<p>so是手机端的可执行文件，在电脑端编译手机端的文件，就被称为交叉编译，NDK就是开发安卓端的一个交叉编译工具</p>
<p>NDK的路径一般是默认的，不需要去指定</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240920164902502-1728459407957-17.png" alt="image-20240920164902502"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240920165414195-1728459407956-16.png" alt="image-20240920165414195"></p>
<h5 id="app项目目录"><a href="#app项目目录" class="headerlink" title="app项目目录"></a>app项目目录</h5><p><img src="/../%E5%9B%BE%E7%89%87/image-20240920174104599-1728459407957-20.png" alt="image-20240920174104599"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240920175008639-1728459407957-19.png" alt="image-20240920175008639"></p>
<h4 id="执行入口"><a href="#执行入口" class="headerlink" title="执行入口"></a>执行入口</h4><p>build.gradle配置文件</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240920181544849-1728459407957-18.png" alt="image-20240920181544849"></p>
<p>AndroidManifest.xml文件</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240920204113104-1728459407957-22.png" alt="image-20240920204113104"></p>
<blockquote>
<p>application中还有若干字节点，比如四大组件的注册<br>    <activity android:name=".MainActivity"><br>        表示这是一个界面，对应类名是当前包名路径下的MainActivity<br>        <category android:name="android.intent.category.LAUNCHER"/><br>        带有这一条的界面，是启动界面入口</p>
</blockquote>
<p>&#x3D;&#x3D;一个activity就是一个界面，name指定这个界面绑定哪个Java类&#x3D;&#x3D;</p>
<p>AndroidManifest.xml文件还会有体现最小支持的SDK版本和安卓版本，还有有申请的权限内容，上面的文件是刚创建项目时初始化的文件</p>
<h4 id="app执行入口"><a href="#app执行入口" class="headerlink" title="app执行入口"></a>app执行入口</h4><p><img src="/../%E5%9B%BE%E7%89%87/image-20240920211541098-1728459407957-21.png" alt="image-20240920211541098"></p>
<p>Application的生命周期很长，可以用来传递一些全局变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用</span><br><span class="line">public static HashMap&lt;String, String&gt; mlnfoMap = new HahMap&lt;&gt;;</span><br><span class="line">定义静态变量，别的类中直接通过类名引用</span><br></pre></td></tr></table></figure>



<h4 id="基本控件"><a href="#基本控件" class="headerlink" title="基本控件"></a>基本控件</h4><h5 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h5><p>按钮</p>
<h6 id="绑定点击事件"><a href="#绑定点击事件" class="headerlink" title="绑定点击事件"></a>绑定点击事件</h6><p>细算有四种</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、在button组件上给出Android:onClick，在这个属性上绑定一个事件，然后在页面对应的Java文件中，定义这个事件</span><br><span class="line"></span><br><span class="line">2、在button组件上的android:id属性上，给出一个id，然后通过在页面对应的Java文件中，通过binding来获取这个id的地址值，然后实现View.OnClickListener接口重写onClick方法，绑定事件成功</span><br><span class="line"></span><br><span class="line">3、第二种方法的一个变型。定义一个class类，让这个类实现View.OnClickListener接口，然后重写onClick方法，然后操作id值，只不过不需要通过匿名内部类来实例化方法，而是实例化刚刚的class类（多态）</span><br><span class="line"></span><br><span class="line">4、也是第二种方法的一个变型。不需要定义一个新的class类了，而是让现有的类实现View.OnClickListener接口，重写onClick方法，然后在这个类的内部使用</span><br><span class="line">	但是调用的方法变多了，不再是只通过匿名内部类</span><br><span class="line">	button1.setOnClickListener(new MainActivity)</span><br><span class="line">	button1.setOnClickListener(this)</span><br><span class="line">	button1.setOnClickListener(MainActivity.this)</span><br><span class="line">	</span><br><span class="line">	// 第四种方式是比较方便的一种方式</span><br></pre></td></tr></table></figure>



<p>示例一</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240920220720500-1728459407957-23.png" alt="image-20240920220720500"></p>
<p>这是最简单的一种绑定事件的方法，如果绑定的事件不小心忘写了，那么点击这个按钮的时候会直接导致系统崩溃，看到下面报错提示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Could not find method test1(View)</span><br><span class="line"></span><br><span class="line">// 找不到test1这个方法</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20240920220941679-1728459407957-24.png" alt="image-20240920220941679"></p>
<p>示例二</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240921130449725-1728459407957-25.png" alt="image-20240921130449725"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Button</span> <span class="variable">button1</span> <span class="operator">=</span> binding.button1;</span><br><span class="line">   button1.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">           Log.d(<span class="string">&quot;xiaojianbang&quot;</span>, <span class="string">&quot;test: id test&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>



<p>示例三</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240921131309219-1728459407957-26.png" alt="image-20240921131309219"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClick</span> <span class="keyword">implements</span> <span class="title class_">View</span>.OnClickListener &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;xiaojianbang&quot;</span>, <span class="string">&quot;onClick: class onClick&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">button1.setOnClickListener(<span class="keyword">new</span> <span class="title class_">MyClick</span>())</span><br></pre></td></tr></table></figure>



<p>示例四</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240921132338989-1728459407957-27.png" alt="image-20240921132338989"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接实现View.OnClickListener接口，重写onClick方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title class_">View</span>.OnClickListener &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Used to load the &#x27;demo&#x27; library on application startup.</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;xiaojianbang&quot;</span>, <span class="string">&quot;static 初始值设定项: MainActivity static&quot;</span>);</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ActivityMainBinding binding;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        Log.d(<span class="string">&quot;xiaojianbang&quot;</span>, <span class="string">&quot;static 初始值设定项: MainActivity static&quot;</span>);</span><br><span class="line"></span><br><span class="line">        binding = ActivityMainBinding.inflate(getLayoutInflater());</span><br><span class="line">        setContentView(binding.getRoot());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example of a call to a native method</span></span><br><span class="line">        <span class="type">TextView</span> <span class="variable">tv</span> <span class="operator">=</span> binding.sampleText;</span><br><span class="line">        tv.setText(stringFromJNI());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Button</span> <span class="variable">button1</span> <span class="operator">=</span> binding.button1;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 有三种调用的方式，下面哪种都行</span></span><br><span class="line">        button1.setOnClickListener(<span class="keyword">new</span> <span class="title class_">MainActivity</span>());</span><br><span class="line">        button1.setOnClickListener(<span class="built_in">this</span>);</span><br><span class="line">        button1.setOnClickListener(MainActivity.<span class="built_in">this</span>);</span><br><span class="line"><span class="comment">//        button1.setOnClickListener(new View.OnClickListener() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void onClick(View view) &#123;</span></span><br><span class="line"><span class="comment">//                Log.d(&quot;xiaojianbang&quot;, &quot;test: id test&quot;);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A native method that is implemented by the &#x27;demo&#x27; native library,</span></span><br><span class="line"><span class="comment">     * which is packaged with this application.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">stringFromJNI</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void test(View view) &#123;</span></span><br><span class="line"><span class="comment">//        Log.d(&quot;xiaojianbang&quot;, &quot;test: test test&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;xiaojianbang&quot;</span>, <span class="string">&quot;onClick: Override onClick&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>last</p>
<p>如果有多个按钮，需要区分不同的按钮</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="built_in">this</span>);</span><br><span class="line">button2.setOnClickListener(<span class="built_in">this</span>);</span><br><span class="line">button3.setOnClickListener(<span class="built_in">this</span>);</span><br><span class="line">button4.setOnClickListener(<span class="built_in">this</span>);</span><br><span class="line">button5.setOnClickListener(<span class="built_in">this</span>);</span><br><span class="line">button6.setOnClickListener(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">	<span class="comment">// 使用这个方法可以获取是传入的id</span></span><br><span class="line">	<span class="keyword">switch</span> (view,getId()) &#123;</span><br><span class="line">        <span class="keyword">case</span> R.id.button1:</span><br><span class="line">            Log.d(<span class="string">&quot;xiaojianbang&quot;</span>, <span class="string">&quot;onClick: button1&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">补：</span><br><span class="line">    <span class="comment">// switch需要常量来，直接传入R.id.button1是会报错的，所以还是使用if-else比较好</span></span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240921144326594-1728459407957-29.png" alt="image-20240921144326594"></p>
<h6 id="Toast"><a href="#Toast" class="headerlink" title="Toast"></a>Toast</h6><p>Toast是一个写好了的弹出框，现在的弹框有点丑，也可以自定义一下让他华丽一点，但是没必要</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240921144522645-1728459407957-31.png" alt="image-20240921144522645"></p>
<p>看一下定义的Toast</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Toast.makeText(MainActivity.this, &quot;点击button1&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line"></span><br><span class="line">// 使用maskeText方法，传入了三个参数</span><br><span class="line">// 第一个，设置弹出框在哪个页面内弹出</span><br><span class="line">// 第二个，设置弹出框的内容</span><br><span class="line">// 第三个，设置弹出时间，一共有两个，一个是LENGTH_SHORT，另一个是LENGTH_LONG</span><br><span class="line">// 使用maskeText方法设置好了弹出框的一些参数，然后再使用show方法来实现点击按钮，显示这个设置好的弹出框</span><br></pre></td></tr></table></figure>





<h5 id="TextView"><a href="#TextView" class="headerlink" title="TextView"></a>TextView</h5><p>顾名思义作用是添加文字</p>
<p>1、在activity_main.xml直接把这个组件拖到页面上，添加成功，使用id来操作这个组件</p>
<p>2、</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title class_">View</span>.OnClickListener &#123;</span><br><span class="line">	…………</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> TextView text;</span><br><span class="line">    <span class="comment">// 将这个变量设置为类的一个属性，方便在方法中调用</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        …………</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        text = binding.textView;</span><br><span class="line">        <span class="comment">// 根据id绑定到这个属性中</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    …………</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在重写方法onClick中，点击按钮的时候操作文字</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (view.getId() == R.id.button1) &#123;</span><br><span class="line">            Log.d(<span class="string">&quot;xiaojianbang&quot;</span>, <span class="string">&quot;onClick: button1&quot;</span>);</span><br><span class="line">            Toast.makeText(MainActivity.<span class="built_in">this</span>, <span class="string">&quot;点击button1&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            <span class="comment">// 将文字设置为你好</span></span><br><span class="line">            text.setText(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个就是TextView主要的用法</p>
<h6 id="string-xml"><a href="#string-xml" class="headerlink" title="string.xml"></a>string.xml</h6><p>看一个飘黄</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240921152201441-1728459407957-28.png" alt="image-20240921152201441"></p>
<p>找到res资源目录下的values目录的string.xml文件，定义字符串</p>
<p>引用方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在xml文件中：</span><br><span class="line">	@string/[name]</span><br><span class="line">	</span><br><span class="line">在Java文件中：</span><br><span class="line">	R.string.[name]</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20240921153209928-1728459407957-33.png" alt="image-20240921153209928"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240921153519147-1728459407957-32.png" alt="image-20240921153519147"></p>
<p>这样使用配置文件的好处非常明显，就是如果要改动字符串，只需要更改配置文件中的字符串，不需要去代码中挨个寻找</p>
<p>还可以进行汉化，开发弄其他语种的版本</p>
<h6 id="public-xml"><a href="#public-xml" class="headerlink" title="public.xml"></a>public.xml</h6><p>既然配置了字符串内容，那么在反编译中是什么样的呢</p>
<p>jadx</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240921162347280-1728459407957-30.png" alt="image-20240921162347280"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240921162049771-1728459407957-34.png" alt="image-20240921162049771"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240921163731461-1728459407957-35.png" alt="image-20240921163731461"></p>
<p>jeb</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240921163008675-1728459407957-36.png" alt="image-20240921163008675"></p>
<p>我看了一下R.java发现是读出一些东西来的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240921163147479-1728459407957-38.png" alt="image-20240921163147479"></p>
<p>对于jed，string.xml更是和activity_main.xml在同一个跟文件夹下</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240921163851305-1728459407957-37.png" alt="image-20240921163851305"></p>
<p>可以看到反编译工具并不能直接的将配置在string.xml中的字符串找出来，这个时候就需要去找public.xml这个反编译后产生的文件了，包括R.java文件也是反编译后产生的</p>
<p>找到public.xml文件，一般是和string.xml在同一目录下</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240921164523066-1728459407957-39.png" alt="image-20240921164523066"></p>
<h5 id="EditText"><a href="#EditText" class="headerlink" title="EditText"></a>EditText</h5><p>输入框</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240921165212598-1728459407957-40.png" alt="image-20240921165212598"></p>
<p>这个进行的一些简单操作和TextView很相似，不再进行演示了</p>
]]></content>
      <categories>
        <category>逆向学习</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向学习 0x02frida环境配置和抓包工具</title>
    <url>/2024/10/09/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-0x02-frida%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h3 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h3><p>抓包就是在客户端和服务端之间，再加上一个代理服务器，这个代理服务器可以拦截发送的数据包，对数据包进行查看、操作、放行</p>
<span id="more"></span>

<h4 id="抓包工具的分类"><a href="#抓包工具的分类" class="headerlink" title="抓包工具的分类"></a>抓包工具的分类</h4><table>
<thead>
<tr>
<th>工具</th>
<th>工具</th>
</tr>
</thead>
<tbody><tr>
<td>全局抓包工具</td>
<td>&#x3D;&#x3D;Http v7&#x3D;&#x3D;、Http debugger pro</td>
</tr>
<tr>
<td>代理抓包工具</td>
<td>&#x3D;&#x3D;Charles&#x3D;&#x3D;、Fiddler</td>
</tr>
<tr>
<td>VPN抓包工具</td>
<td>&#x3D;&#x3D;HttpCanary&#x3D;&#x3D;</td>
</tr>
<tr>
<td>网卡抓包工具</td>
<td>&#x3D;&#x3D;WireShark&#x3D;&#x3D;</td>
</tr>
<tr>
<td>手机抓包工具</td>
<td>tcpdump</td>
</tr>
<tr>
<td>Hook抓包工具</td>
<td>&#x3D;&#x3D;r0Capture&#x3D;&#x3D;</td>
</tr>
</tbody></table>
<h4 id="Charles"><a href="#Charles" class="headerlink" title="Charles"></a>Charles</h4><h5 id="下载安装激活"><a href="#下载安装激活" class="headerlink" title="下载安装激活"></a>下载安装激活</h5><p>Charles免费激活：<a href="https://zzzmode.com/mytools/charles/">https://zzzmode.com/mytools/charles/</a></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240921194140576.png" alt="image-20240921194140576"></p>
<h5 id="抓包手机"><a href="#抓包手机" class="headerlink" title="抓包手机"></a>抓包手机</h5><p>Charles如何抓包手机呢，Charles安装在电脑上，抓包手机就相当于抓包另一台电脑，需要一些配置</p>
<p>设置一个端口，找到IP地址</p>
<p>将SOCKS代理打开</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240921194239724.png" alt="image-20240921194239724"></p>
<p>IP地址</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240922113129896.png" alt="image-20240922113129896"></p>
<p>使用VPN软件链接主机的IP的指定端口，将IP地址和端口配置给SocksDroid然后打开，成功之后会有一个VPN样式</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240922113345398.png" alt="image-20240922113345398"></p>
<p>还可以更改模拟器WiFi的IP地址和端口，手动更改WiFi的代理服务器主机和端口，让主机Charles监听的端口作为代理端口，这个时候就不能使用SOCKS协议端口了，需要配置http端口</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240922120529680.png" alt="image-20240922120529680"></p>
<p>关闭对Windows电脑的抓包</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240922113521041.png" alt="image-20240922113521041"></p>
<p>现在不能抓到https，所以还需要一些配置</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240922130034633.png" alt="image-20240922130034633"></p>
<p>打开 <code>Proxy</code>  -&gt; <code>SSL Proxying Setting</code> </p>
<p>为了方便可以给第一个配置两个*。Exclude是设置排除的不用管</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240922130628823.png" alt="image-20240922130628823"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240922122453735.png" alt="image-20240922122453735"></p>
<p>在模拟器中访问：<a href="http://chls.pro/ssl">http://chls.pro/ssl</a></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240922122836182.png" alt="image-20240922122836182"></p>
<h5 id="证书不安全问题"><a href="#证书不安全问题" class="headerlink" title="证书不安全问题"></a>证书不安全问题</h5><p>一般来说这就已经成功了，但我测试的时候没有数据，而且还提示证书不安全</p>
<p>因为在安卓7之后系统只信任系统证书，需要把用户证书移动到系统证书目录</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240922111754491.png" alt="image-20240922111754491"></p>
<p>这些解析的https数据也是错误</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240922143043094.png" alt="image-20240922143043094"></p>
<p>这个时候需要找到证书的目录了，将安装的证书，放到受信任证书的目录下</p>
<p>模拟器就设置可以写入和开启root</p>
<p>如果是真机的话就需要Magisk中的模块来移动证书了，没有真机不做演示了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240922143225653.png" alt="image-20240922143225653"></p>
<p>找到 &#x2F;data&#x2F;misc&#x2F;user&#x2F;0&#x2F;cacerts-added 这个目录，如果安装了证书这里会有一共 .0 文件，将这个文件移动&#x2F;复制到 &#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts 目录下</p>
<p>这个名字是根据哈希计算的，后面加 .0 如果是哈希值存在一样的就是 .0 .1</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240923083755266.png" alt="image-20240923083755266"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240922143507596.png" alt="image-20240922143507596"></p>
<p>现在再进行抓包即可获取到解密后的数据</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240922143600370.png" alt="image-20240922143600370"></p>
<p>如此如此这般这般，Charles抓包手机就完成了</p>
<h4 id="HttpCanary"><a href="#HttpCanary" class="headerlink" title="HttpCanary"></a>HttpCanary</h4><p>这是一个VPN抓包工具相当于上面Charles和socksdroid的组合，而且他比Charles和socksdroid的组合好用，抓包更多，解析更多</p>
<p>HttpCanary可以按照引导直接将证书移动到安全目录下，如果不能移动的话，参考上方的方法</p>
<p>配置完成就可以使用了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240923084831676.png" alt="image-20240923084831676"></p>
<h4 id="r0capture"><a href="#r0capture" class="headerlink" title="r0capture"></a>r0capture</h4><p>一个Hook抓包脚本，主要原理就是Hook了一些SSL相关的系统函数，直接抓取系统发送的一些明文数据</p>
<p>这个东西是开源的，可以抓取大部分按照框架写的app，如果有魔改的就需要有一定的逆向能力了</p>
<p>GitHup地址：<a href="https://github.com/r0ysue/r0capture">https://github.com/r0ysue/r0capture</a></p>
<h5 id="配置hook"><a href="#配置hook" class="headerlink" title="配置hook"></a>配置hook</h5><h6 id="下载frida"><a href="#下载frida" class="headerlink" title="下载frida"></a>下载frida</h6><p>因为r0capture是一个python脚本，需要python3.6以上的环境，下载几个python库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install frida-tools</span><br><span class="line">pip install loguru click</span><br><span class="line">pip install hexdump</span><br></pre></td></tr></table></figure>



<p>配置好本地Frida之后，查看frida版本，查看手机cpu类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frida --version</span><br><span class="line"></span><br><span class="line">adb shell</span><br><span class="line">getprop ro.product.cpu.abi</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241007204055440.png" alt="image-20241007204055440"></p>
<h6 id="配置frida-server"><a href="#配置frida-server" class="headerlink" title="配置frida-server"></a>配置frida-server</h6><p>去下载对应版本的对应类型的frida-server</p>
<p><a href="https://github.com/frida/frida/releases">https://github.com/frida/frida/releases</a></p>
<p>下载对应版本下载到手机的 <code>/data/local/tmp/</code> 目录下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进入手机端命令：adb shell</span><br><span class="line">切换获取手机的root权限：Su</span><br><span class="line">查找文件是否在手机中：cd/data/local/tmp/</span><br><span class="line">查看路径下的文件并看文件的权限：Is-l</span><br><span class="line">拥有root权限更改文件的权限为777： chmod 777 frida-server-16.5.2-android-x86</span><br><span class="line">在手机中启动运行该文件：./frida-server-14.0.5-android-x86 &amp;</span><br><span class="line">电脑运行检查手机端服务是否开启成功：frida-ps-U</span><br><span class="line">windows运行端口转发到PC：adbforward tcp:27043 tcp:27043</span><br></pre></td></tr></table></figure>



<p>执行 <code>frida-ps-U</code> 成功效果如下</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241007212139483.png" alt="image-20241007212139483"></p>
<p>执行上方语法出现一下情况</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241007212238664.png" alt="image-20241007212238664"></p>
<blockquote>
<p>attach模式是选择app在你感兴趣的地方开始抓包。</p>
<p>apawn模式是系统开始抓包，从打开app开始</p>
<p>使用r0capture抓取的是明文内容，因此并不需要证书</p>
</blockquote>
<p>END</p>
<h5 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h5><p>r0capture有两种使用方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">attach模式，抓包内容可以保存为pacp文件供后续分析</span><br><span class="line">	python r0capture.py -U com.qiyi.video -v -p iqiyi.pcap</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">apawn模式</span><br><span class="line">	python r0capture.py -U -f com.qiyi.video -v -p iqiyi.pcap</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">-p：保存为pacp文件</span><br><span class="line">-f：frida启动这个apk开始抓包</span><br></pre></td></tr></table></figure>



<h3 id="抓包原理"><a href="#抓包原理" class="headerlink" title="抓包原理"></a>抓包原理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、为什么Charles要配合socksdroid使用</span><br><span class="line">	VPN的开关比设置手动代理更加方便</span><br><span class="line">	有些app不走HTTP代理，有些机型http代理不生效（雷电4），VPN代理是可以让所有的流量强制走VPN</span><br><span class="line">	能抓到更全的流量（TCP	UDP）</span><br><span class="line">	OSI七层模型：IP协议、UDP协议、TCP协议、SSL协议、HTTP协议</span><br><span class="line">	</span><br><span class="line">2、对称加密算法：</span><br><span class="line">	典型：AES</span><br><span class="line">	特点：</span><br><span class="line">    	加密解密都是用一个密钥</span><br><span class="line">		加密速度快，可以加密大量数据</span><br><span class="line">		</span><br><span class="line">3、RSA算法(非对称加密算法)</span><br><span class="line">	特点：</span><br><span class="line">		加密和解密使用不同的密钥</span><br><span class="line">		有一个密钥对  公钥  私钥————公钥加密只能私钥解密，私钥加密只能公钥解密</span><br><span class="line">		从公钥无法推导出私钥</span><br><span class="line">		加密速度慢，加密数据有限——————1024公钥，在pkcslpadding  加密117个字节，在nopadding 加密128个字节</span><br><span class="line">		</span><br><span class="line">	如此涉及到了一个应用，RSA算法加密数据有限，可以在本地随机生成一个对称加密的密钥A，然后使用RSA算法加密A，得到密文B，密文B提交给服务器，服务器使用私钥解密，得到了明文A，在后续的通讯过程中使用明文A来进行对称解密</span><br></pre></td></tr></table></figure>

<img src="../图片/image-20241008090108833.png" alt="image-20241008090108833" style="zoom:50%;" />





<p>访问一个链接之后就会返回一个证书，包含RSA的公钥</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241008085839408.png" alt="image-20241008085839408"></p>
<p>这个时候在加上抓包工具的代理服务端考虑一下</p>
<p>未安装证书之前也能够抓包，但是是加密后的数据，这样一看是不是可以理解一些了</p>
<p>代理服务端，作为客户端和服务端的中间人，这个中间人要获取抓包数据的话需要先安装一个证书。</p>
<p>先伪造一个公钥发送给客户端，客户端将加密后的对称密钥返回给代理抓包服务端，这个服务端获取到密钥之后，就可以读取到后续客户端和服务端之间的通讯</p>
<blockquote>
<p>浏览器是不能辨别真实的服务端和代理服务端的</p>
<p>但是之前配置证书时，还需要信任证书，提示不安全什么的。</p>
<p>浏览器检验的是证书路径&#x2F;证书链</p>
<p>最后找到这个根证书，就是自己给自己颁发的一个证书。那么为什么这个证书安全呢</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241008092716033.png" alt="image-20241008092716033"></p>
<p>就是因为在受信任的根证书颁发机构下，如果这个系统库有的证书，浏览器就认为是安全的，就不会有提示</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241008110949000.png" alt="image-20241008110949000"></p>
</blockquote>
<p>但是呢，如果APP端和服务端是同一个团队开发的，开发过程中一般会设置双向验证来验证证书</p>
<h4 id="为什么不直接替换证书信息呢"><a href="#为什么不直接替换证书信息呢" class="headerlink" title="为什么不直接替换证书信息呢"></a>为什么不直接替换证书信息呢</h4><p>这个就涉及到证书的签名信息了</p>
<p>数字证书包含信息：使用者、颁发者、有效期、公钥、指纹、&#x3D;&#x3D;签名信息&#x3D;&#x3D;</p>
<p>用户发送信息的时候会使用数字签名算法 如：<code>md5withrsa、sha1withrsa、sha256withrsa</code> ，在是把两个算法组合在一起</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用：</span><br><span class="line">String signStr = Signature_.getSignature(&quot;hello world&quot;)</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241008113055431.png" alt="image-20241008113055431"></p>
<p>在服务端的视角上，因为服务端签发的证书嘛。</p>
<p>这个会输出一个值，这个值是字符串先进行sha256的一个加密，然后进行的RSA私钥加密。发送数据的时候发送的是明文+数字签名加密后的数据。如果更改了明文，使用公钥解密后，在对明文sha256比对结果，会比对失败。</p>
<p>因此，证书是不能够伪造的，不能改变，否则sha256的值也变，校验就会失败，无法正常通信</p>
<p>这个的重点在于，RSA的加密签名信息无法更改，这就断绝了更改证书的可行性，除非你能拿到服务端的私钥</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241008114414345.png" alt="image-20241008114414345"></p>
<h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><h5 id="常规协议头"><a href="#常规协议头" class="headerlink" title="常规协议头"></a>常规协议头</h5><p>协议头有请求头和响应头两种</p>
<p>协议头包含起始行、首部字段、包体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//访问方式资源路径和GET参数 协议/版本号</span><br><span class="line">GET /v2/getpublickey?x=100&amp;y=200 HTTP/1.1</span><br><span class="line">//主机名</span><br><span class="line">Host: passport.xxxxx.com</span><br><span class="line">//浏览器接受数据类型</span><br><span class="line">Accept: */*</span><br><span class="line">//表示长连接</span><br><span class="line">Connection: keep-alive</span><br><span class="line">//浏览器接受的语言</span><br><span class="line">Accept-Language: zh-CN, zh; q=0.8,en-US; q=0.5,en; q=0.3 </span><br><span class="line">//浏览器支持的编码，一般附加协议头的时候删掉</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">//用户代理，服务器可以根据这个来识别是哪个浏览器</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; w0W64; rv:48.0) Gecko/20100101 Firefox/48.0</span><br><span class="line">//来路，GET和POST中都会出现，表示这个请求是从哪个页面发出的，可能会有会变化的值要特别注意</span><br><span class="line">Referer: https://www. xxxxx. com/?user=123456&amp;pwd=1212121</span><br><span class="line">// cookie在安卓端很少见，表示身份信息的在get或者post请求内</span><br><span class="line">Cookie:XXXXXID=4A89DBBC382B25D9A43D12C4AB0151FD:FG=1</span><br></pre></td></tr></table></figure>



<p><code>GET /v2/getpublickey?x=100&amp;y=200 HTTP/1.1 </code> ：就是起始行包含了一个GET传参方式和HTTP协议以及版本号，中间的资源路径是相对路径，要和下方的Host拼接成完整的路径</p>
<p><code>Accept: */*</code> ：如果是 <code>*/*</code> 表示所有的数据都能接收</p>
<p><code>Accept-Language</code> ：这个包含的q值越大表示比重越大</p>
<p><code>User-Agent: Mozilla/5.0 (Windows NT 6.1; w0W64; rv:48.0) Gecko/20100101 Firefox/48.0</code> ：以下的表示为浏览器的返回，和apk返回不太一样，如果apk返回了这样的代理可能是app是个H5app，内置了html页面。这也是一个判断小技巧</p>
<p>上面是GET，POST比GET多几个东西</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//提交的数据包的长度不能多也不能少一个字节winhttp自动生成可以不附加</span><br><span class="line">Content-Length: 22</span><br><span class="line">//提交数据的类型</span><br><span class="line">Content-Type: application/x-www-form-ur lencoded; charset=UTF-8</span><br><span class="line">//POST提交的数据和协议头之间有一个空行</span><br><span class="line">user=123456&amp;pwd=654321</span><br></pre></td></tr></table></figure>



<h5 id="自定义协议头"><a href="#自定义协议头" class="headerlink" title="自定义协议头"></a>自定义协议头</h5><p>这里的sign、t、qyid都是自定义的协议头，如果要更改的话，不要更改他的位置。有些网站会在协议头里传递重要数据，并且一般是会变化的。如果网站监测，就要找到来源，附加协议头提交</p>
<img src="../图片/image-20241008144745638.png" alt="image-20241008144745638" style="zoom:50%;" />



<h5 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h5><p>这个简单了解一下进行，因为安卓中cookie使用不多。了解即可，最后没办法再考虑这个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、cookie的分类</span><br><span class="line">	服务器返回  Set-cookie</span><br><span class="line">	本地代码生成</span><br><span class="line">	</span><br><span class="line">2、cookie的作用</span><br><span class="line">	识别身份(验证码)</span><br><span class="line">	判断是否登录状态</span><br><span class="line">	</span><br><span class="line">3、cookie的结构</span><br><span class="line">	名1=值1; 名2=值2; 名3=值3</span><br><span class="line">	</span><br><span class="line">4、合并更新步骤</span><br><span class="line">	a、新cookie，去除无效cookie</span><br><span class="line">	b、在新cookie里，寻找是否存在旧cookie的名字，存在就用新的，丢掉旧的</span><br><span class="line">	c、两cookie组合到一个文本型变量中</span><br><span class="line">	</span><br><span class="line">5、前端会用JS生成很多cookie，但是并非所有cookie都会检测</span><br><span class="line">	比如Hm_lvt开头的一般没啥用</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>逆向学习</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向学习 0x04开始hook</title>
    <url>/2024/10/10/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-0x04-%E5%BC%80%E5%A7%8Bhook/</url>
    <content><![CDATA[<h3 id="hook"><a href="#hook" class="headerlink" title="hook"></a>hook</h3><p>Java层的代码hook可以写js，但是方法定义方式不同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Java.perform(function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>仍然去找之前案例的登录方法，找到两个方法</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241009155711445.png" alt="image-20241009155711445"></p>
<p>使用hook来确定到底执行了哪个登录方法</p>
<p>编写JS</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果是Java hook代码，都放在perform中</span></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 获取到相应的类</span></span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">JsonRequest</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.dodonew.online.http.JsonRequest&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;JsonRequest:&quot;</span> + <span class="title class_">JsonRequest</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hook类中的paraMap方法</span></span><br><span class="line">    <span class="title class_">JsonRequest</span>.<span class="property">paraMap</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// paraMap方法传入了一个参数，就给一个参数，打印出来看看</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;paraMap传入的参数：&quot;</span> + a)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用原来的paraMap方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">paraMap</span>(a)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有返回值就return，void就不用return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">JsonRequest</span>.<span class="property">addRequestMap</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.util.Map&#x27;</span>,<span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// addRequestMap方法传入了两个参数，打印出来看看</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;addRequestMap传入的参数1：&quot;</span> + a)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;addRequestMap传入的参数2：&quot;</span> + b)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用原来的addRequestMap方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">addRequestMap</span>(a, b)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有返回值就return，void就不用return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>在手机上执行这个js</p>
<p>先启动hook</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241009173459202.png" alt="image-20241009173459202"></p>
<p>启动成功就是光标一直闪，挂起他，不用管</p>
<p>使用frida命令来执行这个JS，可以看到，在进行登录操作的时候执行的方法是addRequestMap方法</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241009173357970.png" alt="image-20241009173357970"></p>
<p>这个是hook的一个简单应用，将代码注入到相应的进程中</p>
<h4 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h4><p>启动问题：</p>
<p>1、确定手机上的frida-server的版本和电脑上frida版本一致</p>
<p>2、确定是否有权限，赋予权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 777 frida</span><br></pre></td></tr></table></figure>

<p>3、提示已经开启过frida-server，无法正常启动，杀进程解决</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill frida-server</span><br></pre></td></tr></table></figure>



<p>模拟器问题：</p>
<p>1、当时我开了USB调试的，可能设置密码之后给关闭了，一直没注意，怎么执行都执行不了，一看是模拟器的开发者模式没开，打开开发模式，开启USB调试</p>
<p>2、虽然说 -U 是USB连接，但是使用模拟器执行 -U 也是没问题的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frida -UF -l js文件路径</span><br></pre></td></tr></table></figure>

<p>3、通过usb连接真机不需要转发端口，通过ip连接需要转发，连接模拟器也需要转发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb forward tcp:27042 tcp:27042</span><br></pre></td></tr></table></figure>



<h4 id="一些注意"><a href="#一些注意" class="headerlink" title="一些注意"></a>一些注意</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、找到一些疑似关键函数，可以通过hook来确认app执行某个操作的时候，是否调用了他们</span><br><span class="line"></span><br><span class="line">2、如果没有触发这些函数，考虑以下问题</span><br><span class="line">	a) app在执行这个操作的时候，真的没有调用这个函数，换一个其他的关键函数</span><br><span class="line">	b) 代码写错了，导致hook函数没执行</span><br><span class="line">	c) 一般可以通过主动调用上层函数，来触发这些hook函数</span><br><span class="line">	</span><br><span class="line">3、如果触发了这些函数，可以通过hook来打印执行过程中传入函数的参数和返回值</span><br><span class="line"></span><br><span class="line">4、frida -U -F -l 1.js</span><br><span class="line">	-U 代表远程USB设备</span><br><span class="line">	-F 代表附加到最前面这个app</span><br><span class="line">	-l 后面指明需要加载的JS脚本</span><br><span class="line">	-f 指明附加的进程名</span><br><span class="line">	</span><br><span class="line">5、写好的js脚本要注入手机端，并不是在Node.js中使用，所以只能用v8和fridaAPl支持的代码</span><br></pre></td></tr></table></figure>



<h4 id="继续hook"><a href="#继续hook" class="headerlink" title="继续hook"></a>继续hook</h4><p>上面只是简单的打印，打印出来的还是[object]，没有真正读取到内容，继续找字段，获取内容，可以看到这里将两个字段传入了addRequestMap方法中，将这两个打印出来</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241009185105967.png" alt="image-20241009185105967"></p>
<p>注意要使用 变量名.get 不能直接点，否则为 undefined 。</p>
<p>因为function接收到的a属于是Java类型，只能使用Java中的方法。而这里指定的类型是Map接口，意味着是不能直接使用toString()来输出的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">JsonRequest</span>.<span class="property">addRequestMap</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.util.Map&#x27;</span>,<span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// addRequestMap方法传入了两个参数，打印出来看看</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;addRequestMap传入的参数1：&quot;</span> + a)</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">get</span>(<span class="string">&quot;username&quot;</span>))</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">get</span>(<span class="string">&quot;userPwd&quot;</span>))</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;addRequestMap传入的参数2：&quot;</span> + b)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 调用原来的addRequestMap方法</span></span><br><span class="line">       <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">addRequestMap</span>(a, b)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果有返回值就return，void就不用return</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>打印出结果</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241009185355960.png" alt="image-20241009185355960"></p>
<p>如果要使用toString()来输出的话也不是不可以，这就涉及到多态了，需要做一个向下转型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">	<span class="title class_">JsonRequest</span>.<span class="property">addRequestMap</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.util.Map&#x27;</span>,<span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// addRequestMap方法传入了两个参数，打印出来看看</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;addRequestMap传入的参数1：&quot;</span> + a)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下转型</span></span><br><span class="line">        <span class="keyword">var</span> map = <span class="title class_">Java</span>.<span class="title function_">cast</span>(a, <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.util.HashMap&quot;</span>));</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">toString</span>())</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;addRequestMap传入的参数2：&quot;</span> + b)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用原来的addRequestMap方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">addRequestMap</span>(a, b)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有返回值就return，void就不用return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Java.cast进行转型，第一个参数给要转型的变量，第二个参数给要转到的类型，需要的数据是class类型，所以需要Java.use</span></span><br></pre></td></tr></table></figure>



<p>这样就可以成功打印了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241009192739762.png" alt="image-20241009192739762"></p>
<p>然而到现在为止，还没有找到加密的数据，继续向下分析</p>
<img src="../图片/image-20241008213436432-1728546484688-1.png" alt="image-20241008213436432" style="zoom:50%;" />



<p><img src="/../%E5%9B%BE%E7%89%87/image-20241009193849686.png" alt="image-20241009193849686"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241009200420640.png" alt="image-20241009200420640"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> utils = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.dodonew.online.util.Utils&quot;</span>)</span><br><span class="line"></span><br><span class="line">  utils.<span class="property">md5</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;md5传入的参数：&quot;</span> + a)</span><br><span class="line">      <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">md5</span>(a)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;md5返回值：&quot;</span> + result)</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>可以看到传入的数据，前两个很显然是固定的，然后是时间戳，账号密码，后面还有一个key值，多次测试发现他也是固定的，发现key值，包有用的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241009201246501.png" alt="image-20241009201246501"></p>
<p>key为定值</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241009202427897.png" alt="image-20241009202427897"></p>
<p>经测试这个md5也是一个标准的md5</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241009202623832.png" alt="image-20241009202623832"></p>
<p>继续向下</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241009203245578.png" alt="image-20241009203245578"></p>
<p>继续hook</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var Reques = Java.use(&quot;com.dodonew.online.http.RequestUtil&quot;)</span><br><span class="line">   </span><br><span class="line">   Reques.encodeDesMap.overload(&#x27;java.lang.String&#x27;, &#x27;java.lang.String&#x27;, &#x27;java.lang.String&#x27;).implementation = function(a,b,c) &#123;</span><br><span class="line">       </span><br><span class="line">       console.log(&quot;encodeDesMap传入的参数：&quot;+a+&quot;,&quot;+b+&quot;,&quot;+c)</span><br><span class="line">       var result = this.encodeDesMap(a,b,c)</span><br><span class="line">       console.log(&quot;encodeDesMap返回值：&quot;+result)</span><br><span class="line">       return result</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>可以看到三个参数分别为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;equtype&quot;:&quot;ANDROID&quot;,&quot;loginImei&quot;:&quot;Android358523029800728&quot;,&quot;sign&quot;:&quot;8D44FC2EB51F27C6B828BB617EC9EC20&quot;,&quot;timeStamp&quot;:&quot;1728477083894&quot;,&quot;userPwd&quot;:&quot;123123123&quot;,&quot;username&quot;:&quot;13112345678&quot;&#125;</span><br><span class="line">65102933</span><br><span class="line">32028092</span><br><span class="line"></span><br><span class="line">虽然说key和IV也可以根据代码分析找到，但是可能存在热修复的情况，能hook还是hook</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241009210422351.png" alt="image-20241009210422351"></p>
<p>分析这些代码可以分析出来，最后的返回值是byte数组经过base64加密的，解密出来是乱码的，而且这个byte数组是经过DES对称加密，他的key和IV在InitCipher方法中处理了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241009210453484.png" alt="image-20241009210453484"></p>
<p>继续分析key和IV，hook <code>javax.crypto.spec.DESKeySpec</code> 这个方法是系统方法，但是也可以hook</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dDESKeySpec = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;javax.crypto.spec.DESKeySpec&quot;</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 值得注意的是，使用的是其构造方法，所以表示方法的时候就要使用 $init 来表示构造方法</span></span><br><span class="line">   dDESKeySpec.<span class="property">$init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a</span>) &#123;</span><br><span class="line">       </span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;DESKeySpec传入的参数：&quot;</span>+a)</span><br><span class="line">       <span class="keyword">var</span> result = <span class="variable language_">this</span>.$init(a)</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;DESKeySpec返回值：&quot;</span>+result)</span><br><span class="line">       <span class="keyword">return</span> result</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>这里成功输出了byte数组的内容，如果不成功的话，还可以进行fridahook函数构造</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241009212747402.png" alt="image-20241009212747402"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> base64 = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Base64&quot;</span>)</span><br><span class="line">   <span class="keyword">var</span> dDESKeySpec = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;javax.crypto.spec.DESKeySpec&quot;</span>)</span><br><span class="line"></span><br><span class="line">   dDESKeySpec.<span class="property">$init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a</span>) &#123;</span><br><span class="line">       </span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;DESKeySpec传入的参数：&quot;</span>+a)</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;params&quot;</span>, base64.<span class="title function_">encodeToString</span>(a,<span class="number">0</span>))</span><br><span class="line">       <span class="keyword">var</span> result = <span class="variable language_">this</span>.$init(a)</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;DESKeySpec返回值：&quot;</span>+result)</span><br><span class="line">       <span class="keyword">return</span> result</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>将其转换为base64字符串输出，再进行解码获取字节</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241009213612245.png" alt="image-20241009213612245"></p>
<h4 id="总结API"><a href="#总结API" class="headerlink" title="总结API"></a>总结API</h4><table>
<thead>
<tr>
<th>API</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Java.use</td>
<td>获取一个Java的类</td>
</tr>
<tr>
<td>Java.cast</td>
<td>强转某个数据的数据类型</td>
</tr>
<tr>
<td>$init</td>
<td>指构造函数</td>
</tr>
<tr>
<td>.implementation</td>
<td>执行函数</td>
</tr>
</tbody></table>
<h4 id="算法复现"><a href="#算法复现" class="headerlink" title="算法复现"></a>算法复现</h4><p>以上操作只是了解了大题的加密流程</p>
<p>利用JS代码来模拟复现加密后的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NIszaqFPos1vd0pFqKlB42Np5itPxaNH//FDsRnlBfgL4lcVxjXii3YDM4Ldj62VpjjNQTngbACPLo2OP5oJEUP2uHky2gXh1XxeGRPcoZdFd4azu5U7k+Y7XTZH76IREt+HpFXupG8d63zw+ofK/XyuC0fLQmg8VPPASfP0NU3goG2EBcncto3VohIjavtyt0lQ2dkwXzsQmg9WJdSP4/FazKBwf2c1JgpoKWXi5pg=</span><br></pre></td></tr></table></figure>



<p>加密流程如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先加密了数据</span><br><span class="line">equtype=ANDROID&amp;loginImei=Android358523029800728&amp;timeStamp=&quot; +time+&quot;&amp;userPwd=&quot; +pwd+ &quot;&amp;username=&quot;+user+&quot;&amp;key=sdlkjsdljf0j2fsjk</span><br><span class="line">其中有三个不是固定的，时间戳，账号和密码，取出这三个值，写一个方法</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 别忘了下载crypto-js</span><br><span class="line">npm install crypto-js</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sign值是一个MD5值，所以先进行MD5加密</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSign</span>(<span class="params">user, pwd, time</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="string">&quot;equtype=ANDROID&amp;loginImei=Android358523029800728&amp;timeStamp=&quot;</span> +time+</span><br><span class="line">                <span class="string">&quot;&amp;userPwd=&quot;</span> +pwd+ <span class="string">&quot;&amp;username=&quot;</span>+user+<span class="string">&quot;&amp;key=sdlkjsdljf0j2fsjk&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">CryptoJS</span>.<span class="title class_">MD5</span>(data).<span class="title function_">toString</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这样就获取到了下一个需要加密的明文数据的sign值</p>
<p>注意hook出来的MD5是大写，需要对sign值进行大写处理</p>
<p>然后难点就是处理解析key和iv值了</p>
<p>key值经过MD5加密之后得到32位十六进制，为确保16位密钥，将32位的十六进制数进行hex解密，得到16位</p>
<p>iv值只有8位，进行utf-8解析，得到16位</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟DES加密</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">encodeDesMap</span>(<span class="params">user, pwd</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加工明文</span></span><br><span class="line">    <span class="comment">// var time = new Date().getTime();</span></span><br><span class="line">    <span class="keyword">var</span> time = <span class="string">&quot;1728480847190&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> sign = <span class="title function_">getSign</span>(user, pwd, time).<span class="title function_">toUpperCase</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> data = <span class="string">&#x27;&#123;&quot;equtype&quot;:&quot;ANDROID&quot;,&quot;loginImei&quot;:&quot;Android358523029800728&quot;,&quot;sign&quot;:&quot;&#x27;</span></span><br><span class="line">                +sign+<span class="string">&#x27;&quot;,&quot;timeStamp&quot;:&quot;&#x27;</span>+ time +<span class="string">&#x27;&quot;,&quot;userPwd&quot;:&quot;&#x27;</span> + pwd+<span class="string">&#x27;&quot;,&quot;username&quot;:&quot;&#x27;</span> +user+ <span class="string">&#x27;&quot;&#125;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 密钥和向量，原算法中key和iv也是经过处理的</span></span><br><span class="line">    <span class="comment">// 解析key值</span></span><br><span class="line">    <span class="keyword">var</span> keyMD5 = <span class="title class_">CryptoJS</span>.<span class="title class_">MD5</span>(<span class="string">&quot;65102933&quot;</span>).<span class="title function_">toString</span>();</span><br><span class="line">    <span class="keyword">var</span> _key = <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Hex</span>.<span class="title function_">parse</span>(keyMD5);</span><br><span class="line">    <span class="comment">// 解析iv值</span></span><br><span class="line">    <span class="keyword">var</span> _iv = <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(<span class="string">&quot;32028092&quot;</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">CryptoJS</span>.<span class="property">DES</span>.<span class="title function_">encrypt</span>(data, _key, &#123;</span><br><span class="line">        <span class="attr">iv</span>: _iv,</span><br><span class="line">        <span class="attr">mode</span>: <span class="title class_">CryptoJS</span>.<span class="property">mode</span>.<span class="property">CBC</span>,</span><br><span class="line">        <span class="attr">padding</span>: <span class="title class_">CryptoJS</span>.<span class="property">pad</span>.<span class="property">Pkcs7</span></span><br><span class="line">    &#125;).<span class="title function_">toString</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>输出结果如下，如此一来就脱离了app，模拟出来了app发出去的包的加密数据，加密算法复现成功。</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241010112932978.png" alt="image-20241010112932978"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CryptoJS</span> = <span class="built_in">require</span>(<span class="string">&#x27;crypto-js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sign值是一个MD5值，所以先进行MD5加密</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSign</span>(<span class="params">user, pwd, time</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="string">&quot;equtype=ANDROID&amp;loginImei=Android358523029800728&amp;timeStamp=&quot;</span> +time+</span><br><span class="line">                <span class="string">&quot;&amp;userPwd=&quot;</span> +pwd+ <span class="string">&quot;&amp;username=&quot;</span>+user+<span class="string">&quot;&amp;key=sdlkjsdljf0j2fsjk&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">CryptoJS</span>.<span class="title class_">MD5</span>(data).<span class="title function_">toString</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">encodeDesMap</span>(<span class="params">user, pwd</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加工明文</span></span><br><span class="line">    <span class="comment">// var time = new Date().getTime();</span></span><br><span class="line">    <span class="keyword">var</span> time = <span class="string">&quot;1728480847190&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> sign = <span class="title function_">getSign</span>(user, pwd, time).<span class="title function_">toUpperCase</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> data = <span class="string">&#x27;&#123;&quot;equtype&quot;:&quot;ANDROID&quot;,&quot;loginImei&quot;:&quot;Android358523029800728&quot;,&quot;sign&quot;:&quot;&#x27;</span></span><br><span class="line">                +sign+<span class="string">&#x27;&quot;,&quot;timeStamp&quot;:&quot;&#x27;</span>+ time +<span class="string">&#x27;&quot;,&quot;userPwd&quot;:&quot;&#x27;</span> + pwd+<span class="string">&#x27;&quot;,&quot;username&quot;:&quot;&#x27;</span> +user+ <span class="string">&#x27;&quot;&#125;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 密钥和向量，原算法中key和iv也是经过处理的</span></span><br><span class="line">    <span class="comment">// 解析key值</span></span><br><span class="line">    <span class="keyword">var</span> keyMD5 = <span class="title class_">CryptoJS</span>.<span class="title class_">MD5</span>(<span class="string">&quot;65102933&quot;</span>).<span class="title function_">toString</span>();</span><br><span class="line">    <span class="keyword">var</span> _key = <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Hex</span>.<span class="title function_">parse</span>(keyMD5);</span><br><span class="line">    <span class="comment">// 解析iv值</span></span><br><span class="line">    <span class="keyword">var</span> _iv = <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(<span class="string">&quot;32028092&quot;</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">CryptoJS</span>.<span class="property">DES</span>.<span class="title function_">encrypt</span>(data, _key, &#123;</span><br><span class="line">        <span class="attr">iv</span>: _iv,</span><br><span class="line">        <span class="attr">mode</span>: <span class="title class_">CryptoJS</span>.<span class="property">mode</span>.<span class="property">CBC</span>,</span><br><span class="line">        <span class="attr">padding</span>: <span class="title class_">CryptoJS</span>.<span class="property">pad</span>.<span class="property">Pkcs7</span></span><br><span class="line">    &#125;).<span class="title function_">toString</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">encodeDesMap</span>(<span class="string">&quot;13112345678&quot;</span>, <span class="string">&quot;123123123&quot;</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>算法复现：</p>
<p>​	利用hook出来的信息，来进行算法复现</p>
<p>​	算法复现不限语言，能复现出来就是成功，这是用JS尝试的，使用JS的好处是&#x3D;时可以被其他语言调用</p>
</blockquote>
<h4 id="主动调用"><a href="#主动调用" class="headerlink" title="主动调用"></a>主动调用</h4><p>之前也试过，这个还是很有用的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用：</span><br><span class="line">	1、可以用来测试Hook代码的正确性</span><br><span class="line">	2、调用加密函数观察算法输出结果特征</span><br><span class="line">	3、调用加密函数测试算法复现正确性</span><br><span class="line">		标准算法一般不需要，非标准算法需要反复测试</span><br><span class="line">		</span><br><span class="line">	4、比较复杂的算法，需要借助主动调用实现算法转发</span><br><span class="line">		算法复杂可以不复现啊，直接hook把自己想要算的数据传输进去，打印出来，转发出去即可</span><br></pre></td></tr></table></figure>

<p>2、拿DES加密举例，有CBC模式和ECB模式，那么如果没有找到的话，怎么区分呢，加密一串数据试一下就可以看出来</p>
<p>8位数以下是16位，8位数就是32位</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241010115758308.png" alt="image-20241010115758308"></p>
<p>如果一组数是一样的话看输出结果，很明显的一个特点，如果是so层这样的难以辨别模式的，就可以通过hook的主动调用来测试</p>
<p>AES算法的分组长度是16字节，DES算法的分组长度是8字节，也就是说AES算法每16字节增加一次长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1234567812345678</span><br><span class="line">96d0028878d58c89</span><br><span class="line">96d0028878d58c89</span><br><span class="line">feb959b7d4642fcb</span><br><span class="line"></span><br><span class="line">123456781234567812345678</span><br><span class="line">96d0028878d58c89</span><br><span class="line">96d0028878d58c89</span><br><span class="line">96d0028878d58c89</span><br><span class="line">feb959b7d4642fcb</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241010115908507.png" alt="image-20241010115908507"></p>
<h4 id="协议复现"><a href="#协议复现" class="headerlink" title="协议复现"></a>协议复现</h4><p>将以上算法复现完毕之后，还需要与服务器交互才能进行正常登录操作，现在进行协议复现，去与服务器进行交互</p>
<p>先完成加密解密这一部分的功能，已经写好加密了，解密方法直接一把梭，在把加密和解密的两个方法交出去</p>
<p>注意交出使用 module.exports 而不是直接使用 exports</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241010143830706.png" alt="image-20241010143830706"></p>
<p>模拟http请求</p>
<p>很多语言都可以写，这里用的JS</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入HTTP模块，创建客户端请求，导入加密解密算法方法</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> jscode = <span class="built_in">require</span>(<span class="string">&#x27;./DES&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收的三个变量分别是请求的路径，发送的数据，响应后的回调</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">post</span>(<span class="params">action, send, callback</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义request对象，包括主机名、端口、路径、方法、请求头</span></span><br><span class="line">    <span class="keyword">var</span> options = &#123;</span><br><span class="line">        <span class="attr">hostname</span>: <span class="string">&#x27;api.dodovip.com&#x27;</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="number">80</span>,</span><br><span class="line">        <span class="attr">path</span>: action,</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">        <span class="attr">headers</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json; charset=utf-8&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Dalvik/2.1.0 (Linux; U; Android 9; NX627J Build/PQ3B.190801.03191204)&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个post请求</span></span><br><span class="line">    <span class="keyword">var</span> req = http.<span class="title function_">request</span>(options, <span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">        <span class="comment">// 打印响应状态码、响应头</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;STATUS:&#x27;</span>+ res.<span class="property">statusCode</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;HEADERS:&#x27;</span>+ <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(res.<span class="property">headers</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义了一个post变量，用于存储请求体的信息</span></span><br><span class="line">        <span class="keyword">var</span> body = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        res.<span class="title function_">setEncoding</span>(<span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过res的data事件监听函数，每次接受到数据，就累加到post变量中</span></span><br><span class="line">        res.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span> (<span class="params">chunk</span>) &#123;</span><br><span class="line">            body += chunk;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在res的end事件触发后，通过json.parse将post变量解析成JSON对象</span></span><br><span class="line">        res.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="title function_">callback</span>(body);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;problem with request:&#x27;</span>+ e.<span class="property">message</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将数据写入请求流</span></span><br><span class="line">    req.<span class="title function_">write</span>(send);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 请求结束</span></span><br><span class="line">    req.<span class="title function_">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密数据</span></span><br><span class="line">cipherText = jscode.<span class="title function_">encodeDesMap</span>(<span class="string">&quot;13112345678&quot;</span>, <span class="string">&quot;123123123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 伪造原APP的数据格式</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="string">&quot;Encrypt&quot;</span>: cipherText&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用post函数，向服务器的指定路径发送加密数据，并设置回调函数处理响应数据</span></span><br><span class="line"><span class="title function_">post</span>(<span class="string">&#x27;/api/user/login&#x27;</span>, data, <span class="keyword">function</span> (<span class="params">json</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(json);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解密文本</span></span><br><span class="line">    plainText = jscode.<span class="title function_">decodeDesMap</span>(json)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(plainText);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>python复现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br><span class="line">pip install PyExecJS</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests, json</span><br><span class="line"><span class="keyword">import</span> execjs</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> _locale</span><br><span class="line">_locale._getdefaultlocale = (<span class="keyword">lambda</span> *args: [<span class="string">&#x27;zh_CN&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>])</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;DES.js&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">demo_list = f.readlines()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(demo_list))))</span><br><span class="line">jscode = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(demo_list)):</span><br><span class="line">    jscode += demo_list[i]</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">js = execjs.<span class="built_in">compile</span>(jscode)</span><br><span class="line">cipherText = js.call(<span class="string">&#x27;encrypt&#x27;</span>, <span class="string">&quot;13112345678&quot;</span>, <span class="string">&quot;123123123&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(cipherText)</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://api.dodovip.com/api/user/login&#x27;</span></span><br><span class="line">data = json.dumps(&#123;<span class="string">&quot;Encrypt&quot;</span>: cipherText&#125;)</span><br><span class="line">headers = &#123;</span><br><span class="line">            <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json; charset=utf-8&quot;</span>,</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Dalvik/2.1.0 (Linux; U; Android 9; NX627J Build/PQ3B.190801.03191204)&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">r = requests.post(url, data=data, headers=headers)</span><br><span class="line"><span class="built_in">print</span>(r)</span><br><span class="line"><span class="built_in">print</span>(r.text)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(r.text))</span><br><span class="line"><span class="built_in">print</span>(r.content)</span><br><span class="line"></span><br><span class="line">ciptherText = js.call(<span class="string">&#x27;decrypt&#x27;</span>, r.text)</span><br><span class="line"><span class="built_in">print</span>(ciptherText)</span><br><span class="line"></span><br><span class="line">// 这个实现就不需要JS文件导出模块了，是python直接读取的内容</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>逆向学习</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向学习 0x03简单逆向apk</title>
    <url>/2024/10/09/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-0x03-%E7%AE%80%E5%8D%95%E9%80%86%E5%90%91apk/</url>
    <content><![CDATA[<h3 id="app逆向示例"><a href="#app逆向示例" class="headerlink" title="app逆向示例"></a>app逆向示例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、抓包分析是否有需要逆向的加密字段</span><br><span class="line">2、查壳分析是否加固</span><br><span class="line">3、查看界面元素，看是否是原生开发的app，因为不同形式app分析方法不一样</span><br><span class="line">4、传统关键代码定位方法</span><br><span class="line">	通过控件绑定的事件代码，来一步步定位</span><br><span class="line">		控件id、setOnClickListener</span><br><span class="line">	人肉搜索字符串</span><br><span class="line">		搜索链接</span><br><span class="line">		搜索加密的参数名：当有多个可以关键处，如何确定是哪一个？动态调试、Hook</span><br><span class="line">		搜索同一个数据包中，没有加密的参数名</span><br><span class="line">		</span><br><span class="line">5、关键代码快速定位</span><br><span class="line">	跑一下自吐算法</span><br><span class="line">	hook常用系统函数，如果app有调用就打印函数栈</span><br><span class="line">	在自制的沙盒中运行，打印app运行过程中的指令、函数调用关系等</span><br><span class="line">	</span><br><span class="line">6、逆向分析不是完全静态分析明白了才去hook，实际上是边分析边hook</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="app界面控件查看"><a href="#app界面控件查看" class="headerlink" title="app界面控件查看"></a>app界面控件查看</h4><p>逆向的第一步就是先让app可以运行，app可能存在手机类型检测，或者没有X86架构的so，模拟器运行不了。或者存在抓包检测，不抓包可以用，有抓包用不了</p>
<p>因为是简单操作，以上这些都不考虑，现在的情况是抓到包了，包含加密后的数据，如果是明文也没必要逆向了，这个时候就需要考虑怎么解密了</p>
<p>首先分析其开发方式，开发方式不同分析的方法也不同</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241008160008324.png" alt="image-20241008160008324"></p>
<p>通过其界面来分析开发方式，利用Android Studio中的一个的SDK下tools中的一个工具</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241008164013180.png" alt="image-20241008164013180"></p>
<p>打开后选择截图，分析页面</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241008164028462.png" alt="image-20241008164028462"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看界面控件的作用</span><br><span class="line">	原生方式开发的app，使用Java和C++开发，加密用的是Java和C++</span><br><span class="line">	H5的app，使用Webview控件加载网页，加密用的JS</span><br><span class="line">	app自动化测试，需要知道控件的ID，或者说需要定位到控件</span><br><span class="line">	</span><br><span class="line">用uiautomatorviewer.bat查看</span><br><span class="line">	Android SDK根 目录\tooIs\bin</span><br><span class="line">	</span><br><span class="line">这个方式也不是一直有效的，在app开发中可以作禁止截屏，那么这个工具就用不了了</span><br><span class="line">	禁止截屏：activity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_SECURE);</span><br><span class="line">	解除禁止：activity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_SECURE);</span><br><span class="line">	</span><br><span class="line">// 如果非要用，学会hook之后，把这个方法hook掉即可，或者找个地方执行clearFlags把这个常量值清除掉也可以</span><br></pre></td></tr></table></figure>

<p>这个禁止截屏的方法有很多种，这个只是一个简单的示例，也可以在so层之间调用Java方法禁止截屏，或者找更底层的方法来实现这个功能。不一定就是这一种</p>
<h4 id="app壳"><a href="#app壳" class="headerlink" title="app壳"></a>app壳</h4><p>反编译之前先使用软件检测一下是否有壳</p>
<img src="../图片/image-20241008204823187.png" alt="image-20241008204823187" style="zoom:50%;" />



<p>其实也可以之间反编译，因为加壳之后反编译结果不正常，很容易看出来，很明显的代码少，甚至没有代码</p>
<h4 id="人肉搜索"><a href="#人肉搜索" class="headerlink" title="人肉搜索"></a>人肉搜索</h4><h5 id="搜索控件绑定事件"><a href="#搜索控件绑定事件" class="headerlink" title="搜索控件绑定事件"></a>搜索控件绑定事件</h5><p>登录操作产生的密文</p>
<img src="../图片/image-20241008213436432.png" alt="image-20241008213436432" style="zoom:50%;" />



<p>按钮ID <code>btn_login</code></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241008213557980.png" alt="image-20241008213557980"></p>
<p>反编译爆搜id</p>
<p><code>findViewById</code> 是一种寻找id的方式，下面两个是QQ登录和微信登录的按钮id</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241008213808135.png" alt="image-20241008213808135"></p>
<p>追进去</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241008214226589.png" alt="image-20241008214226589"></p>
<p>继续追</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241008214651735.png" alt="image-20241008214651735"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241008215024596.png" alt="image-20241008215024596"></p>
<p>返回为true之后，执行上一个函数的login方法</p>
<h5 id="搜索关键字符串"><a href="#搜索关键字符串" class="headerlink" title="搜索关键字符串"></a>搜索关键字符串</h5><p>可以搜索这个相关链接，搜不到就缩小长度搜，搜 user&#x2F;login 就出来了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241009085929689.png" alt="image-20241009085929689"></p>
<p>也可以从其他字符串入手，比如这个 encrypt ，或者是登录失败的提示。因为登录逻辑一般在同一个地方的，找到一个就都找到了</p>
<p>搜索结果过多的时候，优先看和包名有关的类</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241009091755079.png" alt="image-20241009091755079"></p>
<h4 id="传统搜索的弊端"><a href="#传统搜索的弊端" class="headerlink" title="传统搜索的弊端"></a>传统搜索的弊端</h4><p>通过人肉搜索是放在最后才用的，因为暴力搜索很费时费力还可能搜不到，如果开发控件的时候不将登录的逻辑写在同一个文件内，然后各种调用，各种接口就很难找到真正的功能方法。如果字符串不组合，使用相加的形式，那么单独搜索一个字符串的话可能会有上千条数据，一一分析起来非常麻烦。甚至可以做加密处理，搜索字符串根本搜不到。例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// login_0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">login_0</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;12345678&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">MessageDigest</span> <span class="variable">md5</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line"><span class="comment">//            Class&lt;?&gt; a = Class.forName(dd(&quot;amF2YS5zZWN1cml0eS5nZYWdlRGlnZXN0&quot;));</span></span><br><span class="line"><span class="comment">//            Method getInstance = a.getMethod(dd(&quot;Z2v0sW5zdGFuY2U&quot;),String.class);</span></span><br><span class="line"><span class="comment">//            Object b = getInstance.invoke(a, dd(&quot;TUQ1&quot;));</span></span><br><span class="line"></span><br><span class="line">          md5.update(password.getBytes());</span><br><span class="line"><span class="comment">//            Method update = a.getMethod(dd(&quot;dXBkYXRl&quot;), byte[].class);</span></span><br><span class="line"><span class="comment">//            update.invoke(b, password.getBytes());</span></span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] digest = md5.digest();</span><br><span class="line"><span class="comment">//            Method c=a.getMethod(dd(&quot;ZGlnZXNo&quot;));</span></span><br><span class="line"><span class="comment">//            byte[] d = (byte[])c.invoke(b);</span></span><br><span class="line"></span><br><span class="line">            HashMap&lt;String,String&gt; hashMap =<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            hashMap.put(<span class="string">&quot;password&quot;</span>, Base64.encodeToString(digest, <span class="number">0</span>));</span><br><span class="line">            Log.d(<span class="string">&quot;xiaojianbang&quot;</span>,hashMap.toString());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// login</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">login</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;12345678&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);</span></span><br><span class="line">            Class&lt;?&gt; a = Class.forName(dd(<span class="string">&quot;amF2YS5zZWN1cml0eS5nZYWdlRGlnZXN0&quot;</span>));</span><br><span class="line">            <span class="comment">// 这个是上面MessageDigest的base64编码之后的结果</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">getInstance</span> <span class="operator">=</span> a.getMethod(dd(<span class="string">&quot;Z2v0sW5zdGFuY2U&quot;</span>),String.class);</span><br><span class="line">            <span class="comment">// 这个是上面getInstance的base64编码之后的结果</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">b</span> <span class="operator">=</span> getInstance.invoke(a, dd(<span class="string">&quot;TUQ1&quot;</span>));</span><br><span class="line">            <span class="comment">// 通过这三行代码将真正使用的方法名隐藏起来，并且执行方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//          md5.update(password.getBytes());</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">update</span> <span class="operator">=</span> a.getMethod(dd(<span class="string">&quot;dXBkYXRl&quot;</span>), <span class="type">byte</span>[].class);</span><br><span class="line">            update.invoke(b, password.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">//            byte[] digest = md5.digest();</span></span><br><span class="line">            Method c=a.getMethod(dd(<span class="string">&quot;ZGlnZXNo&quot;</span>));</span><br><span class="line">            <span class="type">byte</span>[] d = (<span class="type">byte</span>[])c.invoke(b);</span><br><span class="line"></span><br><span class="line">            HashMap&lt;String,String&gt; hashMap =<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            hashMap.put(dd(<span class="string">&quot;cGFzc3dvcmQ=&quot;</span>), Base64.encodeToString(d, <span class="number">0</span>));</span><br><span class="line">            Log.d(<span class="string">&quot;xiaojianbang&quot;</span>,hashMap.toString());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dd</span><span class="params">(String cipherText)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] decode = Base64.decode(cipherText, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(decode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两种方法输出的结果是一样的，但是反编译的结果截然不同</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241009110546414.png" alt="image-20241009110546414"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241009110606927.png" alt="image-20241009110606927"></p>
<p>只需要对字符串进行一个反射和加密就搜索不到了，通过反射将加密使用的方法名给隐藏起来，通过base64将字符串加密，这样一来，就大大降低了搜索找到的可能性。</p>
<h5 id="常见防护"><a href="#常见防护" class="headerlink" title="常见防护"></a>常见防护</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、反编译一个app搜不到关键字：</span><br><span class="line">	a) HTML5的app （HTML5的关键信息通常在js里面）</span><br><span class="line">	b) 字符串被加密了 （通过算法或者字符串拼接等手段）</span><br><span class="line">	c) 反射调用的相关类</span><br><span class="line">	d) app被加固了 （加壳）</span><br><span class="line">	e) 动态加载的dex （jadx会将所有的dex文件反编译，但是如果有dex文件加密了，经过解密之后动态加载，这个时候是反编译不出来的。一般在分析的时候都会将重点放到classes.dex上，很容易忽略其他dex）</span><br><span class="line">	f) 热修复 （在安卓中，有骚操作是app运行起来之后动态修改代码，静态分析不出来，这个时候就必须需要hook获取内存中的数据了）</span><br><span class="line">	</span><br><span class="line">2、简单字符串加密的实现</span><br><span class="line">	dex的字符串加密可以用代码自动实现，需要使用到dexlib2这个库</span><br><span class="line">	</span><br><span class="line">3、反射相关类的实现</span><br></pre></td></tr></table></figure>



<h4 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hook可以用来做什么</span><br><span class="line">	可以用来判断app执行某个操作的时候，是否经过我们的怀疑的这个函数</span><br><span class="line">	可以用来修改被hook函数的运行逻辑</span><br><span class="line">	可以用来在运行过程中，获取被hook的函数传入的具体的参数和返回值</span><br><span class="line">	可以用来主动调用app中的某些函数</span><br></pre></td></tr></table></figure>

<p>hook环境之前就搭建好了，开发js文件的话直接使用VScode，需要调试的话下载node.js</p>
<h4 id="关键代码定位"><a href="#关键代码定位" class="headerlink" title="关键代码定位"></a>关键代码定位</h4><p>这个时候就需要hook了，因为无论你怎么加工包装，都是用了系统定义好了的 <code>MessageDigest.getInstance</code> 方法，将传入的内容打印一下，就可以直接到得明文</p>
]]></content>
      <categories>
        <category>逆向学习</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向学习 0x05关键代码快速定位</title>
    <url>/2024/10/15/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-0x05-%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<h3 id="关键代码快速定位"><a href="#关键代码快速定位" class="headerlink" title="关键代码快速定位"></a>关键代码快速定位</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">搜索不太靠谱，需要更精准更通用的方式来定位关键代码</span><br><span class="line">	Java：hook系统函数、沙盒</span><br><span class="line">	C：hook系统函数</span><br><span class="line">	</span><br><span class="line">通过hook一些底层的方法来定位</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>HashMap的应用场景一般是在提交参数的时候使用</p>
<p>ArrayList的应用场景是需要对数据进行排序的时候</p>
<h4 id="hook系统函数"><a href="#hook系统函数" class="headerlink" title="hook系统函数"></a>hook系统函数</h4><h5 id="一、HashMap-put"><a href="#一、HashMap-put" class="headerlink" title="一、HashMap.put"></a>一、HashMap.put</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">HashMap</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;java.util.HashMap&#x27;</span>);</span><br><span class="line">    <span class="title class_">HashMap</span>.<span class="property">put</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;put: &quot;</span>, a, b);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">put</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>只要代码中使用了HashMap.put添加数据，就把数据打印出来</p>
<p>包有关键信息的湿鸽</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241012152611580.png" alt="image-20241012152611580"></p>
<p>打印一下函数栈，看看是哪个函数调用的HashMap.put</p>
<p>利用 <code>logOutPut(Log.getStackTraceString(new Throwable()));</code> 打印函数栈</p>
<p>注意：因为有很多HashMap的输出，要过滤一下打印堆栈的数据，否则容易崩溃</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">showStacks</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">            <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>)</span><br><span class="line">               .<span class="title function_">getStackTraceString</span>(</span><br><span class="line">                    <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new()</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">HashMap</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;java.util.HashMap&#x27;</span>);</span><br><span class="line">    <span class="title class_">HashMap</span>.<span class="property">put</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印username的堆栈信息</span></span><br><span class="line">        <span class="keyword">if</span> (a.<span class="title function_">equals</span>(<span class="string">&quot;username&quot;</span>)) &#123;</span><br><span class="line">            <span class="title function_">showStacks</span>();</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hashMap.put :&quot;</span>, a, b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;put: &quot;</span>, a, b);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">put</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>包有内容的，可以看到堆栈信息，有login方法和onClick方法，通过这样的方式来快速定位代码。被hook的函数带有 <code>(Native Method)</code> 的标志</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241012164606352.png" alt="image-20241012164606352"></p>
<p>除了HashMap之外，LinkedHashMap中也有put方法，也是有可能有内容的</p>
<p>java.util.concurrent.ConcurrentHashMap中有有put方法</p>
<h5 id="二、ArrayList-add"><a href="#二、ArrayList-add" class="headerlink" title="二、ArrayList.add"></a>二、ArrayList.add</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> addlist = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.util.ArrayList&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// add方法有两个重载方法，将两个方法的都打印一下</span></span><br><span class="line">    addlist.<span class="property">add</span>.<span class="title function_">overload</span>(<span class="string">&quot;java.lang.Object&quot;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;add: &quot;</span>, obj);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">add</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    addlist.<span class="property">add</span>.<span class="title function_">overload</span>(<span class="string">&quot;int&quot;</span>, <span class="string">&quot;java.lang.Object&quot;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a, obj</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;add a + obj: &quot;</span>, a, obj);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">add</span>(a, obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>这个输出的内容多点多，在命令行中不太好看，输出成文件格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fride -UF -l 1.js -o log.txt</span><br></pre></td></tr></table></figure>



<p>如果失败了可能不是脚本的问题重启一下app试试，还是不行就换hook点</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241012195847768.png" alt="image-20241012195847768"></p>
<p>找到需要比对的字符串之后再进行筛选</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">showStacks</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">            <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>)</span><br><span class="line">               .<span class="title function_">getStackTraceString</span>(</span><br><span class="line">                    <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new()</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// add方法有两个重载方法，将两个方法的都打印一下</span></span><br><span class="line">    <span class="keyword">var</span> addlist = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.util.ArrayList&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> addlist = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.util.ArrayList&quot;</span>);</span><br><span class="line">    addlist.<span class="property">add</span>.<span class="title function_">overload</span>(<span class="string">&quot;java.lang.Object&quot;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;add: &quot;</span>, obj);</span><br><span class="line">        <span class="keyword">if</span> (obj.<span class="title function_">equals</span>(<span class="string">&quot;username=13112345678&quot;</span>)) &#123;</span><br><span class="line">            <span class="title function_">showStacks</span>();</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;addlist.add :&quot;</span>, obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">add</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//addlist.add.overload(&quot;int&quot;, &quot;java.lang.Object&quot;).implementation = function(a, obj) &#123;</span></span><br><span class="line">    <span class="comment">//    console.log(&quot;add a + obj: &quot;, a, obj);</span></span><br><span class="line">    <span class="comment">//     return this.add(a, obj);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>一注入运行这个代码模拟器直接就是崩溃了，没有成功啊，但是思路就是这样的，打印出来的堆栈也是从调用add开始一直到login方法，在往上就是Android包中的了</p>
<p>除了add方法之外，还可能用到addAll、set方法</p>
<p>其他函数中也有add方法 Vector、LinkedList</p>
<h5 id="三、TextUtils的isEmpty方法"><a href="#三、TextUtils的isEmpty方法" class="headerlink" title="三、TextUtils的isEmpty方法"></a>三、TextUtils的isEmpty方法</h5><p>这个方法是判断是否为空的方法，一般有输入的地方很有可能使用了这个方法来进行非空判断</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">showStacks</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">            <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>)</span><br><span class="line">               .<span class="title function_">getStackTraceString</span>(</span><br><span class="line">                    <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new()</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> textUtils = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.text.TextUtils&quot;</span>);</span><br><span class="line">    textUtils.<span class="property">isEmpty</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">str</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;TextUtils.isEmpty: &quot;</span>, str);</span><br><span class="line">        <span class="comment">// if (str == &quot;13112345678&quot;) &#123;</span></span><br><span class="line">        <span class="comment">//     showStacks();</span></span><br><span class="line">        <span class="comment">//     console.log(&quot;TextUtils.isEmpty :&quot;, str);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">isEmpty</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>这里输入的账号密码是会调用isEmpty的，这个时候再判断一下打印出堆栈即可</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241012205746668.png" alt="image-20241012205746668"></p>
<p>不打印电话号了，没新意，打印下面的加密数据看看是在哪里调用的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241012210144357.png" alt="image-20241012210144357"></p>
<p>跟着方法名找过去，找到了解密返回数据的方法，说明这串加密数据，就是服务端返回的数据结果</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241012210555730.png" alt="image-20241012210555730"></p>
<h5 id="四、Log"><a href="#四、Log" class="headerlink" title="四、Log"></a>四、Log</h5><p>一般发布的apk是不会有Log打印信息的，但是也不排除有的忘删掉了，或者开发不规范。不推荐一开始就使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> log = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>);</span><br><span class="line">log.<span class="property">w</span>.<span class="title function_">overload</span>(<span class="string">&quot;java.lang.String&quot;</span>, <span class="string">&quot;java.lang.String&quot;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">tag, msg</span>) &#123;</span><br><span class="line">    <span class="title function_">showStacks</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Log.w: &quot;</span>, tag, msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">w</span>(tag, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p><img src="/../%E5%9B%BE%E7%89%87/image-20241012213241815.png" alt="image-20241012213241815"></p>
<h5 id="五、Collections的sort方法"><a href="#五、Collections的sort方法" class="headerlink" title="五、Collections的sort方法"></a>五、Collections的sort方法</h5><p>这是一个排序方法，可能会用到，直接hook</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> collection = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.util.Collections&quot;</span>);</span><br><span class="line">   collection.<span class="property">sort</span>.<span class="title function_">overload</span>(<span class="string">&quot;java.util.List&quot;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">list</span>) &#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 可以看到类型是List，输出结果包是[object, object]，所有转换一下数据格式</span></span><br><span class="line">           <span class="comment">// 防止转换失败，使用try catch</span></span><br><span class="line">           <span class="title function_">showStacks</span>();</span><br><span class="line">           <span class="keyword">var</span> a = <span class="title class_">Java</span>.<span class="title function_">cast</span>(list, <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.util.ArrayList&quot;</span>));</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Collections.sort: &quot;</span>, a.<span class="title function_">toString</span>());</span><br><span class="line">       &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">           </span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">sort</span>(list);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20241012214953389.png" alt="image-20241012214953389"></p>
<h5 id="六、JSONObject的put、getString方法等"><a href="#六、JSONObject的put、getString方法等" class="headerlink" title="六、JSONObject的put、getString方法等"></a>六、JSONObject的put、getString方法等</h5><p>这个是Java中的一个处理json数据的方法，但是现在用的比较少了，会用到外面的库的json数据处理方法。因为嘟嘟牛的抓包结果是想服务端发送了json数据的，所以就可以hook处理json的方法</p>
<p>put是将数据转换成json形式，getString是将json格式的数据还原</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jSONObject = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;org.json.JSONObject&quot;</span>);</span><br><span class="line">   jSONObject.<span class="property">put</span>.<span class="title function_">overload</span>(<span class="string">&quot;java.lang.String&quot;</span>, <span class="string">&quot;java.lang.Object&quot;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">       <span class="title function_">showStacks</span>();</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;JSONObject.put: &quot;</span>, a, b);</span><br><span class="line">       <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">put</span>(a, b);</span><br><span class="line">   &#125;</span><br><span class="line">   jSONObject.<span class="property">getString</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a</span>) &#123;</span><br><span class="line">       <span class="title function_">showStacks</span>();</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;JSONObject.getString: &quot;</span>, a);</span><br><span class="line">       <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">getString</span>(a);</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;result: &quot;</span>, result);</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>





<p><img src="/../%E5%9B%BE%E7%89%87/image-20241012221216949.png" alt="image-20241012221216949"></p>
<h5 id="七、Toast的show方法"><a href="#七、Toast的show方法" class="headerlink" title="七、Toast的show方法"></a>七、Toast的show方法</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> toast = <span class="title class_">Java</span>,<span class="title function_">use</span>(<span class="string">&quot;android.widget.Toast&quot;</span>);</span><br><span class="line">toast.<span class="property">show</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="title function_">showStacks</span>();</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Toast.show :&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">show</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>app登录失败是有提示的，就可以试试hook Toast</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241013160757422.png" alt="image-20241013160757422"></p>
<h5 id="八、Base64"><a href="#八、Base64" class="headerlink" title="八、Base64"></a>八、Base64</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> base64 = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Base64&quot;</span>);</span><br><span class="line">   base64.<span class="property">encodeToString</span>.<span class="title function_">overload</span>(<span class="string">&quot;[B&quot;</span>, <span class="string">&quot;int&quot;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">       <span class="title function_">showStacks</span>();</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Base64.encodeToString: &quot;</span>, a, b);</span><br><span class="line">       <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">encodeToString</span>(a, b);</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;result: &quot;</span>, result);</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>内容包括字节数据，和加密后的数据，一般为了保存字节数据会进行base64编码</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241013162220492.png" alt="image-20241013162220492"></p>
<h5 id="九、String的getBytes、isEmpty方法"><a href="#九、String的getBytes、isEmpty方法" class="headerlink" title="九、String的getBytes、isEmpty方法"></a>九、String的getBytes、isEmpty方法</h5><p>既然保存的是字节数据，那么就有可能使用了系统函数的转化字节的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">   str.<span class="property">getBytes</span>.<span class="title function_">overload</span>(<span class="string">&quot;java.lang.String&quot;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a</span>) &#123;</span><br><span class="line">       <span class="comment">// showStacks();</span></span><br><span class="line">       <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">getBytes</span>(a);</span><br><span class="line">       <span class="keyword">var</span> newStr = str.$new(result);</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;getBytes: &quot;</span>, newStr);</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   str.<span class="property">getBytes</span>.<span class="title function_">overload</span>().<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="comment">// showStacks();</span></span><br><span class="line">       <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">getBytes</span>();</span><br><span class="line">       <span class="keyword">var</span> newStr = str.$new(result);</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;getBytes: &quot;</span>, newStr);</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>可以看到这些数据和协议还有密文有很大关系，加上数据也不多，直接打印出堆栈，都不需要过滤</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241013163441418.png" alt="image-20241013163441418"></p>
<h5 id="十、String的构造函数"><a href="#十、String的构造函数" class="headerlink" title="十、String的构造函数"></a>十、String的构造函数</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">str.<span class="property">$init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> result = <span class="variable language_">this</span>.$init(a);</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;str $init:&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按道理来说是这样的，但是这样运行会直接崩溃掉，没有例外，因为String的构造是通过StringFactory来构造的</span></span><br><span class="line"><span class="comment">// 这个就需要从源码中来分析了</span></span><br></pre></td></tr></table></figure>



<p>java&#x2F;lang&#x2F;string.java</p>
<p>可以看到string的任何一种构造方法都是抛出了一个错误，提示使用 StringFactory</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241013170412420.png" alt="image-20241013170412420"></p>
<p>搜索StringFactory找到StringFactory.java</p>
<p>在Java中使用的 new String() 方法其实在经过虚拟机的编译之后转换成了 StringFactory 中的方法，返回一个字符串，至于虚拟机怎么做到的，那就要看虚拟机的源码了，这个太深了，知道即可，所以要hook String的构造方法就需要hook StringFactory</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241013171014269.png" alt="image-20241013171014269"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241013171727574.png" alt="image-20241013171727574"></p>
<p>String函数的构造替换成了StringFactory，所以应该去hook StringFactory中的方法</p>
<p>newStringFactoryString、newStringFactoryChars、newStringFactoryBytes、newStringFactoryBuffer、newStringFactoryBuilder</p>
<p>这是几个定义的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">var</span> stringFactory = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.StringFactory&quot;</span>)</span><br><span class="line">    stringFactory.<span class="property">newStringFromString</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a</span>) &#123;</span><br><span class="line">        <span class="title function_">showStacks</span>();</span><br><span class="line">        <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">newStringFromString</span>(a);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;StringFactory.newStringFromString: &quot;</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    stringFactory.<span class="property">newStringFromChars</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[C&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a</span>) &#123;</span><br><span class="line">        <span class="title function_">showStacks</span>();</span><br><span class="line">        <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">newStringFromChars</span>(a);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;StringFactory.newStringFromChars: &quot;</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先hook两个演示一下吧，能hook出东西进行</span></span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20241013172915181.png" alt="image-20241013172915181"></p>
<h5 id="十一、StringBuider、StringBuffer的hook"><a href="#十一、StringBuider、StringBuffer的hook" class="headerlink" title="十一、StringBuider、StringBuffer的hook"></a>十一、StringBuider、StringBuffer的hook</h5><p>奖池还在累积</p>
<p>上面介绍了String转换的方法，String定义的方法，StringBuider就是String拼接的方法 <code>+</code> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var sb = Java.use(&quot;java.lang.StringBuilder&quot;);</span><br><span class="line">   sb.toString.implementation = function() &#123;</span><br><span class="line">       var result = this.toString();</span><br><span class="line">       if (result.indexOf(&quot;Encrypt&quot;) != -1) &#123;</span><br><span class="line">           showStacks();</span><br><span class="line">       &#125;</span><br><span class="line">       console.log(&quot;StringBuilder.toString: &quot;, result);</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   var sb2 = Java.use(&quot;java.lang.StringBuffer&quot;);</span><br><span class="line">   sb2.toString.implementation = function() &#123;</span><br><span class="line">       var result = this.toString();</span><br><span class="line">       if (result.indexOf(&quot;username&quot;) != -1) &#123;</span><br><span class="line">           showStacks();</span><br><span class="line">       &#125;</span><br><span class="line">       console.log(&quot;StringBuffer.toString: &quot;, result);</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20241013202318594.png" alt="image-20241013202318594"></p>
<h5 id="十二、findViewByld找控件id-打印R-id属性"><a href="#十二、findViewByld找控件id-打印R-id属性" class="headerlink" title="十二、findViewByld找控件id(打印R$id属性)"></a>十二、findViewByld找控件id(打印R$id属性)</h5><p>找到findViewByld的位置，但是运行会报错</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241013205232411.png" alt="image-20241013205232411"></p>
<p>有时候在源码中看到的名字不一定是正确的，需要检验一下</p>
<p>比如 android.appcompat.app 包中的 AppCompatActivity 。</p>
<p>枚举所有已经加载的类</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 枚举所有已经加载的类</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> classes = <span class="title class_">Java</span>.<span class="title function_">enumerateLoadedClassesSync</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; classes.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> className = classes[i];</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;className: &quot;</span> + className);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>AppCompatActivity 类只有一个，和看到的包名不一样，以frida的类为准，这个时候再去反 AppCompatActivity 类</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241013204635738.png" alt="image-20241013204635738"></p>
<p>你别说fittencode挺通人性，直接把正确的提示出来了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241013205419763.png" alt="image-20241013205419763"></p>
<p>但是又有问题了，如何找到控件id呢——去hook R文件</p>
<p>而且，id是R.java的内部类，不同通过 <code>.</code>  来指向要使用  <code>R$id</code></p>
<p>需要使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn_login_id = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.dodonew.online.R$id&quot;</span>).<span class="property">btn_login</span>.<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .btn_login 是获取了这个对象，需要加上 .value 才下面的 0x7f……  的十进制</span></span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241013210122620.png" alt="image-20241013210122620"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn_login_id = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.dodonew.online.R$id&quot;</span>).<span class="property">btn_login</span>.<span class="property">value</span>;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;btn_login_id: &quot;</span> + btn_login_id);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> appCompatActivity = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.support.v7.app.AppCompatActivity&quot;</span>);</span><br><span class="line">   appCompatActivity.<span class="property">findViewById</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (a == btn_login_id) &#123;</span><br><span class="line">           <span class="title function_">showStacks</span>();</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;AppCompatActivity.findViewByle: &quot;</span>, a);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">findViewByle</span>(a);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>这个时候发现点击是没有反应的，原因就是界面已经创建好了，代码已经执行过了，还找什么控件啊，不执行这个方法了。这是一个生命周期的问题，想要有效果就需要换一个hook模式</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241013211210479.png" alt="image-20241013211210479"></p>
<p>现在需要在界面创建之前进行注入操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frida -U -f com.dodonew.online -l 1.js</span><br><span class="line">frida -U -f com.dodonew.online -l 1.js --no-pause</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20241013212229262.png" alt="image-20241013212229262"></p>
<p>我勒个一波三折，学到不少</p>
<h5 id="十三、setOnClickstener"><a href="#十三、setOnClickstener" class="headerlink" title="十三、setOnClickstener"></a>十三、setOnClickstener</h5><p>hook这个函数，对比控件id，打印函数栈</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 获取控件id</span></span><br><span class="line">   <span class="keyword">var</span> btn_login_id = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.dodonew.online.R$id&quot;</span>).<span class="property">btn_login</span>.<span class="property">value</span>;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;btn_login_id: &quot;</span> + btn_login_id);</span><br><span class="line">   </span><br><span class="line"><span class="keyword">var</span> view = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.view.View&quot;</span>);</span><br><span class="line">   view.<span class="property">setOnClickListener</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">getId</span>() == btn_login_id) &#123;</span><br><span class="line">           <span class="title function_">showStacks</span>();</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;View.setOnClickListener: &quot;</span>, <span class="variable language_">this</span>.<span class="title function_">getId</span>());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">setOnClickListener</span>(a);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>和刚刚的是一个操作也需要加上 -f</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241013213248087.png" alt="image-20241013213248087"></p>
<p>上面这两个方法不推荐有限使用，因为距离加密的方法太远了，而且还需要分析出来控件id进行过滤，还是比较麻烦的。</p>
<h5 id="可hook点老多了"><a href="#可hook点老多了" class="headerlink" title="可hook点老多了"></a>可hook点老多了</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">加密库相关的hook</span><br><span class="line">SSL相关的hook</span><br><span class="line">socket相关的hook</span><br><span class="line">	SocketOutputStream</span><br><span class="line">	SocketInputStream</span><br><span class="line">读写文件相关的 java.io.File</span><br><span class="line">证书双向验证 Keystore.load 通常有证书和密码</span><br><span class="line">安卓退出进程的方式</span><br><span class="line"></span><br><span class="line">// 快速定位协议头加密 okhttp3的addHeader 方法</span><br><span class="line">var okhttp_Builder = Java.use(&quot;okhttp3.Request$Builder&quot;);</span><br><span class="line">okhttp_Builder.addHeader.implementation = function(a, b) &#123;</span><br><span class="line">	showStacks();</span><br><span class="line">	return this.addHeader(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 其实就是猜，猜app中使用了哪些方法，一般找一些底层的方法</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>逆向学习</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向学习 0x06JAVA层hook的API</title>
    <url>/2024/10/15/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-0x06-JAVA%E5%B1%82hook%E7%9A%84API/</url>
    <content><![CDATA[<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>现在介绍的只是Java层的API</p>
<p>注意frida代码需要写在 <code>Java.perform(function() &#123;&#125;);</code> 函数体中，下面省略不写了</p>
<h4 id="静态方法和实例方法的hook"><a href="#静态方法和实例方法的hook" class="headerlink" title="静态方法和实例方法的hook"></a>静态方法和实例方法的hook</h4><span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不需要区分修饰符，也不需要区分静态方法和实例方法，hook代码的写法都是一样的</span></span><br><span class="line"><span class="comment">// 无论带不带static都可以直接hook</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到要hook的类的对象</span></span><br><span class="line"><span class="keyword">var</span> xxx = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.xxxx.xxx&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// hook实例方法</span></span><br><span class="line">xxx.(方法).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="variable language_">this</span>.(方法)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;xxx :&quot;</span>, result)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="函数参数和返回值的修改"><a href="#函数参数和返回值的修改" class="headerlink" title="函数参数和返回值的修改"></a>函数参数和返回值的修改</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> money = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.hello.demo.money&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> str = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>)</span><br><span class="line">money.<span class="property">getInfo</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">getInfo</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">	<span class="keyword">return</span> str.$new(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里直接返回 &quot;hello world&quot; 是没有什么问题的，这是因为frida会自动帮忙处理掉这些问题</span></span><br><span class="line">    <span class="comment">// &quot;hello world&quot; 这个是JS类型的字符串，而函数需要的返回值是Java类型的字符串，需要进行一个转化</span></span><br><span class="line">    <span class="comment">// frida 是会自动处理这个问题的，但是在一些情况下可能处理不了</span></span><br><span class="line">    <span class="comment">// 这个时候就需要手动来进行一个转换了，就是调用String方法来new String</span></span><br><span class="line">    <span class="comment">// 在参数传递上也是类似的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="构造方法的hook"><a href="#构造方法的hook" class="headerlink" title="构造方法的hook"></a>构造方法的hook</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本上都是使用$init来表示构造函数，例外：String</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> money = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.hello.demo.money&quot;</span>)</span><br><span class="line">money.<span class="property">$init</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="property">$init</span>;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.StringFactory&quot;</span>)</span><br><span class="line">str.<span class="property">newStringFromString</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="comment">// ……………………</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="对象参数的构造和修改"><a href="#对象参数的构造和修改" class="headerlink" title="对象参数的构造和修改"></a>对象参数的构造和修改</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其实上面那个String就是一种构造</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wallet = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> money = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">wallet.(方法).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">	<span class="keyword">return</span> <span class="variable language_">this</span>.方法(money.$new(<span class="string">&quot;你好&quot;</span>, <span class="number">200</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个$new其实就是一种构造，在需要传递自己定义的类型数据的时候执行，只需要找到相应的类，然后进行$new</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wallet = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">wallet.(方法).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// console.log(a);</span></span><br><span class="line">    <span class="comment">// 这里的a类型，如果没有toString方法的话，是只能打印出返回值的</span></span><br><span class="line">    <span class="comment">// 需要自己去找相应的变量名，去点出方法获取输出，或者点变量再点value</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">currency</span>.<span class="property">value</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">getCurrency</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 如果要进行修改操作</span></span><br><span class="line">    <span class="comment">// 也是两个操作，第一个是找到要更改的变量直接点value进行更改</span></span><br><span class="line">    <span class="comment">// 第二个是找到更改的方法执行</span></span><br><span class="line">    a.<span class="property">amount</span>.<span class="property">value</span> = <span class="number">3000</span>;</span><br><span class="line">    a.<span class="title function_">setAmount</span>(<span class="number">3000</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="variable language_">this</span>.方法(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="HashMap的打印"><a href="#HashMap的打印" class="headerlink" title="HashMap的打印"></a>HashMap的打印</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> utils = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> stringBuilder = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.StringBuilder&quot;</span>);</span><br><span class="line">utils.方法.<span class="property">implementation</span>. = <span class="keyword">function</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果传入的参数是HashMap类型的，无法向下转型，自然也没有toString方法，这个时候就需要手动将内容打印出来</span></span><br><span class="line">    <span class="comment">// keySet()方法是获取到key值</span></span><br><span class="line">	<span class="keyword">var</span> key = a.<span class="title function_">keySet</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义一个迭代器</span></span><br><span class="line">	<span class="keyword">var</span> it = key.<span class="title function_">iterator</span>();</span><br><span class="line">	<span class="keyword">var</span> result = stringBuilder.$new();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 迭代器方法类似于for循环</span></span><br><span class="line">	<span class="keyword">while</span>(it.<span class="title function_">hasNext</span>()) &#123;</span><br><span class="line">		<span class="keyword">var</span> keystr = it.<span class="title function_">next</span>();</span><br><span class="line">		<span class="keyword">var</span> valuestr = a.<span class="title function_">get</span>(keystr);</span><br><span class="line">		result.<span class="title function_">append</span>(valuestr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="title function_">toString</span>());</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">shufferMap</span>(a);</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 题外话，如果是byte数组，就使用 JSON.stringify() 处理</span></span><br></pre></td></tr></table></figure>



<h4 id="重载方法的hook"><a href="#重载方法的hook" class="headerlink" title="重载方法的hook"></a>重载方法的hook</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">z<span class="comment">// 之前比比皆是，在 implementation 前加上 overload() 括号内指定类型</span></span><br><span class="line"><span class="comment">// 这个也不用特意的去管他，如果碰到重载方法，一执行就会提示相应的类型，复制粘贴即可</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>)</span><br><span class="line">str.<span class="property">getBytes</span>.<span class="title function_">overload</span>().<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;getBytes() called&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>.<span class="title function_">getBytes</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个东西太慢了，尤其是重载方法比较多的时候</span></span><br><span class="line"><span class="comment">// 直接hook所有重载方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用frida中的一个方法获取到所有的重载方法，复写implementation方法，便利这个数组</span></span><br><span class="line"><span class="keyword">var</span> utils = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.xxx.xxx&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> overloadsArr = utils.方法.<span class="property">overloads</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; overloadsArr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    overloadsArr[i].<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> params = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; j++) &#123;</span><br><span class="line">            params += <span class="variable language_">arguments</span>[j] + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(params);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 介绍一下JS中的两个小方法</span></span><br><span class="line">        <span class="comment">// call 和 apply</span></span><br><span class="line">        <span class="comment">// 下面这个就相当于 this.方法(arguments) 这个东西</span></span><br><span class="line">        <span class="comment">// 这两个的区别是接收多个参数还是单个，如果是call 的话就需要将参数挨个传入</span></span><br><span class="line">        <span class="comment">// 如果要根据参数的个数不同进行处理的话，使用 if(arguments.length)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.方法.<span class="title function_">apply</span>(<span class="variable language_">this</span>， <span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hook全部重载方法的这个了解就可以了，有相关的命令可以解决这个问题，遇到命令解决不了的，再来手敲</p>
<h4 id="主动调用"><a href="#主动调用" class="headerlink" title="主动调用"></a>主动调用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于静态方法，直接打印调用即可</span></span><br><span class="line"><span class="keyword">var</span> money = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.xxx.xxxx&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(money.方法())</span><br><span class="line"><span class="comment">// 这样这个静态方法就调用成功了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果用同样的方法来调用非static修饰的方法那就出事了，会报错</span></span><br><span class="line"><span class="comment">// Error: 方法名: cannot call instance method without an instance</span></span><br><span class="line"><span class="comment">// 不使用 一个对象就不能调用方法</span></span><br><span class="line"><span class="comment">// 现在需要一个对象，方法一，新建一个对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(money.<span class="property">$new</span>.方法())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二，获取已有的对象</span></span><br><span class="line"><span class="comment">// 要和需要获取的对象的位置相同</span></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;com.xxx.xxxx&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">onMatch</span>: <span class="keyword">function</span> (<span class="params">obj</span>) &#123;</span><br><span class="line">        <span class="comment">// 主动调用成功</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.方法());</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onComplete</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;END&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Android Context的获取</span></span><br><span class="line"><span class="keyword">var</span> current_application = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.app.ActivityThread&quot;</span>).<span class="title function_">cuttrntApplication</span>();</span><br><span class="line"><span class="keyword">var</span> content = current_application.<span class="title function_">getApplicationContext</span>();</span><br></pre></td></tr></table></figure>



<h4 id="获取和修改类的字段"><a href="#获取和修改类的字段" class="headerlink" title="获取和修改类的字段"></a>获取和修改类的字段</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态字段</span></span><br><span class="line"><span class="keyword">var</span> money = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.xxx.xxxx&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(money.变量名.<span class="property">value</span>);</span><br><span class="line">money.变量名.<span class="property">value</span> = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(money.变量名.<span class="property">value</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例字段 创建新对象</span></span><br><span class="line"><span class="keyword">var</span> moneyObj = money.$new();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(moneyObj.变量名.<span class="property">value</span>)</span><br><span class="line">money.变量名.<span class="property">value</span> = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(money.变量名.<span class="property">value</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例字段(获取已有对象)</span></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;com.xxx.xxxx&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">onMatch</span>: <span class="keyword">function</span> (<span class="params">obj</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.变量名.<span class="property">value</span>);</span><br><span class="line">    &#125;, <span class="attr">onComplete</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有字段名和方法名一样，如果想要获取到属性需要加下划线前缀</span></span><br><span class="line"><span class="comment">// 例如一个类中有一个accountName属性也有一个accountName方法，如果想要指定accountName属性，需要加_</span></span><br><span class="line"><span class="comment">// 调用方法直接用即可</span></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;com.xxx.xxxx&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">onMatch</span>: <span class="keyword">function</span> (<span class="params">obj</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">_accountName</span>.<span class="property">value</span>);</span><br><span class="line">    &#125;, <span class="attr">onComplete</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>





<h4 id="hook内部类和匿名类"><a href="#hook内部类和匿名类" class="headerlink" title="hook内部类和匿名类"></a>hook内部类和匿名类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">内部类简单来说就是class中的class</span><br><span class="line">比如调用R文件中的内部类</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">tset</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">a</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">com.xxx.xxx.R$id</span><br><span class="line"><span class="comment">// 这个就是调用了R中的内部类id</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 这里创建的就是匿名类，方法没有名字，也就是说hook这个getInfo()方法是hook不到东西的</span></span><br><span class="line"><span class="comment">// 只能使用 $ + 数字进行hook，比如 com.demo.tast$1</span></span><br><span class="line"><span class="comment">// 这个数字从1开始排序，从上到下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	System.out.println(<span class="keyword">new</span> <span class="title class_">people</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">19</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getName() + <span class="string">&quot;&quot;</span> + getAge();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.getInfo());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hook内部类，需要使用Java.choose来获取匿名对象</span></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;com.xxx.xxxx$a&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">onMatch</span>: <span class="keyword">function</span> (<span class="params">obj</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">_accountName</span>.<span class="property">value</span>);</span><br><span class="line">    &#125;, <span class="attr">onComplete</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// hook匿名类</span></span><br><span class="line"><span class="keyword">var</span> people$1 = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.xxx.people$1);</span></span><br><span class="line"><span class="string">people$1.getInfo.implementation = function() &#123;</span></span><br><span class="line"><span class="string">    var result = this.getInfo();</span></span><br><span class="line"><span class="string">    return result;</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 如果有匿名内部类就使用Java.choose进行嵌套即可，如果太过于复杂，可以直接遍历所有的类，直接去搜索</span></span><br></pre></td></tr></table></figure>





<h4 id="混淆函数的hook方法"><a href="#混淆函数的hook方法" class="headerlink" title="混淆函数的hook方法"></a>混淆函数的hook方法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数被混淆之后，这个时候直接根据它的名字hook即可，如果有乱码或者难以填写可以进行编码，将编码后的数据去JS脚本中解密，用变量来表示名称</span></span><br><span class="line"><span class="comment">// 假如进行了base64编码处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> people = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.xxx.xxxx&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> base64 = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Base64&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> str = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> funcName = str.$new(base64.<span class="title function_">decode</span>(<span class="string">&quot;Z2V0SW5mbw==&quot;</span>, <span class="number">0</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(funcName);</span><br><span class="line">people[funcName].<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">funcName</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>做一个小小的混淆，就是将类名、方法名进行base64加密</p>
<p>如果要更改dex中的类名，需要用到一个库dexlib2</p>
<p>输出结果：</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241016112901816.png" alt="image-20241016112901816"></p>
<p>混淆前后对比</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241016113231981.png" alt="image-20241016113231981"></p>
<p>面对混淆的名字，jadx可能会处理一部分，如果出现注释和名字不一样的，以注释为准进行hook</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241016113314869.png" alt="image-20241016113314869"></p>
<p>混淆代码</p>
<p>因为是使用Android开发的，所有目录在安卓端，运行比较慢，也可以使用Java写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 读取原本的dex和新创建的dex，这里是手机中的文件路径</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">oldDexFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/data/data/com.example.demo/classes.dex&quot;</span>);</span><br><span class="line">            <span class="type">File</span> <span class="variable">newDexFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/data/data/com.example.demo/new_classes.dex&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Log.d(<span class="string">&quot;demo&quot;</span>, <span class="string">&quot;从assets中读取classes.dex&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打开放在assets目录下的dex文件，输入流，然后将文件写出到app私有空间去</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">ins</span> <span class="operator">=</span> getApplicationContext().getAssets().open(<span class="string">&quot;classes.dex&quot;</span>);</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> index;</span><br><span class="line">            <span class="keyword">while</span> ((index = ins.read(bytes)) != -<span class="number">1</span>)</span><br><span class="line">                baos.write(bytes, <span class="number">0</span> ,index);</span><br><span class="line">            </span><br><span class="line">            Log.d(<span class="string">&quot;demo&quot;</span>, <span class="string">&quot;开始写出classes.dex到&quot;</span> + oldDexFile.toString() + <span class="string">&quot;...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(oldDexFile);</span><br><span class="line">            fos.write(baos.toByteArray());</span><br><span class="line">            ins.close();</span><br><span class="line">            fos.close();</span><br><span class="line">            baos.close();</span><br><span class="line">            </span><br><span class="line">            Log.d(<span class="string">&quot;demo&quot;</span>, <span class="string">&quot;开始使用dexlib2加载classes.dex...&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 指明api版本</span></span><br><span class="line">            <span class="type">Opcodes</span> <span class="variable">opcodes</span> <span class="operator">=</span> Opcodes.forApi(<span class="number">29</span>);</span><br><span class="line">            <span class="comment">// DexFileFactory.loadDexFile(oldDexFile, opcodes)是用来指明dex文件，两个参数为路径和api版本</span></span><br><span class="line">            <span class="comment">// 这一步的操作是将dex文件不进行修改直接写进来，如果这一步报错了其他也没戏，就是一个测试属于是</span></span><br><span class="line">            DexFileFactory.writeDexFile(oldDexFile.toString(), DexFileFactory.loadDexFile(oldDexFile, opcodes));</span><br><span class="line">            <span class="comment">// 重新将dex文件加载进来</span></span><br><span class="line">            <span class="type">DexBackedDexFile</span> <span class="variable">dexBackedDexFile</span> <span class="operator">=</span> DexFileFactory.loadDexFile(oldDexFile, opcodes);</span><br><span class="line">            Log.d(<span class="string">&quot;demo&quot;</span>, <span class="string">&quot;dexFile:&quot;</span> + dexBackedDexFile.getClass().getName());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设定要更改的内容</span></span><br><span class="line">            <span class="type">DexRewriter</span> <span class="variable">rewriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DexRewriter</span>(<span class="keyword">new</span> <span class="title class_">RewriterModule</span>() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// getClassDefRewriter获取一个类的时候调用该方法</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> Rewriter&lt;ClassDef&gt; <span class="title function_">getClassDefRewriter</span><span class="params">(Rewriters rewriters)</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClassDefRewriter</span>(rewriters) &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> ClassDef <span class="title function_">rewrite</span><span class="params">(ClassDef classDef)</span> &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> classDef.getType();</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 获取类名，如果类名包含com.example就重写，getType()方法中是获取类名后进行重写的具体操作</span></span><br><span class="line">                            <span class="keyword">if</span> (className.contains(<span class="string">&quot;com/dodonew&quot;</span>)) &#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RewrittenClassDef</span>(classDef) &#123;</span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">                                        <span class="type">String</span> <span class="variable">class_fullName</span> <span class="operator">=</span> classDef.getType();</span><br><span class="line">                                        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> class_fullName.lastIndexOf(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">                                        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> class_fullName.lastIndexOf(<span class="string">&quot;$&quot;</span>);</span><br><span class="line">                                        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> class_fullName.length();</span><br><span class="line">                                        <span class="keyword">if</span> (end &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                                            <span class="keyword">if</span> (class_fullName.contains(<span class="string">&quot;;&quot;</span>)) &#123;</span><br><span class="line">                                                end = length - <span class="number">1</span>;</span><br><span class="line">                                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                                end = length;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line"></span><br><span class="line">                                        <span class="comment">// 进行base64编码，替换旧名字</span></span><br><span class="line">                                        <span class="type">String</span> <span class="variable">class_name</span> <span class="operator">=</span> class_fullName.substring(start + <span class="number">1</span>, end);</span><br><span class="line">                                        <span class="type">String</span> <span class="variable">class_name_enc</span> <span class="operator">=</span> Base64.encodeToString(class_name.getBytes(), <span class="number">0</span>);</span><br><span class="line">                                        Log.d(<span class="string">&quot;demo&quot;</span>, class_name + <span class="string">&quot;&quot;</span> + class_name_enc);</span><br><span class="line">                                        <span class="keyword">return</span> class_fullName.replace(class_name, class_name_enc);</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="keyword">public</span> String <span class="title function_">getSourceFile</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="literal">null</span>;&#125;</span><br><span class="line">                                &#125;;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">return</span> <span class="built_in">super</span>.rewrite(classDef);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// getFieldRewriter获取类中的一个字段的时候调用该方法</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> Rewriter&lt;Field&gt; <span class="title function_">getFieldRewriter</span><span class="params">(Rewriters rewriters)</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FieldRewriter</span>(rewriters) &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> Field <span class="title function_">rewrite</span><span class="params">(Field field)</span> &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> field.getDefiningClass();</span><br><span class="line">                            <span class="keyword">if</span> (className.contains(<span class="string">&quot;com/dodonew&quot;</span>)) &#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RewrittenField</span>(field) &#123;</span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">                                        <span class="keyword">return</span> Base64.encodeToString(field.getName().getBytes(), <span class="number">0</span>);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">return</span> <span class="built_in">super</span>.rewrite(field);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// getMethodRewriter获取方法的时候调用该方法</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> Rewriter&lt;Method&gt; <span class="title function_">getMethodRewriter</span><span class="params">(Rewriters rewriters)</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MethodRewriter</span>(rewriters) &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> Method <span class="title function_">rewrite</span><span class="params">(Method value)</span> &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> value.getDefiningClass();</span><br><span class="line">                            <span class="keyword">if</span> (className.contains(<span class="string">&quot;com/dodonew&quot;</span>)) &#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RewrittenMethod</span>(value) &#123;</span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">                                        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> Base64.encodeToString(value.getName().getBytes(), <span class="number">0</span>);</span><br><span class="line">                                        Log.d(<span class="string">&quot;demo&quot;</span>, <span class="string">&quot;methodName:&quot;</span> + methodName);</span><br><span class="line">                                        <span class="keyword">return</span> methodName;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">return</span> <span class="built_in">super</span>.rewrite(value);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将设定好的rewrite保存，这个写的是dexBackedDexFile，这是一开始加载的dex就相当于覆盖写出了</span></span><br><span class="line">            <span class="type">DexFile</span> <span class="variable">rewriteDexFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DexFileRewriter</span>(rewriter).rewrite(dexBackedDexFile);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将改好的dex写出保存</span></span><br><span class="line">            <span class="type">DexPool</span> <span class="variable">dexPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DexPool</span>(rewriteDexFile.getOpcodes());</span><br><span class="line">            <span class="keyword">for</span> (ClassDef classDef : rewriteDexFile.getClasses()) &#123;</span><br><span class="line">                dexPool.internClass(classDef);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dexPool.writeTo(<span class="keyword">new</span> <span class="title class_">FileDataStore</span>(newDexFile));</span><br><span class="line">            Log.d(<span class="string">&quot;demo&quot;</span>, <span class="string">&quot;new_classes.dex生成完毕，保存路径为：&quot;</span> + newDexFile.toString());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="枚举所有已加载的类与枚举类的所有方法"><a href="#枚举所有已加载的类与枚举类的所有方法" class="headerlink" title="枚举所有已加载的类与枚举类的所有方法"></a>枚举所有已加载的类与枚举类的所有方法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个之前就用过一个一键打印所有已经加载的类的方法</span></span><br><span class="line"><span class="comment">// 1、注意是已加载不是所有</span></span><br><span class="line"><span class="comment">// 2、加载的类也不一定能hook到，原因是存在类加载器，有的类的类加载器和正在使用的类加载器不一样，会找不到这个类，但是会被打印出来</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Java</span>.<span class="title function_">enumerateLoadedClassesSync</span>().<span class="title function_">join</span>(<span class="string">&quot;\n&quot;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举类的所有方法</span></span><br><span class="line"><span class="comment">// 实现思想呢就是Java中的反射思想</span></span><br><span class="line"><span class="comment">// 第一步就是获取class对象，这个和Java中的实现不一样直接use就行了</span></span><br><span class="line"><span class="keyword">var</span> people = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.xxx.xxxx.People&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取函数名、构造函数、字段、内部类</span></span><br><span class="line"><span class="keyword">var</span> methods = people.<span class="property">class</span>.<span class="title function_">getDeclaredMethods</span>();</span><br><span class="line"><span class="keyword">var</span> constructors = people.<span class="property">class</span>.<span class="title function_">getDeclaredConstructors</span>();</span><br><span class="line"><span class="keyword">var</span> fields = people.<span class="property">class</span>.<span class="title function_">getDeclaredFields</span>();</span><br><span class="line"><span class="keyword">var</span> classes = people.<span class="property">class</span>.<span class="title function_">getDeclaredClasses</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; methods.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(methods[i].<span class="title function_">getName</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;============================&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; fields.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(constructors[i].<span class="title function_">getName</span>())</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;============================&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; fields.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(fields[i].<span class="title function_">getName</span>())</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;============================&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; fields.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(classes[i].<span class="title function_">getName</span>())</span><br><span class="line">    <span class="comment">// classes[i] 这里得到的已经是类的字节码，不需要再.class</span></span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">Wallet</span>$InnerStructure = classes[i].<span class="title function_">getDeclaredFields</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="title class_">Wallet</span>$InnerStructure.<span class="property">length</span>; j++) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Wallet</span>$InnerStructure[j].<span class="title function_">getName</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="hook类的所有方法"><a href="#hook类的所有方法" class="headerlink" title="hook类的所有方法"></a>hook类的所有方法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hookFunc</span>(<span class="params">methodName</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(methodName)</span><br><span class="line">    <span class="keyword">var</span> overloadsArr = utils[methodName].<span class="property">overloads</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; overloadsArr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">        overloadsArr[j].<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> params = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; k++) &#123;</span><br><span class="line">                params += <span class="variable language_">arguments</span>[k] + <span class="string">&quot; &quot;</span>;                    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;utils.&quot;</span> + methodName + <span class="string">&quot;is called! params is: &quot;</span>, params);</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>[methodName].<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> utils = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.dodonew.online.DodonewOnlineApplication&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> methods = utils.<span class="property">class</span>.<span class="title function_">getDeclaredMethods</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; methods.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> methodName = methods[i].<span class="title function_">getName</span>();</span><br><span class="line">    <span class="title function_">hookFunc</span>(methodName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241017192903835.png" alt="image-20241017192903835"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241017193046511.png" alt="image-20241017193046511"></p>
<h4 id="注入dex"><a href="#注入dex" class="headerlink" title="注入dex"></a>注入dex</h4><h5 id="Java-registerClass"><a href="#Java-registerClass" class="headerlink" title="Java.registerClass"></a>Java.registerClass</h5><p>这个是使用JS语言写的，frida注入之后可能会出现bug</p>
<p>这个必须需要实现一个接口，这个还是比较麻烦的，接口内的东西还需要都实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">MyWeirdTrustManager</span> = <span class="title class_">Java</span>.<span class="title function_">registerClass</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;com.dodonew.online.MyWeirdTrustManager&quot;</span>,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 实现接口，这个貌似是必须要实现一个接口才行</span></span><br><span class="line">        <span class="attr">implements</span>: [<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;接口名&quot;</span>)],</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 继承父类</span></span><br><span class="line">        <span class="attr">superClass</span>: </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义变量</span></span><br><span class="line">        <span class="attr">fields</span>: &#123;</span><br><span class="line">            <span class="attr">description</span>: <span class="string">&#x27;java.lang.String&#x27;</span>,</span><br><span class="line">            <span class="attr">limit</span>: <span class="string">&#x27;int&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义方法</span></span><br><span class="line">        <span class="attr">methods</span>: &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 构建方法</span></span><br><span class="line">            $init() &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Constructor called&quot;</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 重载方法需要使用中括号</span></span><br><span class="line">            <span class="attr">test1</span>: [&#123;</span><br><span class="line">                <span class="attr">returnType</span>: <span class="string">&#x27;void&#x27;</span>,</span><br><span class="line">                <span class="attr">argumentTypes</span>: [],</span><br><span class="line">                <span class="title function_">implementation</span>(<span class="params"></span>) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;test1 called&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,&#123;</span><br><span class="line">                <span class="attr">returnType</span>: <span class="string">&#x27;void&#x27;</span>,</span><br><span class="line">                <span class="attr">argumentTypes</span>: [<span class="string">&quot;java.lang.String&quot;</span>, <span class="string">&quot;int&quot;</span>],</span><br><span class="line">                <span class="title function_">implementation</span>(<span class="params">str, num</span>) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;test1 called with &quot;</span> + str + <span class="string">&quot; and &quot;</span> + num)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;],</span><br><span class="line">            <span class="title function_">test2</span>(<span class="params">str, num</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;test2 called with &quot;</span> + str + <span class="string">&quot; and &quot;</span> + num)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> myObj = <span class="title class_">MyWeirdTrustManager</span>.$new();</span><br><span class="line">    myObj.<span class="title function_">test1</span>();</span><br><span class="line">    myObj.<span class="title function_">test1</span>(<span class="string">&quot;Hello&quot;</span>, <span class="number">123</span>);</span><br><span class="line">    myObj.<span class="title function_">test2</span>(<span class="string">&quot;World&quot;</span>, <span class="number">456</span>);</span><br><span class="line">    myObj.<span class="property">limit</span>.<span class="property">value</span> = <span class="number">100</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(myObj.<span class="property">limit</span>.<span class="property">value</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20241021083842196.png" alt="image-20241021083842196"></p>
<h5 id="frida注入dex"><a href="#frida注入dex" class="headerlink" title="frida注入dex"></a>frida注入dex</h5><p>这个操作是自己写好一个dex文件，将其注入到app中去然后再调用其中的方法</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241021085640901.png" alt="image-20241021085640901"></p>
<p>先使用studio打包一个自己随便写的apk，然后取出classes.dex文件，将这个文件放到手机的 &#x2F;data&#x2F;local&#x2F;tmp 路径下</p>
<p>在进行注入，这样的方法是写成Java类型的，容易纠错和编写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">openClassFile</span>(<span class="string">&quot;/data/local/tmp/patch.dex&quot;</span>).<span class="title function_">load</span>();</span><br><span class="line">   <span class="keyword">var</span> use = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.demo.test&quot;</span>);</span><br><span class="line">   <span class="keyword">var</span> obj =  use.<span class="title function_">test</span>();</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20241021085159066.png" alt="image-20241021085159066"></p>
<p>通过这种方式就可以在hook其他app的时候主动调用自己写好的方法</p>
<h4 id="hook枚举类"><a href="#hook枚举类" class="headerlink" title="hook枚举类"></a>hook枚举类</h4><p>回忆一下枚举</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241021090808965.png" alt="image-20241021090808965"></p>
<p>hook枚举类没什么价值，可以直接看的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;com.xiaojianbang.app.Season&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">onMatch</span>: <span class="keyword">function</span> (<span class="params">obj</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">ordinal</span>());</span><br><span class="line">    &#125;, <span class="attr">onComplete</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.xiaojianbang.app.Season&quot;</span>).<span class="title function_">values</span>())</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241021091445508.png" alt="image-20241021091445508"></p>
<h4 id="firda写文件"><a href="#firda写文件" class="headerlink" title="firda写文件"></a>firda写文件</h4><p>frida是有API支持文件写入的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">var</span> ios = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/data/data/com.xiaojianbang.app/test.txt&quot;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    ios.<span class="title function_">write</span>(<span class="string">&quot;Hello, world!\n&quot;</span>)</span><br><span class="line">    ios.<span class="title function_">flush</span>()</span><br><span class="line">    ios.<span class="title function_">close</span>()</span><br><span class="line"></span><br><span class="line">最好将文件路径写在当前包名下，否则容易没有写入权限</span><br><span class="line">w  覆盖</span><br><span class="line">a+ 追加</span><br><span class="line"></span><br><span class="line">注意：frida只有写文件的<span class="variable constant_">API</span>，没有读文件<span class="variable constant_">API</span>，如果要读文件，要去hook libc.<span class="property">so</span> 中的读文件的函数</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241021093410843.png" alt="image-20241021093410843"></p>
<h4 id="转型-Java-cast"><a href="#转型-Java-cast" class="headerlink" title="转型 Java.cast"></a>转型 Java.cast</h4><p>进行向上或者向下转型，应对那种不能 toString() 的情况</p>
<p>之前也使用过这个东西，注意使用 cast 转型要是本来就是这个类型的才能转型</p>
<p>例如这个参数传进来的时候就进行了一个向上转型，在hook代码中向下转型是没什么问题的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241021094753946.png" alt="image-20241021094753946"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var utils = Java.use(&quot;com.xiaojianbang.hook.Utils&quot;);</span><br><span class="line">utils.shufferMap2.implementation = function(map) &#123;</span><br><span class="line">	console.log(&quot;map: &quot; map);</span><br><span class="line">	var result = Java.cast(map, Java.use(&quot;java.util.HashMap&quot;));</span><br><span class="line">	console.log(&quot;map: &quot;， result);</span><br><span class="line">	return this.shufferMap2(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="数组的构建"><a href="#数组的构建" class="headerlink" title="数组的构建"></a>数组的构建</h4><p>这样也算是创建了一个数组</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241021100342745.png" alt="image-20241021100342745"></p>
<p>frida对于创建数组是专门提供了API的，array就是将JS数组转化为Java数组传到方法中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Utils</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.xiaojianbang.hook.Utils&quot;</span>);</span><br><span class="line"><span class="comment">// var obj =  Utils.myPrint([&quot;Hello&quot;, &quot;world&quot;, &quot;!&quot;])</span></span><br><span class="line"><span class="comment">// console.log(obj)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> strarr = <span class="title class_">Java</span>.<span class="title function_">array</span>(<span class="string">&quot;java.lang.String&quot;</span>, [<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;!&quot;</span>])</span><br><span class="line"><span class="keyword">var</span> obj =  <span class="title class_">Utils</span>.<span class="title function_">myPrint</span>(strarr)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241021100657763.png" alt="image-20241021100657763"></p>
<h5 id="object数组的构建"><a href="#object数组的构建" class="headerlink" title="object数组的构建"></a>object数组的构建</h5><p><img src="/../%E5%9B%BE%E7%89%87/image-20241021174344517.png" alt="image-20241021174344517"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">可以看到传入的东西花里胡哨，有字符串，基本数据类型和对象</span><br><span class="line">这个时候就麻爪了，原因就是在<span class="title class_">Java</span>中万物皆对象，基本数据类型put到数组时是会转换成包装类，而js中没有这个操作，所以就报错了</span><br><span class="line">其实也是可以直接传的</span><br><span class="line">给他手动转换成包装类不就是了</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> money = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.xiaojianbang.hook.Money&quot;</span>).$new(<span class="string">&quot;demoMoney&quot;</span>, <span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">var</span> bool = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Boolean&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> integer = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Integer&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="title class_">Utils</span>.<span class="title function_">myPrint</span>([<span class="string">&quot;demo&quot;</span>, integer.$new(<span class="number">100</span>), bool.$new(<span class="literal">true</span>), money])</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241021180237078.png" alt="image-20241021180237078"></p>
<p>只需要记住 Java.array 可以创建一个Java数组即可</p>
<h5 id="ArrayList主动调用"><a href="#ArrayList主动调用" class="headerlink" title="ArrayList主动调用"></a>ArrayList主动调用</h5><p>list是数组数据，map是键值对数据</p>
<p>原理和object一样的，都是基本数据类型要转换成包装类</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Utils</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.xiaojianbang.hook.Utils&quot;</span>);</span><br><span class="line">   <span class="comment">// var obj =  Utils.myPrint([&quot;Hello&quot;, &quot;world&quot;, &quot;!&quot;])</span></span><br><span class="line">   <span class="comment">// console.log(obj)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// var strarr = Java.array(&quot;java.lang.String&quot;, [&quot;Hello&quot;, &quot;world&quot;, &quot;!&quot;])</span></span><br><span class="line">   <span class="comment">// var obj =  Utils.myPrint(strarr)</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> money = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.xiaojianbang.hook.Money&quot;</span>).$new(<span class="string">&quot;demoMoney&quot;</span>, <span class="number">2000</span>);</span><br><span class="line">   <span class="keyword">var</span> bool = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Boolean&quot;</span>);</span><br><span class="line">   <span class="keyword">var</span> integer = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Integer&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// var strarr = Java.array(&quot;Ljava.lang.Object;&quot;, [&quot;demo&quot;, integer.$new(100), bool.$new(true), money])</span></span><br><span class="line">   <span class="comment">// var obj =  Utils.myPrint(strarr)</span></span><br><span class="line">   <span class="keyword">var</span> obj = <span class="title class_">Utils</span>.<span class="title function_">myPrint</span>([<span class="string">&quot;demo&quot;</span>, integer.$new(<span class="number">100</span>), bool.$new(<span class="literal">true</span>), money])</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;==============================&quot;</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> arraylist = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.util.ArrayList&quot;</span>).$new();</span><br><span class="line">   arraylist.<span class="title function_">add</span>(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line">   arraylist.<span class="title function_">add</span>(integer.$new(<span class="number">100</span>));</span><br><span class="line">   arraylist.<span class="title function_">add</span>(bool.$new(<span class="literal">true</span>));</span><br><span class="line">   arraylist.<span class="title function_">add</span>(money);</span><br><span class="line">   <span class="keyword">var</span> obj1 = <span class="title class_">Utils</span>.<span class="title function_">myPrint</span>(arraylist)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(obj1)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;==============================&quot;</span>)</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20241021185206996.png" alt="image-20241021185206996"></p>
<h4 id="hook动态加载的dex"><a href="#hook动态加载的dex" class="headerlink" title="hook动态加载的dex"></a>hook动态加载的dex</h4><p>这个和枚举所有已加载的类长得很相似  <code>Java.enumerateLoadedClassesSync()</code> </p>
<p><code>Java.enumerateClassLoaders()</code>  这个是动态加载类</p>
<h5 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h5><p>报错提示没有找到 com.xiaojianbang.app.Dynamic 这个类</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241021190736252.png" alt="image-20241021190736252"></p>
<p>但是可以看到 com.xiaojianbang.app.Dynamic 这个类是已经加载了的，这个就和类加载器有关了，回旋镖转回来了，因为类加载器不同，所以没有找到这个类</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241021190636980.png" alt="image-20241021190636980"></p>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 获取所有的加载器</span></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">enumerateClassLoaders</span>(&#123;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 每有一个加载器，执行这个方法</span></span><br><span class="line">       <span class="attr">onMatch</span>: <span class="keyword">function</span> (<span class="params">loader</span>) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 在这个加载器中去寻找 dynamic 这个类，找到了就执行这个类，没找打就打印这个加载器</span></span><br><span class="line">               <span class="title class_">Java</span>.<span class="property">classFactory</span>.<span class="property">loader</span> = loader;</span><br><span class="line">               <span class="keyword">var</span> dynamic = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.xiaojianbang.app.Dynamic&quot;</span>);</span><br><span class="line">               <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;dynamic: &quot;</span>, dynamic);</span><br><span class="line">               dynamic.<span class="property">sayHello</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hook sayHello called&quot;</span>);</span><br><span class="line">                   <span class="keyword">return</span> <span class="string">&quot;demo&quot;</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">               <span class="variable language_">console</span>.<span class="title function_">log</span>(loader);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 全部加载完毕执行这个方法</span></span><br><span class="line">       <span class="attr">onComplete</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20241021192603865.png" alt="image-20241021192603865"></p>
<p>动态加载：也可以理解成按需加载，就是在代码执行过程中加载dex文件，就比如 dynamic类，它不是classes.dex文件中的类，是apk执行过程中动态加载的一个类。hook动态加载类的时候就容易碰到，枚举类中有这个方法，但是hook说找不到这个方法。如果这个dex文件加密了，jadx也不会反编译出来这个类。</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241021193047976.png" alt="image-20241021193047976"></p>
<blockquote>
<p>Java.enumerateClassLoaders()这个API要安卓7以上才能使用</p>
</blockquote>
<h4 id="让hook只在指定函数内生效（了解）"><a href="#让hook只在指定函数内生效（了解）" class="headerlink" title="让hook只在指定函数内生效（了解）"></a>让hook只在指定函数内生效（了解）</h4><p>如果hook系统函数，调用很频繁的话是hook不成功的，直接崩溃了。</p>
<p>但是如果已经确定了范围，就可以用这种方式，其实也可以理解为hook嵌套</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainActivity = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.xiaojianbang.app.MainActivity&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> stringBuilder = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.StringBuilder&quot;</span>)</span><br><span class="line">mainActivity.<span class="property">generateAESKey</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;mainActivity generateAESKey called&quot;</span>);</span><br><span class="line">    stringBuilder.<span class="property">toString</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">toString</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;generateAESKey result: &quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="property">generateAESKey</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">    stringBuilder.<span class="property">toString</span>.<span class="property">implementation</span> = <span class="literal">null</span>;  <span class="comment">// 取消hook</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20241021194022869.png" alt="image-20241021194022869"></p>
<h4 id="hook定位接口-抽象类的实现类"><a href="#hook定位接口-抽象类的实现类" class="headerlink" title="hook定位接口\抽象类的实现类"></a>hook定位接口\抽象类的实现类</h4><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>如果定位代码找到接口了，单纯的hook接口是没有什么东西的，我们要去找接口的实现类</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">var</span> classes = <span class="title class_">Java</span>.<span class="title function_">enumerateLoadedClassesSync</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环所有已经加载的类</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">const</span> index <span class="keyword">in</span> classes) &#123;</span><br><span class="line">       <span class="keyword">let</span> className = classes[index];</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 过滤掉部分系统类</span></span><br><span class="line">       <span class="keyword">if</span> (className.<span class="title function_">indexOf</span>(<span class="string">&quot;com.xiaojianbang&quot;</span>) === -<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// try一下防止有的类不在同一加载器，直接一个报错处理</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">let</span> clazz = <span class="title class_">Java</span>.<span class="title function_">use</span>(className);</span><br><span class="line">           </span><br><span class="line">           <span class="comment">// 获取接口数组</span></span><br><span class="line">           <span class="keyword">let</span> resultArr = clazz.<span class="property">class</span>.<span class="title function_">getInterfaces</span>();</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resultArr: &quot;</span>, resultArr);</span><br><span class="line">           <span class="keyword">if</span> (resultArr.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; resultArr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">               </span><br><span class="line">               <span class="comment">// 比对这个接口，打印这个数组</span></span><br><span class="line">               <span class="keyword">if</span> (resultArr[i].<span class="title function_">toString</span>().<span class="title function_">indexOf</span>(<span class="string">&quot;com.xiaojianbang.app.TestRegisterClass&quot;</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">                   <span class="variable language_">console</span>.<span class="title function_">log</span>(className, resultArr);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Didn&#x27;t find class: &quot;</span> + className)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>出了一点小bug，但是问题不大，还是得到了接口的实现类，对于不在同一个dex中的直接 try-catch 处理算了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241022215523856.png" alt="image-20241022215523856"></p>
<h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>和接口的方法极其相似，但是牢弟你要知道接口可以实现多个，但是抽象类只能实现一个，因此 getSuperclass() 获取到的不是一个数组，所以不需要循环了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">var</span> classes = <span class="title class_">Java</span>.<span class="title function_">enumerateLoadedClassesSync</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环所有已经加载的类</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">const</span> index <span class="keyword">in</span> classes) &#123;</span><br><span class="line">       <span class="keyword">let</span> className = classes[index];</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 过滤掉部分系统类</span></span><br><span class="line">       <span class="keyword">if</span> (className.<span class="title function_">indexOf</span>(<span class="string">&quot;com.xiaojianbang&quot;</span>) === -<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// try一下防止有的类不在同一加载器，直接一个报错处理</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">let</span> clazz = <span class="title class_">Java</span>.<span class="title function_">use</span>(className);</span><br><span class="line">           </span><br><span class="line">           <span class="comment">// 获取抽象类</span></span><br><span class="line">           <span class="keyword">let</span> resultArr = clazz.<span class="property">class</span>.<span class="title function_">getSuperclass</span>();</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resultArr: &quot;</span>, className, resultArr);</span><br><span class="line">           <span class="keyword">if</span> (resultArr == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">           <span class="keyword">if</span> (resultArr[i].<span class="title function_">toString</span>().<span class="title function_">indexOf</span>(<span class="string">&quot;com.xiaojianbang.app.TestRegisterClass&quot;</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">               <span class="variable language_">console</span>.<span class="title function_">log</span>(className, resultArr);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">           <span class="comment">// console.log(&quot;Didn&#x27;t find class: &quot; + className)</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20241023110937621.png" alt="image-20241023110937621"></p>
<p>END</p>
]]></content>
      <categories>
        <category>逆向学习</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>JSEncrypt添加NOPadding填充</title>
    <url>/2024/11/19/JSEncrypt%E6%B7%BB%E5%8A%A0NOPadding%E5%A1%AB%E5%85%85/</url>
    <content><![CDATA[<h3 id="JSEncrypt添加NOPadding填充"><a href="#JSEncrypt添加NOPadding填充" class="headerlink" title="JSEncrypt添加NOPadding填充"></a>JSEncrypt添加NOPadding填充</h3><p>JSEncrypt是一个加密库，支持RSA加密，但是只有PKCS1的填充模式</p>
<p>之前了解到NOPadding的填充是在明文前面填充字节0，如果我想实现的话就可以进行手动填充</p>
<p>打个断点进去</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241118201358518.png" alt="image-20241118201358518"></p>
<span id="more"></span>

<p>结果在这直接return了，从这里进去</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241118201651343.png" alt="image-20241118201651343"></p>
<p>导出了一个方法,这个方法是用来将 hex 的十六进制数据转换成 base64 编码</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241118202056572.png" alt="image-20241118202056572"></p>
<p>继续进,getkey 方法是检验之前是否传入了key，不管，继续</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241118202319995.png" alt="image-20241118202319995"></p>
<p>进入加密方法，这个是关键方法</p>
<p>maxLength 是检测最大字符长度，不用管他，PKSC1Padding 和 NOPadding 都需要这个数</p>
<p>经过 pkcs2 处理后进行判断是否有内容，有内容就进行加密，然后进行hex编码，再进行hex转base64将结果返回。</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241118202631605.png" alt="image-20241118202631605"></p>
<p>这里就直接进PKSC1模式进行加密了，可以在这里加一个判断，让用户多传进来一个字符串，来判断模式，这样就可以二者兼得</p>
<p>开始尝试，依照pkcs写Nopadding照葫芦画瓢了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NOPadding (type1, byte[0]) pad input string s to n byte[n] array, and return a bigint</span></span><br><span class="line"><span class="comment">// 入乡随俗了老铁</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">nopkcs</span>(<span class="params">s, n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; s.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Message too long for RSA&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> ba = [];</span><br><span class="line">    <span class="keyword">var</span> i = s.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> c = s.<span class="title function_">charCodeAt</span>(i--);</span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="number">128</span>) &#123; <span class="comment">// encode using utf-8</span></span><br><span class="line">            ba[--n] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((c &gt; <span class="number">127</span>) &amp;&amp; (c &lt; <span class="number">2048</span>)) &#123;</span><br><span class="line">            ba[--n] = (c &amp; <span class="number">63</span>) | <span class="number">128</span>;</span><br><span class="line">            ba[--n] = (c &gt;&gt; <span class="number">6</span>) | <span class="number">192</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ba[--n] = (c &amp; <span class="number">63</span>) | <span class="number">128</span>;</span><br><span class="line">            ba[--n] = ((c &gt;&gt; <span class="number">6</span>) &amp; <span class="number">63</span>) | <span class="number">128</span>;</span><br><span class="line">            ba[--n] = (c &gt;&gt; <span class="number">12</span>) | <span class="number">224</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前面的都一样,但是处理完数据之后,就该填充0了,这时候就不一样了</span></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ba[--n] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(ba);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添一个判断model的逻辑</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">RSAKey</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">encrypt</span> = <span class="keyword">function</span> (<span class="params">text, model</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> maxLength = (<span class="variable language_">this</span>.<span class="property">n</span>.<span class="title function_">bitLength</span>() + <span class="number">7</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">var</span> m;</span><br><span class="line">    <span class="comment">// 还是保留默认是PKCS#1</span></span><br><span class="line">    <span class="keyword">if</span> (model == <span class="string">&quot;PKCSPadding&quot;</span> || model == <span class="literal">undefined</span> || model == <span class="literal">null</span>) &#123;</span><br><span class="line">        m = <span class="title function_">pkcs1pad2</span>(text, maxLength);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (model == <span class="string">&quot;NOPadding&quot;</span>) &#123;</span><br><span class="line">        m = <span class="title function_">nopkcs</span>(text, maxLength)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Invalid padding model&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="variable language_">this</span>.<span class="title function_">doPublic</span>(m);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> h = c.<span class="title function_">toString</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">var</span> length = h.<span class="property">length</span>;</span><br><span class="line">    <span class="comment">// fix zero before result</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; maxLength * <span class="number">2</span> - length; i++) &#123;</span><br><span class="line">        h = <span class="string">&quot;0&quot;</span> + h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>更改传入值，可以发现这之只是改了加密，还没改解密，不着急，先让这个传入两个参数，base形式的就先放一放</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241118210735767.png" alt="image-20241118210735767"></p>
<p>在相应的文件中更改，打断点调试的时候还是源代码，待我稍作思量，更益其巧</p>
<p>找到这个文件，上面有各个文件的信息啥的，代码没有被解析，怎么说呢，直接改吧</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241119145222944.png" alt="image-20241119145222944"></p>
<p>调用时，多接收一个参数</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241118211817786.png" alt="image-20241118211817786"></p>
<p>&#x2F;&#x2F; 处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">判断方法</span><br><span class="line">\n        var m;\n        // 还是保留默认的是PKCS#1\n        if (model == &#x27;PKCSPadding&#x27; || model == undefined || model == null) &#123;/n            m = pkcs1pad2(text, maxLength);/n        &#125; else if (model == &#x27;NOPadding&#x27;) &#123;\n            m = nopkcs(text, maxLength);\n        &#125; else &#123;\n            console.error(&#x27;Invalid padding model&#x27;);\n            returm null;\n        &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Nopadding填充操作</span><br><span class="line">function nopkcs(s, n) &#123;\n    if (n &lt; s.length) &#123;\n        console.error(&#x27;Message too long for RSA&#x27;);\n        return null;\n    &#125;\n    var ba = [];\n    var i = s.length - 1;\n    while (i &gt;= 0 &amp;&amp; n &gt; 0) &#123;\n        var c = s.charCodeAt(i--);\n        if (c &lt; 128) &#123;\n            ba[--n] = c;\n        &#125;\n        else if ((c &gt; 127) &amp;&amp; (c &lt; 2024)) &#123;\n            ba[--n] = (c &amp; 63) | 128;\n            ba[--n] = (c &gt;&gt; 6) | 192;\n        &#125;\n        else &#123;\n            ba[--n] = (c &amp; 63) | 128;\n            ba[--n] = ((c &gt;&gt; 6) &amp; 63) | 128;\n            ba[--n] = (c &gt;&gt; 12) | 224;\n        &#125;    \n    &#125;\n    // 前面的都一样，但是处理完数据之后，就改填充0了，这时候就比PKSC简单了\n    while (--n &gt; 0) &#123;\n        ba[--n] = 0;\n    &#125;\n     return new _jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger(ba);\n&#125;</span><br></pre></td></tr></table></figure>



<p>大功告成</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241119144624973.png" alt="image-20241119144624973"></p>
<p>验证一下</p>
<p>无需多言，还有解密</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241119145500510.png" alt="image-20241119145500510"></p>
<p>接下来写NOPadding的解密</p>
<p>和加密的套路差不多，先检验是否有私钥，然后获取 base64转hex 的方法，将密文转成hex</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241119153831614.png" alt="image-20241119153831614"></p>
<p>然后就是重点了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241119154429072.png" alt="image-20241119154429072"></p>
<p>这个C是处理hex数据的和解密无关，m我也看了一下直接用就行，真正处理的在 return上，这样也省事了，开始微操</p>
<p>加一个判断，通过打断点发现，这个m比较短，也就是说很可能就是明文的一种编码，反复实验之后先将这个 BigInteger 类型的数据转换成 byte 数组，然后将byte数组转换成utf-8的数据，有点弯弯绕。</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241119165204122.png" alt="image-20241119165204122"></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;return m;</span><br><span class="line">&gt;BigInteger &#123; &#x27;0&#x27;: 53753142, &#x27;1&#x27;: 201507, s: 0, t: 2 &#125;</span><br><span class="line"></span><br><span class="line">&gt;return m.toByteArray();</span><br><span class="line">&gt;[ 49, 50, 51, 52, 53, 54 ]</span><br><span class="line"></span><br><span class="line">&gt;return String.fromCharCode.apply(null, m.toByteArray());</span><br><span class="line">&gt;123456</span><br></pre></td></tr></table></figure>


</blockquote>
<p>需要更改的位置有</p>
<p>这个是调试视图，去那一堆没解析的乱码里去改！就不放图片了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241119165810685.png" alt="image-20241119165810685"></p>
<p>如此这般，NOPadding填充模式就完成了</p>
]]></content>
      <categories>
        <category>逆向实践</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向学习 0x08密码学基础</title>
    <url>/2024/11/19/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-0x08%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h1><p>概要：</p>
<p>在逆向中，非常有必要了解一下密码学，在逆向过程中，有些参数不知道来源，可能是随机生成、标准算法、自写算法加密</p>
<p>在安卓中，标准算法加密通常会 出现在Java、so(C\C++)、JS中</p>
<p>对于标准算法，Java中有现成的API调用，如果要使用这些API就需要使用指定的方法，就有了hook的机会，这些前面已经操作过了</p>
<span id="more"></span>

<p>C\C++中没有现成的系统API调用，开发者要么自己去实现算法，要么调用别人写好的模块，算法的运行就不依靠系统API，因此这些方法名可以进行混淆。我们需要根据各种标准算法的特征，去识别是否为标准算法</p>
<p>JS中没有系统API但是有知名的第三方库：CryptoJS、jsencrypt等</p>
<blockquote>
<p>常见的算法：</p>
<p>​	信息摘要算法（散列函数、哈希函数）</p>
<p>​		MD5、SHA、MAC</p>
<p>​	对称加密算法</p>
<p>​		DES、3DES、AES</p>
<p>​	非对称加密算法</p>
<p>​		RSA</p>
<p>​	数字签名算法</p>
<p>​		MD5withRSA、SHA1withRSA、SHA256withRSA</p>
</blockquote>
<h3 id="H5的app逆向"><a href="#H5的app逆向" class="headerlink" title="H5的app逆向"></a>H5的app逆向</h3><p>使用前面提到过的查看app界面控件的小东西，看一下</p>
<p>这个页面只有框架，这个就是将一个网页做的像app登录的页面，然后放到这个框架里</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241102162750820.png" alt="image-20241102162750820"></p>
<blockquote>
<p>那么这个时候的逆向思路是什么呢</p>
<p>1、H5的核心代码通常在JS文件中</p>
<p>​		远程调试、修改JS代码注入代码</p>
<p>2、WebView远程调试</p>
<p>​	注意：a. 手机端的WebView版本要比电脑端的chrome版本低</p>
<p>​			   b. 手机端的WebView要开启可调式</p>
<p>​		 	  c. 需要VPN，因为点击inspect时要下载一些东西</p>
<p>​			   d. 通常app中的WebView是不可调试的，需要hook来开启调试</p>
</blockquote>
<h3 id="WebView调试准备"><a href="#WebView调试准备" class="headerlink" title="WebView调试准备"></a>WebView调试准备</h3><p>上面有四条了，chrome访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chrome://inspect</span><br></pre></td></tr></table></figure>

<p>可以看到是有设备的一些信息的 </p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241102164435629.png" alt="image-20241102164435629"></p>
<p>在手机中尝试随便访问一个网站，然后刷新chrome页面，是可以看到有页面情况的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241102164619306.png" alt="image-20241102164619306"></p>
<p>也是有webView的，而且为啥拿百度呢，因为百度是开启了webview调试的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241102164936217.png" alt="image-20241102164936217"></p>
<p>点击chrome中的inspect就可以进入谷歌的开发者工具，可以打断点，调试什么的，剩下的就交给JS逆向了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241102165507956.png" alt="image-20241102165507956"></p>
<p>再回头来看怎么开启WebView调试</p>
<p>不开启调试是获取不到东西的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241102165834207.png" alt="image-20241102165834207"></p>
<p>hook掉WebView方法，设置为开启调试状态</p>
<p>代码hook了所有的构造方法，在构造方法中设置开启调试，再hook掉开启方法，始终保持为true</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">WebView</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;android.webkit.WebView&#x27;</span>);</span><br><span class="line">    <span class="title class_">WebView</span>.<span class="property">$init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;android.content.Context&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WebView.$init is called!&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> retval = <span class="variable language_">this</span>.$init(a);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setWebContentsDebuggingEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">WebView</span>.<span class="property">$init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;android.content.Context&#x27;</span>, <span class="string">&#x27;android.util.AttributeSet&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WebView.$init is called!&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> retval = <span class="variable language_">this</span>.$init(a, b);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setWebContentsDebuggingEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">WebView</span>.<span class="property">$init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;android.content.Context&#x27;</span>, <span class="string">&#x27;android.util.AttributeSet&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a, b, c</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WebView.$init is called!&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> retval = <span class="variable language_">this</span>.$init(a, b, c);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setWebContentsDebuggingEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">WebView</span>.<span class="property">$init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;android.content.Context&#x27;</span>, <span class="string">&#x27;android.util.AttributeSet&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;boolean&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a, b, c, d</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WebView.$init is called!&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> retval = <span class="variable language_">this</span>.$init(a, b, c, d);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setWebContentsDebuggingEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">WebView</span>.<span class="property">$init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;android.content.Context&#x27;</span>, <span class="string">&#x27;android.util.AttributeSet&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a, b, c, d</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WebView.$init is called!&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> retval = <span class="variable language_">this</span>.$init(a, b, c, d);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setWebContentsDebuggingEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">WebView</span>.<span class="property">$init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;android.content.Context&#x27;</span>, <span class="string">&#x27;android.util.AttributeSet&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;java.util.Map&#x27;</span>, <span class="string">&#x27;boolean&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a, b, c, d, e</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WebView.$init is called!&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> retval = <span class="variable language_">this</span>.$init(a, b, c, d, e);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setWebContentsDebuggingEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">WebView</span>.<span class="property">$init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;android.content.Context&#x27;</span>, <span class="string">&#x27;android.util.AttributeSet&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;java.util.Map&#x27;</span>, <span class="string">&#x27;boolean&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a, b, c, d, e, f</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WebView.$init is called!&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> retval = <span class="variable language_">this</span>.$init(a, b, c, d, e, f);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setWebContentsDebuggingEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title class_">WebView</span>.<span class="property">setWebContentsDebuggingEnabled</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setWebContentsDebuggingEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setWebContentsDebuggingEnabled is called!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>将这个脚本重启附加到app中</p>
<p>必须要重启不能附加，因为页面都构建完成了，时机过去了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frida -U -f com.zngst.app -l hook_webview.js</span><br></pre></td></tr></table></figure>



<p>这个时候就成功了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241102171105422.png" alt="image-20241102171105422"></p>
<p>登录以下是，抓个包</p>
<p>从这里可以跳转到登录有关的方法，跳转，打断点就不展示了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241102171451165.png" alt="image-20241102171451165"></p>
<blockquote>
<p>H5的app也分很多种</p>
<p>​	1、纯JS发包，这个时候可以在远程调试工具上抓到包，也有相应JS代码</p>
<p>​	2、部分JS发包，部分Java发包，这个时候有些包可以在调试工具上抓到，有些不行，需要分析</p>
<p>​			比如：Java和JS的相互调用，从这个角度入手，找Java里面的接口。</p>
<p>​	3、纯Java发包，典型的就是uni-app，但是uni-app核心代码是在JS中，因为就是用JS写的。这个就牛逼了。发包在Java中，谷歌中看不到代码，这个时候远程调试就没啥用了。只能修改JS代码注入代码。对uni-app感兴趣可以下载一个HBuilderX耍一下</p>
</blockquote>
<h2 id="HEX编码"><a href="#HEX编码" class="headerlink" title="HEX编码"></a>HEX编码</h2><p>闲话少扯，看密码学内容，H5的app弄到调试的位置剩下的就和JS逆向差不多了</p>
<blockquote>
<p>概述：</p>
<p>​	HEX编码是一种用16进制字符表示任意二进制数据的方法</p>
<p>​	是一种编码，不存在加密</p>
</blockquote>
<p>一个字节的范围是 0-255 ，hex编码用两个16进制字符表示这个一个字节</p>
<p>第一个F就代表了二进制中前四个比特位 <code>1111</code> 。也就是说十六进制中的一个十六进制字符占四个比特位，半个字节。两个十六进制字符，就可以表示八个比特位一个字节的数据。</p>
<img src="../图片/image-20241102174147974.png" alt="image-20241102174147974" style="zoom: 67%;" />



<blockquote>
<p>注意和字符编码区分开来：</p>
<p>​	字符编码有 ASCII、UTF-8、GBK</p>
<p>​	字符编码说白了是一种映射规则，将字符映射到唯一一种状态（二进制字符串），这个就是编码。也就是说如果没有字符编码来表示特定二进制的意思，那我们就只能读0101101这样的01字符串了</p>
<p>USC2、URL和HEX差不多是一种编码方式</p>
</blockquote>
<h3 id="hex编码的代码实现及码表"><a href="#hex编码的代码实现及码表" class="headerlink" title="hex编码的代码实现及码表"></a>hex编码的代码实现及码表</h3><p>这个是一个针对字符串的实现，还有char的</p>
<p>是用函数将字符串转换成二进制，然后转换成16进制的表示方式</p>
<p>char数组直接转换</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241102181035429.png" alt="image-20241102181035429"></p>
<p>不够底层，看一下Java第三方库的一个处理方法</p>
<p>看注释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">hex</span><span class="params">(data)</span> &#123;</span><br><span class="line">    <span class="comment">// 码表</span></span><br><span class="line">    <span class="type">char</span>[] HEX_DIGITS = &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;</span><br><span class="line">	<span class="comment">// 创建char数组，长度为明文字节的长度 * 2，因为两个十六进制字符才能表示一个字节信息</span></span><br><span class="line">    <span class="type">char</span>[] result = <span class="keyword">new</span> <span class="title class_">char</span>[data.length * <span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 取出字节，挨个处理</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">byte</span> b: data) &#123;</span><br><span class="line">        <span class="comment">// 先将二进制数据右移四位</span></span><br><span class="line">        <span class="comment">// 比如： 1111 1111</span></span><br><span class="line">        <span class="comment">// 右移： 0000 1111 1111</span></span><br><span class="line">        <span class="comment">// 结果后面的四个字符被舍去为：0000 1111</span></span><br><span class="line">        <span class="comment">// 然后进行 &amp; 操纵，只有两个都为1才是1，0xf的值为0000 1111</span></span><br><span class="line">        <span class="comment">// 比如：1010 1111 右移四位 0000 1010</span></span><br><span class="line">        <span class="comment">// &amp; 操作之后的结果为 0000 1010 ，成功取出前四位</span></span><br><span class="line">        result[c++] = HEX_DIGITS[(b &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xf</span>];</span><br><span class="line">        <span class="comment">// 再进行 &amp; 操作 1010 1111 和 0000 1111</span></span><br><span class="line">        <span class="comment">// 结果为 0000 1111 ，成功取出后四位</span></span><br><span class="line">        result[c++] = HEX_DIGITS[b &amp; <span class="number">0xf</span>];</span><br><span class="line">        <span class="comment">// 利用这样的操作，两个代码，第一行获取高四位，第二行获取低四位。来转换成HEX编码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(result)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写一个小小的注释，这个中括号内传入的是二进制数据，就会根据二进制找到对应的索引</span></span><br></pre></td></tr></table></figure>



<p>光看这个hex编码有点无聊，思路打开，为什么码表一定要0-9+a-f呢，将码表改一下，那就是一个非标准的hex编码。这个时候就需要找到这个码表了</p>
<blockquote>
<p>hex编码的特点：</p>
<p>​	1、用0-9 a-f 十六个字符表示</p>
<p>​	2、每个十六进制字符代表4bit，也就是2个十六进制字符代表一个字节</p>
<p>​	3、在实际的应用中，比如密钥初始化，一定要分清楚传进去的密钥是哪种编码，采用对应的方式解析，才能得到对应的密钥</p>
<p>​	4、编程中的很多问题，需要从字节甚至二进制位的角度去考虑</p>
</blockquote>
<h2 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h2><blockquote>
<p>用64个字符表示任意二进制数据的方法</p>
<p>base64是一种编码，而非加密</p>
<p>64个字符表示256种情况。和hex编码不同，hex编码是16*16正好为256，所以正好可以将一个字节拆开，用两个十六进制字符表示。一个十六进制字符占4bit</p>
<p>与hex不同的是base64编码的一个字符占6bit，用四个字符表示三个字节 6*4&#x3D;8*3</p>
<p>base64使用的字符为 A-Z a-z 0-9 + &#x2F; &#x3D;</p>
<p>实际使用的是65个，最后的等号是用来补位填充的，看上面的表示方式应该也能理解为啥需要补位吧</p>
</blockquote>
<p>base64的应用比较光，比如RSA密钥、加密后的密文、图片等数据，会有一些不可见的字符，直接转成文本传输的话，会有乱码、数据错误、数据丢失等情况，就需要用到base64编码</p>
<p>瞅一下实现代码</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241105193154873.png" alt="image-20241105193154873"></p>
<p>大致了解一下这个处理过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个方法，作用于 ByteArray 类型，它接受一个可选参数 map</span></span><br><span class="line"><span class="comment">// 参数的默认值为BASE64，这个是BASE64编码的字典</span></span><br><span class="line"><span class="comment">// internal val BASE64 =</span></span><br><span class="line"><span class="comment">//   &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;.encodeUtf8().data</span></span><br><span class="line">internal fun ByteArray.encodeBase64(map: ByteArray = BASE64): String &#123;</span><br><span class="line">    <span class="comment">// 因为base64四位字符表示三个字节，+2是防止数据丢失</span></span><br><span class="line">	<span class="type">val</span> <span class="variable">length</span> <span class="operator">=</span> (size + <span class="number">2</span>) / <span class="number">3</span> * <span class="number">4</span></span><br><span class="line">    <span class="comment">// 创建新字节数组，来存储编码后的结果</span></span><br><span class="line">	<span class="type">val</span> <span class="variable">out</span> <span class="operator">=</span> ByteArray(length)</span><br><span class="line">    <span class="comment">// 定义索引</span></span><br><span class="line">	<span class="type">var</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">// 因为之前无脑+2了，这里处理一下结束位置，避免不必要的补位</span></span><br><span class="line">	<span class="type">val</span> <span class="variable">end</span> <span class="operator">=</span> size - size % <span class="number">3</span></span><br><span class="line">	<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">// 遍历数组</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; end) &#123;</span><br><span class="line">        <span class="comment">// 先读取前三个字节的二进制数据，转换成int类型</span></span><br><span class="line">    	<span class="type">val</span> <span class="variable">b0</span> <span class="operator">=</span> <span class="built_in">this</span>[i++].toInt()</span><br><span class="line">    	<span class="type">val</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="built_in">this</span>[i++].toInt()</span><br><span class="line">    	<span class="type">val</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="built_in">this</span>[i++].toInt()</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 截取b0 的前六位数据，b0 的后两位和 b1 的前四位，b1 的后四位和 b2 的前两位，b2 的后六位</span></span><br><span class="line">    	out[index++] = map[(b0 and <span class="number">0xff</span> shr <span class="number">2</span>)]</span><br><span class="line">    	out[index++] = map[(b0 and <span class="number">0x03</span> shl <span class="number">4</span>) or (b1 and <span class="number">0xff</span> shr <span class="number">4</span>)]</span><br><span class="line">    	out[index++] = map[(b1 and <span class="number">0x0f</span> shl <span class="number">2</span>) or (b2 and <span class="number">0xff</span> shr <span class="number">6</span>)]</span><br><span class="line">    	out[index++] = map[(b2 and <span class="number">0x3f</span>)]</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否有剩余字节长度，如果有进入when</span></span><br><span class="line">	when (size - end) &#123;</span><br><span class="line">        <span class="comment">// 如果剩一个字节</span></span><br><span class="line">		<span class="number">1</span> -&gt; &#123;</span><br><span class="line">            <span class="comment">// 用两位base64字符读取这一个字节，再来两位字符“==”补位</span></span><br><span class="line">			<span class="type">val</span> <span class="variable">b0</span> <span class="operator">=</span> <span class="built_in">this</span>[i].toInt()</span><br><span class="line">			out[index++] = map[b0 and <span class="number">0xff</span> shr <span class="number">2</span>]</span><br><span class="line">			out[index++] = map[b0 and <span class="number">0x03</span> shl <span class="number">4</span>]</span><br><span class="line">			out[index++] = <span class="string">&#x27;=&#x27;</span>.code.toByte()</span><br><span class="line">			out[index] = <span class="string">&#x27;=&#x27;</span>.code.toByte()</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 如果剩两个字节</span></span><br><span class="line">		<span class="number">2</span> -&gt; &#123;</span><br><span class="line">            <span class="comment">// 用三位base64字符读取剩余的两个字节，再使用一个“=”补位</span></span><br><span class="line">			<span class="type">val</span> <span class="variable">b0</span> <span class="operator">=</span> <span class="built_in">this</span>[i++].toInt()</span><br><span class="line">			<span class="type">val</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="built_in">this</span>[i].toInt()</span><br><span class="line">			out[index++] = map[(b0 and <span class="number">0xff</span> shr <span class="number">2</span>)]</span><br><span class="line">			out[index++] = map[(b0 and <span class="number">0x03</span> shl <span class="number">4</span>) or (b1 and <span class="number">0xff</span> shr <span class="number">4</span>)]</span><br><span class="line">			out[index++] = map[(b1 and <span class="number">0x0f</span> shl <span class="number">2</span>)]</span><br><span class="line">			out[index] = <span class="string">&#x27;=&#x27;</span>.code.toByte()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 返回处理好的数据</span></span><br><span class="line">	<span class="keyword">return</span> out.toUtf8String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>它其实还有一套码表，是BASE64_URL_SAFE</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">internal <span class="type">val</span> <span class="variable">BASE64_URL_SAFE</span> <span class="operator">=</span></span><br><span class="line"><span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_&quot;</span>.encodeUtf8().data</span><br></pre></td></tr></table></figure>

<p>看名字就知道用途了，如果用于url编码，+就变为空格了，数据就出大问题，所以就需要把+&#x2F;给替换掉，就换成了-_，这样一替换就不需要再进行url编码了</p>
</blockquote>
<p>再了解一下核心科技，转换字符部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如进去的三个字节为 e f g</span></span><br><span class="line"><span class="comment">// toInt是将字节根据ASCII码表将其转化为数字</span></span><br><span class="line"><span class="type">val</span> <span class="variable">b0</span> <span class="operator">=</span> <span class="built_in">this</span>[i++].toInt()	<span class="comment">// 101</span></span><br><span class="line"><span class="type">val</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="built_in">this</span>[i++].toInt()	<span class="comment">// 102</span></span><br><span class="line"><span class="type">val</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="built_in">this</span>[i++].toInt()	<span class="comment">// 103</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 101 的二进制 0110 0101 和1111 1111 进行 &amp; 操作，结果不变再进行shr 2的操作，得到结果 0001 1001（25=&#x27;Z&#x27;）</span></span><br><span class="line">out[index++] = map[(b0 and <span class="number">0xff</span> shr <span class="number">2</span>)]</span><br><span class="line"><span class="comment">// 将 0110 0101 和 0000 0011 进行 &amp; 操作，得到01</span></span><br><span class="line"><span class="comment">// 再将 0110 0110 和 1111 1111 进行 &amp; 操作，结果不变，再右移四位 0000 0110。合并这两部分 0001 0110（22=&#x27;W&#x27;）</span></span><br><span class="line">out[index++] = map[(b0 and <span class="number">0x03</span> shl <span class="number">4</span>) or (b1 and <span class="number">0xff</span> shr <span class="number">4</span>)]</span><br><span class="line"><span class="comment">// 将 0110 0110 和 0000 1111 &amp; 操作，得到 0000 0110， 再从取 0110 0111 的前两位，组成 0001 1001（25=&#x27;Z&#x27;）</span></span><br><span class="line">out[index++] = map[(b1 and <span class="number">0x0f</span> shl <span class="number">2</span>) or (b2 and <span class="number">0xff</span> shr <span class="number">6</span>)]</span><br><span class="line"><span class="comment">// 得到最后的六个 0010 0111（39=&#x27;n&#x27;）</span></span><br><span class="line">out[index++] = map[(b2 and <span class="number">0x3f</span>)]</span><br><span class="line">    </span><br><span class="line"><span class="comment">// efg的base64编码结果为ZWZn</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>base64编码的特点</p>
<p>​	1、Base64编码是一种编码，编码后会增加字节数</p>
<p>​	2、算法可逆，解码很方便，不用于私密信息通信</p>
<p>​	3、标准的Base64每行76个字符，行末添加换行符（这个需要注意，在拿到base64字符串进行解密操作的时候，一定不要忘了加上换行符）</p>
<p>​	4、加密后的字符串只有65种字符，不可打印的字符也能传输</p>
<p>​	5、在Java层可以通过hook对应的方法名来快速定位关键代码</p>
<p>​	6、在so层可以通过输入输出的数据和码表来确定算法</p>
</blockquote>
<h3 id="工具函数封装"><a href="#工具函数封装" class="headerlink" title="工具函数封装"></a>工具函数封装</h3><p>使用安卓的一个API，ByteString将byte数组转换成对应的hex编码或者base64编码，方便数据的查找和显示</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">ByteString</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.android.okhttp.okio.ByteString&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">toBase64</span>(<span class="params">tag, data</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(tag + <span class="string">&quot;Base64：&quot;</span> + <span class="title class_">ByteString</span>.<span class="title function_">of</span>(data).<span class="title function_">base64</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">toHex</span>(<span class="params">tag, data</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(tag + <span class="string">&quot;hex：&quot;</span> + <span class="title class_">ByteString</span>.<span class="title function_">of</span>(data).<span class="title function_">hex</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">toUtf8</span>(<span class="params">tag, data</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(tag + <span class="string">&quot;Utf8：&quot;</span> + <span class="title class_">ByteString</span>.<span class="title function_">of</span>(data).<span class="title function_">utf8</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>





<h2 id="信息摘要算法"><a href="#信息摘要算法" class="headerlink" title="信息摘要算法"></a>信息摘要算法</h2><blockquote>
<p>特点：</p>
<p>​	1、不同长度的输入，产生固定长度的输出</p>
<p>​	2、信息摘要算法&#x2F;单向散列函数&#x2F;哈希函数</p>
<p>​	3、散列后的密文不可逆</p>
<p>​	4、散列后的结果唯一</p>
<p>​	5、哈希碰撞</p>
<p>​	6、一般用于校验数据完整性、签名sign</p>
<p>​			由于密文不可逆，所以服务端也无法解密</p>
<p>​			想要验证，只能跟前端一样再重新验证、计算签名</p>
<p>​			签名算法一般会把源数据和签名后的值一起提交到数据段</p>
<p>​			要保证在签名的时候的数据和提交上去的源数据一致</p>
<p>常见算法：MD5、SHA1、SHA256、SHA512、HmacMD5、HmacSHA1、HmacSHA256、HmacSHA512、RIPEMD160、HmacRIPEMD160、PBKDF2、EvpKDF</p>
<p>根据密文不可逆就可以推测出，签名的明文一定在数据包内，让服务端知道，否则服务端无法验证密文真伪</p>
</blockquote>
<p>之前在Java层逆向的时候，小记了一下如何区分签名算法</p>
<img src="../图片/image-20241105210941137.png" alt="image-20241105210941137"  />



<p>SHA-0已经废弃了，SHA-3虽然2011发布，但是不常见，常见的是MD5、SHA-1、SHA-256，这个256是SHA-2的256，SHA-2的256和SHA-3的256算出来的结果是不一样的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241105211506561.png" alt="image-20241105211506561"></p>
<blockquote>
<p>输出散列值长度是输出的结果占的字节数，比如MD5占128个字节</p>
<p>资料区块长度是算法进行分组摘要，如MD5每组分512bit</p>
<p>哈希碰撞：即出现不同的信息算出的MD5相同的情况，所以现在很多都使用SHA-256进行签名，虽然哈希碰撞的概率很小，但是是客观存在的</p>
</blockquote>
<h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><p>MD5的Java实现，想要实现MD5很简单，因为Java已经写好这个底层了，直接拿来主义就好</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先获取到MD5的对象</span></span><br><span class="line"><span class="type">MessageDigest</span> <span class="variable">md5</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line"><span class="comment">// 使用 .update 进行加密操作，注意传进去的要是byte数组</span></span><br><span class="line">md5.update(<span class="string">&quot;demo&quot;</span>.getBytes());</span><br><span class="line"><span class="comment">// 返回的结果也需要byte数组接收</span></span><br><span class="line"><span class="type">byte</span>[] bytes = md5.digest();</span><br><span class="line"><span class="comment">// 想要打印结果再将byte数组使用hex或者base64编码一下即可</span></span><br></pre></td></tr></table></figure>



<h4 id="算法加盐"><a href="#算法加盐" class="headerlink" title="算法加盐"></a>算法加盐</h4><p>通俗点来说就是在明文前&#x2F;后加上一段固定的字符串，来计算MD5，想要获取盐值也很简单，传一个空的得到MD5去网站上，爆破一下就好了</p>
<p><a href="https://www.cmd5.com/">https://www.cmd5.com/</a></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241106184835852.png" alt="image-20241106184835852"></p>
<h3 id="SHA"><a href="#SHA" class="headerlink" title="SHA"></a>SHA</h3><p>SHA的Java实现</p>
<p>和MD5的方法几乎一模一样，就是把传进去的名字改一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先获取到SHA-1的对象</span></span><br><span class="line"><span class="type">MessageDigest</span> <span class="variable">sha1</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;SHA-1&quot;</span>);</span><br><span class="line"><span class="comment">// 使用 .update 进行加密操作，注意传进去的要是byte数组</span></span><br><span class="line">sha1.update(<span class="string">&quot;demo&quot;</span>.getBytes());</span><br><span class="line"><span class="comment">// 返回的结果也需要byte数组接收</span></span><br><span class="line"><span class="type">byte</span>[] bytes = sha1.digest();</span><br><span class="line"><span class="comment">// 想要打印结果再将byte数组使用hex或者base64编码一下即可</span></span><br></pre></td></tr></table></figure>





<h3 id="算法通杀"><a href="#算法通杀" class="headerlink" title="算法通杀"></a>算法通杀</h3><p>所谓的通杀也只是hook标准算法需要走的Java层一些函数，如果不走这个函数也杀不掉，如果不是标准算法更杀不掉</p>
<h4 id="MD5的hook"><a href="#MD5的hook" class="headerlink" title="MD5的hook"></a>MD5的hook</h4><p>将之前的工具函数和打印堆栈先拿过来</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">showStacks</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">        	<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>)</span><br><span class="line">            	.<span class="title function_">getStackTraceString</span>(</span><br><span class="line">                	<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new()</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">ByteString</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.android.okhttp.okio.ByteString&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">toBase64</span>(<span class="params">tag, data</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(tag + <span class="string">&quot;Base64：&quot;</span> + <span class="title class_">ByteString</span>.<span class="title function_">of</span>(data).<span class="title function_">base64</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">toHex</span>(<span class="params">tag, data</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(tag + <span class="string">&quot;hex：&quot;</span> + <span class="title class_">ByteString</span>.<span class="title function_">of</span>(data).<span class="title function_">hex</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">toUtf8</span>(<span class="params">tag, data</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(tag + <span class="string">&quot;Utf8：&quot;</span> + <span class="title class_">ByteString</span>.<span class="title function_">of</span>(data).<span class="title function_">utf8</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>如果要hook安卓的md5，根据上方的实现代码，有两个方法需要hook，一个是 update 另一个是 digest，因为 digest 也是可以传明文数值的</p>
<p>update这个方法在 java.security 包下的 MessageDigest 类中，有很多重载方法</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241106193133857.png" alt="image-20241106193133857"></p>
<p>hook update方法</p>
<p>因为加密的数据可能不是明文，而是乱码，这个时候就需要之前的工具函数来进行转换显示</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> messageDigest = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.security.MessageDigest&quot;</span>)</span><br><span class="line">messageDigest.<span class="property">update</span>.<span class="title function_">overload</span>(<span class="string">&#x27;byte&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;MessageDigest update(&#x27;byte&#x27;): &quot;</span> + data);</span><br><span class="line">    <span class="title function_">showStacks</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">update</span>(data);</span><br><span class="line">&#125;</span><br><span class="line">messageDigest.<span class="property">update</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.nio.ByteBuffer&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;MessageDigest update(&#x27;java.nio.ByteBuffer&#x27;): &quot;</span> + data);</span><br><span class="line">    <span class="title function_">showStacks</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">update</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意下面的这两个是比较常用到的</span></span><br><span class="line">messageDigest.<span class="property">update</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;MessageDigest update(&#x27;[B&#x27;)&quot;</span>);</span><br><span class="line">    <span class="title function_">showStacks</span>();</span><br><span class="line">    <span class="comment">// getAlgorithm() 获取算法名称</span></span><br><span class="line">    <span class="keyword">var</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>();</span><br><span class="line">    <span class="keyword">var</span> tag = algorithm + <span class="string">&quot; update(&#x27;[B&#x27;)&quot;</span>;</span><br><span class="line">    <span class="title function_">toBase64</span>(tag, data);</span><br><span class="line">    <span class="title function_">toHex</span>(tag, data);</span><br><span class="line">    <span class="title function_">toUtf8</span>(tag, data);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;===========================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">update</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个是定义字符串从什么地方开始截取，取多长</span></span><br><span class="line">messageDigest.<span class="property">update</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">data,start, len</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;MessageDigest update(&#x27;[B&#x27;, &#x27;int&#x27;, &#x27;int&#x27;)&quot;</span>);</span><br><span class="line">    <span class="title function_">showStacks</span>();</span><br><span class="line">    <span class="keyword">var</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>();</span><br><span class="line">    <span class="keyword">var</span> tag = algorithm + <span class="string">&quot; update(&#x27;[B&#x27;)&quot;</span>;</span><br><span class="line">    <span class="title function_">toBase64</span>(tag, data);</span><br><span class="line">    <span class="title function_">toHex</span>(tag, data);</span><br><span class="line">    <span class="title function_">toUtf8</span>(tag, data);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;==============================================&quot;</span>, start, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">update</span>(data, start, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241106200233800.png" alt="image-20241106200233800"></p>
<h4 id="SHA-1"><a href="#SHA-1" class="headerlink" title="SHA"></a>SHA</h4><p>SHA算法在安卓中实现的时候，就和MD5几乎一样，只有一个名字不一样，但是又使用了 MessageDigest 类的 getAlgorithm 方法，来获取传入的名字，这个时候MD5的和SHA的hook就是互通的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241106200618601.png" alt="image-20241106200618601"></p>
<p>hook digest方法</p>
<p>toUtf8就是看热闹，包乱码的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hook digest方法</span></span><br><span class="line">messageDigest.<span class="property">digest</span>.<span class="title function_">overload</span>().<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;MessageDigest digest()&quot;</span>);</span><br><span class="line">    <span class="title function_">showStacks</span>();</span><br><span class="line">    <span class="keyword">var</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>();</span><br><span class="line">    <span class="keyword">var</span> tag = algorithm + <span class="string">&quot; digest data&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">digest</span>();</span><br><span class="line">    <span class="title function_">toBase64</span>(tag, result);</span><br><span class="line">    <span class="title function_">toHex</span>(tag, result);</span><br><span class="line">    <span class="title function_">toUtf8</span>(tag, result);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;==================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">messageDigest.<span class="property">digest</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;MessageDigest digest()&quot;</span>);</span><br><span class="line">    <span class="title function_">showStacks</span>();</span><br><span class="line">    <span class="keyword">var</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>();</span><br><span class="line">    <span class="keyword">var</span> tag = algorithm + <span class="string">&quot; digest data&quot;</span>;</span><br><span class="line">    <span class="title function_">toBase64</span>(tag, data);</span><br><span class="line">    <span class="title function_">toHex</span>(tag, data);</span><br><span class="line">    <span class="title function_">toUtf8</span>(tag, data);</span><br><span class="line">    <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">digest</span>(data);</span><br><span class="line">    <span class="title function_">toBase64</span>(tag, result);</span><br><span class="line">    <span class="title function_">toHex</span>(tag, result);</span><br><span class="line">    <span class="title function_">toUtf8</span>(tag, result);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;==================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">messageDigest.<span class="property">digest</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">data, start, len</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;MessageDigest digest()&quot;</span>);</span><br><span class="line">    <span class="title function_">showStacks</span>();</span><br><span class="line">    <span class="keyword">var</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>();</span><br><span class="line">    <span class="keyword">var</span> tag = algorithm + <span class="string">&quot; digest data&quot;</span>;</span><br><span class="line">    <span class="title function_">toBase64</span>(tag, data);</span><br><span class="line">    <span class="title function_">toHex</span>(tag, data);</span><br><span class="line">    <span class="title function_">toUtf8</span>(tag, data);</span><br><span class="line">    <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">digest</span>(data, start, len);</span><br><span class="line">    <span class="title function_">toBase64</span>(tag, result);</span><br><span class="line">    <span class="title function_">toHex</span>(tag, result);</span><br><span class="line">    <span class="title function_">toUtf8</span>(tag, result);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;==================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241106203420408.png" alt="image-20241106203420408"></p>
<h3 id="MAC算法"><a href="#MAC算法" class="headerlink" title="MAC算法"></a>MAC算法</h3><p>MAC系列算法</p>
<table>
<thead>
<tr>
<th align="center">算法</th>
<th align="center">摘要长度</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">HmacMD5</td>
<td align="center">128</td>
<td align="center">Java6实现</td>
</tr>
<tr>
<td align="center">HmacSHA1</td>
<td align="center">160</td>
<td align="center">Java6实现</td>
</tr>
<tr>
<td align="center">HmacSHA256</td>
<td align="center">256</td>
<td align="center">Java6实现</td>
</tr>
<tr>
<td align="center">HmacSHA384</td>
<td align="center">384</td>
<td align="center">Java6实现</td>
</tr>
<tr>
<td align="center">HmacSHA512</td>
<td align="center">512</td>
<td align="center">Java6实现</td>
</tr>
<tr>
<td align="center">HmacMD2</td>
<td align="center">128</td>
<td align="center">Bouncy Castle实现</td>
</tr>
<tr>
<td align="center">HmacMD4</td>
<td align="center">128</td>
<td align="center">Bouncy Castle实现</td>
</tr>
<tr>
<td align="center">HmacSHA224</td>
<td align="center">224</td>
<td align="center">Bouncy Castle实现</td>
</tr>
</tbody></table>
<p>MAC算法和MD和SHA算法的唯一区别就是多了一个密钥，密钥可以随便给</p>
<p>Java实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 首先实例化密钥，指明算法名字，得到密钥对象</span></span><br><span class="line">   <span class="type">SecretKeySpec</span> <span class="variable">secretKeySpec</span> <span class="operator">=</span> </span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(<span class="string">&quot;a12345678&quot;</span>.getBytes(), <span class="string">&quot;HmacSHA1&quot;</span>);</span><br><span class="line"><span class="comment">// 获取算法名字，这里也可以直接给明文</span></span><br><span class="line">   <span class="type">Mac</span> <span class="variable">mac</span> <span class="operator">=</span> Mac.getInstance(secretKeySpec.getAlgorithm());</span><br><span class="line"><span class="comment">// 初始化密钥</span></span><br><span class="line">   mac.init(secretKeySpec);</span><br><span class="line"><span class="comment">// 这个就是和md5等相同了，放入明文，有重载函数</span></span><br><span class="line">   mac.update(<span class="string">&quot;demo&quot;</span>.getBytes());</span><br><span class="line"><span class="comment">// 和digest相似</span></span><br><span class="line">   mac.doFinal();</span><br></pre></td></tr></table></figure>



<h4 id="hook-MAC算法"><a href="#hook-MAC算法" class="headerlink" title="hook MAC算法"></a>hook MAC算法</h4><p>根据Java实现来hook算法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mac = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;javax.crypto.Mac&quot;</span>)</span><br><span class="line"><span class="comment">// 获取密钥，可以hook init方法也可以hook SecretKeySpec构造方法</span></span><br><span class="line">mac.<span class="property">init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.security.Key&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Mac Key&quot;</span>)</span><br><span class="line">    <span class="title function_">showStacks</span>();</span><br><span class="line">    <span class="keyword">var</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>();</span><br><span class="line">    <span class="keyword">var</span> tag = algorithm + <span class="string">&quot; Mac Key&quot;</span>;</span><br><span class="line">    <span class="comment">// key.getEncoded() 获取密钥的字节数组</span></span><br><span class="line">    <span class="title function_">toBase64</span>(tag, key.<span class="title function_">getEncoded</span>());</span><br><span class="line">    <span class="title function_">toHex</span>(tag, key.<span class="title function_">getEncoded</span>());</span><br><span class="line">    <span class="title function_">toUtf8</span>(tag, key.<span class="title function_">getEncoded</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">init</span>(key);</span><br><span class="line">&#125;</span><br><span class="line">mac.<span class="property">init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.security.Key&#x27;</span>, <span class="string">&#x27;java.security.spec.AlgorithmParameterSpec&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Mac Key&quot;</span>)</span><br><span class="line">    <span class="comment">// showStacks();</span></span><br><span class="line">    <span class="keyword">var</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>();</span><br><span class="line">    <span class="keyword">var</span> tag = algorithm + <span class="string">&quot;Mac Key&quot;</span>;</span><br><span class="line">    <span class="title function_">toBase64</span>(tag, key.<span class="title function_">getEncoded</span>());</span><br><span class="line">    <span class="title function_">toHex</span>(tag, key.<span class="title function_">getEncoded</span>());</span><br><span class="line">    <span class="title function_">toUtf8</span>(tag, key.<span class="title function_">getEncoded</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">init</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mac.<span class="property">update</span>.<span class="title function_">overload</span>(<span class="string">&#x27;byte&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Mac update(&#x27;byte&#x27;)&quot;</span>)</span><br><span class="line">    <span class="comment">// showStacks();</span></span><br><span class="line">    <span class="keyword">var</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>();</span><br><span class="line">    <span class="keyword">var</span> tag = algorithm + <span class="string">&quot; Mac update(&#x27;byte&#x27;)&quot;</span>;</span><br><span class="line">    <span class="title function_">toBase64</span>(tag, data);</span><br><span class="line">    <span class="title function_">toHex</span>(tag, data);</span><br><span class="line">    <span class="title function_">toUtf8</span>(tag, data);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;=====================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">update</span>(data);</span><br><span class="line">&#125;</span><br><span class="line">mac.<span class="property">update</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.nio.ByteBuffer&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Mac update(&#x27;java.nio.ByteBuffer&#x27;)&quot;</span>)</span><br><span class="line">    <span class="comment">// showStacks();</span></span><br><span class="line">    <span class="keyword">var</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>();</span><br><span class="line">    <span class="keyword">var</span> tag = algorithm + <span class="string">&quot; Mac update(&#x27;java.nio.ByteBuffer&#x27;)&quot;</span>;</span><br><span class="line">    <span class="title function_">toBase64</span>(tag, data);</span><br><span class="line">    <span class="title function_">toHex</span>(tag, data);</span><br><span class="line">    <span class="title function_">toUtf8</span>(tag, data);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;=====================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">update</span>(data);</span><br><span class="line">&#125;</span><br><span class="line">mac.<span class="property">update</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Mac update(&#x27;[B&#x27;)&quot;</span>)</span><br><span class="line">    <span class="comment">// showStacks();</span></span><br><span class="line">    <span class="keyword">var</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>();</span><br><span class="line">    <span class="keyword">var</span> tag = algorithm + <span class="string">&quot; Mac update(&#x27;[B&#x27;)&quot;</span>;</span><br><span class="line">    <span class="title function_">toBase64</span>(tag, data);</span><br><span class="line">    <span class="title function_">toHex</span>(tag, data);</span><br><span class="line">    <span class="title function_">toUtf8</span>(tag, data);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;=====================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">update</span>(data);</span><br><span class="line">&#125;</span><br><span class="line">mac.<span class="property">update</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">data, start, len</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Mac update(&#x27;[B&#x27;, &#x27;int&#x27;, &#x27;int&#x27;)&quot;</span>)</span><br><span class="line">    <span class="comment">// showStacks();</span></span><br><span class="line">    <span class="keyword">var</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>();</span><br><span class="line">    <span class="keyword">var</span> tag = algorithm + <span class="string">&quot; Mac update(&#x27;[B&#x27;, &#x27;int&#x27;, &#x27;int&#x27;)&quot;</span>;</span><br><span class="line">    <span class="title function_">toBase64</span>(tag, data);</span><br><span class="line">    <span class="title function_">toHex</span>(tag, data);</span><br><span class="line">    <span class="title function_">toUtf8</span>(tag, data);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;=====================================&quot;</span>, start, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">update</span>(data, start, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mac.<span class="property">doFinal</span>.<span class="title function_">overload</span>().<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Mac doFinal()&quot;</span>)</span><br><span class="line">    <span class="comment">// showStacks();</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">doFinal</span>();</span><br><span class="line">    <span class="keyword">var</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>();</span><br><span class="line">    <span class="keyword">var</span> tag = algorithm + <span class="string">&quot; Mac doFinal()&quot;</span>;</span><br><span class="line">    <span class="title function_">toBase64</span>(tag, result);</span><br><span class="line">    <span class="title function_">toHex</span>(tag, result);</span><br><span class="line">    <span class="title function_">toUtf8</span>(tag, result);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">mac.<span class="property">doFinal</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Mac doFinal(&#x27;[B&#x27;)&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">doFinal</span>(data);</span><br><span class="line">    <span class="keyword">var</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>();</span><br><span class="line">    <span class="keyword">var</span> tag = algorithm + <span class="string">&quot; Mac doFinal()&quot;</span>;</span><br><span class="line">    <span class="title function_">toBase64</span>(tag, result);</span><br><span class="line">    <span class="title function_">toHex</span>(tag, result);</span><br><span class="line">    <span class="title function_">toUtf8</span>(tag, result);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;======================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">mac.<span class="property">doFinal</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">data, start</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Mac doFinal(&#x27;[B&#x27;, &#x27;int&#x27;)&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">doFinal</span>(data, start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><blockquote>
<p>1、加密&#x2F;解密过程可逆的算法，叫做加密算法</p>
<p>2、加密&#x2F;解密使用相同的密钥，叫做对称加密算法</p>
<p>3、对称加密算法的密钥可以随便给，但是有位数要求</p>
<p>4、对称加密算法的输入数据没有长度要求，加密速度快</p>
<p>5、各算法的密钥长度</p>
<p>​		RC4  密钥长度1-256字节</p>
<p>​		DES  密钥长度8字节</p>
<p>​		3DES&#x2F;DESede&#x2F;TripleDES  密钥长度24字节</p>
<p>​		AES  密钥长度16、24、32字节</p>
<p>​		根据密钥长度不同的AES又分为AES-128、AES-192、AES-256</p>
<p>6、对称加密分类</p>
<p>​		a. 序列加密&#x2F;流加密：以字节流的方式，依次加密(解密)明文(密文)中的每一个字节</p>
<p>​				RC4</p>
<p>​		b. 分组加密：将明文信息分组（每组有多个字节），逐组进行加密</p>
<p>​				DES、3DES、AES</p>
</blockquote>
<p>PS：MAC密钥是可以无限给的，如果密钥长度超过512bit，就计算密钥的MD5，使用MD5值作为密钥</p>
<p>PS：流加密和分组加密很好区分，流加密每增加一个字符密文长度就会变化，而分组加密是在一定的字节范围内，密文长度是不变的，超出这个长度，密文长度变长一倍</p>
<h3 id="DES算法"><a href="#DES算法" class="headerlink" title="DES算法"></a>DES算法</h3><p>Java实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加密</span></span><br><span class="line"><span class="comment">// 还是定义密钥key和加密方式</span></span><br><span class="line"><span class="type">SecretKeySpec</span> <span class="variable">secretKeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(<span class="string">&quot;123454678&quot;</span>.getBytes(), <span class="string">&quot;DES&quot;</span>);</span><br><span class="line"><span class="comment">// 还有一种方式，这个API有密钥长度判断，如果传入的密钥过长，会自动截取8个字节</span></span><br><span class="line"><span class="type">DESKeySpec</span> <span class="variable">desKeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DESKeySpec</span>(<span class="string">&quot;12345678&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// getInstance得到一个单例，一个虚拟机只此一份</span></span><br><span class="line"><span class="type">Cipher</span> <span class="variable">des</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;DES/ECB/PKCS5Padding&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ENCRYPT_MOOE的值为1代表加密模式，DECRYPT_MOOD为2代表解密模式</span></span><br><span class="line">des.init(Cipher.ENCRYPT_MODE, secretKeySpec);</span><br><span class="line"><span class="comment">// 这里使用 doFinal 进行加密操作获取加密结果，因为update方法有问题，所以实现对称加密算法，一般传到 doFinal 方法中</span></span><br><span class="line"><span class="type">byte</span>[] result = des.doFinal(<span class="string">&quot;demo&quot;</span>.getBytes());</span><br><span class="line"><span class="type">String</span> <span class="variable">hexStr</span> <span class="operator">=</span> ByteString.of(result).hex();</span><br><span class="line">System.out.println(hexStr);</span><br><span class="line">System.out.println(Base64.getEncoder().encodeToString(result));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密</span></span><br><span class="line">des.init(Cipher.DECRYPT_MOOD, secretKeySpec);</span><br><span class="line"><span class="type">byte</span>[] result1 = des.doFinal();</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(result1));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>特点：</p>
<p>1、对称加密算法里，使用NOPadding，加密的明文必须等于分组长度倍数，否则报错</p>
<p>2、没有指明加密模式和填充模式的，表示使用默认的 DES&#x2F;ECB&#x2F;PKCS5Padding</p>
<p>3、加密后的字节数组可以编码成hex、base64</p>
<p>4、要复现一个对称加密算法，需要得到明文，key、iv、mode、padding</p>
<p>5、明文、key、iv需要注意解析方式，看是utf-8还是hex，不一定都是字符串形式</p>
<p>6、ECB模式和CBC模式的区别</p>
<p>7、如果加密模式是ECB，则不需要加iv，加了的话包报错的</p>
<p>8、如果使用PKCS5Padding，会对加密的明文填充1字节至一个分组的长度</p>
<p>9、DES算法明文按64位进行分组加密</p>
<p>10、如果明文中有两个分组的内容相同，ECB会得到完全一样的密文，CBC不会</p>
<p>11、加密算法的结果通常与明文等长或者更长，如果变短了，可能是gzip、protobuf，或者信息摘要算法</p>
</blockquote>
<h3 id="加密模式"><a href="#加密模式" class="headerlink" title="加密模式"></a>加密模式</h3><p>对称加密算法中，不光有密钥，还有一个IV值，上方的演示因为是 ECB 模式，没有用到 IV 值，但是逆向中常见的是 CBC 模式，这个是存在一个IV向量值的</p>
<p>这个IV向量是有长度限制的，根据算法的分组长度不同，IV长度也不同，DES加密的IV向量占8个字节</p>
<h4 id="ECB模式和CBC模式"><a href="#ECB模式和CBC模式" class="headerlink" title="ECB模式和CBC模式"></a>ECB模式和CBC模式</h4><blockquote>
<p>这二者都是分组加密的形式</p>
<p>ECB模式，分八个字节一组，分别加密，得到密文</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">明文：sjjwsnb666</span><br><span class="line">分割为： sjjwsnb6 66</span><br><span class="line">sjjwsnb666 加密结果： Vmkul5panJ +bu+Jo4DZ7Lw==</span><br><span class="line">					56692e979a5a9c9f 9bbbe268e0367b2f</span><br><span class="line">sjjwsnb6   加密结果： Vmkul5panJ /+uVm31GQvyw==</span><br><span class="line">					56692e979a5a9c9f feb959b7d4642fcb</span><br><span class="line"></span><br><span class="line">空格我自己加的，可以看到有很明显的分组痕迹，各管各的，拿出一段密文就可以获取部分明文，甚至可以自己加密一部分密文替换掉，达到替换明文的目的</span><br></pre></td></tr></table></figure>

<p>ECB模式是不安全的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241107122725336.png" alt="image-20241107122725336"></p>
<p>CBC模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">明文：sjjwsnb666</span><br><span class="line">IV： 12345678</span><br><span class="line"></span><br><span class="line">明文分组： sjjwsnb6 66</span><br><span class="line"></span><br><span class="line">CBC模式处理时先异或操作</span><br><span class="line">sjjwsnb6 &amp; 12345678</span><br><span class="line">再将异或的结果进行加密操作</span><br><span class="line">假如结果是：asddfgfh</span><br><span class="line"></span><br><span class="line">再将下一组和上一组加密的结果异或</span><br><span class="line">asddfgfh &amp; 66</span><br><span class="line">再进行加密，这样前后串连起来，断绝了更改密文影响明文的操作，更加的安全</span><br></pre></td></tr></table></figure>




</blockquote>
<p>CBC加密模式实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      <span class="type">SecretKeySpec</span> <span class="variable">secretKeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(<span class="string">&quot;123454678&quot;</span>.getBytes(), <span class="string">&quot;DES&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 这里定义iv向量值</span></span><br><span class="line">      <span class="type">IvParameterSpec</span> <span class="variable">ivParameterSpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IvParameterSpec</span>(<span class="string">&quot;12345678&quot;</span>.getBytes());</span><br><span class="line">      <span class="type">Cipher</span> <span class="variable">des</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;DES/CBC/PKCS5Padding&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里初始化时需要添加上iv值</span></span><br><span class="line">      des.init(Cipher.ENCRYPT_MODE ,secretKeySpec, ivParameterSpec);</span><br><span class="line">      <span class="type">byte</span>[] result = des.doFinal(<span class="string">&quot;demo&quot;</span>.getBytes());</span><br><span class="line">      <span class="type">String</span> <span class="variable">hexStr</span> <span class="operator">=</span> ByteString.of(result).hex();</span><br><span class="line">      System.out.println(hexStr);</span><br><span class="line">      System.out.println(Base64.getEncoder().encodeToString(result));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密亦同</span></span><br><span class="line">      des.init(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec);</span><br><span class="line">      <span class="type">byte</span>[] result1 = des.doFinal(result);</span><br><span class="line">      System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(result1));</span><br></pre></td></tr></table></figure>





<h3 id="填充方式"><a href="#填充方式" class="headerlink" title="填充方式"></a>填充方式</h3><p>“DES&#x2F;CBC&#x2F;PKCS5Padding”中 CBC 是加密模式，PKCS5Padding是填充方式</p>
<blockquote>
<p>NOPadding方式：必须是整组的数据，否则加密失败，拿到ECB的整组数据，进行NOPadding就可以得到明文</p>
<p>PKCS5Padding填充：如果使用了PKCS5Padding填充，填充的是一个字节到一个分组的长度，这就是为啥刚好8位明文，还会增加一个空分组的原因，如果最后只有一个字节，那么就会填充7个字节上去</p>
</blockquote>
<h4 id="DES密钥的漏洞"><a href="#DES密钥的漏洞" class="headerlink" title="DES密钥的漏洞"></a>DES密钥的漏洞</h4><p>DES的密钥虽然是64个字节，但是真正使用的只有56个字节，每个字节的最后一位会被舍去，看一下演示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先令密钥位12345678</span><br><span class="line">字节表示为：00110001 00110010 00110011 00110100 00110101 00110110 00110111 00111000</span><br><span class="line"></span><br><span class="line">将字节最后一位随便改，这里都改成0了：</span><br><span class="line">00110000 00110010 00110010 00110100 00110100 00110110 00110110 00111000</span><br><span class="line">转换成数字为：02244668</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用12345678来加密字符串，结果为96d0028878d58c89feb959b7d4642fcb</span><br><span class="line">使用02244668来加密字符串，结果为96d0028878d58c89feb959b7d4642fcb</span><br></pre></td></tr></table></figure>



<p>加密结果是一样的，最后一个bit位是不重要的，也就是说可以有好几个密钥来进行加解密得到同样的结果</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241107135559234.png" alt="image-20241107135559234"></p>
<h3 id="DESede算法"><a href="#DESede算法" class="headerlink" title="DESede算法"></a>DESede算法</h3><p>又叫3DES，DESede算法进行三次DES操作，需要24位密钥，先用前八位密钥进行DES加密，再用中间八位密钥进行DES解密，最后用剩下的八位密钥进行DES加密。所以说如果前两组的密钥是一样的话，就相当于只用了后八位进行一次DES加密，效果是一样的</p>
<p>同样的有密钥问题</p>
<p>看看怎么用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="type">SecretKeySpec</span> <span class="variable">secretKeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(<span class="string">&quot;123456781234567812345678&quot;</span>.getBytes(), <span class="string">&quot;DESede&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// DESede也是有一个API，也是如果密钥长度过长取前24字节</span></span><br><span class="line"><span class="type">DESedeKeySpec</span> <span class="variable">deskeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DesedeKeySpec</span>(<span class="string">&quot;123456788765432112345678&quot;</span>.getBytes())</span><br><span class="line"></span><br><span class="line">   <span class="type">IvParameterSpec</span> <span class="variable">iv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IvParameterSpec</span>(<span class="string">&quot;12345678&quot;</span>.getBytes());</span><br><span class="line">   <span class="type">Cipher</span> <span class="variable">desede</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;DESede/CBC/PKCS5Padding&quot;</span>);</span><br><span class="line">   desede.init(Cipher.ENCRYPT_MODE, secretKeySpec, iv);</span><br><span class="line">   desede.doFinal(<span class="string">&quot;demo&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>





<h3 id="AES算法"><a href="#AES算法" class="headerlink" title="AES算法"></a>AES算法</h3><p>DES算法还是有很大的问题的，现在使用AES算法居多</p>
<p>根据密钥长度不同，分为AES128、AES192、AES256。分别对应16、20、32个字节</p>
<table>
<thead>
<tr>
<th align="center">AES</th>
<th align="center">密钥长度(bit)</th>
<th align="center">分组长度(bit)</th>
<th align="center">向量长度(bit)</th>
<th align="center">加密轮数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AES-128</td>
<td align="center">128</td>
<td align="center">128</td>
<td align="center">128</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">AES-192</td>
<td align="center">192</td>
<td align="center">128</td>
<td align="center">128</td>
<td align="center">12</td>
</tr>
<tr>
<td align="center">AES-256</td>
<td align="center">256</td>
<td align="center">128</td>
<td align="center">128</td>
<td align="center">14</td>
</tr>
</tbody></table>
<p>实现</p>
<p>AES算法明文按128位进行分组加密，其余特征与DES一致</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// AES算法没有特定的key的方法，使用SecretKeySpec定义密钥</span></span><br><span class="line">   <span class="type">SecretKeySpec</span> <span class="variable">secretKeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(<span class="string">&quot;1234567890abcdef&quot;</span>.getBytes(), <span class="string">&quot;AES&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// iv 长度为16字节</span></span><br><span class="line">   <span class="type">AlgorithmParameterSpec</span> <span class="variable">iv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IvParameterSpec</span>(<span class="string">&quot;1234567890abcdef&quot;</span>.getBytes());</span><br><span class="line">   <span class="type">Cipher</span> <span class="variable">aes</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES/CBC/PKCS5Padding&quot;</span>);</span><br><span class="line">   aes.init(Cipher.ENCRYPT_MODE, secretKeySpec, iv);</span><br><span class="line">   aes.doFinal(<span class="string">&quot;demodemodemo1234567890abcdef&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>





<h3 id="通杀hook"><a href="#通杀hook" class="headerlink" title="通杀hook"></a>通杀hook</h3><h4 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h4><p>看到这就可以发现，hook的函数其实是大同小异的，主要的是看hook的一个思路</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DES算法</span></span><br><span class="line"><span class="keyword">var</span> des = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;javax.crypto.Cipher&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里之所以不传值，是因为 return this.init.apply(this, arguments) ,this表示调用原始方法的对象，arguments表示原始方法的参数</span></span><br><span class="line">des.<span class="property">init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;java.security.cert.Certificate&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Cipher init(&#x27;int&#x27;, &#x27;java.security.cert.Certificate&#x27;)&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;=============================================================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">init</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">des.<span class="property">init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;java.security.Key&#x27;</span>, <span class="string">&#x27;java.security.SecureRandom&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Cipher init(&#x27;int&#x27;, &#x27;java.security.Key&#x27;, &#x27;java.security.SecureRandom&#x27;)&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;=============================================================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">init</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">des.<span class="property">init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;java.security.cert.Certificate&#x27;</span>, <span class="string">&#x27;java.security.SecureRandom&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Cipher init(&#x27;int&#x27;, &#x27;java.security.cert.Certificate&#x27;, &#x27;java.security.SecureRandom&#x27;)&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;=============================================================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">init</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">des.<span class="property">init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;java.security.Key&#x27;</span>, <span class="string">&#x27;java.security.spec.AlgorithmParameterSpec&#x27;</span>, <span class="string">&#x27;java.security.SecureRandom&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Cipher init(&#x27;int&#x27;, &#x27;java.security.Key&#x27;, &#x27;java.security.spec.AlgorithmParameterSpec&#x27;, &#x27;java.security.SecureRandom&#x27;)&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;=============================================================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">init</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">des.<span class="property">init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;java.security.Key&#x27;</span>, <span class="string">&#x27;java.security.AlgorithmParameters&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Cipher init(&#x27;int&#x27;, &#x27;java.security.Key&#x27;, &#x27;java.security.AlgorithmParameters&#x27;)&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;=============================================================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">init</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">des.<span class="property">init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;java.security.Key&#x27;</span>, <span class="string">&#x27;java.security.AlgorithmParameters&#x27;</span>, <span class="string">&#x27;java.security.SecureRandom&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Cipher init(&#x27;int&#x27;, &#x27;java.security.Key&#x27;, &#x27;java.security.AlgorithmParameters&#x27;, &#x27;java.security.SecureRandom&#x27;)&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;=============================================================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">init</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面的不重要，随随便便打印一下看看有没有运行就行了，这两个则是传密钥和IV向量的方法 </span></span><br><span class="line">des.<span class="property">init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;java.security.Key&#x27;</span>, <span class="string">&#x27;java.security.spec.AlgorithmParameterSpec&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Cipher init(&#x27;int&#x27;, &#x27;java.security.Key&#x27;, &#x27;java.security.spec.AlgorithmParameterSpec&#x27;)&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>();</span><br><span class="line">    <span class="keyword">var</span> tag = algorithm + <span class="string">&quot;init key&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> key = <span class="variable language_">arguments</span>[<span class="number">1</span>].<span class="title function_">getEncoded</span>();</span><br><span class="line">    <span class="title function_">toBase64</span>(tag, key);</span><br><span class="line">    <span class="title function_">toHex</span>(tag, key);</span><br><span class="line">    <span class="title function_">toUtf8</span>(tag, key);</span><br><span class="line">    <span class="keyword">var</span> tag = algorithm + <span class="string">&quot;init iv&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> iv = <span class="title class_">Java</span>.<span class="title function_">cast</span>(<span class="variable language_">arguments</span>[<span class="number">2</span>], <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;javax.crypto.spec.IvParameterSpec&quot;</span>));</span><br><span class="line">    iv = iv.<span class="title function_">getIV</span>();</span><br><span class="line">    <span class="title function_">toBase64</span>(tag, iv);</span><br><span class="line">    <span class="title function_">toHex</span>(tag, iv);</span><br><span class="line">    <span class="title function_">toUtf8</span>(tag, iv);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;=============================================================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">init</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">des.<span class="property">init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;java.security.Key&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Cipher init(&#x27;int&#x27;, &#x27;java.security.Key&#x27;)&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>();</span><br><span class="line">    <span class="keyword">var</span> tag = algorithm + <span class="string">&quot;init key&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> key = <span class="variable language_">arguments</span>[<span class="number">1</span>].<span class="title function_">getEncoded</span>();</span><br><span class="line">    <span class="title function_">toBase64</span>(tag, key);</span><br><span class="line">    <span class="title function_">toHex</span>(tag, key);</span><br><span class="line">    <span class="title function_">toUtf8</span>(tag, key);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;=============================================================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">init</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// doFinal方法</span></span><br><span class="line">des.<span class="property">doFinal</span>.<span class="title function_">overload</span>().<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Cipher doFinal()&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">doFinal</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">des.<span class="property">doFinal</span>.<span class="title function_">overload</span>(<span class="string">&quot;java.nio.ByteBuffer&quot;</span>, <span class="string">&quot;java.nio.ByteBuffer&quot;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Cipher doFinal(&#x27;java.nio.ByteBuffer&#x27;, &#x27;java.nio.ByteBuffer&#x27;)&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">doFinal</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">des.<span class="property">doFinal</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Cipher doFinal(&#x27;[B&#x27;)&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">doFinal</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">des.<span class="property">doFinal</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Cipher doFinal(&#x27;[B&#x27;, &#x27;int&#x27;)&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;=======================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">doFinal</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">des.<span class="property">doFinal</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;[B&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Cipher doFinal(&#x27;[B&#x27;, &#x27;int&#x27;, &#x27;int&#x27;, &#x27;[B&#x27;)&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;===============================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">doFinal</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">des.<span class="property">doFinal</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Cipher doFinal(&#x27;[B&#x27;, &#x27;int&#x27;, &#x27;int&#x27;, &#x27;[B&#x27;, &#x27;int&#x27;)&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;===================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">doFinal</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 和其他的加密方法差不多，这两个方法重要</span></span><br><span class="line">des.<span class="property">doFinal</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Cipher doFinal(&#x27;[B&#x27;, &#x27;int&#x27;, &#x27;int&#x27;)&quot;</span>)</span><br><span class="line">    <span class="title function_">showStacks</span>();</span><br><span class="line">    <span class="keyword">var</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>();</span><br><span class="line">    <span class="keyword">var</span> tag = algorithm + <span class="string">&quot; doFinal data&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="variable language_">arguments</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="title function_">toBase64</span>(tag, data);</span><br><span class="line">    <span class="title function_">toHex</span>(tag, data);</span><br><span class="line">    <span class="title function_">toUtf8</span>(tag, data);</span><br><span class="line">    <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="property">doFinal</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="keyword">var</span> tag = algorithm + <span class="string">&quot; doFinal result&quot;</span>;</span><br><span class="line">    <span class="title function_">toBase64</span>(tag, result);</span><br><span class="line">    <span class="title function_">toHex</span>(tag, result);</span><br><span class="line">    <span class="title function_">toUtf8</span>(tag, result);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;=======================================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">des.<span class="property">doFinal</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Cipher doFinal(&#x27;[B&#x27;)&quot;</span>)</span><br><span class="line">    <span class="title function_">showStacks</span>();</span><br><span class="line">    <span class="keyword">var</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>();</span><br><span class="line">    <span class="keyword">var</span> tag = algorithm + <span class="string">&quot; doFinal data&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="variable language_">arguments</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="title function_">toBase64</span>(tag, data);</span><br><span class="line">    <span class="title function_">toHex</span>(tag, data);</span><br><span class="line">    <span class="title function_">toUtf8</span>(tag, data);</span><br><span class="line">    <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="property">doFinal</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="keyword">var</span> tag = algorithm + <span class="string">&quot; doFinal result&quot;</span>;</span><br><span class="line">    <span class="title function_">toBase64</span>(tag, result);</span><br><span class="line">    <span class="title function_">toHex</span>(tag, result);</span><br><span class="line">    <span class="title function_">toUtf8</span>(tag, result);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;===============================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个不只是hookDES算法，DESede、AES和RSA都包含在内的，通杀了属于是</p>
</blockquote>
<h4 id="DESede"><a href="#DESede" class="headerlink" title="DESede"></a>DESede</h4><p>看一下两个加密方法的差别</p>
<p>可以看到中加密方式几乎使用的方法是一模一样的，DES直接就给他杀了，不用写其他的了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DES</span></span><br><span class="line"><span class="type">SecretKeySpec</span> <span class="variable">secretKeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(<span class="string">&quot;123454678&quot;</span>.getBytes(), <span class="string">&quot;DES&quot;</span>);</span><br><span class="line"><span class="type">Cipher</span> <span class="variable">des</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;DES/ECB/PKCS5Padding&quot;</span>);</span><br><span class="line">des.init(Cipher.ENCRYPT_MODE, secretKeySpec);</span><br><span class="line">des.doFinal(<span class="string">&quot;demo&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">               </span><br><span class="line"></span><br><span class="line"><span class="comment">// DESede</span></span><br><span class="line">   <span class="type">SecretKeySpec</span> <span class="variable">secretKeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(<span class="string">&quot;123456781234567812345678&quot;</span>.getBytes(), <span class="string">&quot;DESede&quot;</span>);</span><br><span class="line">   <span class="type">IvParameterSpec</span> <span class="variable">iv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IvParameterSpec</span>(<span class="string">&quot;12345678&quot;</span>.getBytes());</span><br><span class="line">   <span class="type">Cipher</span> <span class="variable">desede</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;DESede/CBC/PKCS5Padding&quot;</span>);</span><br><span class="line">   desede.init(Cipher.ENCRYPT_MODE, secretKeySpec, iv);</span><br><span class="line">   desede.doFinal(<span class="string">&quot;demo&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>





<h4 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h4><p>同上，一起杀了，就是IV不一样，但是不需要hook这个iv</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// AES算法没有特定的key的方法，使用SecretKeySpec定义密钥</span></span><br><span class="line">   <span class="type">SecretKeySpec</span> <span class="variable">secretKeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(<span class="string">&quot;1234567890abcdef&quot;</span>.getBytes(), <span class="string">&quot;AES&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// iv 长度为16字节</span></span><br><span class="line">   <span class="type">AlgorithmParameterSpec</span> <span class="variable">iv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IvParameterSpec</span>(<span class="string">&quot;1234567890abcdef&quot;</span>.getBytes());</span><br><span class="line">   <span class="type">Cipher</span> <span class="variable">aes</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES/CBC/PKCS5Padding&quot;</span>);</span><br><span class="line">   aes.init(Cipher.ENCRYPT_MODE, secretKeySpec, iv);</span><br><span class="line">   aes.doFinal(<span class="string">&quot;demodemodemo1234567890abcdef&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>





<h2 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h2><h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p>RSA算法是一个非对称加密算法，就是说加密和解密不使用同一个密钥，分为公钥和私钥，公钥用来加密数据，私钥用来解密数据</p>
<h4 id="私钥的格式"><a href="#私钥的格式" class="headerlink" title="私钥的格式"></a>私钥的格式</h4><p>pkcs1格式通常开头是 <code>-----BEGIN RSA PRIVATE KEY -----</code></p>
<p>pkcs8格式通常开头是 <code>-----BEGIN PRIVATE KEY-----</code> </p>
<p>java中的私钥必须是pkcs8格式，如果得到了pkcs1，需要转成pkcs8</p>
<p><a href="https://www.ssleye.com/ssltool/pkcs.html">https://www.ssleye.com/ssltool/pkcs.html</a></p>
<p><a href="http://web.chacuo.net/netrsakeypair">http://web.chacuo.net/netrsakeypair</a></p>
<h4 id="RSA密钥的解析"><a href="#RSA密钥的解析" class="headerlink" title="RSA密钥的解析"></a>RSA密钥的解析</h4><p>去在线网站上弄一个没有密码的RSA密钥对</p>
<p>公钥</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">pubKey</span><span class="params">()</span> <span class="keyword">throws</span> InvalidKeySpecException, NoSuchAlgorithmException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC2kIa+rcK0oirgwxOM9tIkW95i&quot;</span> +</span><br><span class="line">            <span class="string">&quot;GNpo7tmiR8KLOapz13kYcy0csBeIJ6R44J3KEWVQcrjSqkPGeQtOrPYl1LxX5evb&quot;</span> +</span><br><span class="line">            <span class="string">&quot;DsIjmKBZXu4w8FkFxCW0ItaJu2qrX+3vr14g+JXcOYrcED+l53pwQ5sls1bbHqAe&quot;</span> +</span><br><span class="line">            <span class="string">&quot;V+I+MfaZ2XWYTNRbRwIDAQAB&quot;</span>;</span><br><span class="line">    <span class="comment">// 解码密钥</span></span><br><span class="line">    <span class="type">byte</span>[] keyBytes = ByteString.decodeBase64(key).toByteArray();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 公钥使用 X509EncodedKeySpec ，私钥使用 PKCS8EncodedKeySpec，这两个是限于Base64的，如果是hex还有其他API</span></span><br><span class="line">    <span class="type">X509EncodedKeySpec</span> <span class="variable">keySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X509EncodedKeySpec</span>(keyBytes);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 然后使用 KeyFactory 来指明密钥类型</span></span><br><span class="line">    <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 然后使用 publicKey 来生成public类型的密钥</span></span><br><span class="line">    <span class="type">PublicKey</span> <span class="variable">publicKey</span> <span class="operator">=</span> keyFactory.generatePublic(keySpec);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用publickey的getEncode方法可以返回来得到密钥的byte数组，这个时候再输出base64的编码结果和原文是一样的</span></span><br><span class="line">    <span class="type">byte</span>[] keyBytes = publickey.getEncode();</span><br><span class="line">    System.out.println(Base64.getEncoder().encodeToString(bytes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>私钥</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticKey</span><span class="params">()</span> <span class="keyword">throws</span> InvalidKeySpecException, NoSuchAlgorithmException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">stakey</span> <span class="operator">=</span> <span class="string">&quot;MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBALaQhr6twrSiKuDD&quot;</span> +</span><br><span class="line">            <span class="string">&quot;E4z20iRb3mIY2mju2aJHwos5qnPXeRhzLRywF4gnpHjgncoRZVByuNKqQ8Z5C06s&quot;</span> +</span><br><span class="line">            <span class="string">&quot;9iXUvFfl69sOwiOYoFle7jDwWQXEJbQi1om7aqtf7e+vXiD4ldw5itwQP6XnenBD&quot;</span> +</span><br><span class="line">            <span class="string">&quot;myWzVtseoB5X4j4x9pnZdZhM1FtHAgMBAAECgYBDKOW4zZk79BBMANd3WvExWO51&quot;</span> +</span><br><span class="line">            <span class="string">&quot;LeljAsLjFPz3VK5k0RaGLRCiZhEyEEtMAG1rgXzA3IMrVGF8aNkFB1HB1wG1wC4P&quot;</span> +</span><br><span class="line">            <span class="string">&quot;t7hZl5s2tdseXsIMmS0mpDUZZu+tnFwHcqZS4K6rIFjQ8lZn7epv32Pc/0aSliWp&quot;</span> +</span><br><span class="line">            <span class="string">&quot;5II5OZG2rrcG5C+y4QJBAPDQHba3wbuirDkq1QE3qUv05RAXGurideos9audGbf7&quot;</span> +</span><br><span class="line">            <span class="string">&quot;RXu4RjiYT7xlEVdZBARL/eAu36PDZy+GTb6No5Iqn5ECQQDCE//3YVKgUbfMDLrq&quot;</span> +</span><br><span class="line">            <span class="string">&quot;2LznXk+S5NXNbj2tocKsvQJLIa29qfd3eouQpR1osCJvqmA8aV2Z90y03yFBUOmv&quot;</span> +</span><br><span class="line">            <span class="string">&quot;B5FXAkEAzyp7JYGYDQ+5EcUjUdTMtCeOF/WIlqETx82921FfmsNz1yeEYZPGpNBd&quot;</span> +</span><br><span class="line">            <span class="string">&quot;xsMxjXDCi2ZHxt6Hmn7zywaWvVwlwQJALFNVCrL3pBYF3Fyr9Cc8PbuUgQAytJCR&quot;</span> +</span><br><span class="line">            <span class="string">&quot;Fa70P2+Lro0qmT7QfkFGzupnJRnVQ5uuDx4heqC4rDap6bkJJiicUQJAfWRkNXyX&quot;</span> +</span><br><span class="line">            <span class="string">&quot;WFvfM04BMjWSBgBOUmAVyB8GFAGh3e4uUvZYIr9oAnzdErFLDdXUyl1uCw5qrYkj&quot;</span> +</span><br><span class="line">            <span class="string">&quot;hM7Kq5Lkby/iaw==&quot;</span>;</span><br><span class="line">    <span class="comment">// 解码密钥</span></span><br><span class="line">    <span class="type">byte</span>[] keyBytes = ByteString.decodeBase64(stakey).toByteArray();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析密钥</span></span><br><span class="line">    <span class="type">PKCS8EncodedKeySpec</span> <span class="variable">keySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PKCS8EncodedKeySpec</span>(keyBytes);</span><br><span class="line">    <span class="comment">// 经过密钥工厂处理</span></span><br><span class="line">    <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">    <span class="comment">// 得到私钥</span></span><br><span class="line">    <span class="type">PrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> keyFactory.generatePrivate(keySpec);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同理</span></span><br><span class="line">    Log.d(<span class="string">&quot;demo&quot;</span>, ByteString.of(privateKey.getEncoded().base64()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>虽然要是64的倍数，但是一般是 512，1024，2048这样的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241114213144356.png" alt="image-20241114213144356"></p>
<h4 id="RSA加解密"><a href="#RSA加解密" class="headerlink" title="RSA加解密"></a>RSA加解密</h4><p>实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">RSACipher</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC2kIa+rcK0oirgwxOM9tIkW95i\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;GNpo7tmiR8KLOapz13kYcy0csBeIJ6R44J3KEWVQcrjSqkPGeQtOrPYl1LxX5evb\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;DsIjmKBZXu4w8FkFxCW0ItaJu2qrX+3vr14g+JXcOYrcED+l53pwQ5sls1bbHqAe\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;V+I+MfaZ2XWYTNRbRwIDAQAB&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] keyBytes = ByteString.decodeBase64(key).toByteArray();</span><br><span class="line">    <span class="type">X509EncodedKeySpec</span> <span class="variable">keySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X509EncodedKeySpec</span>(keyBytes);</span><br><span class="line">    <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">    <span class="type">PublicKey</span> <span class="variable">publicKey</span> <span class="operator">=</span> keyFactory.generatePublic(keySpec);</span><br><span class="line">    <span class="type">byte</span>[] bytes = publicKey.getEncoded();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">stakey</span> <span class="operator">=</span> <span class="string">&quot;MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBALaQhr6twrSiKuDD&quot;</span> +</span><br><span class="line">            <span class="string">&quot;E4z20iRb3mIY2mju2aJHwos5qnPXeRhzLRywF4gnpHjgncoRZVByuNKqQ8Z5C06s&quot;</span> +</span><br><span class="line">            <span class="string">&quot;9iXUvFfl69sOwiOYoFle7jDwWQXEJbQi1om7aqtf7e+vXiD4ldw5itwQP6XnenBD&quot;</span> +</span><br><span class="line">            <span class="string">&quot;myWzVtseoB5X4j4x9pnZdZhM1FtHAgMBAAECgYBDKOW4zZk79BBMANd3WvExWO51&quot;</span> +</span><br><span class="line">            <span class="string">&quot;LeljAsLjFPz3VK5k0RaGLRCiZhEyEEtMAG1rgXzA3IMrVGF8aNkFB1HB1wG1wC4P&quot;</span> +</span><br><span class="line">            <span class="string">&quot;t7hZl5s2tdseXsIMmS0mpDUZZu+tnFwHcqZS4K6rIFjQ8lZn7epv32Pc/0aSliWp&quot;</span> +</span><br><span class="line">            <span class="string">&quot;5II5OZG2rrcG5C+y4QJBAPDQHba3wbuirDkq1QE3qUv05RAXGurideos9audGbf7&quot;</span> +</span><br><span class="line">            <span class="string">&quot;RXu4RjiYT7xlEVdZBARL/eAu36PDZy+GTb6No5Iqn5ECQQDCE//3YVKgUbfMDLrq&quot;</span> +</span><br><span class="line">            <span class="string">&quot;2LznXk+S5NXNbj2tocKsvQJLIa29qfd3eouQpR1osCJvqmA8aV2Z90y03yFBUOmv&quot;</span> +</span><br><span class="line">            <span class="string">&quot;B5FXAkEAzyp7JYGYDQ+5EcUjUdTMtCeOF/WIlqETx82921FfmsNz1yeEYZPGpNBd&quot;</span> +</span><br><span class="line">            <span class="string">&quot;xsMxjXDCi2ZHxt6Hmn7zywaWvVwlwQJALFNVCrL3pBYF3Fyr9Cc8PbuUgQAytJCR&quot;</span> +</span><br><span class="line">            <span class="string">&quot;Fa70P2+Lro0qmT7QfkFGzupnJRnVQ5uuDx4heqC4rDap6bkJJiicUQJAfWRkNXyX&quot;</span> +</span><br><span class="line">            <span class="string">&quot;WFvfM04BMjWSBgBOUmAVyB8GFAGh3e4uUvZYIr9oAnzdErFLDdXUyl1uCw5qrYkj&quot;</span> +</span><br><span class="line">            <span class="string">&quot;hM7Kq5Lkby/iaw==&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] staKeyBytes = ByteString.decodeBase64(stakey).toByteArray();</span><br><span class="line">    <span class="type">PKCS8EncodedKeySpec</span> <span class="variable">staKeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PKCS8EncodedKeySpec</span>(staKeyBytes);</span><br><span class="line">    <span class="type">KeyFactory</span> <span class="variable">staKeyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">    <span class="type">PrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> staKeyFactory.generatePrivate(staKeySpec);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加密，使用公钥初始化</span></span><br><span class="line">    <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;RSA/None/NOPadding&quot;</span>);</span><br><span class="line">    cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">    <span class="type">byte</span>[] bt_encrypted = cipher.doFinal(<span class="string">&quot;1232345456&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解密，使用私钥初始化</span></span><br><span class="line">    <span class="type">Cipher</span> <span class="variable">cipher1</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;RSA/None/NOPadding&quot;</span>);</span><br><span class="line">    cipher1.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">    <span class="type">byte</span>[] bt_original = cipher1.doFinal(bt_encrypted);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以明显的看到RSA的实现还是cipher，那么DES的代码改都不用改</p>
<p>所谓的加密结果不固定就是使用padding的时候  bt_encrypted 的值不固定，会发生变化，但是NOpadding就是固定的</p>
</blockquote>
<h4 id="RSAd的加密模式和填充方式"><a href="#RSAd的加密模式和填充方式" class="headerlink" title="RSAd的加密模式和填充方式"></a>RSAd的加密模式和填充方式</h4><blockquote>
<p>RSA模式和填充细节</p>
<p>1、None模式与ECB模式是一致的</p>
<p>2、NOPadding</p>
<p>​		明文最多字节数为密钥字节数，如果密钥1024bit，最多加密1024bit</p>
<p>​		密文与密钥等长</p>
<p>​		填充字节0（不是字符是占8个bit位的字节），加密后的密文不变</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241116115653290.png"></p>
<p>​		NOPadding解密之后还需要进行去零，0是byte数组中的0，在数据的前面添加的</p>
<p>3、PKCS1Padding</p>
<p>​		明文最大字节数为密钥字节数 -11，如果密钥128字节，最多加密117字节，剩余的随机填充</p>
<p>​		密文与密钥等长</p>
<p>​		因为是随机填充，每一次的填充不一样，使得加密后的密文会变</p>
<p>​		有个小秘密，PKCS1Padding解密的时候不指明是会自动取出前面的填充，指明了反而不去除</p>
</blockquote>
<h4 id="RSA密钥的转换"><a href="#RSA密钥的转换" class="headerlink" title="RSA密钥的转换"></a>RSA密钥的转换</h4><p>全面使用的密钥都是使用base64编码的，也有hex的密钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// hex不是简单的将base64的结果解码然后hex编码</span><br><span class="line">将转换后的数据进行这样的分割</span><br><span class="line">30819f300d06092a864886f70d010101050003818d0030818902818100 | bdab976385934fb3ca17ec8775da752e191ce4ef6b5dc6398b3faf60615d45ad06e01216f8f11f4cab9e43a789b296a7bb318882bf320d2a21c00f6da233607576de16e7f6f552d97c2a4db345c97db5b5fc15127bd77ff1f1f588c577959d62694819a7eecb1f23d91c45654fbe90f300f68b64429cd4770d6685a761a1ed2d | 0203 | 010001</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 这两部分没啥用了</span><br><span class="line">30819f300d06092a864886f70d010101050003818d0030818902818100</span><br><span class="line">0203</span><br><span class="line"></span><br><span class="line">// 需要操作这两部分 RSA 的核心原理就是两个大数相乘</span><br><span class="line">bdab976385934fb3ca17ec8775da752e191ce4ef6b5dc6398b3faf60615d45ad06e01216f8f11f4cab9e43a789b296a7bb318882bf320d2a21c00f6da233607576de16e7f6f552d97c2a4db345c97db5b5fc15127bd77ff1f1f588c577959d62694819a7eecb1f23d91c45654fbe90f300f68b64429cd4770d6685a761a1ed2d</span><br><span class="line">010001</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">modulus</span> <span class="operator">=</span> <span class="string">&quot;bdab976385934fb3ca17ec8775da752e191ce4ef6b5dc6398b3faf60615d45ad06e01216f8f11f4cab9e43a789b296a7bb318882bf320d2a21c00f6da233607576de16e7f6f552d97c2a4db345c97db5b5fc15127bd77ff1f1f588c577959d62694819a7eecb1f23d91c45654fbe90f300f68b64429cd4770d6685a761a1ed2d&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">publicExponent</span> <span class="operator">=</span> <span class="string">&quot;010001&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(modulus, <span class="number">16</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(publicExponent, <span class="number">16</span>);</span><br><span class="line"><span class="type">RSAPublicKeySpec</span> <span class="variable">spec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RSAPublicKeySpec</span>(n, e);</span><br><span class="line"><span class="type">Public</span> <span class="variable">publicKey</span> <span class="operator">=</span> keyFactory.generatePublic(spec);</span><br><span class="line"><span class="type">byte</span>[] publicBytes = publicKey.getEncoded();</span><br><span class="line">System.out.printn(Base64.getEncoded().encodeToString(pubkeyBytes));</span><br><span class="line"><span class="comment">// 这样讲两个数传入得到的仍然是base64编码的私钥，这是hex编码的转换，不是直接hex过去的</span></span><br><span class="line"><span class="comment">// 先从一个00的后面开始截取，一般是最后一个00，最后是截取一个 0203</span></span><br></pre></td></tr></table></figure>



<p>还可以利用工具转换 &#x3D;&#x3D;opensll&#x3D;&#x3D; </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 这样即可输出公钥hex的编码内容</span><br><span class="line">opensll rsa -public -in [文件] -text</span><br><span class="line"></span><br><span class="line">// 私钥</span><br><span class="line">opensll res -in [] -text</span><br></pre></td></tr></table></figure>



<p>具体的加密解密操作和base64是一样的</p>
<h4 id="RSAhook"><a href="#RSAhook" class="headerlink" title="RSAhook"></a>RSAhook</h4><p>其他的方法不用管，可以直接用之前hookDES的代码通杀hook，但是hex编码的密钥不能无脑 getEncoded了，需要进行一个判断</p>
<p>RSA的私钥无法进行 getEncoded ，这样就无法获取私钥，但是一般逆向也不需要RSA的私钥</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">des.init.overload(<span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;java.security.Key&#x27;</span>).implementation = function () &#123;</span><br><span class="line">    console.log(<span class="string">&quot;Cipher init(&#x27;int&#x27;, &#x27;java.security.Key&#x27;)&quot;</span>)</span><br><span class="line">    <span class="type">var</span> <span class="variable">algorithm</span> <span class="operator">=</span> <span class="built_in">this</span>.getAlgorithm();</span><br><span class="line">    <span class="type">var</span> <span class="variable">tag</span> <span class="operator">=</span> algorithm + <span class="string">&quot;init key&quot;</span>;</span><br><span class="line">    <span class="type">var</span> <span class="variable">className</span> <span class="operator">=</span>JSON.stringify(arguments[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(className.indexOf(<span class="string">&quot;SecretKeySpec&quot;</span>) === -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">key</span> <span class="operator">=</span> arguments[<span class="number">1</span>].getEncoded();</span><br><span class="line">        toBase64(tag, key);</span><br><span class="line">        toHex(tag, key);</span><br><span class="line">        toUtf8(tag, key);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(<span class="string">&quot;================================================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.init.apply(<span class="built_in">this</span>, arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="算法常见の套路"><a href="#算法常见の套路" class="headerlink" title="算法常见の套路"></a>算法常见の套路</h2><p>无论是对称加密算法还是非对称加密算法都有局限性，如果仅使用对称加密算法，使用固定的密钥的话，仅破解客户端，所有的东西都可以解密了，随机生成密钥的话，还需要传输密钥，更不安全。仅使用非对称加密算法能够加密的数据太有限了。</p>
<p>常见的套路就是AES+RSA，先随机生成AES密钥，将这个密钥进行RSA加密。得到加密密文，将数据密文和密钥密文发送给服务器。</p>
<h2 id="数字签名算法"><a href="#数字签名算法" class="headerlink" title="数字签名算法"></a>数字签名算法</h2><p>所谓数字签名算法是将信息摘要算法和RSA算法进行结合，先进行信息摘要算法，再进行非对称加密算法</p>
<p>主要作用就是用来防止发出去的数据被篡改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我要发送数据 &quot;demo&quot; 为了防止这个数据被篡改我先加一个信息摘要MD5</span><br><span class="line">fe01ce2a7fbac8fafaed7c982a04e229</span><br><span class="line">这样还有被篡改的可能，对方可以测试我使用的什么信息摘要算法，更改数据之后，再进行摘要算法</span><br><span class="line">我就再给他一个RSA加密，使用私钥进行加密，公钥对外公开，对方可以用公钥来验证数据，这样就难以篡改了，除非我的私钥被拿到</span><br></pre></td></tr></table></figure>



<p>签名实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 私钥签名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">MD5withRSA</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException, InvalidKeySpecException, InvalidKeyException, SignatureException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">stakey</span> <span class="operator">=</span> <span class="string">&quot;MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBALaQhr6twrSiKuDD&quot;</span> +</span><br><span class="line">            <span class="string">&quot;E4z20iRb3mIY2mju2aJHwos5qnPXeRhzLRywF4gnpHjgncoRZVByuNKqQ8Z5C06s&quot;</span> +</span><br><span class="line">            <span class="string">&quot;9iXUvFfl69sOwiOYoFle7jDwWQXEJbQi1om7aqtf7e+vXiD4ldw5itwQP6XnenBD&quot;</span> +</span><br><span class="line">            <span class="string">&quot;myWzVtseoB5X4j4x9pnZdZhM1FtHAgMBAAECgYBDKOW4zZk79BBMANd3WvExWO51&quot;</span> +</span><br><span class="line">            <span class="string">&quot;LeljAsLjFPz3VK5k0RaGLRCiZhEyEEtMAG1rgXzA3IMrVGF8aNkFB1HB1wG1wC4P&quot;</span> +</span><br><span class="line">            <span class="string">&quot;t7hZl5s2tdseXsIMmS0mpDUZZu+tnFwHcqZS4K6rIFjQ8lZn7epv32Pc/0aSliWp&quot;</span> +</span><br><span class="line">            <span class="string">&quot;5II5OZG2rrcG5C+y4QJBAPDQHba3wbuirDkq1QE3qUv05RAXGurideos9audGbf7&quot;</span> +</span><br><span class="line">            <span class="string">&quot;RXu4RjiYT7xlEVdZBARL/eAu36PDZy+GTb6No5Iqn5ECQQDCE//3YVKgUbfMDLrq&quot;</span> +</span><br><span class="line">            <span class="string">&quot;2LznXk+S5NXNbj2tocKsvQJLIa29qfd3eouQpR1osCJvqmA8aV2Z90y03yFBUOmv&quot;</span> +</span><br><span class="line">            <span class="string">&quot;B5FXAkEAzyp7JYGYDQ+5EcUjUdTMtCeOF/WIlqETx82921FfmsNz1yeEYZPGpNBd&quot;</span> +</span><br><span class="line">            <span class="string">&quot;xsMxjXDCi2ZHxt6Hmn7zywaWvVwlwQJALFNVCrL3pBYF3Fyr9Cc8PbuUgQAytJCR&quot;</span> +</span><br><span class="line">            <span class="string">&quot;Fa70P2+Lro0qmT7QfkFGzupnJRnVQ5uuDx4heqC4rDap6bkJJiicUQJAfWRkNXyX&quot;</span> +</span><br><span class="line">            <span class="string">&quot;WFvfM04BMjWSBgBOUmAVyB8GFAGh3e4uUvZYIr9oAnzdErFLDdXUyl1uCw5qrYkj&quot;</span> +</span><br><span class="line">            <span class="string">&quot;hM7Kq5Lkby/iaw==&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] staKeyBytes = ByteString.decodeBase64(stakey).toByteArray();</span><br><span class="line">    <span class="type">PKCS8EncodedKeySpec</span> <span class="variable">staKeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PKCS8EncodedKeySpec</span>(staKeyBytes);</span><br><span class="line">    <span class="type">KeyFactory</span> <span class="variable">staKeyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">    <span class="type">PrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> staKeyFactory.generatePrivate(staKeySpec);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面就是处理私钥的不用管</span></span><br><span class="line">    <span class="comment">// 指定签名算法</span></span><br><span class="line">    <span class="type">Signature</span> <span class="variable">sig</span> <span class="operator">=</span> Signature.getInstance(<span class="string">&quot;SHA256withRSA&quot;</span>);</span><br><span class="line">    <span class="comment">// 导入私钥</span></span><br><span class="line">    sig.initSign(privateKey);</span><br><span class="line">    <span class="comment">// 加密明文数据的字节数组</span></span><br><span class="line">    sig.update(<span class="string">&quot;demo&quot;</span>.getBytes());</span><br><span class="line">    <span class="comment">// 得到结果，值得注意的是，签名算法要保证运行结果不变的，所以填充是NOPadding</span></span><br><span class="line">    <span class="type">byte</span>[] signResult = sig.sign();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>验证实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC2kIa+rcK0oirgwxOM9tIkW95i\n&quot;</span> +</span><br><span class="line">           <span class="string">&quot;GNpo7tmiR8KLOapz13kYcy0csBeIJ6R44J3KEWVQcrjSqkPGeQtOrPYl1LxX5evb\n&quot;</span> +</span><br><span class="line">           <span class="string">&quot;DsIjmKBZXu4w8FkFxCW0ItaJu2qrX+3vr14g+JXcOYrcED+l53pwQ5sls1bbHqAe\n&quot;</span> +</span><br><span class="line">           <span class="string">&quot;V+I+MfaZ2XWYTNRbRwIDAQAB&quot;</span>;</span><br><span class="line">   <span class="type">byte</span>[] keyBytes = ByteString.decodeBase64(key).toByteArray();</span><br><span class="line">   <span class="type">X509EncodedKeySpec</span> <span class="variable">keySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X509EncodedKeySpec</span>(keyBytes);</span><br><span class="line">   <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">   <span class="type">PublicKey</span> <span class="variable">publicKey</span> <span class="operator">=</span> keyFactory.generatePublic(keySpec);</span><br><span class="line"></span><br><span class="line"><span class="type">Signature</span> <span class="variable">sig</span> <span class="operator">=</span> Signature.getInstance(<span class="string">&quot;SHA256withRSA&quot;</span>);</span><br><span class="line"><span class="comment">// 导入公钥</span></span><br><span class="line">   sig.initVerify(publicKey);</span><br><span class="line"><span class="comment">// 导入明文</span></span><br><span class="line">   sig.update(<span class="string">&quot;demo&quot;</span>.getBytes());</span><br><span class="line"><span class="comment">// 将给到密文传入，验证是否正确，返回布尔类型</span></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">isTrue</span> <span class="operator">=</span> sig.verify(signResult);</span><br><span class="line">   System.out.println(isTrue);</span><br></pre></td></tr></table></figure>



<p>这个签名算法的结果是加密之后前面，将信息摘要算法的结果放在最后面，然后在前面填充东西，具体填充的啥还不知道</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">RSAwithRSA</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException, InvalidKeySpecException, InvalidKeyException, SignatureException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">stakey</span> <span class="operator">=</span> <span class="string">&quot;MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBALaQhr6twrSiKuDD&quot;</span> +</span><br><span class="line">            <span class="string">&quot;E4z20iRb3mIY2mju2aJHwos5qnPXeRhzLRywF4gnpHjgncoRZVByuNKqQ8Z5C06s&quot;</span> +</span><br><span class="line">            <span class="string">&quot;9iXUvFfl69sOwiOYoFle7jDwWQXEJbQi1om7aqtf7e+vXiD4ldw5itwQP6XnenBD&quot;</span> +</span><br><span class="line">            <span class="string">&quot;myWzVtseoB5X4j4x9pnZdZhM1FtHAgMBAAECgYBDKOW4zZk79BBMANd3WvExWO51&quot;</span> +</span><br><span class="line">            <span class="string">&quot;LeljAsLjFPz3VK5k0RaGLRCiZhEyEEtMAG1rgXzA3IMrVGF8aNkFB1HB1wG1wC4P&quot;</span> +</span><br><span class="line">            <span class="string">&quot;t7hZl5s2tdseXsIMmS0mpDUZZu+tnFwHcqZS4K6rIFjQ8lZn7epv32Pc/0aSliWp&quot;</span> +</span><br><span class="line">            <span class="string">&quot;5II5OZG2rrcG5C+y4QJBAPDQHba3wbuirDkq1QE3qUv05RAXGurideos9audGbf7&quot;</span> +</span><br><span class="line">            <span class="string">&quot;RXu4RjiYT7xlEVdZBARL/eAu36PDZy+GTb6No5Iqn5ECQQDCE//3YVKgUbfMDLrq&quot;</span> +</span><br><span class="line">            <span class="string">&quot;2LznXk+S5NXNbj2tocKsvQJLIa29qfd3eouQpR1osCJvqmA8aV2Z90y03yFBUOmv&quot;</span> +</span><br><span class="line">            <span class="string">&quot;B5FXAkEAzyp7JYGYDQ+5EcUjUdTMtCeOF/WIlqETx82921FfmsNz1yeEYZPGpNBd&quot;</span> +</span><br><span class="line">            <span class="string">&quot;xsMxjXDCi2ZHxt6Hmn7zywaWvVwlwQJALFNVCrL3pBYF3Fyr9Cc8PbuUgQAytJCR&quot;</span> +</span><br><span class="line">            <span class="string">&quot;Fa70P2+Lro0qmT7QfkFGzupnJRnVQ5uuDx4heqC4rDap6bkJJiicUQJAfWRkNXyX&quot;</span> +</span><br><span class="line">            <span class="string">&quot;WFvfM04BMjWSBgBOUmAVyB8GFAGh3e4uUvZYIr9oAnzdErFLDdXUyl1uCw5qrYkj&quot;</span> +</span><br><span class="line">            <span class="string">&quot;hM7Kq5Lkby/iaw==&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] staKeyBytes = ByteString.decodeBase64(stakey).toByteArray();</span><br><span class="line">    <span class="type">PKCS8EncodedKeySpec</span> <span class="variable">staKeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PKCS8EncodedKeySpec</span>(staKeyBytes);</span><br><span class="line">    <span class="type">KeyFactory</span> <span class="variable">staKeyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">    <span class="type">PrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> staKeyFactory.generatePrivate(staKeySpec);</span><br><span class="line"></span><br><span class="line">    <span class="type">Signature</span> <span class="variable">sig</span> <span class="operator">=</span> Signature.getInstance(<span class="string">&quot;SHA256withRSA&quot;</span>);</span><br><span class="line">    sig.initSign(privateKey);</span><br><span class="line">    sig.update(<span class="string">&quot;demo&quot;</span>.getBytes());</span><br><span class="line">    <span class="type">byte</span>[] signResult = sig.sign();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC2kIa+rcK0oirgwxOM9tIkW95i\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;GNpo7tmiR8KLOapz13kYcy0csBeIJ6R44J3KEWVQcrjSqkPGeQtOrPYl1LxX5evb\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;DsIjmKBZXu4w8FkFxCW0ItaJu2qrX+3vr14g+JXcOYrcED+l53pwQ5sls1bbHqAe\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;V+I+MfaZ2XWYTNRbRwIDAQAB&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] keyBytes = ByteString.decodeBase64(key).toByteArray();</span><br><span class="line">    <span class="type">X509EncodedKeySpec</span> <span class="variable">keySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X509EncodedKeySpec</span>(keyBytes);</span><br><span class="line">    <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">    <span class="type">PublicKey</span> <span class="variable">publicKey</span> <span class="operator">=</span> keyFactory.generatePublic(keySpec);</span><br><span class="line"></span><br><span class="line">    sig.initVerify(publicKey);</span><br><span class="line">    sig.update(<span class="string">&quot;demo&quot;</span>.getBytes());</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isTrue</span> <span class="operator">=</span> sig.verify(signResult);</span><br><span class="line">    System.out.println(isTrue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="数字签名算法hook通杀"><a href="#数字签名算法hook通杀" class="headerlink" title="数字签名算法hook通杀"></a>数字签名算法hook通杀</h3><p>从实现可以看出，可hook的方法有 &#x3D;&#x3D;getPrivateKey&#x3D;&#x3D; 、initSign、 update、 sign、initVerify、verify </p>
<p>hook update方法获取明文</p>
<p>hook  sign方法获取密文</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hook数字签名算法</span></span><br><span class="line"><span class="comment">// hook update方法，获取签名前的数据</span></span><br><span class="line"><span class="keyword">var</span> signature = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.security.Signature&quot;</span>)</span><br><span class="line">signature.<span class="property">update</span>.<span class="title function_">overload</span>(<span class="string">&#x27;byte&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Signature update(&#x27;byte)&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;===============================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">update</span>(data);</span><br><span class="line">&#125;</span><br><span class="line">signature.<span class="property">update</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.nio.ByteBuffer&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Signature update(&#x27;java.nio.ByteBuffer&#x27;)&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;===============================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">update</span>(data);</span><br><span class="line">&#125;</span><br><span class="line">signature.<span class="property">update</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Signature update(&#x27;[B&#x27;)&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>();</span><br><span class="line">    <span class="keyword">var</span> tag = algorithm + <span class="string">&quot; Signature update(&#x27;[B&#x27;)&quot;</span>;</span><br><span class="line">    <span class="title function_">toBase64</span>(tag, data);</span><br><span class="line">    <span class="title function_">toHex</span>(tag, data);</span><br><span class="line">    <span class="title function_">toUtf8</span>(tag, data);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;===============================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">update</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其实着重hook下面这个方法就够了，上面的byte数组需要走下面这个方法</span></span><br><span class="line">signature.<span class="property">update</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">data, start, len</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Signature update(&#x27;[B&#x27;, &#x27;int&#x27;, &#x27;int&#x27;)&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>();</span><br><span class="line">    <span class="keyword">var</span> tag = algorithm + <span class="string">&quot; Signature update(&#x27;[B&#x27;, &#x27;int&#x27;, &#x27;int&#x27;)&quot;</span>;</span><br><span class="line">    <span class="title function_">toBase64</span>(tag, data);</span><br><span class="line">    <span class="title function_">toHex</span>(tag, data);</span><br><span class="line">    <span class="title function_">toUtf8</span>(tag, data);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;===============================================&quot;</span>, start, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">update</span>(data, start, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// hook sign方法，获取签名密文</span></span><br><span class="line">signature.<span class="property">sign</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Signature sign(&#x27;[B&#x27;, &#x27;int&#x27;, &#x27;int&#x27;)&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;===============================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">sign</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">signature.<span class="property">sign</span>.<span class="title function_">overload</span>().<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Signature sign()&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">sign</span>();</span><br><span class="line">    <span class="keyword">var</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>();</span><br><span class="line">    <span class="keyword">var</span> tag = algorithm + <span class="string">&quot; Signature sign()&quot;</span>;</span><br><span class="line">    <span class="title function_">toBase64</span>(tag, result);</span><br><span class="line">    <span class="title function_">toHex</span>(tag, result);</span><br><span class="line">    <span class="title function_">toUtf8</span>(tag, result);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;===============================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20241117195958891.png" alt="image-20241117195958891"></p>
<p>verify 方法能获取密文，已经获取到了，再hook起来没有什么意义</p>
<p>initSign和initVerify方法可以获取到 公钥和私钥</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hook initSign方法，获取签名私钥</span></span><br><span class="line">signature.<span class="property">initSign</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.security.PrivateKey&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Signature initSign(&#x27;java.security.PrivateKey&#x27;)&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> algorithm = <span class="variable language_">this</span>.<span class="title function_">getAlgorithm</span>();</span><br><span class="line">    <span class="keyword">var</span> tag = algorithm + <span class="string">&quot; Signature initSign()&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">OpenSSLRSAPrivateKey</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.android.org.conscrypt.OpenSSLRSAPrivateKey&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> realkey = <span class="title class_">Java</span>.<span class="title function_">cast</span>(key, <span class="title class_">OpenSSLRSAPrivateKey</span>).<span class="title function_">getEncoded</span>();</span><br><span class="line">    <span class="title function_">toBase64</span>(tag, realkey);</span><br><span class="line">    <span class="title function_">toHex</span>(tag, realkey);</span><br><span class="line">    <span class="title function_">toUtf8</span>(tag, realkey);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;================================================&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">initSign</span>(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个密钥是不能直接获取，因为传入的是PrivateKey类 ，PrivateKey 是一个接口，没有像之前一样的 getEncoded 方法，所以需要做一个多态转型，来获取，而且只能获取到base64的，不能获取到hex的密钥，有用处但是用处不大</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241118163848199.png" alt="image-20241118163848199"></p>
</blockquote>
<h2 id="CryptoJS"><a href="#CryptoJS" class="headerlink" title="CryptoJS"></a>CryptoJS</h2><p>学一下JS的加解密，因为可能要复现某算法，使用JS脚本来hook复现比较方便，而且被其他语言调用也比较方便</p>
<p>使用CryptoJS来实现信息摘要算法和对称加密算法</p>
<h3 id="信息摘要算法的实现"><a href="#信息摘要算法的实现" class="headerlink" title="信息摘要算法的实现"></a>信息摘要算法的实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cryptoJS = <span class="built_in">require</span>(<span class="string">&#x27;crypto-js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> demo = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> key = <span class="string">&quot;demo&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;MD5：&quot;</span> + cryptoJS.<span class="title class_">MD5</span>(demo).<span class="title function_">toString</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;HmacMD5：&quot;</span> + cryptoJS.<span class="title class_">HmacMD5</span>(demo, key).<span class="title function_">toString</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;SHA1：&quot;</span> + cryptoJS.<span class="title class_">SHA1</span>(demo).<span class="title function_">toString</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;HmacSHA1：&quot;</span> + cryptoJS.<span class="title class_">HmacSHA1</span>(demo, key).<span class="title function_">toString</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;SHA256：&quot;</span> + cryptoJS.<span class="title class_">SHA256</span>(demo).<span class="title function_">toString</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;HmacSHA256：&quot;</span> + cryptoJS.<span class="title class_">HmacSHA256</span>(demo, key).<span class="title function_">toString</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;SHA512：&quot;</span> + cryptoJS.<span class="title class_">SHA512</span>(demo).<span class="title function_">toString</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;HmacSHA512：&quot;</span> + cryptoJS.<span class="title class_">HmacSHA512</span>(demo, key).<span class="title function_">toString</span>())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="title class_">MD5</span>：e10adc3949ba59abbe56e057f20f883e</span><br><span class="line"><span class="title class_">HmacMD5</span>：e8649f37712cdad94724b22154e4b83b</span><br><span class="line"><span class="title class_">SHA1</span>：7c4a8d09ca3762af61e59520943dc26494f8941b</span><br><span class="line"><span class="title class_">HmacSHA1</span>：8a497921f4d842b57f6e054cee4fd2d91577815a</span><br><span class="line"><span class="title class_">SHA256</span>：8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92</span><br><span class="line"><span class="title class_">HmacSHA256</span>：1b8e71ff0087551bb6f063b15ea850650ddbdf6a02e5e81c2a981b91efafebdd</span><br><span class="line"><span class="title class_">SHA512</span>：ba3253876aed6bc22d4a6ff53d8406c6ad864195ed144ab5c87621b6c233b548baeae6956df346ec8c17f5ea10f35ee3cbc514797ed7ddd3145464e2a0bab413</span><br><span class="line"><span class="title class_">HmacSHA512</span>：14f04320d0a4a21ed7517b94a8cf219f3e674fa95dd6281d5b61e3fc2e52a5567468e3ef4b4ace6edbecd6aa809f012606e482c367bbb7c285278a1bb3a0008d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不加toString 输出的形式是 wordArray</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">words</span>: [ -<span class="number">519381959</span>, <span class="number">1236949419</span>, -<span class="number">1101602729</span>, -<span class="number">233863106</span> ],</span><br><span class="line">  <span class="attr">sigBytes</span>: <span class="number">16</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用一个字符串+ 后面的东西，即使没有toString也没问题，也是字符串形式，自动转换了就</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;MD5：&quot;</span> + cryptoJS.<span class="title class_">MD5</span>(demo))</span><br></pre></td></tr></table></figure>



<p>也存在一种，冗长，难写，复杂的实现形式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hasher = cryptoJS.<span class="property">algo</span>.<span class="property">SHA256</span>.<span class="title function_">create</span>();</span><br><span class="line"><span class="comment">// reset是清空内容</span></span><br><span class="line">hasher.<span class="title function_">reset</span>();</span><br><span class="line"><span class="comment">// update是添加内容，可以多次添加</span></span><br><span class="line">hasher.<span class="title function_">update</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">hasher.<span class="title function_">update</span>(<span class="string">&quot;789&quot;</span>);</span><br><span class="line"><span class="comment">// 进行加密</span></span><br><span class="line"><span class="keyword">var</span> hash = hasher.<span class="title function_">finalize</span>().<span class="title function_">toString</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hash);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hmac还需要指定密钥</span></span><br><span class="line"><span class="keyword">var</span> hasherHmac = cryptoJS.<span class="property">algo</span>.<span class="property">HMAC</span>.<span class="title function_">create</span>(cryptoJS.<span class="property">algo</span>.<span class="property">SHA256</span>, <span class="string">&quot;demo&quot;</span>);</span><br><span class="line">hasherHmac.<span class="title function_">reset</span>();</span><br><span class="line">hasherHmac.<span class="title function_">update</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">hasherHmac.<span class="title function_">update</span>(<span class="string">&quot;789&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> hmac = hasherHmac.<span class="title function_">finalize</span>().<span class="title function_">toString</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hmac);</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241117205858280.png" alt="image-20241117205858280"></p>
<blockquote>
<p>怎么说呢，放着简单的不用，用复杂的干啥呢</p>
</blockquote>
<h3 id="字符串解析"><a href="#字符串解析" class="headerlink" title="字符串解析"></a>字符串解析</h3><p>在Java中字符串解析是转换成 base64或者hex或者UTF-8，在JS中当然没什么不一样了，换个写法而已</p>
<p>哦，说一下之前的wordArray</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">words</span>: [ -<span class="number">519381959</span>, <span class="number">1236949419</span>, -<span class="number">1101602729</span>, -<span class="number">233863106</span> ],</span><br><span class="line">  <span class="attr">sigBytes</span>: <span class="number">16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这个words是一个类似于字节数组的东西，将四个字节变成了一个整数，也可以理解成字节数组，反正就是存这个的</span><br></pre></td></tr></table></figure>



<h4 id="String转wordArray"><a href="#String转wordArray" class="headerlink" title="String转wordArray"></a>String转wordArray</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个就相当于Java中的 getBytes() 方法</span></span><br><span class="line">cryptoJS.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(utf8ToString)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 就是HEX解码</span></span><br><span class="line">cryptoJS.<span class="property">enc</span>.<span class="property">Hex</span>.<span class="title function_">parse</span>(hexToString)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 就是base64解码</span></span><br><span class="line">cryptoJS.<span class="property">enc</span>.<span class="property">Base64</span>.<span class="title function_">parse</span>(base64ToString)</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241117211621418.png" alt="image-20241117211621418"></p>
<h4 id="wordArray转String"><a href="#wordArray转String" class="headerlink" title="wordArray转String"></a>wordArray转String</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// wordArray转string</span></span><br><span class="line"><span class="keyword">let</span> wordArray = cryptoJS.<span class="title class_">MD5</span>(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(wordArray)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(wordArray + <span class="string">&#x27;&#x27;</span>)		<span class="comment">// 强转</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(wordArray.<span class="title function_">toString</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(wordArray.<span class="title function_">toString</span>(cryptoJS.<span class="property">enc</span>.<span class="property">Hex</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(wordArray.<span class="title function_">toString</span>(cryptoJS.<span class="property">enc</span>.<span class="property">Base64</span>))</span><br><span class="line"><span class="comment">// console.log(wordArray.toString(cryptoJS.enc.Utf8))</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cryptoJS.<span class="property">enc</span>.<span class="property">Hex</span>.<span class="title function_">stringify</span>(wordArray))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cryptoJS.<span class="property">enc</span>.<span class="property">Base64</span>.<span class="title function_">stringify</span>(wordArray))</span><br><span class="line"><span class="comment">// cryptoJS.enc.Utf8.stringify(wordArray)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>转UTF-8有报错，知道就行了，可以看到toString方法默认的是转成HEX编码</p>
<p>注意这个转base64是将字符数组转base64不是将hex转成base64编码，那样会变得很长，很显然这并没有发生</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241117212032481.png" alt="image-20241117212032481"></p>
<p>这些的用处在于有时候得到的数据千奇百怪，需要各种处理，比如得到hex编码的明文</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 如果直接这样操作的话，是当作utf8来解析的</span><br><span class="line">var mdhex = &quot;313233343536&quot;</span><br><span class="line">console.log(cryptoJS.MD5(mdhex).toString())</span><br><span class="line"></span><br><span class="line">// 这个时候就需要转换</span><br><span class="line">var mdhex = &quot;313233343536&quot;</span><br><span class="line">console.log(cryptoJS.MD5(cryptoJS.enc.Hex.parse(mdhex)).toString())</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241117212918100.png" alt="image-20241117212918100"></p>
</blockquote>
<h3 id="对称加密算法-1"><a href="#对称加密算法-1" class="headerlink" title="对称加密算法"></a>对称加密算法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对称加密算法</span></span><br><span class="line"><span class="comment">// 不同算法的key长度和iv长度也不一样，就不进行初始化了，看一下格式就行，具体使用具体查找</span></span><br><span class="line"><span class="comment">// cfg一般包含加密模式、填充方式（PKcs7最常用和Java模式中的PKCS5结果一样）</span></span><br><span class="line"><span class="keyword">var</span> cfg = &#123;</span><br><span class="line">    <span class="attr">iv</span>: iv,</span><br><span class="line">    <span class="attr">mode</span>: cryptoJS.<span class="property">mode</span>.<span class="property">CBC</span>,</span><br><span class="line">    <span class="attr">padding</span>: cryptoJS.<span class="property">pad</span>.<span class="property">Pkcs7</span>,</span><br><span class="line">    <span class="attr">format</span>: cryptoJS.<span class="property">format</span>.<span class="property">Hex</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ciphertext = cryptoJS.<span class="property">DES</span>.<span class="title function_">encrypt</span>(message, key, cfg)</span><br><span class="line"><span class="keyword">var</span> plaintext = cryptoJS.<span class="property">DES</span>.<span class="title function_">decrypt</span>(ciphertext, key, cfg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ciphertext = cryptoJS.<span class="property">TripleDES</span>.<span class="title function_">encrypt</span>(message, key, cfg)</span><br><span class="line"><span class="keyword">var</span> plaintext = cryptoJS.<span class="property">TripleDES</span>.<span class="title function_">decrypt</span>(ciphertext, key, cfg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ciphertext = cryptoJS.<span class="property">AES</span>.<span class="title function_">encrypt</span>(message, key, cfg)</span><br><span class="line"><span class="keyword">var</span> plaintext = cryptoJS.<span class="property">AES</span>.<span class="title function_">decrypt</span>(ciphertext, key, cfg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ciphertext = cryptoJS.<span class="property">RC4</span>.<span class="title function_">encrypt</span>(message, key, cfg)</span><br><span class="line"><span class="keyword">var</span> plaintext = cryptoJS.<span class="property">RC4</span>.<span class="title function_">decrypt</span>(ciphertext, key, cfg)</span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进行AES加密，iv和key都需要解析</span></span><br><span class="line"><span class="keyword">var</span> hexKeyBytes = cryptoJS.<span class="property">enc</span>.<span class="property">Hex</span>.<span class="title function_">parse</span>(<span class="string">&quot;0123456789ABCDEF&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> hexIvBytes = cryptoJS.<span class="property">enc</span>.<span class="property">Hex</span>.<span class="title function_">parse</span>(<span class="string">&quot;0123456789ABCDEF&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// cfg中不传mode和padding是默认的CBC/PKcs7的形式，format中可以定义格式化输出</span></span><br><span class="line"><span class="keyword">var</span> cfg = &#123;</span><br><span class="line">    <span class="attr">iv</span>: hexIvBytes,</span><br><span class="line">    <span class="attr">mode</span>: cryptoJS.<span class="property">mode</span>.<span class="property">CBC</span>,</span><br><span class="line">    <span class="attr">padding</span>: cryptoJS.<span class="property">pad</span>.<span class="property">Pkcs7</span>,</span><br><span class="line">    <span class="attr">format</span>: cryptoJS.<span class="property">format</span>.<span class="property">Hex</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> encrypted = cryptoJS.<span class="property">AES</span>.<span class="title function_">encrypt</span>(<span class="string">&quot;123456&quot;</span>, hexKeyBytes, cfg);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到的这个 encrypted 是一个对象，加密的wordArray内容在 ciphertext 中</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(encrypted.<span class="property">ciphertext</span>.<span class="title function_">toString</span>());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：cfg中不指定输出形式的话，encrypted 默认以Base64的形式输出</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241118164530869.png" alt="image-20241118164530869"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果直接这样输出是会报错的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(encrypted.<span class="title function_">toString</span>(cryptoJS.<span class="property">enc</span>.<span class="property">Base64</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hex则是无输出</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(encrypted.<span class="title function_">toString</span>(cryptoJS.<span class="property">enc</span>.<span class="property">Hex</span>));</span><br></pre></td></tr></table></figure>



<p>format属性中还可以夹带私货，自定义输出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cfg = &#123;</span><br><span class="line"> <span class="attr">iv</span>: hexIvBytes,</span><br><span class="line"> <span class="attr">mode</span>: cryptoJS.<span class="property">mode</span>.<span class="property">CBC</span>,</span><br><span class="line"> <span class="attr">padding</span>: cryptoJS.<span class="property">pad</span>.<span class="property">Pkcs7</span>,</span><br><span class="line"> <span class="attr">format</span>: &#123;</span><br><span class="line">     <span class="attr">stringify</span>: <span class="keyword">function</span> (<span class="params">data</span>)&#123;</span><br><span class="line">         <span class="keyword">let</span> e = &#123;</span><br><span class="line">             <span class="attr">ct</span>: data.<span class="property">ciphertext</span>.<span class="title function_">toString</span>(),</span><br><span class="line">             <span class="attr">miaoshu</span>: <span class="string">&quot;这是自定义的输出&quot;</span></span><br><span class="line">         &#125;；</span><br><span class="line">         <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(e)</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="comment">// 定义parse是解密使用的</span></span><br><span class="line">     <span class="attr">parse</span>: <span class="keyword">function</span> (<span class="params">data</span>)&#123;</span><br><span class="line">         <span class="comment">// 解析自己写的JSON</span></span><br><span class="line">         <span class="keyword">let</span> json = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(data)</span><br><span class="line">         <span class="comment">// json.ct获取加密后的数据，以为是hex的形式，使用hex解析，再进行create创建，返回</span></span><br><span class="line">         <span class="keyword">let</span> newVar = cryptoJS.<span class="property">lib</span>.<span class="property">CipherParams</span>.<span class="title function_">create</span>(&#123;<span class="attr">ciphertext</span>: cryptoJS.<span class="property">enc</span>.<span class="property">Hex</span>.<span class="title function_">parse</span>(json.<span class="property">ct</span>)&#125;);</span><br><span class="line">         <span class="keyword">return</span> newVar</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241118165839649.png" alt="image-20241118165839649"></p>
</blockquote>
<p>解密也没啥难度，不写了</p>
<h3 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h3><h4 id="RIPEMD160-和-HmacRIPEMD160"><a href="#RIPEMD160-和-HmacRIPEMD160" class="headerlink" title="RIPEMD160 和 HmacRIPEMD160"></a>RIPEMD160 和 HmacRIPEMD160</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RIPEMD160 一种信息摘要算法</span></span><br><span class="line"><span class="comment">// 有两种形式，一种没有密钥--RIPEMD160 </span></span><br><span class="line"><span class="comment">// 一种有密钥--HmacRIPEMD160</span></span><br><span class="line"><span class="comment">// 加密结果有40个十六进制字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ripemd160 = cryptoJS.<span class="title class_">RIPEMD160</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ripemd160 + <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> hmacRIPEMD160 = cryptoJS.<span class="title class_">HmacRIPEMD160</span>(<span class="string">&quot;123456&quot;</span>, <span class="string">&quot;demo&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hmacRIPEMD160 + <span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241118184812571.png" alt="image-20241118184812571"></p>
<h4 id="PBKDF2-和-EvpKDF"><a href="#PBKDF2-和-EvpKDF" class="headerlink" title="PBKDF2 和 EvpKDF"></a>PBKDF2 和 EvpKDF</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PBKDF2</span></span><br><span class="line"><span class="comment">// keySize大小设定为 4/8/16 对应输出结果位数是 128/256/512</span></span><br><span class="line"><span class="comment">// iterations 表示迭代次数，这种算法的安全性随迭代次数增加而增加</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">PBKDF2</span> = cryptoJS.<span class="title class_">PBKDF2</span>(<span class="string">&quot;123456&quot;</span>, <span class="string">&quot;demo&quot;</span>, &#123; <span class="attr">keySize</span>: <span class="number">8</span>, <span class="attr">iterations</span>: <span class="number">1000</span> &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">PBKDF2</span> + <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">// EvpKDF</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">EvpKDF</span> = cryptoJS.<span class="title class_">EvpKDF</span>(<span class="string">&quot;123456&quot;</span>, <span class="string">&quot;demo&quot;</span>, &#123; <span class="attr">keySize</span>: <span class="number">8</span>, <span class="attr">iterations</span>: <span class="number">1000</span> &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">EvpKDF</span> + <span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241118185931951.png" alt="image-20241118185931951"></p>
<h2 id="jsencrypt"><a href="#jsencrypt" class="headerlink" title="jsencrypt"></a>jsencrypt</h2><h3 id="非对称加密算法-1"><a href="#非对称加密算法-1" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h3><p>非对称加密算法（RSA）CryptoJS没有，使用jsencrypt库来实现。</p>
<p>这个库是服务于web开发的，纯JS可能有问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">JSEncrypt</span> = <span class="built_in">require</span>(<span class="string">&#x27;jsencrypt&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个密钥可以不加头不换行的，直接一个字符串进去</span></span><br><span class="line"><span class="keyword">var</span> publicKey = <span class="string">&quot;-----BEGIN PUBLIC KEY-----\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC9zDcwxIE6ivfU821isEn0jpQM\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;l+sSK+DA5fJYKEkaGUyOWyxLt2E89+wJx80Ezn2R62kK/NzQ84ZHH8bRG2P7upZ7\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;LkYCDg+9EzmWzbPPIeSiTv5jHOFGCSmlC58S45eq5WBf8qU2haa50x004m87iW4S\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;TrpCuA0mPjXP/ZkjcQIDAQAB\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;-----END PUBLIC KEY-----&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> privateKey = <span class="string">&quot;-----BEGIN RSA PRIVATE KEY-----\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbAgEAAoGBAL3MNzDEgTqK99Tz\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;bWKwSfSOlAyX6xIr4MDl8lgoSRoZTI5bLEu3YTz37AnHzQTOfZHraQr83NDzhkcf\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;xtEbY/u6lnsuRgIOD70TOZbNs88h5KJO/mMc4UYJKaULnxLjl6rlYF/ypTaFprnT\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;HTTibzuJbhJOukK4DSY+Nc/9mSNxAgMBAAECgYBPNCqP8mEPYjDcMB2kwnaKVPmZ\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;a8hQU/k95nfErEMdXhNhkNCiZEty2u8ogbWf3N/wBfJXAIDRvd56Tdt1Jd4J1UJ+\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;osHNkmWfx9ld6GYWkN8JRFGjI8Gj3FTNKqWhWCTlnpvWsyyK4F6aCHIWD6f211lk\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;u6H1+r/q9zjvu1rNhQJBAOwTn38twXyW7CumZKfqtaBJfnhKOvVmDMyGia02oOx1\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;ZVL9stsoYKCC/RxcBEi6E3ZfQOeDyBGxN5UxCiojyMsCQQDN0L9sG2KJHHa7BuwA\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;lkXDVs6geE+a4SdNbHSp5JMfUPID7ul+r0wlnpljD7g3s/2+TkpqUseMiNPs5Hhb\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;GwkzAkBDyTapC/hcz/Esb3DDjm9sgO3hmF7pi83tBEyQAfmfK+5WMCalKyjjrfkD\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;paBNSbDA8oTudTaDbgFpw1UJ2JCVAkBxqlGtgMpAcunXjJEWGefZY72lvgwouyQb\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;jEQ597SQ3QFrzqxBfMqPFDIeFXZlvQ/r5A0Q/zqZkI+KCvu1RQ8lAkAZEhjGasXX\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;SNZuX0FZzcAUEs/rkhrPL4pqNg5XXda/nzYHdxdPVMsgv8A3RSKBc7P+2wMrB075\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;yCszbgV/ovWx\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;-----END PRIVATE KEY-----&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setEncrypt</span> (msg) &#123;</span><br><span class="line">    <span class="comment">// 获取 JSEncrypt 对象</span></span><br><span class="line">    <span class="keyword">const</span> jsencrypt = <span class="keyword">new</span> <span class="title class_">JSEncrypt</span>();</span><br><span class="line">    <span class="comment">// 初始化公钥</span></span><br><span class="line">    jsencrypt.<span class="title function_">setPublicKey</span>(publicKey);</span><br><span class="line">    <span class="comment">// 返回加密结果</span></span><br><span class="line">    <span class="keyword">return</span> jsencrypt.<span class="title function_">encrypt</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">setEncrypt</span>(<span class="string">&quot;123456&quot;</span>));</span><br></pre></td></tr></table></figure>



<p>解决这个报错</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241118195155371.png" alt="image-20241118195155371"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">windows = global;</span><br><span class="line">或者</span><br><span class="line">var windows = global;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241118195128484.png" alt="image-20241118195128484"></p>
<p>还有这个报错</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241118195326505.png" alt="image-20241118195326505"></p>
<p>这个报错是由于错误的引用导致的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">JSEncrypt</span> = <span class="built_in">require</span>(<span class="string">&#x27;jsencrypt&#x27;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>虽然底下这俩和cryptoJS一样冒绿光，但是就是报错，很奇怪</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241118195526753.png" alt="image-20241118195526753"></p>
</blockquote>
<p>调教好之后运行</p>
<p>看结果很明显是 PKCS1Padding 的填充，如果想使用其他填充模式，就需要一些操作了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241118195657998.png" alt="image-20241118195657998"></p>
<h3 id="JSEncrypt添加NOPadding填充"><a href="#JSEncrypt添加NOPadding填充" class="headerlink" title="JSEncrypt添加NOPadding填充"></a>JSEncrypt添加NOPadding填充</h3><p>之前了解到NOPadding的填充是在明文前面填充字节0，如果我想实现的话就可以进行手动填充</p>
<p>打个断点进去</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241118201358518-1732016006152-1.png" alt="image-20241118201358518"></p>
<p>结果在这直接return了，从这里进去</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241118201651343-1732016006152-2.png" alt="image-20241118201651343"></p>
<p>导出了一个方法,这个方法是用来将 hex 的十六进制数据转换成 base64 编码</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241118202056572-1732016006153-3.png" alt="image-20241118202056572"></p>
<p>继续进,getkey 方法是检验之前是否传入了key，不管，继续</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241118202319995-1732016006153-4.png" alt="image-20241118202319995"></p>
<p>进入加密方法，这个是关键方法</p>
<p>maxLength 是检测最大字符长度，不用管他，PKSC1Padding 和 NOPadding 都需要这个数</p>
<p>经过 pkcs2 处理后进行判断是否有内容，有内容就进行加密，然后进行hex编码，再进行hex转base64将结果返回。</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241118202631605-1732016006153-5.png" alt="image-20241118202631605"></p>
<p>这里就直接进PKSC1模式进行加密了，可以在这里加一个判断，让用户多传进来一个字符串，来判断模式，这样就可以二者兼得</p>
<p>开始尝试，依照pkcs写Nopadding照葫芦画瓢了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NOPadding (type1, byte[0]) pad input string s to n byte[n] array, and return a bigint</span></span><br><span class="line"><span class="comment">// 入乡随俗了老铁</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">nopkcs</span>(<span class="params">s, n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; s.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Message too long for RSA&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> ba = [];</span><br><span class="line">    <span class="keyword">var</span> i = s.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> c = s.<span class="title function_">charCodeAt</span>(i--);</span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="number">128</span>) &#123; <span class="comment">// encode using utf-8</span></span><br><span class="line">            ba[--n] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((c &gt; <span class="number">127</span>) &amp;&amp; (c &lt; <span class="number">2048</span>)) &#123;</span><br><span class="line">            ba[--n] = (c &amp; <span class="number">63</span>) | <span class="number">128</span>;</span><br><span class="line">            ba[--n] = (c &gt;&gt; <span class="number">6</span>) | <span class="number">192</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ba[--n] = (c &amp; <span class="number">63</span>) | <span class="number">128</span>;</span><br><span class="line">            ba[--n] = ((c &gt;&gt; <span class="number">6</span>) &amp; <span class="number">63</span>) | <span class="number">128</span>;</span><br><span class="line">            ba[--n] = (c &gt;&gt; <span class="number">12</span>) | <span class="number">224</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前面的都一样,但是处理完数据之后,就该填充0了,这时候就不一样了</span></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ba[--n] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(ba);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添一个判断model的逻辑</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">RSAKey</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">encrypt</span> = <span class="keyword">function</span> (<span class="params">text, model</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> maxLength = (<span class="variable language_">this</span>.<span class="property">n</span>.<span class="title function_">bitLength</span>() + <span class="number">7</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">var</span> m;</span><br><span class="line">    <span class="comment">// 还是保留默认是PKCS#1</span></span><br><span class="line">    <span class="keyword">if</span> (model == <span class="string">&quot;PKCSPadding&quot;</span> || model == <span class="literal">undefined</span> || model == <span class="literal">null</span>) &#123;</span><br><span class="line">        m = <span class="title function_">pkcs1pad2</span>(text, maxLength);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (model == <span class="string">&quot;NOPadding&quot;</span>) &#123;</span><br><span class="line">        m = <span class="title function_">nopkcs</span>(text, maxLength)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Invalid padding model&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="variable language_">this</span>.<span class="title function_">doPublic</span>(m);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> h = c.<span class="title function_">toString</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">var</span> length = h.<span class="property">length</span>;</span><br><span class="line">    <span class="comment">// fix zero before result</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; maxLength * <span class="number">2</span> - length; i++) &#123;</span><br><span class="line">        h = <span class="string">&quot;0&quot;</span> + h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>更改传入值，可以发现这之只是改了加密，还没改解密，不着急，先让这个传入两个参数，base形式的就先放一放</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241118210735767-1732016006153-6.png" alt="image-20241118210735767"></p>
<p>在相应的文件中更改，打断点调试的时候还是源代码，待我稍作思量，更益其巧</p>
<p>找到这个文件，上面有各个文件的信息啥的，代码没有被解析，怎么说呢，直接改吧</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241119145222944-1732016006153-7.png" alt="image-20241119145222944"></p>
<p>调用时，多接收一个参数</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241118211817786-1732016006153-8.png" alt="image-20241118211817786"></p>
<p>&#x2F;&#x2F; 处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">判断方法</span><br><span class="line">\n        var m;\n        // 还是保留默认的是PKCS#1\n        if (model == &#x27;PKCSPadding&#x27; || model == undefined || model == null) &#123;/n            m = pkcs1pad2(text, maxLength);/n        &#125; else if (model == &#x27;NOPadding&#x27;) &#123;\n            m = nopkcs(text, maxLength);\n        &#125; else &#123;\n            console.error(&#x27;Invalid padding model&#x27;);\n            returm null;\n        &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Nopadding填充操作</span><br><span class="line">function nopkcs(s, n) &#123;\n    if (n &lt; s.length) &#123;\n        console.error(&#x27;Message too long for RSA&#x27;);\n        return null;\n    &#125;\n    var ba = [];\n    var i = s.length - 1;\n    while (i &gt;= 0 &amp;&amp; n &gt; 0) &#123;\n        var c = s.charCodeAt(i--);\n        if (c &lt; 128) &#123;\n            ba[--n] = c;\n        &#125;\n        else if ((c &gt; 127) &amp;&amp; (c &lt; 2024)) &#123;\n            ba[--n] = (c &amp; 63) | 128;\n            ba[--n] = (c &gt;&gt; 6) | 192;\n        &#125;\n        else &#123;\n            ba[--n] = (c &amp; 63) | 128;\n            ba[--n] = ((c &gt;&gt; 6) &amp; 63) | 128;\n            ba[--n] = (c &gt;&gt; 12) | 224;\n        &#125;    \n    &#125;\n    // 前面的都一样，但是处理完数据之后，就改填充0了，这时候就比PKSC简单了\n    while (--n &gt; 0) &#123;\n        ba[--n] = 0;\n    &#125;\n     return new _jsbn__WEBPACK_IMPORTED_MODULE_0__.BigInteger(ba);\n&#125;</span><br></pre></td></tr></table></figure>



<p>大功告成</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241119144624973-1732016006153-9.png" alt="image-20241119144624973"></p>
<p>验证一下</p>
<p>无需多言，还有解密</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241119145500510-1732016006153-10.png" alt="image-20241119145500510"></p>
<p>接下来写NOPadding的解密</p>
<p>和加密的套路差不多，先检验是否有私钥，然后获取 base64转hex 的方法，将密文转成hex</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241119153831614-1732016006153-11.png" alt="image-20241119153831614"></p>
<p>然后就是重点了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241119154429072-1732016006153-12.png" alt="image-20241119154429072"></p>
<p>这个C是处理hex数据的和解密无关，m我也看了一下直接用就行，真正处理的在 return上，这样也省事了，开始微操</p>
<p>加一个判断，通过打断点发现，这个m比较短，也就是说很可能就是明文的一种编码，反复实验之后先将这个 BigInteger 类型的数据转换成 byte 数组，然后将byte数组转换成utf-8的数据，有点弯弯绕。</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241119165204122-1732016006153-13.png" alt="image-20241119165204122"></p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;return m;</span><br><span class="line">&gt;BigInteger &#123; &#x27;0&#x27;: 53753142, &#x27;1&#x27;: 201507, s: 0, t: 2 &#125;</span><br><span class="line"></span><br><span class="line">&gt;return m.toByteArray();</span><br><span class="line">&gt;[ 49, 50, 51, 52, 53, 54 ]</span><br><span class="line"></span><br><span class="line">&gt;return String.fromCharCode.apply(null, m.toByteArray());</span><br><span class="line">&gt;123456</span><br></pre></td></tr></table></figure>


</blockquote>
<p>需要更改的位置有</p>
<p>这个是调试视图，去那一堆没解析的乱码里去改！就不放图片了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241119165810685-1732016006153-14.png" alt="image-20241119165810685"></p>
]]></content>
      <categories>
        <category>逆向学习</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向学习 0x07免root使用frida</title>
    <url>/2024/10/24/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-0x07%E5%85%8Droot%E4%BD%BF%E7%94%A8frida/</url>
    <content><![CDATA[<h4 id="frida-exe的详细使用"><a href="#frida-exe的详细使用" class="headerlink" title="frida.exe的详细使用"></a>frida.exe的详细使用</h4><p>有一坨，好多都不怎么用，先整点经常用的</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>-U, –usb</td>
<td>连接USB设备，这个时候是不需要端口转发的，直接连上</td>
</tr>
<tr>
<td>-R, –remote</td>
<td>连接远程设备</td>
</tr>
<tr>
<td>-H HOST, –host HOST</td>
<td>连接网络设备，连接指定IP地址和端口的frida-server</td>
</tr>
<tr>
<td>-f TARGET, –file TARGET</td>
<td>后面跟包名，启动软件，启动时开始hook</td>
</tr>
<tr>
<td>-F, –attach-frontmost</td>
<td>注入正在打开的最前端的进程</td>
</tr>
<tr>
<td>-n NAME, –attach-name NAME</td>
<td>也是加包名，但是 -n 可以省略</td>
</tr>
<tr>
<td>-p PID, –attach-pid PID</td>
<td>根据进程的PID注入；   ps -A  打印进程；  -p 也是可以省略的</td>
</tr>
<tr>
<td>-l SCRIPT, –load SCRIPT</td>
<td>脚本代码的路径</td>
</tr>
<tr>
<td>-o LOGFILE, –output LOGFILE</td>
<td>指定内容输出位置</td>
</tr>
<tr>
<td>–runtime {qjs,v8}</td>
<td>指定解析脚本的引擎</td>
</tr>
</tbody></table>
<p>-p 一般是遇到软件双进程时使用，app有两个进程，包名还是一样的，就需要指定PID</p>
<span id="more"></span>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">options:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -D ID, --device ID    connect to device with the given ID</span><br><span class="line">  -U, --usb             connect to USB device</span><br><span class="line">  -R, --remote          connect to remote frida-server</span><br><span class="line">  -H HOST, --host HOST  connect to remote frida-server on HOST</span><br><span class="line">  --certificate CERTIFICATE</span><br><span class="line">                        speak TLS with HOST, expecting CERTIFICATE</span><br><span class="line">  --origin ORIGIN       connect to remote server with “Origin” header set to ORIGIN</span><br><span class="line">  --token TOKEN         authenticate with HOST using TOKEN</span><br><span class="line">  --keepalive-interval INTERVAL</span><br><span class="line">                        set keepalive interval in seconds, or 0 to disable (defaults to -1 to auto-select based on transport)</span><br><span class="line">  --p2p                 establish a peer-to-peer connection with target</span><br><span class="line">  --stun-server ADDRESS</span><br><span class="line">                        set STUN server ADDRESS to use with --p2p</span><br><span class="line">  --relay address,username,password,turn-&#123;udp,tcp,tls&#125;</span><br><span class="line">                        add relay to use with --p2p</span><br><span class="line">  -f TARGET, --file TARGET</span><br><span class="line">                        spawn FILE</span><br><span class="line">  -F, --attach-frontmost</span><br><span class="line">                        attach to frontmost application</span><br><span class="line">  -n NAME, --attach-name NAME</span><br><span class="line">                        attach to NAME</span><br><span class="line">  -N IDENTIFIER, --attach-identifier IDENTIFIER</span><br><span class="line">                        attach to IDENTIFIER</span><br><span class="line">  -p PID, --attach-pid PID</span><br><span class="line">                        attach to PID</span><br><span class="line">  -W PATTERN, --await PATTERN</span><br><span class="line">                        await spawn matching PATTERN</span><br><span class="line">  --stdio &#123;inherit,pipe&#125;</span><br><span class="line">                        stdio behavior when spawning (defaults to “inherit”)</span><br><span class="line">  --aux option          set aux option when spawning, such as “uid=(int)42” (supported types are: string, bool, int)</span><br><span class="line">  --realm &#123;native,emulated&#125;</span><br><span class="line">                        realm to attach in</span><br><span class="line">  --runtime &#123;qjs,v8&#125;    script runtime to use</span><br><span class="line">  --debug               enable the Node.js compatible script debugger</span><br><span class="line">  --squelch-crash       if enabled, will not dump crash report to console</span><br><span class="line">  -O FILE, --options-file FILE</span><br><span class="line">                        text file containing additional command line options</span><br><span class="line">  --version             show program&#x27;s version number and exit</span><br><span class="line">  -l SCRIPT, --load SCRIPT</span><br><span class="line">                        load SCRIPT</span><br><span class="line">  -P PARAMETERS_JSON, --parameters PARAMETERS_JSON</span><br><span class="line">                        parameters as JSON, same as Gadget</span><br><span class="line">  -C USER_CMODULE, --cmodule USER_CMODULE</span><br><span class="line">                        load CMODULE</span><br><span class="line">  --toolchain &#123;any,internal,external&#125;</span><br><span class="line">                        CModule toolchain to use when compiling from source code</span><br><span class="line">  -c CODESHARE_URI, --codeshare CODESHARE_URI</span><br><span class="line">                        load CODESHARE_URI</span><br><span class="line">  -e CODE, --eval CODE  evaluate CODE</span><br><span class="line">  -q                    quiet mode (no prompt) and quit after -l and -e</span><br><span class="line">  -t TIMEOUT, --timeout TIMEOUT</span><br><span class="line">                        seconds to wait before terminating in quiet mode</span><br><span class="line">  --pause               leave main thread paused after spawning program</span><br><span class="line">  -o LOGFILE, --output LOGFILE</span><br><span class="line">                        output to log file</span><br><span class="line">  --eternalize          eternalize the script before exit</span><br><span class="line">  --exit-on-error       exit with code 1 after encountering any exception in the SCRIPT</span><br><span class="line">  --kill-on-exit        kill the spawned program when Frida exits</span><br><span class="line">  --auto-perform        wrap entered code with Java.perform</span><br><span class="line">  --auto-reload         Enable auto reload of provided scripts and c module (on by default, will be required in the future)</span><br><span class="line">  --no-auto-reload      Disable auto reload of provided scripts and c module</span><br></pre></td></tr></table></figure>





<h4 id="frida-server选项"><a href="#frida-server选项" class="headerlink" title="frida-server选项"></a>frida-server选项</h4><p>之前启动frida-server服务都是直接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">./data/local/tmp/frida</span><br></pre></td></tr></table></figure>

<p>这样的话是默认启动的 27042 端口</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241023114130141.png" alt="image-20241023114130141"></p>
<p>有时候会出现这个端口被APP提前占用的情况，这个时候就需要指定端口了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Help Options:</span><br><span class="line">  -h, --help                            Show help options</span><br><span class="line"></span><br><span class="line">Application Options:</span><br><span class="line">  --version                             Output version information and exit</span><br><span class="line">  -l, --listen=ADDRESS                  Listen on ADDRESS</span><br><span class="line">  --certificate=CERTIFICATE             Enable TLS using CERTIFICATE</span><br><span class="line">  --origin=ORIGIN                       Only accept requests with ?Origin? header matching ORIGIN (by default any origin will be accepted)</span><br><span class="line">  --token=TOKEN                         Require authentication using TOKEN</span><br><span class="line">  --asset-root=ROOT                     Serve static files inside ROOT (by default no files are served)</span><br><span class="line">  -d, --directory=DIRECTORY             Store binaries in DIRECTORY</span><br><span class="line">  -D, --daemonize                       Detach and become a daemon</span><br><span class="line">  --policy-softener=system|internal     Select policy softener</span><br><span class="line">  -P, --disable-preload                 Disable preload optimization</span><br><span class="line">  -C, --ignore-crashes                  Disable native crash reporter integration</span><br><span class="line">  -v, --verbose                         Be verbose</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>选项</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>-l, –listen&#x3D;ADDRESS</td>
<td>修改监听的IP和端口</td>
</tr>
</tbody></table>
<p>使用 <code>ip address</code> 查看当前IP地址</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241023114737298.png" alt="image-20241023114737298"></p>
<p>这里我的frida-server 的名字就是frida，所以输入Frida</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frida -l 0.0.0.0:8000</span><br></pre></td></tr></table></figure>

<p>这个时候启动的frida-server就是8000端口的</p>
<h4 id="frida连接多个设备"><a href="#frida连接多个设备" class="headerlink" title="frida连接多个设备"></a>frida连接多个设备</h4><p>传统简单的连接方式 -U ，但是电脑不能插满USB吧，所以要想连接多个设备，就需要 -H 的帮助，并且frida-server要指定好端口，确保手机和电脑之间可以通信（能ping通）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frida -H IP:端口 -F</span><br></pre></td></tr></table></figure>





<h3 id="脱离PC使用frida"><a href="#脱离PC使用frida" class="headerlink" title="脱离PC使用frida"></a>脱离PC使用frida</h3><p>之前使用的 frida-server 是使用PC用于调试阶段的，如果要进行破解什么的操作，还是要脱离PC端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、在手机上使用 Termux 终端，这个就相当于在手机上安装一个命令行</span><br><span class="line">2、frida-inject</span><br><span class="line">3、frida-gadget.so</span><br><span class="line">	优点：可以免root使用frida、frida-gadget比较稳定</span><br><span class="line">	缺点：需要重打包app，局限性较大。但是可以通过魔改安卓系统，让系统帮我们注入so，免去重打包的繁琐</span><br></pre></td></tr></table></figure>



<h4 id="frida-inject"><a href="#frida-inject" class="headerlink" title="frida-inject"></a>frida-inject</h4><p>和frida-server安装方法一样，使用之前要先去下载对应frida版本的东西，然后和frida-server一样推送到手机中。</p>
<p>frida-inject可以做到持续hook，实现脱离PC</p>
<p>看一下帮助</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  frida-inject [OPTION?]</span><br><span class="line"></span><br><span class="line">Help Options:</span><br><span class="line">  -h, --help                           Show help options</span><br><span class="line"></span><br><span class="line">Application Options:</span><br><span class="line">  -D, --device=ID                      connect to device with the given ID</span><br><span class="line">  -f, --file=FILE                      spawn FILE</span><br><span class="line">  -p, --pid=PID                        attach to PID</span><br><span class="line">  -n, --name=NAME                      attach to NAME</span><br><span class="line">  -r, --realm=REALM                    attach in REALM</span><br><span class="line">  -s, --script=JAVASCRIPT_FILENAME</span><br><span class="line">  -R, --runtime=qjs|v8                 Script runtime to use</span><br><span class="line">  -P, --parameters=PARAMETERS_JSON     Parameters as JSON, same as Gadget</span><br><span class="line">  -e, --eternalize                     Eternalize script and exit</span><br><span class="line">  -i, --interactive                    Interact with script through stdin</span><br><span class="line">  --development                        Enable development mode</span><br><span class="line">  --version                            Output version information and exit</span><br></pre></td></tr></table></figure>



<p>值得一说的是 -e 永久化脚本，将脚本文件放到手机文件中，然后运行执行frida命令，就可以关闭命令行来实现hook了，但是这种方法也是有缺陷的，手机重启还得重新进行执行命令</p>
<p>如果说不使用 -e 选项，frida-inject 也是不能离开电脑的</p>
<h4 id="frida-gadget-so"><a href="#frida-gadget-so" class="headerlink" title="frida-gadget.so"></a>frida-gadget.so</h4><p>这个服务是免root的，也就是用户用起来最舒服的一种方式，但是开发者不舒服[doge]</p>
<p>我们需要将这个so放到app中去，这个时候需要反编译app，并且不需要root权限，将so打包进app省略了之前注入时需要的root权限</p>
<p>先使用 apktool 进行解包，然后将 so 放到对应的目录下，然后修改代码加载这个so，然会回编译，最后进行签名</p>
<p>使用过程比较繁琐，但是objection中有简单的方法</p>
<h3 id="objection"><a href="#objection" class="headerlink" title="objection"></a>objection</h3><h4 id="下崽安装使用"><a href="#下崽安装使用" class="headerlink" title="下崽安装使用"></a>下崽安装使用</h4><p>objection对frida进行了进一步的封装，通过一系列的命令即可完成hook。大大降低了hook的门槛</p>
<p>安装objection之前需要安装frida和frida-tools</p>
<p>为了兼容性更好，安装的objection的版本最好在当前frida版本之后更新，然后发现。测，21年就停更了牢弟，那我还下鸡毛啊</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install objection</span><br></pre></td></tr></table></figure>



<p>直接下崽就完事了</p>
<p>命令行输入，检测是否下载完成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objection</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Usage: objection [OPTIONS] COMMAND [ARGS]...</span><br><span class="line"></span><br><span class="line">       _   _         _   _</span><br><span class="line">   ___| |_|_|___ ___| |_|_|___ ___</span><br><span class="line">  | . | . | | -_|  _|  _| | . |   |</span><br><span class="line">  |___|___| |___|___|_| |_|___|_|_|</span><br><span class="line">        |___|(object)inject(ion)</span><br><span class="line"></span><br><span class="line">       Runtime Mobile Exploration</span><br><span class="line">          by: @leonjza from @sensepost</span><br><span class="line"></span><br><span class="line">  By default, communications will happen over USB, unless the --network option</span><br><span class="line">  is provided.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -N, --network            Connect using a network connection instead of USB.</span><br><span class="line">  -h, --host TEXT          [default: 127.0.0.1]</span><br><span class="line">  -p, --port INTEGER       [default: 27042]</span><br><span class="line">  -ah, --api-host TEXT     [default: 127.0.0.1]</span><br><span class="line">  -ap, --api-port INTEGER  [default: 8888]</span><br><span class="line">  -g, --gadget TEXT        Name of the Frida Gadget/Process to connect to.</span><br><span class="line">                           [default: Gadget]</span><br><span class="line">  -S, --serial TEXT        A device serial to connect to.</span><br><span class="line">  -d, --debug              Enable debug mode with verbose output. (Includes</span><br><span class="line">                           agent source map in stack traces)</span><br><span class="line">  --help                   Show this message and exit.</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  api          Start the objection API server in headless mode.</span><br><span class="line">  device-type  Get information about an attached device.</span><br><span class="line">  explore      Start the objection exploration REPL.</span><br><span class="line">  patchapk     Patch an APK with the frida-gadget.so.</span><br><span class="line">  patchipa     Patch an IPA with the FridaGadget dylib.</span><br><span class="line">  run          Run a single objection command.</span><br><span class="line">  signapk      Zipalign and sign an APK with the objection key.</span><br><span class="line">  version      Prints the current version and exists.</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-N： 表示网络连接，不加表示USB连接</span><br><span class="line">-h： 主机名，默认是 127.0.0.1</span><br><span class="line">-p： 端口，默认是 27042</span><br><span class="line">-g： 指定进程名\包名</span><br><span class="line"></span><br><span class="line">explore：启动objection交互界面，explore也有选项，下面再说</span><br><span class="line">patchapk</span><br></pre></td></tr></table></figure>



<p>启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objection -g 包名 explore</span><br></pre></td></tr></table></figure>



<p>objection使用的是frida-server，所以要开启frida-server</p>
<p>可以提示代码，按右箭头选中</p>
<p>之前打印所有加载的类也只需要一行代码（JS中好像也是一行</p>
<p>然后运行的结果会保存在 C盘中用户目录下的 <code>.objection</code> 目录中</p>
<p>PS：感觉不是很好啊，聊胜于无吧</p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>既然是一行代码可以解决问题，那就看看可以干什么吧。毕竟被称为——有手就行的hook</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">列出所有已加载的类（常用）</span><br><span class="line">	android hooking list classes</span><br><span class="line">	</span><br><span class="line">在所有已加载的类中搜索包含特定关键字的类（常用）</span><br><span class="line">	android hooking search classes &lt;pattern&gt;</span><br><span class="line">	</span><br><span class="line">列出类的所有方法（常用）</span><br><span class="line">	android hooking list class_methods &lt;路径.类名&gt;</span><br><span class="line">	</span><br><span class="line">hook类的所有方法（不包括构造方法）</span><br><span class="line">	android hooking watch class &lt;路径.类名&gt;</span><br><span class="line">	</span><br><span class="line">hook类的构造方法</span><br><span class="line">	android hooking watch class_method &lt;路径.类名.$init&gt;</span><br><span class="line">	</span><br><span class="line">默认是hook方法的所有重载（常用）</span><br><span class="line">	android hooking watch class_method &lt;路径.类名.方法名&gt;</span><br><span class="line">	</span><br><span class="line">hook方法的参数、返回值和调用栈（常用）</span><br><span class="line">	android hooking watch class_method &lt;路径.类名.方法名&gt; --dump-args --dump-return --dump-backtrace</span><br><span class="line">	</span><br><span class="line">hook单个重载函数，需要指定参数类型，多个参数需要用逗号分隔</span><br><span class="line">	android hooking watch class_method &lt;路径.类名.方法名&gt; &quot;&lt;参数类型&gt;&quot;</span><br></pre></td></tr></table></figure>



<p>收回我愚昧的话，还挺方便，那就先把他的log输出路径改一下吧，不要在我神圣不可侵犯的C盘，乱写乱画。</p>
<h4 id="更改log路径"><a href="#更改log路径" class="headerlink" title="更改log路径"></a>更改log路径</h4><p>爆搜一下文佳路径中包含的文件夹，文件也不是很多，打开第一个</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241023210239420.png" alt="image-20241023210239420"></p>
<p>没想到直接中奖了</p>
<p>直接给这玩意改个喜欢的路径试试效果</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241023210514569.png" alt="image-20241023210514569"></p>
<p>运行一下试试水</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241023210609691.png" alt="image-20241023210609691"></p>
<p>很显然，主要的问题解决了，但是还有剩余，因为还有两个文件</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241023210841965.png" alt="image-20241023210841965"></p>
<p>在这三个文件中找到了，三个文件的地址，都改为自己喜欢的地址即可</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241023211125050.png" alt="image-20241023211125050"></p>
<p>还有一个意外之喜，在base.py中还有一个文件路径，虽然没看见这个文件，但是牢弟改就完了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241023211223906.png" alt="image-20241023211223906"></p>
<p>非常好，已经从C盘消失了，我很满意</p>
<h4 id="其他常见操作"><a href="#其他常见操作" class="headerlink" title="其他常见操作"></a>其他常见操作</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看hook了多少类</span><br><span class="line">	jobs list</span><br><span class="line">	</span><br><span class="line">取消hook</span><br><span class="line">	jobs kill &lt;jobld&gt;</span><br><span class="line">	</span><br><span class="line">指定IP和端口连接</span><br><span class="line">	objection -N -h &lt;ip&gt; -p &lt;port&gt; -g &lt;进程名&gt; explore</span><br><span class="line">	</span><br><span class="line">启动前就hook</span><br><span class="line">	objection -N -h &lt;ip&gt; -p &lt;port&gt; -g &lt;进程名&gt; explore --startup-command &quot;android hooking watch class &lt;路径.类名&gt;&quot;</span><br><span class="line">	</span><br><span class="line">启动前就hook打印参数、返回值、函数调用栈</span><br><span class="line">	objection -N -h &lt;ip&gt; -p &lt;port&gt; -g &lt;进程名&gt; explore --startup-command &quot;android hooking watch class &lt;路径.类名.方法名&gt; --dump-args --dump-return --dump-backtrace&quot;</span><br></pre></td></tr></table></figure>



<p>看一下explore有啥小功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Usage: objection explore [OPTIONS]</span><br><span class="line"></span><br><span class="line">  Start the objection exploration REPL.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -s, --startup-command TEXT     A command to run before the repl polls the</span><br><span class="line">                                 device for information.</span><br><span class="line">  -q, --quiet                    Do not display the objection logo on startup.</span><br><span class="line">  -c, --file-commands FILENAME   A file containing objection commands,</span><br><span class="line">                                 separated by a newline, that will run before</span><br><span class="line">                                 the repl polls the device for information.</span><br><span class="line">  -S, --startup-script FILENAME  A script to import and run before the repl</span><br><span class="line">                                 polls the device for information.</span><br><span class="line">  -a, --enable-api               Start the objection API server.</span><br><span class="line">  -P, --plugin-folder TEXT       The folder to load plugins from.</span><br><span class="line">  --help                         Show this message and exit.</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objection -g &lt;进程名&gt; explore --startup-command &quot;android hooking watch class_method com.xiaojianbang.hook.Utils.shufferMap2 --dump-args --dump-backtrace --dump-return&quot;</span><br><span class="line"></span><br><span class="line">-N -h &lt;ip&gt; -p &lt;port&gt; 默认frida-server服务的话是不需要这个的</span><br><span class="line">这就是一句启动前hook的代码</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果启动前需要hook多个函数，那么就需要 -c 了，将引号内的指令，放到一个文件中去</span><br><span class="line">objection -g &lt;进程名&gt; explore -c &quot;文件路径&quot;</span><br></pre></td></tr></table></figure>



<h4 id="不太常见的操作"><a href="#不太常见的操作" class="headerlink" title="不太常见的操作"></a>不太常见的操作</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">关闭ssl校检</span><br><span class="line">	android sslpinning disable</span><br><span class="line">	</span><br><span class="line">关闭root检测</span><br><span class="line">	android root disable</span><br></pre></td></tr></table></figure>

<p>这两个并不能百分百过掉，但是可以先上来测他一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">搜索堆中的实例</span><br><span class="line">	android heap search instances &lt;类名&gt;</span><br><span class="line">	</span><br><span class="line">查看当前app的activity</span><br><span class="line">	android hooking list activities</span><br><span class="line">	</span><br><span class="line">尝试跳转到对应activiy (或许可以直接跳转到想要的页面也说不定)</span><br><span class="line">	android intent launch_activity</span><br><span class="line">	</span><br><span class="line">枚举内存中所有模块 （枚举SO文件）</span><br><span class="line">	memory list modules</span><br><span class="line">	</span><br><span class="line">枚举模块中所有导出函数</span><br><span class="line">	memory list exports &lt;so库名&gt;</span><br><span class="line">	</span><br><span class="line">当结果太多，可以将结果导出到本地文件中</span><br><span class="line">	memory list exports &lt;so库名&gt; --json &lt;路径.文件名&gt;	</span><br></pre></td></tr></table></figure>



<h4 id="整个小插件"><a href="#整个小插件" class="headerlink" title="整个小插件"></a>整个小插件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">插件加载</span><br><span class="line">	plugin load 插件路径 Wallbreaker</span><br><span class="line">	</span><br><span class="line">搜索类</span><br><span class="line">	plugin Wallbreaker classsearch &lt;pattern&gt;</span><br><span class="line">	</span><br><span class="line">搜索对象</span><br><span class="line">	plugin Wallbreaker objectsearch &lt;classname&gt;</span><br><span class="line">	</span><br><span class="line">classdump输出类结构，若加了 --fullname 参数，打印数据中的类名会带完整包名</span><br><span class="line">	plugin Wallbreaker classdump &lt;classname&gt; [--fullname]</span><br><span class="line">	</span><br><span class="line">objectdump在classdump的基础上，输出指定对象中的每个字段的数据</span><br><span class="line">	plugin Wallbreaker objectdump &lt;handle&gt; [--fullname]</span><br></pre></td></tr></table></figure>



<p>objection起起来之后先进行插件加载操作，然后输出类结构，去搜索这个类的对象，根据对象的地址值来打印字段数据</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241024111346319.png" alt="image-20241024111346319"></p>
<h4 id="frida-gadget-so-1"><a href="#frida-gadget-so-1" class="headerlink" title="frida-gadget.so"></a>frida-gadget.so</h4><p>干点正事吧，巴巴托斯。简单使用这个需要使用到 objection 的 patchapk 选项，这个一会再说，先准备一下环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Usage: objection patchapk [OPTIONS]</span><br><span class="line"></span><br><span class="line">  Patch an APK with the frida-gadget.so.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -s, --source TEXT              The source APK to patch  [required]</span><br><span class="line">  -a, --architecture TEXT        The architecture of the device the patched</span><br><span class="line">                                 APK will run on. This can be determined with</span><br><span class="line">                                 `adb shell getprop ro.product.cpu.abi`. If it</span><br><span class="line">                                 is not specified, this command will try and</span><br><span class="line">                                 determine it automatically.</span><br><span class="line">  -V, --gadget-version TEXT      The gadget version to use. If not specified,</span><br><span class="line">                                 the latest version will be used.</span><br><span class="line">  -p, --pause                    Pause the patcher before rebuilding the APK.</span><br><span class="line">  -k, --skip-cleanup             Do not clean temporary files once finished.</span><br><span class="line">  -d, --enable-debug             Set the android:debuggable flag to true in</span><br><span class="line">                                 the application manifest.</span><br><span class="line">  -N, --network-security-config  Include a network_security_config.xml file</span><br><span class="line">                                 allowing for user added CA&#x27;s to be trusted on</span><br><span class="line">                                 Android 7 and up. This option can not be used</span><br><span class="line">                                 with the --skip-resources flag.</span><br><span class="line">  -D, --skip-resources           Skip resource decoding as part of the apktool</span><br><span class="line">                                 processing.</span><br><span class="line">  -t, --target-class TEXT        The target class to patch.</span><br><span class="line">  -2, --use-aapt2                Use the aapt2 binary instead of aapt as part</span><br><span class="line">                                 of the apktool processing.</span><br><span class="line">  -c, --gadget-config TEXT       The gadget configuration file to use. Refer</span><br><span class="line">                                 to https://frida.re/docs/gadget/ for more</span><br><span class="line">                                 information.</span><br><span class="line">  -l, --script-source TEXT       A script file to use with the the &quot;path&quot;</span><br><span class="line">                                 config type. Specify &quot;libfrida-</span><br><span class="line">                                 gadget.script.so&quot; as the &quot;path&quot; in your</span><br><span class="line">                                 config.</span><br><span class="line">  -n, --ignore-nativelibs        Do not change the extractNativeLibs flag in</span><br><span class="line">                                 the AndroidManifest.xml.</span><br><span class="line">  -m, --manifest TEXT            A decoded AndroidManifest.xml file to read.</span><br><span class="line">  --help                         Show this message and exit.</span><br></pre></td></tr></table></figure>



<h5 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h5><p>aapt</p>
<p>去build-tools中找到这个，确保可以随时使用，可以配置一下环境变量</p>
<p>很显然这个东西是用来做打包apk的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241024120148085.png" alt="image-20241024120148085"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241024120232932.png" alt="image-20241024120232932"></p>
<p>jarsigner</p>
<p>一般jadx中就有，如果jadx可以正常使用，命令行输入 jarsigner 也没什么问题</p>
<p>这个是用来签名的，app反编译回编译之后是需要签名的，否则无法在安卓系统中使用</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241024120308115.png" alt="image-20241024120308115"></p>
<p>apktool</p>
<p><a href="https://apktool.org/docs/install/">https://apktool.org/docs/install/</a></p>
<p>先下载jar文件，然后找到将网页中 bat 信息复制到自己新建的 apktool.bat 文件中</p>
<img src="../图片/image-20241024142159935.png" alt="image-20241024142159935" style="zoom:33%;" />



<p>配置环境变量，输入apktool出现如下结果</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241024142101973.png" alt="image-20241024142101973"></p>
<p>adb</p>
<p>这个之前弄过了，还弄个鸡毛呀，pass</p>
<h5 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-s： 指定apk的路径</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241024145841820.png" alt="image-20241024145841820"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-a： 指定手机的平台，如果不指定的话自动运行 adb shell getprop ro.product.cup.abi 获取，之所以准备adb也是因为这个</span><br></pre></td></tr></table></figure>

<p>如果指定了 -a 就不会执行这句了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241024150006322.png" alt="image-20241024150006322"></p>
<p>这里插入一个so平台选择吧</p>
<p>可以执行adb代码查看，我用的模拟器，所以是 x86_64，如果是真机的话就是arm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell getprop ro.product.cup.abi</span><br></pre></td></tr></table></figure>

<p>Android系统是32位，那么app里的so都走32位的</p>
<p>Android系统是64位，如果app里面有64位的so，那么app就走64位的so</p>
<p>Android系统是64位，如果app里面只有32位的so，那么app就走32位的so</p>
<p>所以说还需要注意apk的so的情况，如果手机是64位的，但是apk中没有64位的so文件，那么就必须用 -a 指定32位的下载，否则执行文件里就一个 gadget.so app还执行个P啊还</p>
<p>还有一个bug，就是是会从gitup上下载最新版本的 frida-gadget.so 不仅和frida版本不匹配还得下载东西，气抖冷</p>
<p>快对他使用 -V</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-V： 指定gadget版本</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-p： 在回编译的时候停止，这个一般是不用的，因为停止之后需要手动的回编译和签名</span><br></pre></td></tr></table></figure>



<p>这个东西下的慢，很不体面，帮他体面体面</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241024153201315.png" alt="image-20241024153201315"></p>
<p>去这个目录下，把下载好的 gadget.so 解压放里面，重命名为 <code>libfrida-gadget.so</code> ，没体面成功，但是他体面了，但是这个方法应该是可行的。</p>
<p>还有一个问题，我犯忌讳了，目录不能有中文路径，得给apk路径改一下</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241024154243457.png" alt="image-20241024154243457"></p>
<p>运行成功，目录里多了一个apk文件</p>
<p>而且改的那个文件路径也是有备无患了，果然用到了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241024154301562.png" alt="image-20241024154301562"></p>
<p>这个时候apk已经打包完成了，现在不需要开启frida-server了，也就是说不需要root就可以hook了</p>
<h5 id="过程介绍"><a href="#过程介绍" class="headerlink" title="过程介绍"></a>过程介绍</h5><p>稀里糊涂的就给他注入了，看一下注入过程</p>
<p>第一步：反编译，将so注入对应平台的cup的so文件夹</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241024155714111.png" alt="image-20241024155714111"></p>
<p>第二布：加载so</p>
<p>找到入口类：第一个带有 LAUNCHER 的 activity 的类或者 application 上的 android:name</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241024160112663.png" alt="image-20241024160112663"></p>
<p>在这个类中可以看到一个静态代码块，直接就加载了so</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241024160350035.png" alt="image-20241024160350035"></p>
<p>第三步：回编译为apk，更改签名信息</p>
<p>光看名字就能看出来，签名信息是不一样的，变为了OBJECTION的签名信息</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241024160720713.png" alt="image-20241024160720713"></p>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>优点很明显就是免root，如果遇到绕不过的root检测，或者手机无法获取root，这个无疑是一个很好的方法</p>
<p>缺点也很突出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、有些app反编译和回编译可能会出错</span><br><span class="line">2、有些app存在签名校检、文件校检</span><br></pre></td></tr></table></figure>

<p>签名校验</p>
<p>包露馅的牢弟，签名信息是包改不可的，因为文件变了，哈希也就变了，签名信息对不上是不能安装的。</p>
<p>就得见招拆招，过签名检测，还可能有文件校验，你就使劲过吧，牢弟</p>
<p>改进方法就是魔改安卓系统，启动app时，自动开启 gadget.so </p>
<h3 id="使用gadget实现脱离PC"><a href="#使用gadget实现脱离PC" class="headerlink" title="使用gadget实现脱离PC"></a>使用gadget实现脱离PC</h3><p><a href="https://frida.re/docs/gadget/">https://frida.re/docs/gadget/</a></p>
<p>gadget的文档</p>
<p>gadget有四种模式：监听、连接、脚本、脚本目录</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241024164653802.png" alt="image-20241024164653802"></p>
<p>使用这些模式需要创建一个配置文件 libgadget.config.txt ，而且 objection 便捷处理的时候需要新增一个选项 -c ，用于指定配置文件</p>
<p>使用脚本和脚本目录就可以做到脱离PC，什么都不需要开，跑app就完事了，持久化hook，但是还是要写hook脚本的牢弟。</p>
<h4 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h4><p>默认模式是监听</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;interaction&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;listen&quot;,</span><br><span class="line">    &quot;address&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;port&quot;: 27042,</span><br><span class="line">    &quot;on_port_conflict&quot;: &quot;fail&quot;,</span><br><span class="line">    &quot;on_load&quot;: &quot;wait&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以修改IP和端口，但是我监听干鸡毛吧，弄得那么麻烦，看看就得了</p>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>更是重量级，跳过</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241024165106868.png" alt="image-20241024165106868"></p>
<h4 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h4><p>这个就很常用了，不然废那么大劲和frida-server差不多不是很气人</p>
<p>path指定脚本文件，注意路径是手机上的目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;interaction&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;script&quot;,</span><br><span class="line">    &quot;path&quot;: &quot;/home/oleavr/explore.js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="脚本目录"><a href="#脚本目录" class="headerlink" title="脚本目录"></a>脚本目录</h4><p>这个还是比较少用的，因为很多时候一个文件就能完事</p>
<p>而且目录的配置文件比较麻烦，注意路径是手机上的目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;interaction&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;script-directory&quot;,</span><br><span class="line">    &quot;path&quot;: &quot;/usr/local/frida/scripts&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>还得整过滤什么的，麻烦</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241024171127315.png" alt="image-20241024171127315"></p>
]]></content>
      <categories>
        <category>逆向学习</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向学习 0x09NDK开发</title>
    <url>/2024/12/06/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-0x09NDK%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h2 id="SO入门"><a href="#SO入门" class="headerlink" title="SO入门"></a>SO入门</h2><p>先自己测一下这个案例</p>
<p>抓个包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /user/api/v1/login/app/mobile HTTP/1.1</span><br><span class="line">pa: MTczMjAxNzY1MzAzMyxhMTZhM2ZmOWVmYzU0M2IxYjlkMTBiMGI3NjY3NTk4MiwzZjg3MjNlMWNiMzBhYzYwM2RiYjY1ZGQ4N2QxMTA3Miw=</span><br><span class="line">appInfo: &#123;&quot;IMEI&quot;:&quot;bf1821d5634d0ec8&quot;,&quot;appBuild&quot;:&quot;21070602&quot;,&quot;appVersion&quot;:&quot;6.2.0&quot;,&quot;deviceId&quot;:&quot;bf1821d5634d0ec8&quot;,&quot;deviceName&quot;:&quot;NX627J&quot;,&quot;osType&quot;:&quot;android&quot;,&quot;osVersion&quot;:&quot;9&quot;,&quot;phoneName&quot;:&quot;NX627J&quot;,&quot;phoneSystemVersion&quot;:&quot;9&quot;,&quot;vendor&quot;:&quot;nubia&quot;&#125;</span><br><span class="line">User-Agent: PocketFans201807/6.2.0_21070602 (NX627J:Android 9;nubia PQ3B.190801.03191204 release-keys)</span><br><span class="line">Content-Type: application/json; charset=UTF-8</span><br><span class="line">Content-Length: 43</span><br><span class="line">Host: pocketapi.48.cn</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Accept-Encoding: gzip</span><br><span class="line"></span><br><span class="line">&#123;&quot;mobile&quot;:&quot;13112345678&quot;,&quot;pwd&quot;:&quot;a123123123&quot;&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<img src="../图片/image-20241119200211946.png" alt="image-20241119200211946" style="zoom: 50%;" />



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">感觉只有 pa 字段值得注意， MT ey 开头的一般是base64</span><br><span class="line">MTczMjAxNzY1MzAzMyxhMTZhM2ZmOWVmYzU0M2IxYjlkMTBiMGI3NjY3NTk4MiwzZjg3MjNlMWNiMzBhYzYwM2RiYjY1ZGQ4N2QxMTA3Miw=</span><br><span class="line"></span><br><span class="line">base64解码</span><br><span class="line">1732017653033,a16a3ff9efc543b1b9d10b0b76675982,3f8723e1cb30ac603dbb65dd87d11072,</span><br><span class="line">看到有三节数据，第一节感觉像是时间戳</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241119201034054.png" alt="image-20241119201034054"></p>
<p>那么直觉告诉我剩下两个就是账号和密码了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a16a3ff9efc543b1b9d10b0b76675982</span><br><span class="line">3f8723e1cb30ac603dbb65dd87d11072</span><br><span class="line">32位密文感觉和MD5有关，但是不完全是，可能加了什么东西</span><br></pre></td></tr></table></figure>



<p>hook了一下加密方法，出现了SHA1，不理解，进去看看</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241119201744331.png" alt="image-20241119201744331"></p>
<p>native表示调用SO层的方法</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241119202129315.png" alt="image-20241119202129315"></p>
<p>这有个libcipher.so可能有加密的方法，逆一下</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241119202254016.png" alt="image-20241119202254016"></p>
<p>打开IDA就麻爪了</p>
<p>视频是从base64开始入手，因为已经知道是Base64编码了，就hook base64的方法，尝试四个类</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">java.<span class="property">net</span>.<span class="property">URLEncoder</span></span><br><span class="line">java.<span class="property">util</span>.<span class="property">Base64</span></span><br><span class="line">okio.<span class="property">Base64</span></span><br><span class="line">okio.<span class="property">ByteString</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> base64 = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Base64&quot;</span>) ;</span><br><span class="line">base64.<span class="property">encodeToString</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>, <span class="string">&#x27;int&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">a, b</span>)&#123;</span><br><span class="line">	<span class="title function_">showStacks</span>();</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;base64.encodeToString:&quot;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(a));</span><br><span class="line">	<span class="keyword">var</span> result = <span class="variable language_">this</span>.<span class="title function_">encodeToString</span>(a, b);</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;base64.encodeToString result: &quot;</span>, result)</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>两个数据，要找的在下面</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241119204315093.png" alt="image-20241119204315093"></p>
<p>去反编译找 com.pocket.snh48.base.core.kotlin.net.KTokenHeaderInterceptor.intercept 方法</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241119204536583.png" alt="image-20241119204536583"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str = String.valueOf(System.currentTimeMillis()) + <span class="string">&#x27;,&#x27;</span> + StringsKt__StringsJVMKt.replace$<span class="keyword">default</span>(UUID.randomUUID().toString(), <span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="literal">false</span>, <span class="number">4</span>, (Object) <span class="literal">null</span>) + <span class="string">&#x27;,&#x27;</span> + ((Object) EncryptlibUtils.MD5(AbstractC9602.m21775(), valueOf, replace$<span class="keyword">default</span>, postkey)) + <span class="string">&#x27;,&#x27;</span> + ((Object) postkeyVersion);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第一个是时间戳实锤了</span><br><span class="line"></span><br><span class="line">第二部分</span><br><span class="line">StringsKt__StringsJVMKt.replace$<span class="keyword">default</span>(UUID.randomUUID().toString(), <span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="literal">false</span>, <span class="number">4</span>, (Object) <span class="literal">null</span>)</span><br><span class="line">这个东西是生成一个UUID，然后进行一些操作，这个东西看起来像MD5其实不是，只是一个随机数</span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">最后一个是空值不管他</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">第三部分</span><br><span class="line">((Object) EncryptlibUtils.MD5(AbstractC9602.m21775(), valueOf, replace$<span class="keyword">default</span>, postkey))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>进入MD5方法</p>
<p>看到没有代码，这个时候有两种情况，1、被加固了，或者被加密了（详见消失的钥匙）2、代码在SO层</p>
<p>这里有native关键字，那就是SO层</p>
<p>上面有提到加载了那个SO文件  encryptlib</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241119205122099.png" alt="image-20241119205122099"></p>
<p>对比一下这两个流程，很显然下面这个更有逻辑，从base64入手。我自己就没什么逻辑了想到加密就hook一下。</p>
<p>IDA逆向，找到了MD5，这个 Java_+包名的 是jni的静态注册</p>
<p>空格切换视图，F5查看伪C代码</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241119205946687.png" alt="image-20241119205946687"></p>
<p>hook一下这个方法就好了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241119210326618.png" alt="image-20241119210326618"></p>
<p>至于这么hook这个步子迈大了，先老老实实看一下SO的东西，再说hook</p>
<h3 id="so中通常会解除到的东西"><a href="#so中通常会解除到的东西" class="headerlink" title="so中通常会解除到的东西"></a>so中通常会解除到的东西</h3><blockquote>
<p>&#x3D;&#x3D;jni调用&#x3D;&#x3D;</p>
<p>jni相关的代码可以理解成so层的系统函数，下面这些就是jni的调用</p>
<p>这个调用名字固定，功能固定</p>
<p>GetStringUTFChars ：将Java的字符串转换为C的字符串</p>
<p>NewStringUTF ：将C语言字符串转换成Java字符串</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241119210640338.png" alt="image-20241119210640338"></p>
<p>关于jni还要学习的东西还很多，比如为什么调用的就是这个函数呢，是这么实现转换的呢，C是这么调用Java函数的，Java是这么调用C函数的，为什么传进去四个参数，接收了六个参数</p>
<p>&#x3D;&#x3D;系统库函数&#x3D;&#x3D;</p>
<p>比如这些 strlen 、memcpy C语言函数，来自libc.so，由libc.so来实现</p>
<p>比如 std::  这样的C++函数，来自libC++.so</p>
<p>这些系统函数也是可以hook的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241119211616336.png" alt="image-20241119211616336"></p>
<p>&#x3D;&#x3D;加密算法&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;魔改算法&#x3D;&#x3D;</p>
<p>这俩没啥好说的，学好基础就能看，熟能生巧</p>
<p>&#x3D;&#x3D;系统调用&#x3D;&#x3D;</p>
<p>所谓的Linux内核的东西了，app是有四层，最上方是第三方的app，然后是Java层，然后是so层，最后是Linux内核，在其他层的操作最终都是由Linux内核来实现的。那么有些app就直接对Linux内核进行调用，这个时候是hook不到的，除非魔改内核</p>
<p>&#x3D;&#x3D;自定义算法&#x3D;&#x3D;</p>
<p>自己写的算法，这个时候就要有汇编基础了</p>
<p>&#x3D;&#x3D;SO加固、混淆&#x3D;&#x3D;</p>
<p>SO有一个头表SHT，IDA就是从这个表开始，解析so文件，有的app运行起来会把这个表删掉，这个时候IDA就解析不了了，就需要去手机中进行 &#x3D;&#x3D;SO的dump&#x3D;&#x3D; 就是将SO从内存中保存下来，保存的SO是损坏的，需要使用工具进行 &#x3D;&#x3D;SO的修复&#x3D;&#x3D; ，想要理解就需要去了解 &#x3D;&#x3D;SO的文件结构&#x3D;&#x3D; ，这个东西就很复杂了，如果工具解析不出来，说明进行了 &#x3D;&#x3D;自定义linker&#x3D;&#x3D; ，否则工具一般没问题</p>
<p>自定义linker 是自己定义了SO的加载和解析</p>
</blockquote>
<h3 id="NDK介绍"><a href="#NDK介绍" class="headerlink" title="NDK介绍"></a>NDK介绍</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、app为什么会把代码放到SO中</span><br><span class="line">	a C语言历史悠久，有很多现成的代码可用</span><br><span class="line">	b C代码的执行效率比Java高</span><br><span class="line">	c java代码容易被反编译，而且反编译以后逻辑比较清晰，C语言反编译的伪代码扣出来是难运行的</span><br><span class="line"></span><br><span class="line">2、为什么学NDK开发</span><br><span class="line">	在安卓的so开发中，其他基本跟C/C++开发一致，而与Java交互需要用到jni</span><br><span class="line">	学习NDK的jni相关的内容</span><br><span class="line">	so中会接触到的：系统库调用、jni调用、加密算法、魔改算法、系统调用、自定义算法</span><br><span class="line">	</span><br><span class="line">3、什么是jni</span><br><span class="line">	jni是Java Native Interface的缩写。从Java1.1开始，jni标准成为Java平台的一部分，允许Java代码和其他语言写的代码进行交互</span><br><span class="line">	</span><br><span class="line">4、什么是NDK</span><br><span class="line">	交叉编译工具链，用来编译so代码的</span><br><span class="line">	NDK的配置</span><br><span class="line">	NDK、CMake、LLDB</span><br><span class="line">	NDK是原生开发套件，可以让app中使用C/C++代码</span><br><span class="line">	CMake是外部构建工具，与Gradle搭配构建原生库</span><br><span class="line">	LLDB可以调试原生代码（stuid默认存在）</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241120110704561.png" alt="image-20241120110704561"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5、ABI与指令集</span><br><span class="line">	https://developer.android.com/ndk/guides/abis</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>ABI</th>
<th>支持的指令集</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>armeabi-v7a<br>arm32<br>32位汇编</td>
<td>armeabi<br>Thumb-2<br>VFPv3-D16</td>
<td></td>
</tr>
<tr>
<td>arm64-v8a<br>64位</td>
<td>AArch64</td>
<td></td>
</tr>
<tr>
<td>x86<br>x86主要是来支持模拟器</td>
<td>x86(IA-32)<br>MMX<br>SSE&#x2F;2&#x2F;3<br>SSSE3</td>
<td></td>
</tr>
<tr>
<td>x86_64<br>如果没有模拟器的支持<br>就需要模拟器来模拟<br>arm的指令来运行app</td>
<td>x86_64<br>MMX<br>SSE&#x2F;2&#x2F;3<BR>SSSE3<br>SSE4.1、4.2<br>POPCNT</td>
<td></td>
</tr>
</tbody></table>
<h4 id="NDK和Java工程的区别"><a href="#NDK和Java工程的区别" class="headerlink" title="NDK和Java工程的区别"></a>NDK和Java工程的区别</h4><p>C工程比Java工程多静态代码块用于加载SO</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241120120506984.png" alt="image-20241120120506984"></p>
<p>需要有声明，声明完就可以使用了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public native String stringFromJNI();</span><br></pre></td></tr></table></figure>



<p>C的代码是写在cpp文件夹下的，有个同名的cpp</p>
<p>build.gradle.kts 文件中指明了CMake的路径和C语言的版本，这个CMake是指导编译的文件，C语言版本下面可以选择支持的SOABI，默认是四种都支持</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241120120857752.png" alt="image-20241120120857752"></p>
<p>这些是C工程比Java工程多出来的东西，在Java工程中加上这些就是一个C工程了</p>
<h4 id="jni注册"><a href="#jni注册" class="headerlink" title="jni注册"></a>jni注册</h4><p>这里是一种静态注册，jni还有动态注册，这里默认是给SO层的方法传了两个参数，只要是跟Java对接的函数，都有这两个参数  JNIEnv 和 jobject&#x2F;jclass</p>
<p>JNIEnv 后面再说，还是比较重要的</p>
<p>jobject是指的调用方法的对象，用 jclass是当方法为静态方法时使用</p>
<p>NewStringUTF 是将C语言的字符串转化为Java的字符串</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241121132114713.png" alt="image-20241121132114713"></p>
<p>extern “C” 是表示函数以C的形式解析，可能会给函数名加上一些东西</p>
<p>JNICALL 中没有什么东西</p>
<p>JNIEXPORT 这里定义了方法是否需要导出，默认是 default ，如果是hidden 之后这个函数名就不会出现在so的导出表内，如果是静态注册是必须要出现在导出表内的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241121133627556.png" alt="image-20241121133627556"></p>
<h4 id="so中常见的log输出"><a href="#so中常见的log输出" class="headerlink" title="so中常见的log输出"></a>so中常见的log输出</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;android/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__android_log_print(ANDROID_LOG_DEBUG, <span class="string">&quot;demo&quot;</span>, <span class="string">&quot;xxxxxx jni native %d %d&quot;</span>, <span class="number">100</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure>



<p>需要最少传入三个值，第一个是枚举类型，第二个是TAG，和安卓里面的tag一样，第三个是输出的结果，但是支持占位符，可以传超过三个的参数</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241121140105082.png" alt="image-20241121140105082"></p>
<p>这么写有点麻烦一般是使用 define 进行一个预先的声明</p>
<p>这个定义之后，再调用就方便很多</p>
<p>编译之后这俩东西就是一样的，预编译会将这个参数替换上去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;android/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAG <span class="string">&quot;demo hello&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGI(...) __android_log_print(ANDROID_LOG_INFO, TAG, __VA_ARGS__);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> JNIEXPORT jstring JNICALL</span><br><span class="line"><span class="title function_">Java_com_example_demo_MainActivity_stringFromJNI</span><span class="params">(</span></span><br><span class="line"><span class="params">        JNIEnv* env,</span></span><br><span class="line"><span class="params">        jobject <span class="comment">/* this */</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> hello = <span class="string">&quot;Hello from C++&quot;</span>;</span><br><span class="line">    __android_log_print(ANDROID_LOG_DEBUG, <span class="string">&quot;demo&quot;</span>, <span class="string">&quot;xxxxxx jni native %d %d&quot;</span>, <span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">    LOGD(<span class="string">&quot;xxxxxx jni native %d %d&quot;</span>, <span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="NDK多线程"><a href="#NDK多线程" class="headerlink" title="NDK多线程"></a>NDK多线程</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;android/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAG <span class="string">&quot;demo hello&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__);</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myThread</span><span class="params">()</span> &#123;</span><br><span class="line">    LOGD(<span class="string">&quot;this is from myThread&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> JNIEXPORT jstring JNICALL</span><br><span class="line"><span class="title function_">Java_com_example_demo_MainActivity_stringFromJNI</span><span class="params">(</span></span><br><span class="line"><span class="params">        JNIEnv* env,</span></span><br><span class="line"><span class="params">        jobject <span class="comment">/* this */</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> hello = <span class="string">&quot;Hello from C++&quot;</span>;</span><br><span class="line">    __android_log_print(ANDROID_LOG_DEBUG, <span class="string">&quot;demo&quot;</span>, <span class="string">&quot;xxxxxx jni native %d %d&quot;</span>, <span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">	<span class="comment">//LOGD(&quot;xxxxxx jni native %d %d&quot;, 100, 200);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="comment">// int pthread_create(pthread_t*--pthread_ptr,pthread_attr_t const*__attr,void*(*__start_routine)(void*),void*);</span></span><br><span class="line">    pthread_create(&amp;thread, nullptr, reinterpret_cast&lt;<span class="type">void</span> *(*)(<span class="type">void</span> *)&gt;(myThread), nullptr);</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>&#x3D;&#x3D;pthread_t   thread&#x3D;&#x3D;</p>
<p>线程ID，其实就是long</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241128193959939.png" alt="image-20241128193959939"></p>
<p>pthread_create(&amp;thread, nullptr, reinterpret_cast&lt;void *(*)(void *)&gt;(myThread), nullptr);</p>
<p>&#x2F;&#x2F; 线程ID（传刚刚定义的long类型的指针）、线程属性、函数（传递函数指针）、传给函数的参数</p>
<p>&#x2F;&#x2F; 等待线程执行完毕</p>
<p>&#x2F;&#x2F; 默认的线程属性是 joinable 随着主线程结束而结束</p>
<p>pthread_join(thread, nullpyr)</p>
<p>&#x2F;&#x2F; 线程属性是 dettach 可以分离执行</p>
<p>pthread_exit(0)</p>
<p>&#x2F;&#x2F; 子线程中使用它来退出线程</p>
</blockquote>
<h4 id="JNI-OnLoad"><a href="#JNI-OnLoad" class="headerlink" title="JNI_OnLoad"></a>JNI_OnLoad</h4><p>so中各种函数的执行时机</p>
<p>init、init_array、JNI_OnLoad</p>
<p>JNI_OnLoad 的执行是比定义的普通函数还要早，init 比 init_array 早， init_array 比 JNI_OnLoad 早</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241128200003818.png" alt="image-20241128200003818"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这两个参数是固定的，第一个JavaVM是一个结构体，第二个暂时没啥用</span></span><br><span class="line"><span class="comment">// 返回值类型是JNI版本</span></span><br><span class="line">JNIEXPORT jint <span class="title function_">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="keyword">void</span> *reserved)</span> &#123;</span><br><span class="line">    JNIEnv *env = nullptr;</span><br><span class="line">    <span class="comment">// JavaVM中有一个方法GetEnv</span></span><br><span class="line">    <span class="keyword">if</span> (vm-&gt;GetEnv((<span class="keyword">void</span> **) &amp;env, JNI_VERSION_1_6) != JNI_OK) &#123;</span><br><span class="line">        LOGD(<span class="string">&quot;getenv failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个so中可以不定义JNI_OnLoad</p>
<p>一旦定义了JNI_OnLoad，在so被加载的时候会自动执行</p>
<p>必须返回JNI版本 JNI_VERSION_1_6，否则报错</p>
</blockquote>
<p>JNIEnv</p>
<p>里面定义了很多的API，创建对象数组什么的，所以需要先获取这个JNIEnv对象，而这个对象的获取就需要用到 JavaVM 这个结构体中的 GetEnv 方法，所以，上面的代码还是很常用的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241128204059608.png" alt="image-20241128204059608"></p>
<p>状态信息，判断是否支持JNI版本</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241128204423521.png" alt="image-20241128204423521"></p>
<h4 id="JavaVM"><a href="#JavaVM" class="headerlink" title="JavaVM"></a>JavaVM</h4><p>结构体，注意这个是C++版本的</p>
<p>东西也不多，一个属性，五个函数</p>
<p>比较常用的只有两个方法，GetEnv 和 AttachCurrentThread 一个是在主线程获得 JNIEnv ，一个是在子线程获得 JNIEnv</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241128204627408.png" alt="image-20241128204627408"></p>
<p>点 DestroyJavaVM 查看C语言版本，其实就在上面翻一下就到了</p>
<p>C++版本只是对C版本的封装，其实还是调用的C中的方法，真正反编译看到的是C语言版本的</p>
<p>注意一下，参数个数是不一样的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241128205145656.png" alt="image-20241128205145656"></p>
<blockquote>
<p>JavaVM的获取</p>
<p>​	JNI_OnLoad 的第一个参数</p>
<p>​	JNI_OnUnload的第一个参数</p>
<p>​	env-&gt;GetJavaVM</p>
<p>​	对比各种方式获取的JavaVM指针是否一致</p>
<p>​		%p 打印地址，地址是一样的</p>
<p>因为 &#x3D;&#x3D;JavaVM每个进程中只有一份&#x3D;&#x3D;（一个地址值）</p>
</blockquote>
<h4 id="JNIEnv"><a href="#JNIEnv" class="headerlink" title="JNIEnv"></a>JNIEnv</h4><p>也是结构体，但是这个很常用</p>
<p>里面定义了很多的API，创建对象数组什么的，所以需要先获取这个JNIEnv对象，而这个对象的获取就需要用到 JavaVM 这个结构体中的 GetEnv 方法，具体的API后面再学，先简单知道有这个东西就好了</p>
<blockquote>
<p>JNIEnv的获取方式</p>
<p>​	函数静态&#x2F;动态注册，传的第一个参数（不光JNIEnv的函数）</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241128211740416.png" alt="image-20241128211740416"></p>
<p>​	vm-&gt;GetEnv</p>
<p>​	globalIVM-&gt;AttachCurrentThread（在子线程中使用的，和上面的同理）</p>
<p>​	主线程和子线程中取得的JNIEnv的地址是不一样的</p>
<p>与JavaVM不同的是，&#x3D;&#x3D;JNIEnv是每个线程中都有一份&#x3D;&#x3D;（每个线程一个地址值）</p>
</blockquote>
<h4 id="so的基本概念"><a href="#so的基本概念" class="headerlink" title="so的基本概念"></a>so的基本概念</h4><p>导出表、导入表</p>
<p>反编译后这个Exports就是导出表，也可以在编写的时候使用hidden这样对应的函数就不会出现在导出表中</p>
<p>导入表在旁边的imports中，是程序依赖的函数</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241129112947458.png" alt="image-20241129112947458"></p>
<p>出现在导出表，导入表中的函数，一般可以通过frida相关的API获取函数地址，也可以自己计算</p>
<p>没有出现在导出表、导入表、符号表中的函数，都需要自己计算函数地址</p>
<p>所谓的符号表就是能看见名字的，都在符号表内，有的名字是IDA自己生成的，这个就需要自己计算，为什么一定要获取函数地址呢，因为So函数的hook需要函数地址</p>
<h3 id="SO函数注册"><a href="#SO函数注册" class="headerlink" title="SO函数注册"></a>SO函数注册</h3><p>有静态注册和动态注册两种方式</p>
<h4 id="JNI函数的静态注册"><a href="#JNI函数的静态注册" class="headerlink" title="JNI函数的静态注册"></a>JNI函数的静态注册</h4><p>静态注册的命名必须遵循一定的命名规则，一般是 Java_包名_类名_方法名</p>
<p>系统会通过dlopen加载对应的so，通过dlsym来获取指定名字的函数地址，然后调用静态注册的jni函数</p>
<p>静态注册的函数必然在导出表内</p>
<h4 id="JNI动态注册"><a href="#JNI动态注册" class="headerlink" title="JNI动态注册"></a>JNI动态注册</h4><blockquote>
<p>通过 env -&gt; RegisterNatives 注册函数，通常在 JNI_OnLoad 中注册</p>
<p>​	RegisterNatives：意思是注册本地</p>
<p>​	JNINativeMethod：指定C函数和Java调用的对应关系</p>
<p>​	函数签名：指定调用哪一个C函数</p>
<p>可以给同一个Java函数注册多个native函数，以最后一次为准</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个FindClass的作用类似于frida的Java.use，也是注册函数传入的第一个参数</span></span><br><span class="line">jclass MainActivityClazz = env-&gt;FindClass(<span class="string">&quot;com/example/demo/test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// JNINativeMethod是一个结构体，分别为 name 函数名，signature 存放函数签名，fnRtr 函数指针</span></span><br><span class="line"><span class="comment">// 这个结构体规定了Java和C函数的对应关系</span></span><br><span class="line"><span class="comment">// JNINativeMethod中是可以注册多个函数的</span></span><br><span class="line"><span class="comment">// 第二个参数 () 内是传入的参数，后面是返回值的类型，因为String是对象，不是基本数据类型，所以需要用 L; 来包围，中间填写对象的具体路径。基本数据类型 int 就用I表示了，byte 数组用 [B</span></span><br><span class="line"><span class="comment">// 第三个参数是指定函数在C层对应的方法</span></span><br><span class="line">JNINativeMethod method[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;stringFromJNI3&quot;</span>, <span class="string">&quot;(Ljava/lang/String;I[B)Ljava/lang/String;&quot;</span>, (<span class="type">void</span> *)test&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// jint其实就是int，是指明注册函数的个数</span></span><br><span class="line"><span class="comment">// jint RegisterNatives(jclass clazz, const JNINativeMethod* method, jint nMethods)</span></span><br><span class="line"><span class="comment">// 最后这个参数可以之间给数字，但是如果在开发中最好计算一下 sizeof(method)/sizeof(JNINativeMethod) 。</span></span><br><span class="line">env-&gt;RegisterNatives(MainActivityClazz, method, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<img src="../图片/image-20241129164315798.png" alt="image-20241129164315798" style="zoom: 50%;" />

<p>完整代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个时候就可以自定义方法名了，传参什么的不能少</span></span><br><span class="line">jstring <span class="title function_">test</span><span class="params">(JNIEnv* env, jobject that, jstring a, jint b, jbyteArray c)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> env-&gt;NewStringUTF(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在JNI_OnLoad中进行 env-&gt;RegisterNatives 的动态注册</span></span><br><span class="line">JNIEXPORT jint <span class="title function_">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="type">void</span> *reserved)</span> &#123;</span><br><span class="line">	JNIEnv *env = nullptr;</span><br><span class="line">	<span class="keyword">if</span> (vm-&gt;GetEnv((<span class="type">void</span> **) &amp;env, JNI_VERSION_1_6) != JNI_OK) &#123;</span><br><span class="line">		LOGD(<span class="string">&quot;getenv failed&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> 	jclass MainActivityClazz = env-&gt;FindClass(<span class="string">&quot;com/example/demo/test&quot;</span>);</span><br><span class="line"> 	JNINativeMethod method[] = &#123;</span><br><span class="line">     	&#123;<span class="string">&quot;stringFromJNI3&quot;</span>, <span class="string">&quot;(Ljava/lang/String;I[B)Ljava/lang/String;&quot;</span>, (<span class="type">void</span> *)test&#125;</span><br><span class="line"> 	&#125;;</span><br><span class="line"> 	<span class="comment">// jint RegisterNatives(jclass clazz, const JNINativeMethod* method, jint nMethods)</span></span><br><span class="line"> env-&gt;RegisterNatives(MainActivityClazz, method, <span class="keyword">sizeof</span>(method)/<span class="keyword">sizeof</span>(JNINativeMethod));</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">return</span> JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;native-lib&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">stringFromJNI3</span><span class="params">(String a, <span class="type">int</span> b, <span class="type">byte</span>[] c)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果有重名的调用的是后面的，以最后一个为准。如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">JNINativeMethod method[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;stringFromJNI3&quot;</span>, <span class="string">&quot;(Ljava/lang/String;IB)Ljava/lang/String;&quot;</span>, (<span class="type">void</span> *)test&#125;;</span><br><span class="line">    &#123;<span class="string">&quot;stringFromJNI3&quot;</span>, <span class="string">&quot;(Ljava/lang/String;IB)Ljava/lang/String;&quot;</span>, (<span class="type">void</span> *)test0x1&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个时候在Java端调用 stringFromJNI3 时，执行的C函数是 test0x1</p>
<h3 id="SO之间的相互调用"><a href="#SO之间的相互调用" class="headerlink" title="SO之间的相互调用"></a>SO之间的相互调用</h3><h4 id="多个cpp编译成一个so文件"><a href="#多个cpp编译成一个so文件" class="headerlink" title="多个cpp编译成一个so文件"></a>多个cpp编译成一个so文件</h4><p>创建一个c的源文件，将要编译成一个so文件的cpp写在配置文件中</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241202202608155.png" alt="image-20241202202608155"></p>
<p>调用另一个cpp中的方法时，不需要再使用下面的方法调用，省去这个步骤，在前面声明一下方法名，然后在需要调用的时候直接函数名调用即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241202203340209.png" alt="image-20241202203340209"></p>
<p>测试成功，只有一个so，且可以正常使用cpp内的方法</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241202202406481.png" alt="image-20241202202406481"><img src="/../%E5%9B%BE%E7%89%87/image-20241202202457604.png" alt="image-20241202202457604"></p>
<h4 id="编译多个SO"><a href="#编译多个SO" class="headerlink" title="编译多个SO"></a>编译多个SO</h4><p>这个需要的操作用小脑想一下，创建cpp文件，修改CMakeLists文件。最重要的当然是CMakeLists文件。</p>
<p>新加上一个add_library和target_link_libraries</p>
<p>一个值得so的名称和so内的cpp文件，另一个进行链接</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241202204854659.png" alt="image-20241202204854659"></p>
<h4 id="SO路径的动态获取"><a href="#SO路径的动态获取" class="headerlink" title="SO路径的动态获取"></a>SO路径的动态获取</h4><p>so在手机中的data&#x2F;app&#x2F;包名+随机名&#x2F;lib&#x2F;  目录下</p>
<p>包名这个目录后面的数是随机的，每次安装都不一样</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241202210143999.png" alt="image-20241202210143999"></p>
<p>我们需要用代码来找到这个目录中的SO文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个Context是安卓一个常用的对象，里面有很多API</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getPath</span><span class="params">(Context cxt)</span> &#123;</span><br><span class="line">       <span class="comment">// .getPackageManager 得到包管理器</span></span><br><span class="line">       <span class="type">PackageManager</span> <span class="variable">pm</span> <span class="operator">=</span> cxt.getPackageManager();</span><br><span class="line">       <span class="comment">// .getInstalledPackages 获取已经安装的app</span></span><br><span class="line">       List&lt;PackageInfo&gt; pkgList = pm.getInstalledPackages(<span class="number">0</span>);</span><br><span class="line">       <span class="comment">// 过滤</span></span><br><span class="line">       <span class="keyword">if</span> (pkgList == <span class="literal">null</span> || pkgList.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 循环查找</span></span><br><span class="line">       <span class="keyword">for</span> (PackageInfo pi : pkgList) &#123;</span><br><span class="line">           <span class="comment">// .applicationInfo.nativeLibraryDir 就是获取本地so保存的地方</span></span><br><span class="line">           <span class="comment">// 然后判断是 /data/app 开头，内容包含包名的so文件</span></span><br><span class="line">           <span class="keyword">if</span> (pi.applicationInfo.nativeLibraryDir.startsWith(<span class="string">&quot;/data/app/&quot;</span>)</span><br><span class="line">               &amp;&amp; pi.packageName.startsWith(<span class="string">&quot;com.example.demo&quot;</span>)) &#123;</span><br><span class="line">               <span class="keyword">return</span> pi.applicationInfo.nativeLibraryDir;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>Context对象通过 getApplicationContext() 方法来获取，可以看到输出了so所在的路径，但是还差了一个so的名字，自行补充一下就好了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241202212101582.png" alt="image-20241202212101582"></p>
<h4 id="SO的动态调用"><a href="#SO的动态调用" class="headerlink" title="SO的动态调用"></a>SO的动态调用</h4><p>既然已经能够获取到SO的路径了，那么就可以实现so之间的相互调用了</p>
<p>在cpp文件中使用 dlopen 方法来获得</p>
<p>需要给两个参数，一个是SO的文件名，这个地方要给出全路径，一个是指定对SO的操着是立即解析还是懒加载等，常用的是 now和 lazy，RTLD_NOW是立即解析</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241203132351488.png" alt="image-20241203132351488"></p>
<p>注册的时候加上一个这玩意，调用的时候多加一个参数，jstring</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241203133033340.png" alt="image-20241203133033340"></p>
<p>人要的是 char * ，你给的是Java的字符串jstring，需要一个转换</p>
<p>使用 GetStringUTFChars 将 jstring 转换成 cstring，两个参数第一个是Java字符串，第二个是选择是否拷贝，一般用nullptr</p>
<p>然后使用 void* 来接收</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* cPath = env-&gt;GetStringUTFChars(SoPath, nullptr);</span><br><span class="line"><span class="type">void</span>* soInfo = dlopen(cPath, RTLD_NOW);</span><br></pre></td></tr></table></figure>



<p>有了这个 void* 的指针就可以使用 dlsym 函数来获取so文件中的符号，不是cpp文件中的函数名，而是函数名经过符号修饰之后的结果，这个结果可以通过反编译查看，或者使用 extren “C” 修饰函数，如此函数名就不会被修饰。</p>
<p>返回值是一个函数指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先进行一个函数声明，声明一个可以代表任意一个没有返回值和没有参数的函数</span></span><br><span class="line">   <span class="type">void</span> (*ref)();</span><br><span class="line"><span class="comment">// 使用 dlsym 函数获取指定函数名的地址值，然后使用 reinterpret_cast 强转成函数指针，然后就可以直接调用方法了</span></span><br><span class="line">   ref = reinterpret_cast&lt;<span class="type">void</span> (*)()&gt; (dlsym(soInfo ,<span class="string">&quot;_Z4testv&quot;</span>));</span><br><span class="line">   ref();</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241203174733741.png" alt="image-20241203174733741"></p>
<p>调用成功</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241203180532224.png" alt="image-20241203180532224"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241203182405188.png" alt="image-20241203182405188"></p>
<p>这中方式调用so是不用在Java层加载so的，执行代码的时候就自己给加载上了，如果要卸载so使用dlclose 函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dlclose(soInfo);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>SO的动态调用了解一下，逆向的时候可能会碰到。</p>
<p>这个的hook也和普通的不一样，因为这个地址是在一定时间内存在的</p>
</blockquote>
<p>还有一种方式</p>
<p>给需要调用的SO方法 extern ”C“，然后在调用cpp的文件中使用 <code>extern &quot;C&quot; </code> 进行声明</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241203191333495.png" alt="image-20241203191333495"></p>
<h3 id="通过JNI创建Java对象"><a href="#通过JNI创建Java对象" class="headerlink" title="通过JNI创建Java对象"></a>通过JNI创建Java对象</h3><p>在使用so层的方法时，难免需要Java对象，有两种创建Java对象的方式</p>
<h4 id="NewObject"><a href="#NewObject" class="headerlink" title="NewObject"></a>NewObject</h4><p>很像Java中的反射，找类，找方法，调方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// NewObject创建对象，通过FindClass获取相应的类</span></span><br><span class="line">   jclass clazz = env-&gt;FindClass(<span class="string">&quot;com/example/demo/test&quot;</span>);</span><br><span class="line"><span class="comment">// init这个函数名代表构造函数，找到对象的构造方法，这个示例是无参构造</span></span><br><span class="line">   jmethodID methodId = env-&gt;GetMethodID(clazz, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line"><span class="comment">// 获取object对象，如果需要传参数，就从第三个开始</span></span><br><span class="line">   jobject ReflectDemoObj = env-&gt;NewObject(clazz, methodId);</span><br><span class="line">   LOGD(<span class="string">&quot;ReflectDemoObj %p&quot;</span>, ReflectDemoObj);</span><br></pre></td></tr></table></figure>



<p>ReflectDemoObj 是Java中的一个对象，输出的是这个对象在虚拟机中的一个唯一标识</p>
<p>这个地址是在虚拟机内，和外部的内存地址不在一个位置，因为在JNI中需要区分Java的东西和C的东西，本质就是因为存放的位置不一样。所以需要来回的转换</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241203210850623.png" alt="image-20241203210850623"></p>
<h4 id="AllocObject"><a href="#AllocObject" class="headerlink" title="AllocObject"></a>AllocObject</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AllocObject创建对象</span></span><br><span class="line">   jclass jclass1 = env-&gt;FindClass(<span class="string">&quot;com/example/demo/test&quot;</span>);</span><br><span class="line">   jmethodID jmethodId = env-&gt;GetMethodID(clazz, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前两步是一样的，这里 AllocObject 是给函数分配内存，但是不进行初始化，可以看到只传递了类</span></span><br><span class="line">   jobject ReflectDemoObj2 = env-&gt;AllocObject(jclass1);</span><br><span class="line"><span class="comment">// 定义一个字符串</span></span><br><span class="line">   jstring jstr = env-&gt;NewStringUTF(<span class="string">&quot;from jni str&quot;</span>);</span><br><span class="line"><span class="comment">// 进行初始化，传入内存地址，类，构造方法，传入值</span></span><br><span class="line">   env-&gt;CallNonvirtualVoidMethod(ReflectDemoObj2, jclass1, jmethodId, jstr);</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241203212934398.png" alt="image-20241203212934398"></p>
<h3 id="通过JNI访问Java属性"><a href="#通过JNI访问Java属性" class="headerlink" title="通过JNI访问Java属性"></a>通过JNI访问Java属性</h3><p>Java属性分为静态和非静态的，两种属性获取的方法不同</p>
<h4 id="获取静态字段"><a href="#获取静态字段" class="headerlink" title="获取静态字段"></a>获取静态字段</h4><p>使用 <code>GetStatic****Field</code> 来设置非静态字段</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   jclass clazz = env-&gt;FindClass(<span class="string">&quot;com/example/demo/test&quot;</span>);</span><br><span class="line"><span class="comment">// 获取类之后，通过 GetStaticFieldID 函数来获取静态成员的ID， GetFieldID 是获取非静态成员的ID</span></span><br><span class="line"><span class="comment">// 给三个参数，第一个是 jclass ，第二个是字段名，第三个是字段签名（数据类型）</span></span><br><span class="line">   jfieldID privateStaticStringField = </span><br><span class="line">       env-&gt;GetStaticFieldID(clazz, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后使用 GetStatic+数据类型+Field 这个函数来获取字段的具体内容</span></span><br><span class="line"><span class="comment">// 一共是8+1，八个基本数据类型+object</span></span><br><span class="line"><span class="comment">// env-&gt;GetStaticBooleanField();</span></span><br><span class="line"><span class="comment">// env-&gt;GetStaticIntField();</span></span><br><span class="line"><span class="comment">// env-&gt;GetStaticShortField();</span></span><br><span class="line"><span class="comment">// env-&gt;GetStaticByteField();</span></span><br><span class="line"><span class="comment">// env-&gt;GetStaticCharField();</span></span><br><span class="line"><span class="comment">// env-&gt;GetStaticFloatField();</span></span><br><span class="line"><span class="comment">// env-&gt;GetStaticDoubleField();</span></span><br><span class="line"><span class="comment">// env-&gt;GetStaticLongField();</span></span><br><span class="line"><span class="comment">// env-&gt;GetStaticObjectField();</span></span><br><span class="line"><span class="comment">// 已知是字符串的情况下，可以直接强转从object转成字符串</span></span><br><span class="line"><span class="comment">// 根据类名和字段名以及数据类型可以找到这个静态字段，但是注意，这个时候的age还是在虚拟机中，是Java的字符串，需要进行一个转换</span></span><br><span class="line">   jstring age = </span><br><span class="line">       static_cast&lt;jstring&gt; (env-&gt;GetStaticObjectField(clazz, privateStaticStringField));</span><br><span class="line"><span class="comment">// 将Java字符串转换成C字符串</span></span><br><span class="line">   <span class="type">const</span> <span class="type">char</span>* privatecstr = env-&gt;GetStringUTFChars(age, nullptr);</span><br><span class="line">   LOGD(<span class="string">&quot;age: %s&quot;</span>, age);</span><br><span class="line"><span class="comment">// 使用完毕后需要释放内存</span></span><br><span class="line">   env-&gt;ReleaseStringUTFChars(age, privatecstr);</span><br></pre></td></tr></table></figure>



<h4 id="获取对象字段"><a href="#获取对象字段" class="headerlink" title="获取对象字段"></a>获取对象字段</h4><p>这个和获取静态字段大差不差，就几个函数不一样</p>
<p>使用 <code>Get****Field</code> 来获取非静态字段</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   jclass clazz = env-&gt;FindClass(<span class="string">&quot;com/example/demo/test&quot;</span>);</span><br><span class="line">   jmethodID methodId = env-&gt;GetMethodID(clazz, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">   jobject ReflectDemoObj = env-&gt;NewObject(clazz, methodId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面创建实例化对象，非静态的东西用之前new一下很合理吧</span></span><br><span class="line">   jfieldID nameID = env-&gt;GetFieldID(clazz, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line"><span class="comment">// 除了API上没有static之外，只有这里，传入的是实例化之后的对象，其他的都和上面的差不多</span></span><br><span class="line">   jstring name = static_cast&lt;jstring&gt; (env-&gt;GetObjectField(ReflectDemoObj, nameID));</span><br><span class="line">   <span class="type">const</span> <span class="type">char</span>* nameContent = env-&gt;GetStringUTFChars(name, nullptr);</span><br><span class="line">   LOGD(<span class="string">&quot;name: %s&quot;</span>, nameContent);</span><br><span class="line">   env-&gt;ReleaseStringUTFChars(name, nameContent);</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20241204114753473.png" alt="image-20241204114753473"></p>
<h4 id="设置非静态字段"><a href="#设置非静态字段" class="headerlink" title="设置非静态字段"></a>设置非静态字段</h4><p>使用 <code>Set****Field</code> 来设置非静态字段</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   jclass clazz = env-&gt;FindClass(<span class="string">&quot;com/example/demo/test&quot;</span>);</span><br><span class="line">   jmethodID methodId = env-&gt;GetMethodID(clazz, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">   jobject ReflectDemoObj = env-&gt;NewObject(clazz, methodId);   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取对象字段</span></span><br><span class="line">   jfieldID nameID = env-&gt;GetFieldID(clazz, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line">   jstring name = static_cast&lt;jstring&gt; (env-&gt;GetObjectField(ReflectDemoObj, nameID));</span><br><span class="line">   <span class="type">const</span> <span class="type">char</span>* nameContent = env-&gt;GetStringUTFChars(name, nullptr);</span><br><span class="line">   LOGD(<span class="string">&quot;name: %s&quot;</span>, nameContent);</span><br><span class="line">   env-&gt;ReleaseStringUTFChars(name, nameContent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置非静态字段</span></span><br><span class="line"><span class="comment">// 直接使用 SetObjectField 来更改字段，传入的是实例化之后的对象和要更改的字段ID，以及要更改为的数据</span></span><br><span class="line">   env-&gt;SetObjectField(ReflectDemoObj, nameID, env-&gt;NewStringUTF(<span class="string">&quot;呓语&quot;</span>));</span><br><span class="line"><span class="comment">// 重新获取Java类型的数据</span></span><br><span class="line">   name = static_cast&lt;jstring&gt; (env-&gt;GetObjectField(ReflectDemoObj, nameID));</span><br><span class="line"><span class="comment">// 将Java类型的数据转换成C类型输出</span></span><br><span class="line">   nameContent = env-&gt;GetStringUTFChars(name, nullptr);</span><br><span class="line">   LOGD(<span class="string">&quot;name new: %s&quot;</span>, nameContent);</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241204172804519.png" alt="image-20241204172804519"></p>
<h3 id="通过JNI访问Java数组"><a href="#通过JNI访问Java数组" class="headerlink" title="通过JNI访问Java数组"></a>通过JNI访问Java数组</h3><h4 id="获取数组"><a href="#获取数组" class="headerlink" title="获取数组"></a>获取数组</h4><p>通过 <code>Get****ArrayElements</code> 获取数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   jclass clazz = env-&gt;FindClass(<span class="string">&quot;com/example/demo/test&quot;</span>);</span><br><span class="line">   jmethodID methodId = env-&gt;GetMethodID(clazz, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">   jobject ReflectDemoObj = env-&gt;NewObject(clazz, methodId);   </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取数组字段ID，同字段ID的获取方式一样</span></span><br><span class="line">   jfieldID byteArrayID = env-&gt;GetFieldID(clazz, <span class="string">&quot;byteArray&quot;</span>, <span class="string">&quot;[B&quot;</span>);</span><br><span class="line"><span class="comment">// 这里也是获取数组内容，使用Object来接收，然后再转换成jbyteArray的类型</span></span><br><span class="line">   jbyteArray byteArray1 = </span><br><span class="line">       static_cast&lt;jbyteArray&gt; (env-&gt;GetObjectField(ReflectDemoObj, byteArrayID));</span><br><span class="line"><span class="comment">// 使用 GetArrayLength 方法获取数组的长度</span></span><br><span class="line">   <span class="type">int</span> _byteArrayLength = env-&gt;GetArrayLength(byteArray1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个时候还不能直接遍历数组，需要一个转换，将Java类型的数据转换成 jbyte*</span></span><br><span class="line"><span class="comment">// 不光是 byte数组，其他数组遍历的时候也需要一个转换，对应的api为 Get+类型+ArrayElements。一共九个</span></span><br><span class="line">   jbyte* cByte = env-&gt;GetByteArrayElements(byteArray1, nullptr);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _byteArrayLength; i++) &#123;</span><br><span class="line">       LOGD(<span class="string">&quot;byteArray: %d&quot;</span>, cByte[i])</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line">env-&gt;ReleaseByteArrayElements(byteArray1, cByte, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241204174959021.png" alt="image-20241204174959021"></p>
<h4 id="修改数组"><a href="#修改数组" class="headerlink" title="修改数组"></a>修改数组</h4><p>通过 <code>Get****ArrayRegion</code> 修改数组内容，Region是一次性设置完成，即使是数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 修改数组</span></span><br><span class="line"><span class="comment">// 先创建一个C的数组，C的char相当于Java的byte </span></span><br><span class="line">   <span class="type">char</span> javaByte[<span class="number">10</span>];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">       javaByte[i] = static_cast&lt;<span class="type">char</span>&gt;(<span class="number">100</span>-i);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 将这个char数组转换成jbyte的类型</span></span><br><span class="line">   <span class="type">const</span> jbyte *java_array = reinterpret_cast&lt;<span class="type">const</span> jbyte*&gt;(javaByte);</span><br><span class="line"><span class="comment">// 使用 Region 的这一套API进行数组的修改</span></span><br><span class="line">   env-&gt;SetByteArrayRegion(byteArray1, <span class="number">0</span>, _byteArrayLength, java_array);</span><br><span class="line"><span class="comment">// 修改完之后，可以重新获取数组来遍历</span></span><br><span class="line">   byteArray1 = </span><br><span class="line">       static_cast&lt;jbyteArray&gt; (env-&gt;GetObjectField(ReflectDemoObj, byteArrayID));</span><br><span class="line">   cByte = env-&gt;GetByteArrayElements(byteArray1, nullptr);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _byteArrayLength; i++) &#123;</span><br><span class="line">       LOGD(<span class="string">&quot;byteArray: %d&quot;</span>, cByte[i])</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241204180039225.png" alt="image-20241204180039225"></p>
<h3 id="通过JNI来访问Java方法"><a href="#通过JNI来访问Java方法" class="headerlink" title="通过JNI来访问Java方法"></a>通过JNI来访问Java方法</h3><h4 id="调用静态函数"><a href="#调用静态函数" class="headerlink" title="调用静态函数"></a>调用静态函数</h4><p>调用静态函数的API和使用构造方法的API相似，但是不一样</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 调用静态函数</span></span><br><span class="line"><span class="comment">// 创建类</span></span><br><span class="line">   jclass clazz = env-&gt;FindClass(<span class="string">&quot;com/example/demo/test&quot;</span>);</span><br><span class="line"><span class="comment">// 构造方法使用 NewObject 或者 AllocObject 两个API来找到方法，其他的函数就不一样了，是 GetStaticMethodID</span></span><br><span class="line">   jmethodID staticFunID = env-&gt;GetStaticMethodID(clazz, <span class="string">&quot;StaticFunction&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line"><span class="comment">// 找到这个方法ID之后，使用 Call 系列的API CallStatic+返回值类型+Method，这个组合API有十个</span></span><br><span class="line">   env-&gt;CallStaticVoidMethod(clazz, staticFunID);</span><br></pre></td></tr></table></figure>



<h4 id="调用对象函数"><a href="#调用对象函数" class="headerlink" title="调用对象函数"></a>调用对象函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 调用对象函数</span></span><br><span class="line"><span class="comment">// 找到对象函数的方法ID</span></span><br><span class="line">   jmethodID FunID =</span><br><span class="line">           env-&gt;GetMethodID(clazz, <span class="string">&quot;functional&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</span>);</span><br><span class="line">   jstring str = env-&gt;NewStringUTF(<span class="string">&quot;this is from JNI&quot;</span>);</span><br><span class="line"><span class="comment">// 因为是对象函数调用需要一个实例化对象，使用前面已经创建过的实例化对象 ReflectDemoObj，然后传入方法ID和方法参数，因为返回值是String，将Object转换成string</span></span><br><span class="line">   jstring str2 = reinterpret_cast&lt;jstring&gt;(static_cast&lt;jstring&gt; (env-&gt;CallObjectMethod(ReflectDemoObj, FunID, str)));</span><br><span class="line"><span class="comment">// 将返回值的Java类型的字符串转换成C中的char*字符串</span></span><br><span class="line">   <span class="type">const</span> <span class="type">char</span>* retval_cstr = env-&gt;GetStringUTFChars(str2, nullptr);</span><br><span class="line">   LOGD(<span class="string">&quot;retval_cstr: %s&quot;</span>, retval_cstr);</span><br><span class="line">   env-&gt;ReleaseStringUTFChars(str2,retval_cstr);</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20241204191017506.png" alt="image-20241204191017506"></p>
<h4 id="CallObjectMethodA"><a href="#CallObjectMethodA" class="headerlink" title="CallObjectMethodA"></a>CallObjectMethodA</h4><p>CallObjectMethod这个API是用来调用执行函数的，同系列的还有 CallObjectMethodA 和 CallObjectMethodV</p>
<p>CallObjectMethod 执行的时候调用了 CallObjectMethodV，也就是说 CallObjectMethod 可以完美替代 CallObjectMethodV 在调用的时候的使用了，因为 CallObjectMethod 支持接收多个参数，如果不使用 CallObjectMethod 还得自行处理参数，传入 CallObjectMethodV</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241204191718523.png" alt="image-20241204191718523"></p>
<p>CallObjectMethodA 的使用需要传入一个 jvalue，这个jvalue是一个联合体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">jvalue</span> &#123;</span></span><br><span class="line">    jboolean    z;</span><br><span class="line">    jbyte       b;</span><br><span class="line">    jchar       c;</span><br><span class="line">    jshort      s;</span><br><span class="line">    jint        i;</span><br><span class="line">    jlong       j;</span><br><span class="line">    jfloat      f;</span><br><span class="line">    jdouble     d;</span><br><span class="line">    jobject     l;</span><br><span class="line">&#125; jvalue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后面的字母代表数据类型的简写，定义参数的时候可以使用以下方式</span></span><br><span class="line">jvalue args[<span class="number">3</span>];</span><br><span class="line">args[<span class="number">0</span>].i = <span class="number">100</span>;</span><br><span class="line">args[<span class="number">1</span>].c = str2;</span><br><span class="line">args[<span class="number">2</span>].z = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>



<h4 id="传递数组作为参数"><a href="#传递数组作为参数" class="headerlink" title="传递数组作为参数"></a>传递数组作为参数</h4><p>稍微升级一下，调用传入值为数组，返回值也是数组的方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 传入数组参数</span></span><br><span class="line"><span class="comment">// 先创建一个字符串数组</span></span><br><span class="line"><span class="comment">// 下面的操作就相当于Java中</span></span><br><span class="line"><span class="comment">// String StringArr[] = new String[3]</span></span><br><span class="line"><span class="comment">// for (int i = 0; i &lt; 3; i++) &#123;</span></span><br><span class="line"><span class="comment">//    StringArr[i] = &quot;NB666&quot;;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">   jclass StringClazz = env-&gt;FindClass(<span class="string">&quot;java/lang/String&quot;</span>);</span><br><span class="line">   jobjectArray StringArr = env-&gt;NewObjectArray(<span class="number">3</span>, StringClazz, nullptr);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">       env-&gt;SetObjectArrayElement(StringArr, i, env-&gt;NewStringUTF(<span class="string">&quot;NB666&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法ID GetStaticMethodID</span></span><br><span class="line">   jmethodID StringArrayID =</span><br><span class="line">           env-&gt;GetStaticMethodID(clazz, <span class="string">&quot;functionTest&quot;</span>, <span class="string">&quot;([Ljava/lang/String;)[I&quot;</span>);</span><br><span class="line"><span class="comment">// 执行函数，使用 jintArray 接收返回值，对返回值进行强转</span></span><br><span class="line">   jintArray jint = static_cast&lt;jintArray&gt;</span><br><span class="line">           (env-&gt;CallStaticObjectMethod(clazz, StringArrayID, StringArr));</span><br><span class="line"><span class="comment">// 处理返回值，将Java的数组转换成C的数组</span></span><br><span class="line">   <span class="type">int</span> *cinArr = env-&gt;GetIntArrayElements(jint, nullptr);</span><br><span class="line">   LOGD(<span class="string">&quot;cintArr[0]=%d&quot;</span>, cinArr[<span class="number">0</span>]);</span><br><span class="line">   env-&gt;ReleaseIntArrayElements(jint, cinArr, JNI_ABORT);</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241204201627997.png" alt="image-20241204201627997"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">jstring <span class="title function_">demoHelloWorld</span><span class="params">(JNIEnv* env, jobject that, jstring a, jint b, jbyteArray c)</span> &#123;</span><br><span class="line">    <span class="comment">// NewObject创建对象</span></span><br><span class="line">    jclass clazz = env-&gt;FindClass(<span class="string">&quot;com/example/demo/test&quot;</span>);</span><br><span class="line">    jmethodID methodId = env-&gt;GetMethodID(clazz, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">    jobject ReflectDemoObj = env-&gt;NewObject(clazz, methodId);</span><br><span class="line">    LOGD(<span class="string">&quot;ReflectDemoObj %p&quot;</span>, ReflectDemoObj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AllocObject创建对象</span></span><br><span class="line">    jclass jclass1 = env-&gt;FindClass(<span class="string">&quot;com/example/demo/test&quot;</span>);</span><br><span class="line">    jmethodID jmethodId = env-&gt;GetMethodID(clazz, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">    jobject ReflectDemoObj2 = env-&gt;AllocObject(jclass1);</span><br><span class="line">    jstring jstr = env-&gt;NewStringUTF(<span class="string">&quot;from jni str&quot;</span>);</span><br><span class="line">    env-&gt;CallNonvirtualVoidMethod(ReflectDemoObj2, jclass1, jmethodId, jstr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取静态字段</span></span><br><span class="line">    jfieldID privateStaticStringField = env-&gt;GetStaticFieldID(clazz, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line">    jstring age = static_cast&lt;jstring&gt; (env-&gt;GetStaticObjectField(clazz, privateStaticStringField));</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* privatecstr = env-&gt;GetStringUTFChars(age, nullptr);</span><br><span class="line">    LOGD(<span class="string">&quot;age: %s&quot;</span>, privatecstr);</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(age, privatecstr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对象字段</span></span><br><span class="line">    jfieldID nameID = env-&gt;GetFieldID(clazz, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line">    jstring name = static_cast&lt;jstring&gt; (env-&gt;GetObjectField(ReflectDemoObj, nameID));</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* nameContent = env-&gt;GetStringUTFChars(name, nullptr);</span><br><span class="line">    LOGD(<span class="string">&quot;name: %s&quot;</span>, nameContent);</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(name, nameContent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置非静态字段</span></span><br><span class="line">    env-&gt;SetObjectField(ReflectDemoObj, nameID, env-&gt;NewStringUTF(<span class="string">&quot;呓语&quot;</span>));</span><br><span class="line">    name = static_cast&lt;jstring&gt; (env-&gt;GetObjectField(ReflectDemoObj, nameID));</span><br><span class="line">    nameContent = env-&gt;GetStringUTFChars(name, nullptr);</span><br><span class="line">    LOGD(<span class="string">&quot;name new: %s&quot;</span>, nameContent);</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(name, nameContent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数组字段ID</span></span><br><span class="line">    jfieldID byteArrayID = env-&gt;GetFieldID(clazz, <span class="string">&quot;byteArray&quot;</span>, <span class="string">&quot;[B&quot;</span>);</span><br><span class="line">    jbyteArray byteArray1 = static_cast&lt;jbyteArray&gt; (env-&gt;GetObjectField(ReflectDemoObj, byteArrayID));</span><br><span class="line">    <span class="type">int</span> _byteArrayLength = env-&gt;GetArrayLength(byteArray1);</span><br><span class="line"></span><br><span class="line">    jbyte* cByte = env-&gt;GetByteArrayElements(byteArray1, nullptr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _byteArrayLength; i++) &#123;</span><br><span class="line">        LOGD(<span class="string">&quot;byteArray: %d&quot;</span>, cByte[i])</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;ReleaseByteArrayElements(byteArray1, cByte, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改数组</span></span><br><span class="line">    <span class="type">char</span> javaByte[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        javaByte[i] = static_cast&lt;<span class="type">char</span>&gt;(<span class="number">100</span>-i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> jbyte *java_array = reinterpret_cast&lt;<span class="type">const</span> jbyte*&gt;(javaByte);</span><br><span class="line">    env-&gt;SetByteArrayRegion(byteArray1, <span class="number">0</span>, _byteArrayLength, java_array);</span><br><span class="line"></span><br><span class="line">    byteArray1 = static_cast&lt;jbyteArray&gt; (env-&gt;GetObjectField(ReflectDemoObj, byteArrayID));</span><br><span class="line">    cByte = env-&gt;GetByteArrayElements(byteArray1, nullptr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _byteArrayLength; i++) &#123;</span><br><span class="line">        LOGD(<span class="string">&quot;byteArray: %d&quot;</span>, cByte[i])</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;ReleaseByteArrayElements(byteArray1, cByte, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用静态函数</span></span><br><span class="line">    jmethodID staticFunID = env-&gt;GetStaticMethodID(clazz, <span class="string">&quot;StaticFunction&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">    env-&gt;CallStaticVoidMethod(clazz, staticFunID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用对象函数</span></span><br><span class="line">    jmethodID FunID =</span><br><span class="line">            env-&gt;GetMethodID(clazz, <span class="string">&quot;functional&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;</span>);</span><br><span class="line">    jstring str = env-&gt;NewStringUTF(<span class="string">&quot;this is from JNI&quot;</span>);</span><br><span class="line">    jstring str2 = reinterpret_cast&lt;jstring&gt;(static_cast&lt;jstring&gt;</span><br><span class="line">            (env-&gt;CallObjectMethod(ReflectDemoObj, FunID, str)));</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* retval_cstr = env-&gt;GetStringUTFChars(str2, nullptr);</span><br><span class="line">    LOGD(<span class="string">&quot;retval_cstr: %s&quot;</span>, retval_cstr);</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(str2,retval_cstr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入数组参数</span></span><br><span class="line">    jclass StringClazz = env-&gt;FindClass(<span class="string">&quot;java/lang/String&quot;</span>);</span><br><span class="line">    jobjectArray StringArr = env-&gt;NewObjectArray(<span class="number">3</span>,StringClazz, nullptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        env-&gt;SetObjectArrayElement(StringArr, i, env-&gt;NewStringUTF(<span class="string">&quot;NB666&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    jmethodID StringArrayID =</span><br><span class="line">            env-&gt;GetStaticMethodID(clazz, <span class="string">&quot;functionTest&quot;</span>, <span class="string">&quot;([Ljava/lang/String;)[I&quot;</span>);</span><br><span class="line">    jintArray jint = static_cast&lt;jintArray&gt;</span><br><span class="line">            (env-&gt;CallStaticObjectMethod(clazz, StringArrayID, StringArr));</span><br><span class="line">    <span class="type">int</span> *cinArr = env-&gt;GetIntArrayElements(jint, nullptr);</span><br><span class="line">    LOGD(<span class="string">&quot;cintArr[0]=%d&quot;</span>, cinArr[<span class="number">0</span>]);</span><br><span class="line">    env-&gt;ReleaseIntArrayElements(jint, cinArr, JNI_ABORT);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="通过JNI访问Java父类方法"><a href="#通过JNI访问Java父类方法" class="headerlink" title="通过JNI访问Java父类方法"></a>通过JNI访问Java父类方法</h3><p>在Java中使用 super 来访问父类中的方法，现在就需要在CPP文件中实现类似的操作，就需要使用CallNonvirtual 系列的API</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241205085226582.png" alt="image-20241205085226582"></p>
<p>先获取到调用的onCreate方法的父类，jclass，然后找到需要调用的父类方法的ID，再传入参数，参数是从Java层传过来的，直接放进去即可，这样就实现了一个简单的调用父类方法。</p>
<p>也可以看出要将Java代码使用JNI转换成c代码还是很费事的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="type">void</span> JNICALL</span><br><span class="line"><span class="title function_">Java_com_example_demo_MainActivity_onCreates</span><span class="params">(JNIEnv *env, jobject thiz,</span></span><br><span class="line"><span class="params">                                             jobject saved_instance_state)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement onCreates()</span></span><br><span class="line">    jclass fragmentClass = env-&gt;FindClass(<span class="string">&quot;androidx/fragment/app/FragmentActivity&quot;</span>);</span><br><span class="line">    jmethodID onCreateID = env-&gt;GetMethodID(fragmentClass, <span class="string">&quot;onCreate&quot;</span>, <span class="string">&quot;(Landroid/os/Bundle;)V&quot;</span>);</span><br><span class="line">    env-&gt;CallNonvirtualVoidMethod(thiz,fragmentClass ,onCreateID, saved_instance_state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>之前使用的 ReleaseIntArrayElements、ReleaseStringUTFChars 等方法也算是一种吧，这里主要介绍的是局部引用和全局引用的相关API</p>
<h4 id="局部引用"><a href="#局部引用" class="headerlink" title="局部引用"></a>局部引用</h4><p>之前创建的 jclass、jmethodID、jstring 什么的就是一个局部引用，在函数运行完毕后消失，看起来和局部变量是差不多的，但是不一样的。可以用全局变量来实验一下</p>
<p>IDE也没有报错，运行直接崩溃了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241205103603926.png" alt="image-20241205103603926"></p>
<p>在函数中使用JNI函数，在函数执行完毕之后全部进行回收，不管是不是全局变量还是局部变量，也就是因为JNI_OnLoad函数执行完毕之后，clazz被回收了，所有在 demoHelloWorld 函数中没有获得正确的 clazz。这也就是局部引用和局部变量、全局变量的区别</p>
<blockquote>
<p>大多数的jni函数，调用以后返回的结果都是局部引用</p>
<p>因此，env-&gt;NewLocalRef（创建一个局部引用） 基本不用</p>
<p>一个函数内的局部引用数量是有限制的，在早期的安卓系统中，十分的明显，现在基本够用，因此可能不太会见到这几个函数，早期的时候的so可能会有</p>
<p>当函数体内需要大量使用局部引用时，比如大循环中，最好及时删除不用的局部引用</p>
<p>可以使用env-&gt;DeleteLocalRef 来删除局部引用</p>
</blockquote>
<p>局部引用还有一些函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">env-&gt;EnsureLocalCapacity(num)</span><br><span class="line">// 判断是否有足够的局部引用可以使用，足够则返回0</span><br><span class="line"></span><br><span class="line">需要大量使用局部引用时，手动删除太过麻烦，可以使用下面两个函数来批量管理局部引用</span><br><span class="line">env-&gt;PushLocalFrame(num)</span><br><span class="line">env-&gt;PopLocalFrame(nullptr)</span><br></pre></td></tr></table></figure>



<h4 id="全局引用"><a href="#全局引用" class="headerlink" title="全局引用"></a>全局引用</h4><p>在jni开发中，需要跨函数使用变量时，直接定义全局变量是没啥用的，需要两个方法，来创建、删除全局引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">env-&gt;NewGlobalRef</span><br><span class="line">env-&gt;DeleteGlobalRef</span><br></pre></td></tr></table></figure>



<p>env-&gt;NewGlobalRef 是创建全局引用，需要传入一个 jobject ，然后返回一个jobject</p>
<p>现在就可以正常运行了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241205110707267.png" alt="image-20241205110707267"></p>
<p>全局引用使用完毕之后使用 env-&gt;DeleteGlobalRef 删除</p>
<p>还有两个函数，是弱全局引用，什么叫弱全局引用呢，就是内存充足的时候就是全局引用，内存紧张的时候，可能会被回收。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">env-&gt;NewWeakGlobalRef</span><br><span class="line">env-&gt;DeleteWeakGlobalRef</span><br></pre></td></tr></table></figure>



<h3 id="子线程中获取Java类"><a href="#子线程中获取Java类" class="headerlink" title="子线程中获取Java类"></a>子线程中获取Java类</h3><p>常规的手段在子线程中是不能获取到Java类的，获取值为nullptr。获取方法会导致系统崩溃</p>
<p>但是可以使用FindClass来获取系统类，可以看到自己的Java类是没有获取到地址的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241205112914772.png" alt="image-20241205112914772"></p>
<p>如果想在子线程中获取自己定义的类，也是可以的，可以用到全局引用，在主线程中获取类，使用全局引用来传递到子线程中去。</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241205135936157.png" alt="image-20241205135936157"></p>
<p>还有一种方式就是，在主线程中获取正确的ClassLoader，在子线程中去加载类</p>
<p>之前在Java学习过程中，出现了一些方法已经加载，但是无法hook的情况，那是因为不在同一个 ClassLoader 中，C可以先获取到对应方法所在的 ClassLoader，将ClassLoader给到子线程</p>
<blockquote>
<p>在Java中想要获取ClassLoader，可以先获取类字节码，然后时候 getClassLoader() 来获取</p>
<p>​	Demo.class.getClassLoader();</p>
<p>​	new Demo().getClassLoader();</p>
<p>​	Class.forName(……).getClassLoader();</p>
<p>这三种方法，多少跟反射沾点边，其实FindClass就相当于Demo.class</p>
<p>这个时候只需要在主线程中调用一下getClassLoader() 然后在子线程中调用 loadClass() 就ojbk了</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">在JNI_OnLoad中</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这些操作就相当于 Demo.class.getClassLoader()</span></span><br><span class="line">    <span class="comment">// 然后将返回的 jobject 设置为全局引用，在子线程中引用</span></span><br><span class="line">    jclass text = env-&gt;FindClass(<span class="string">&quot;com/example/demo/test&quot;</span>);</span><br><span class="line">    clazz = static_cast&lt;jclass&gt; (env-&gt;NewGlobalRef(text));</span><br><span class="line"></span><br><span class="line">    jclass javaClass = env-&gt;FindClass(<span class="string">&quot;java/lang/Class&quot;</span>);</span><br><span class="line">    jmethodID jmethodId = env-&gt;GetMethodID(javaClass, <span class="string">&quot;getClassLoader&quot;</span>, <span class="string">&quot;()Ljava/lang/ClassLoader;&quot;</span>);</span><br><span class="line">    jobject obj = env-&gt;CallObjectMethod(text, jmethodId);</span><br><span class="line">    object1 = env-&gt;NewGlobalRef(obj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在子线程中</span><br><span class="line">    </span><br><span class="line">    jclass ClassLoaderClazz = env-&gt;FindClass(<span class="string">&quot;java/lang/ClassLoader&quot;</span>);</span><br><span class="line">    jmethodID loadClassID = env-&gt;GetMethodID(ClassLoaderClazz, <span class="string">&quot;loadClass&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)Ljava/lang/Class;&quot;</span>);</span><br><span class="line">	<span class="comment">// 主要传到Java的字符串包名分割不少/，而是.</span></span><br><span class="line">    jclass test = static_cast&lt;jclass&gt; (env-&gt;CallObjectMethod(object1, loadClassID, env-&gt;NewStringUTF(<span class="string">&quot;com.example.demo.test&quot;</span>)));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 上面的操作就相当于 .loadClass(&quot;com.example.demo.test&quot;)</span></span><br><span class="line">    <span class="comment">// 上面那么多代码，就相当于在Java中写</span></span><br><span class="line">	<span class="comment">// test.class.getClassLoader().loadClass(&quot;com.example.demo.test&quot;);</span></span><br><span class="line">	<span class="comment">// 获取到这个类之后就可以进行一些其他的操作了</span></span><br><span class="line">    jmethodID jmethodId = </span><br><span class="line">        env-&gt;GetStaticMethodID(test, <span class="string">&quot;functionTest&quot;</span>, <span class="string">&quot;([Ljava/lang/String;)[I&quot;</span>);</span><br><span class="line">    LOGD(<span class="string">&quot;myThread jmthodID: %p&quot;</span>, jmethodId);</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241205153112644.png" alt="image-20241205153112644"></p>
<blockquote>
<p>这种方法挺麻烦的，不如 在主线程中获取类，使用全局引用来传递到子线程中来的方便，如果系统类在子线程中 findClass 更好。所以只做了解</p>
</blockquote>
<h3 id="init与initarray"><a href="#init与initarray" class="headerlink" title="init与initarray"></a>init与initarray</h3><p>JNI_OnLoad 在其他函数执行之前执行，还有俩个执行的时机比他早，一个是init，一个是initarray</p>
<p>init和initarray的存在就是处理so的加固解密什么的</p>
<h4 id="init定义"><a href="#init定义" class="headerlink" title="init定义"></a>init定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> _init() &#123;</span><br><span class="line">	<span class="comment">// 函数名必须为 _init，在C++中需要extern &quot;C&quot; 来防止修饰</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="initarray定义"><a href="#initarray定义" class="headerlink" title="initarray定义"></a>initarray定义</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__attribute__ ((constructor)) <span class="type">void</span> <span class="title function_">initArrayTest1</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>



<p>init函数定义只能是这一个，名字为 <code>_init</code> ，而initarray可以有多个，如果 <code>constructor</code> 后面不指定数字的话，就按照在cpp文件中的前后顺序执行，指定数字之后按照数字从小到大执行，不写数字的在带有数字的执行完毕之后执行，不建议使用 0-100，这些系统可能会用。这些执行完毕之后再执行 <code>JNI_OnLoad</code> </p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241206103125764.png" alt="image-20241206103125764"></p>
<p>可以加上一个 hidden 属性，这样so反编译的时候，这个函数就不会出现</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241206104625809.png" alt="image-20241206104625809"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241206104913974.png" alt="image-20241206104913974"></p>
<p>在 IDA View-A 中使用快捷键 ctrl +S，找到这个 .init_array</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241206105000980.png" alt="image-20241206105000980"></p>
<p>可以看到有这三个函数，按照给定的顺序排列执行，2被隐藏了，函数名无法解析，IDA就给自动生成了一个名字，sub_+函数地址</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241206105208277.png" alt="image-20241206105208277"></p>
<p>这个函数地址其实是这个函数在So中的偏移量，一般so中的hook都是hook地址，很少hook函数名，因为符号会被各种的修饰，去除，但是地址值是不变的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241206105419586.png" alt="image-20241206105419586"></p>
<p><code>_init</code> 编译之后，符号会变为 <code>.init_proc</code>，但是定义的时候必须是 <code>_init</code></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241206105651028.png" alt="image-20241206105651028"></p>
<h3 id="onCreate函数native化"><a href="#onCreate函数native化" class="headerlink" title="onCreate函数native化"></a>onCreate函数native化</h3><p>一般情况下app实现先执行MainActivity中的onCreate方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ActivityMainBinding.inflate()</span><br><span class="line">这个是和页面绑定的，具体的类是编译之后自己生成的，将鼠标放上面找打具体的类</span><br><span class="line"></span><br><span class="line">// ActivityMainBinding</span><br><span class="line">com.example.demo.databinding</span><br><span class="line">public final class com.example.demo.databinding.ActivityMainBinding</span><br><span class="line">extends androidx.viewbinding.ViewBinding</span><br><span class="line"></span><br><span class="line">// inflate</span><br><span class="line">com.example.demo.databinding.ActivityMainBinding</span><br><span class="line">public static @NonNull com.example.demo.databinding.ActivityMainBinding inflate(     @NonNull android.view.LayoutInflater inflater )</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241206112301132.png" alt="image-20241206112301132"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// getRoot</span><br><span class="line">com.example.demo.databinding.ActivityMainBinding</span><br><span class="line">public androidx.constraintlayout.widget.ConstraintLayout getRoot()</span><br></pre></td></tr></table></figure>



<p>尝试实现native化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="type">void</span> JNICALL</span><br><span class="line"><span class="title function_">Java_com_example_demo_MainActivity_onCreates</span><span class="params">(JNIEnv *env, jobject thiz,</span></span><br><span class="line"><span class="params">                                             jobject saved_instance_state)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement onCreates()</span></span><br><span class="line">    <span class="comment">// super.onCreate(savedInstanceState);</span></span><br><span class="line">    jclass fragmentClass = env-&gt;FindClass(<span class="string">&quot;androidx/fragment/app/FragmentActivity&quot;</span>);</span><br><span class="line">    jmethodID onCreateID = env-&gt;GetMethodID(fragmentClass, <span class="string">&quot;onCreate&quot;</span>, <span class="string">&quot;(Landroid/os/Bundle;)V&quot;</span>);</span><br><span class="line">    env-&gt;CallNonvirtualVoidMethod(thiz,fragmentClass ,onCreateID, saved_instance_state);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// binding = ActivityMainBinding.inflate(getLayoutInflater());</span></span><br><span class="line">    <span class="comment">// getLayoutInflater()</span></span><br><span class="line">    jclass aClass = env-&gt;FindClass(<span class="string">&quot;android/app/Activity&quot;</span>);</span><br><span class="line">    jmethodID getLayoutInflaterID =</span><br><span class="line">            env-&gt;GetMethodID(aClass, <span class="string">&quot;getLayoutInflater&quot;</span>, <span class="string">&quot;()Landroid/view/LayoutInflater;&quot;</span>);</span><br><span class="line">    <span class="comment">// 这里需要的对象是那个对象调用这个方法，在Java中getLayoutInflater方法没有前缀，说明就是MainActivity调用了这个方法</span></span><br><span class="line">    jobject LayoutInflater = env-&gt;CallObjectMethod(thiz, getLayoutInflaterID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ActivityMainBinding.inflate()</span></span><br><span class="line">    jclass ActivityMainBindingClazz =</span><br><span class="line">            env-&gt;FindClass(<span class="string">&quot;com/example/demo/databinding/ActivityMainBinding&quot;</span>);</span><br><span class="line">    jmethodID inflateID =</span><br><span class="line">            env-&gt;GetStaticMethodID(ActivityMainBindingClazz, <span class="string">&quot;inflate&quot;</span>,</span><br><span class="line">                <span class="string">&quot;(Landroid/view/LayoutInflater;)Lcom/example/demo/databinding/ActivityMainBinding;&quot;</span>);</span><br><span class="line">    jobject Binding = env-&gt;CallStaticObjectMethod(ActivityMainBindingClazz,</span><br><span class="line">                                                  inflateID, LayoutInflater);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// setContentView(binding.getRoot());</span></span><br><span class="line">    jmethodID getRootID =</span><br><span class="line">            env-&gt;GetMethodID(ActivityMainBindingClazz, <span class="string">&quot;getRoot&quot;</span>,</span><br><span class="line">                             <span class="string">&quot;()Landroidx/constraintlayout/widget/ConstraintLayout;&quot;</span>);</span><br><span class="line">    jobject ConstraintLayout = env-&gt;CallObjectMethod(ActivityMainBindingClazz, getRootID);</span><br><span class="line"></span><br><span class="line">    jclass AppCompatActivityClazz = env-&gt;FindClass(<span class="string">&quot;androidx/appcompat/app/AppCompatActivity&quot;</span>);</span><br><span class="line">    jmethodID setContentViewID =</span><br><span class="line">            env-&gt;GetMethodID(AppCompatActivityClazz, <span class="string">&quot;setContentView&quot;</span>, <span class="string">&quot;(Landroid/view/View;)V&quot;</span>);</span><br><span class="line">    env-&gt;CallVoidMethod(thiz, setContentViewID, ConstraintLayout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>调了那么一串，其实才执行了三句话，后面的实现其实也大差不差，都是这个流程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    binding = ActivityMainBinding.inflate(getLayoutInflater());</span><br><span class="line">    setContentView(binding.getRoot());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>补档：</p>
<p>将onCreate彻底native化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    binding = ActivityMainBinding.inflate(getLayoutInflater());</span><br><span class="line">    setContentView(binding.getRoot());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Example of a call to a native method</span></span><br><span class="line">    <span class="type">TextView</span> <span class="variable">tv</span> <span class="operator">=</span> binding.sampleText;</span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> getPath(getApplicationContext()) + <span class="string">&quot;/libdemo.so&quot;</span>;</span><br><span class="line">    tv.setText(stringFromJNI(path));</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> stringFromJNIObject(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>), a,<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>&#125; );</span><br><span class="line"></span><br><span class="line">    <span class="type">Button</span> <span class="variable">button1</span> <span class="operator">=</span> binding.button1;</span><br><span class="line">    button1.setOnClickListener(MainActivity.<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    text = binding.textView;</span><br><span class="line">    editText = binding.editTextText;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">JNIEXPORT <span class="type">void</span> JNICALL</span><br><span class="line"><span class="title function_">Java_com_example_demo_MainActivity_onCreate</span><span class="params">(JNIEnv *env, jobject thiz,</span></span><br><span class="line"><span class="params">                                             jobject saved_instance_state)</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement onCreates()</span></span><br><span class="line">    <span class="comment">// super.onCreate(savedInstanceState);</span></span><br><span class="line">    jclass fragmentClass = env-&gt;FindClass(<span class="string">&quot;androidx/fragment/app/FragmentActivity&quot;</span>);</span><br><span class="line">    jmethodID onCreateID = env-&gt;GetMethodID(fragmentClass, <span class="string">&quot;onCreate&quot;</span>, <span class="string">&quot;(Landroid/os/Bundle;)V&quot;</span>);</span><br><span class="line">    env-&gt;CallNonvirtualVoidMethod(thiz,fragmentClass ,onCreateID, saved_instance_state);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// binding = ActivityMainBinding.inflate(getLayoutInflater());</span></span><br><span class="line">    <span class="comment">// getLayoutInflater()</span></span><br><span class="line">    jclass aClass = env-&gt;FindClass(<span class="string">&quot;android/app/Activity&quot;</span>);</span><br><span class="line">    jmethodID getLayoutInflaterID =</span><br><span class="line">            env-&gt;GetMethodID(aClass, <span class="string">&quot;getLayoutInflater&quot;</span>, <span class="string">&quot;()Landroid/view/LayoutInflater;&quot;</span>);</span><br><span class="line">    <span class="comment">// 这里需要的对象是那个对象调用这个方法，在Java中getLayoutInflater方法没有前缀，说明就是MainActivity调用了这个方法</span></span><br><span class="line">    jobject LayoutInflater = env-&gt;CallObjectMethod(thiz, getLayoutInflaterID);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ActivityMainBinding.inflate()</span></span><br><span class="line">    jclass ActivityMainBindingClazz =</span><br><span class="line">            env-&gt;FindClass(<span class="string">&quot;com/example/demo/databinding/ActivityMainBinding&quot;</span>);</span><br><span class="line">    jmethodID inflateID =</span><br><span class="line">            env-&gt;GetStaticMethodID(ActivityMainBindingClazz, <span class="string">&quot;inflate&quot;</span>,</span><br><span class="line">                <span class="string">&quot;(Landroid/view/LayoutInflater;)Lcom/example/demo/databinding/ActivityMainBinding;&quot;</span>);</span><br><span class="line">    jobject Binding = env-&gt;CallStaticObjectMethod(ActivityMainBindingClazz,</span><br><span class="line">                                                  inflateID, LayoutInflater);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// setContentView(binding.getRoot());</span></span><br><span class="line">    jmethodID getRootID =</span><br><span class="line">            env-&gt;GetMethodID(ActivityMainBindingClazz, <span class="string">&quot;getRoot&quot;</span>,</span><br><span class="line">                             <span class="string">&quot;()Landroidx/constraintlayout/widget/ConstraintLayout;&quot;</span>);</span><br><span class="line">    jobject ConstraintLayout = env-&gt;CallObjectMethod(Binding, getRootID);</span><br><span class="line"></span><br><span class="line">    jclass AppCompatActivityClazz = env-&gt;FindClass(<span class="string">&quot;androidx/appcompat/app/AppCompatActivity&quot;</span>);</span><br><span class="line">    jmethodID setContentViewID =</span><br><span class="line">            env-&gt;GetMethodID(AppCompatActivityClazz, <span class="string">&quot;setContentView&quot;</span>, <span class="string">&quot;(Landroid/view/View;)V&quot;</span>);</span><br><span class="line">    env-&gt;CallVoidMethod(thiz, setContentViewID, ConstraintLayout);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TextView tv = binding.sampleText</span></span><br><span class="line">    <span class="comment">// 注意这里，这个 sampleText 不是方法，而是字段，所以要使用 GetFileID</span></span><br><span class="line">    jfieldID sampleTextID =</span><br><span class="line">            env-&gt;GetFieldID(ActivityMainBindingClazz,</span><br><span class="line">                             <span class="string">&quot;sampleText&quot;</span>, <span class="string">&quot;Landroid/widget/TextView;&quot;</span>);</span><br><span class="line">    jobject tv = env-&gt;GetObjectField(Binding, sampleTextID);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// String path = getPath(getApplicationContext()) + &quot;/libdemo.so&quot;;</span></span><br><span class="line">    jclass ContextWrapperClazz = env-&gt;FindClass(<span class="string">&quot;android/content/ContextWrapper&quot;</span>);</span><br><span class="line">    jmethodID getApplicationContextID =</span><br><span class="line">            env-&gt;GetMethodID(ContextWrapperClazz,</span><br><span class="line">                             <span class="string">&quot;getApplicationContext&quot;</span>, <span class="string">&quot;()Landroid/content/Context;&quot;</span>);</span><br><span class="line">    jobject Context = env-&gt;CallObjectMethod(thiz, getApplicationContextID);</span><br><span class="line"></span><br><span class="line">    jclass MainActivityClazz = env-&gt;FindClass(<span class="string">&quot;com/example/demo/MainActivity&quot;</span>);</span><br><span class="line">    jmethodID getPathID = env-&gt;GetMethodID(MainActivityClazz ,</span><br><span class="line">                               <span class="string">&quot;getPath&quot;</span>, <span class="string">&quot;(Landroid/content/Context;)Ljava/lang/String;&quot;</span>);</span><br><span class="line">    jstring path = static_cast&lt;jstring&gt; (env-&gt;CallObjectMethod(thiz, getPathID, Context));</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *Path = env-&gt;GetStringUTFChars(path, nullptr);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *So = <span class="string">&quot;/libdemo.so&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *result = new <span class="type">char</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(result, Path);</span><br><span class="line">    <span class="built_in">strcat</span>(result, So);</span><br><span class="line">    jstring PathSo = env-&gt;NewStringUTF(result);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// tv.setText(stringFromJNI(path));</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面是为了执行 stringFromJNI(path) ，但是 stringFromJNI 是C的方法，干嘛去用C调用Java来调用C的方法呢，直接函数名调用就好了</span></span><br><span class="line">    <span class="comment">// jmethodID stringFromJNIID =</span></span><br><span class="line">    <span class="comment">//          env-&gt;GetMethodID(MainActivityClazz,</span></span><br><span class="line">    <span class="comment">//                 &quot;stringFromJNI&quot;, &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;);</span></span><br><span class="line">	<span class="comment">// jstring jstring1 = static_cast&lt;jstring&gt;</span></span><br><span class="line">	<span class="comment">// (env-&gt;CallObjectMethod(thiz, stringFromJNIID, PathSo));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// tv.setText()</span></span><br><span class="line">    jclass TextViewID = env-&gt;FindClass(<span class="string">&quot;android/widget/TextView&quot;</span>);</span><br><span class="line">    jmethodID setTextID =</span><br><span class="line">            env-&gt;GetMethodID(TextViewID, <span class="string">&quot;setText&quot;</span>, <span class="string">&quot;(Ljava/lang/CharSequence;)V&quot;</span>);</span><br><span class="line">    env-&gt;CallVoidMethod(tv, setTextID, Java_com_example_demo_MainActivity_stringFromJNI(env, thiz, PathSo));</span><br><span class="line">    LOGD(<span class="string">&quot;tv.setText(stringFromJNI(path));&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// String c = stringFromJNIobject(new String( original: &quot;a&quot;), a,new byte[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#125;);</span></span><br><span class="line">    jmethodID stringFromJNIObjectID =</span><br><span class="line">            env-&gt;GetMethodID(MainActivityClazz,</span><br><span class="line">                             <span class="string">&quot;stringFromJNIObject&quot;</span>, <span class="string">&quot;(Ljava/lang/String;I[B)Ljava/lang/String;&quot;</span>);</span><br><span class="line">    jbyteArray a = env-&gt;NewByteArray(<span class="number">4</span>);</span><br><span class="line">    jbyte bytes[] = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;;</span><br><span class="line">    jint myIntValue = <span class="number">42</span>;</span><br><span class="line">    jstring c = demoHelloWorld(env, thiz, env-&gt;NewStringUTF(<span class="string">&quot;a&quot;</span>), myIntValue, a);</span><br><span class="line">    LOGD(<span class="string">&quot;String c = stringFromJNIobject(new String( original: \&quot;a\&quot;), a,new byte[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#125;);&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Button button1 = binding.button1;</span></span><br><span class="line">    jfieldID button1ID =</span><br><span class="line">            env-&gt;GetFieldID(ActivityMainBindingClazz, <span class="string">&quot;button1&quot;</span>, <span class="string">&quot;Landroid/widget/Button;&quot;</span>);</span><br><span class="line">    jobject button1 = env-&gt;GetObjectField(Binding, button1ID);</span><br><span class="line">    LOGD(<span class="string">&quot;Button button1 = binding.button1;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// button1.setOnClickListener(MainActivity.this);</span></span><br><span class="line">    jclass ViewID = env-&gt;FindClass(<span class="string">&quot;android/view/View&quot;</span>);</span><br><span class="line">    jmethodID setOnClickListenerID =</span><br><span class="line">            env-&gt;GetMethodID(ViewID,</span><br><span class="line">                             <span class="string">&quot;setOnClickListener&quot;</span>, <span class="string">&quot;(Landroid/view/View$OnClickListener;)V&quot;</span>);</span><br><span class="line">    env-&gt;CallVoidMethod(button1, setOnClickListenerID, thiz);</span><br><span class="line">    LOGD(<span class="string">&quot;button1.setOnClickListener(MainActivity.this);&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// text = binding.textView;</span></span><br><span class="line">    <span class="comment">// editText = binding.editTextText;</span></span><br><span class="line">    jfieldID textViewID =</span><br><span class="line">            env-&gt;GetFieldID(ActivityMainBindingClazz,</span><br><span class="line">                             <span class="string">&quot;textView&quot;</span>, <span class="string">&quot;Landroid/widget/TextView;&quot;</span>);</span><br><span class="line">    jobject text = env-&gt;GetObjectField(Binding, textViewID);</span><br><span class="line"></span><br><span class="line">    jfieldID editTextTextID =</span><br><span class="line">            env-&gt;GetFieldID(ActivityMainBindingClazz,</span><br><span class="line">                             <span class="string">&quot;editTextText&quot;</span>, <span class="string">&quot;Landroid/widget/EditText;&quot;</span>);</span><br><span class="line">    jobject editText = env-&gt;GetObjectField(Binding, editTextTextID);</span><br><span class="line">    LOGD(<span class="string">&quot;text = binding.textView;\n&quot;</span></span><br><span class="line">         <span class="string">&quot;editText = binding.editTextText;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20241208210424182.png" alt="image-20241208210424182"></p>
]]></content>
      <categories>
        <category>逆向学习</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>Amarok“极简日历”密码绕过</title>
    <url>/2024/12/16/Amarok%E2%80%98%E6%9E%81%E7%AE%80%E6%97%A5%E5%8E%86%E2%80%99%E5%AF%86%E7%A0%81%E7%BB%95%E8%BF%87/</url>
    <content><![CDATA[<p>这个软件Amarok经常取证的大佬故意已经了如指掌了，一个可以伪装成极简日历的隐藏文件夹和软件的软件，密码绕过可能用处不大，因为他的equals比较简单，就是将你输入的东西计算MD5然后和设定好的密码的MD5进行比较，hook一下equals方法就差不多了，但是这个方法比较邪门，就写个博客记录一下。</p>
<p><img src="../../../新桌面/MC小杨的python学习文件夹/笔记/图片/image-20241216213615163.png" alt="image-20241216213615163" style="zoom:30%;" /><img src="../../../新桌面/MC小杨的python学习文件夹/笔记/图片/image-20241216203438934.png" alt="image-20241216203438934" style="zoom: 30%;" /><img src="../图片/image-20241216203629429.png" alt="image-20241216203629429" style="zoom: 30%;" /></p>
<span id="more"></span>



<p>设备：雷电九模拟器</p>
<p>工具：frida</p>
<p>我设置了一个三位数的密码，使用四位数的密码来测试。</p>
<p>起因就是hook equals准备筛选MD5的结果进行定位堆栈的时候，菜，漏打了一个双引号</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">showStacks</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">        	<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>)</span><br><span class="line">            	.<span class="title function_">getStackTraceString</span>(</span><br><span class="line">                	<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new()</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hook equals 方法</span></span><br><span class="line">    <span class="keyword">var</span> equalsMethod = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>)</span><br><span class="line">    equalsMethod.<span class="property">equals</span>.<span class="title function_">overload</span>(<span class="string">&quot;java.lang.Object&quot;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;equals called with &quot;</span> + <span class="variable language_">this</span> + <span class="string">&quot; and obj &quot;</span> + obj);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span> == b59c67bf196a4758191e42f76670ceba) &#123;</span><br><span class="line">            <span class="title function_">showStacks</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">equals</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<img src="../图片/image-20241216212903362.png" alt="image-20241216212903362" style="zoom:50%;" />



<p>密码错误的状态，注入代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frida -UF -l .\1.js -o log.txt</span><br></pre></td></tr></table></figure>



<p>成功之后，点击解锁</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241216213013621.png" alt="image-20241216213013621"></p>
<p>东西也是可以正常看到的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241216213106621.png" alt="image-20241216213106621"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20241216213121111.png" alt="image-20241216213121111"></p>
<p>PS：注入之前点一次解锁，否则会一开始就弹出很多报错，我的流程在二次点击解锁之前是没有任何飘红的。然后就是进入之后尽快 exit 退出脚本，否则可能导致软件闪退。东西就图一乐呵，弄起来还挺麻烦的</p>
]]></content>
      <categories>
        <category>逆向实践</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>pixel XL初体验</title>
    <url>/2025/01/20/pixel-XL%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="pixel-XL体验"><a href="#pixel-XL体验" class="headerlink" title="pixel XL体验"></a>pixel XL体验</h1><h2 id="先刷个机"><a href="#先刷个机" class="headerlink" title="先刷个机"></a>先刷个机</h2><p>整了个低于市场价的pixel XL，到手一看是个安卓8，还不如雷电模拟器安卓版本高，真是废，整个升级先（理论上来说如果是安卓10就不用刷机，直接恢复出厂设置不就行了）</p>
<p>点击7次版本号，进入开发者模式，在开发者选项中，打开USB调试</p>
<p>刷机包：<a href="https://developers.google.com/android/ota?hl=zh-cn#marlin">https://developers.google.com/android/ota?hl=zh-cn#marlin</a></p>
<span id="more"></span>

<p>下第一个，剩下三个都不是</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250119222002724.png" alt="image-20250119222002724"></p>
<p>下载解压是这样的</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250119224403853.png" alt="image-20250119224403853"></p>
<p>我已经有adb和谷歌驱动了，下面直接让安卓重伤倒地</p>
<p>重启进入bl模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure>



<p>执行，如果没输出说明没谷歌驱动，自行下载安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastboot devices</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20250119224136405.png" alt="image-20250119224136405"></p>
<p>确定可以连接之后，直接执行 flash-all.bat 全刷了算了</p>
<p>有特殊需求可以将这些东西分开执行</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250119224640933.png" alt="image-20250119224640933"></p>
<p>完事了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250119224833172.png" alt="image-20250119224833172"></p>
<h2 id="开启root"><a href="#开启root" class="headerlink" title="开启root"></a>开启root</h2><p>重启后重新打开USB调试</p>
<p>提示没有root</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250119230306041.png" alt="image-20250119230306041"></p>
<p>root需要用到一个软件Magisk</p>
<p>下载 <a href="https://github.com/topjohnwu/Magisk/releases">https://github.com/topjohnwu/Magisk/releases</a></p>
<p>这里用v23.0的刷</p>
<p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb install 路径</span><br></pre></td></tr></table></figure>



<p>然后将刷机包中的 boot.img 推到手机 sdcard文件夹中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb push 镜像路径 手机路径</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20250119231114808.png" alt="image-20250119231114808"></p>
<p>打开这个软件，进行操作，完事点开始，等着刷完</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250119231436049.png" alt="image-20250119231436049"></p>
<p>看完成信息，将加工完的img文件弄出来</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250119231607083.png" alt="image-20250119231607083"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb pull /storage/emulated/0/Download/magisk_patched-23000_M214L.img</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20250119232151404.png" alt="image-20250119232151404"></p>
<p>拿出来新的镜像文件之后，再将其刷入。</p>
<p>再次重伤倒地</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure>



<p>刷入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastboot flash boot bootnew.img</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20250119232634935.png" alt="image-20250119232634935"></p>
<p>直接重启即可</p>
<p>永久同意获取权限之后，直接拿下</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250119232851717.png" alt="image-20250119232851717"></p>
<p>还有一点小瑕疵，这俩东西有点恶心。</p>
<img src="../图片/image-20250119233118051.png" alt="image-20250119233118051" style="zoom:50%;" />



<p>解决WiFi上面的问号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell settings put global captive_portal_mode 0</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20250120000238766.png" alt="image-20250120000238766"></p>
<p>解决谷歌向导</p>
<p>设置&gt;应用和通知&gt;查看全部应用&gt;显示系统程序&gt;找到安卓设置向导&gt;停用&gt;完事了</p>
<img src="../图片/image-20250120000533229.png" alt="image-20250120000533229" style="zoom:50%;" />



<h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p>Charles，之前模拟器也弄个，主要就是更改WiFi的IP地址和端口，然后弄个证书，在电脑上用软件抓包就完事了。</p>
<p>Charles软件是之前配置好了的，就光配置手机，Charles配置看我之前的抓包的博客</p>
<p>最好手机和电脑连接的是同一个网络，这样就可以ping同，如果不是一个网络，ping不通也就没法转发抓包了。用Charles还得下载一个软件 socksdroid ，可以方便更改</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250120003915648.png" alt="image-20250120003915648"></p>
<p>配上IP和端口，开始转发</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250120004422566.png" alt="image-20250120004422566"></p>
<p>配置好重新开始的时候会提示一个这玩楞，选 Allow</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250120005719862.png" alt="image-20250120005719862"></p>
<p>下面就是安装证书，没证书解析不了抓包的内容</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250120005752851.png" alt="image-20250120005752851"></p>
<p>将证书下载到电脑上，也可以选择第三个，根据提示在手机上访问地址去下载</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250120010451254.png" alt="image-20250120010451254"></p>
<p>然后推到手机上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb push Charles.pem /sdcard</span><br></pre></td></tr></table></figure>



<p>设置&gt;安全&gt;加密与凭据&gt;从存储设备安装&gt;选择证书安装</p>
<p>这个时候能抓https，但是还是有一部分不能解析，在将用户安装的这张证书，放到系统证书目录下即可正常抓包。</p>
<p>两种方法，一种是用面具，从模块那个地方搜索，move安装</p>
<p>安装完毕之后手机重启</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250120020216177.png" alt="image-20250120020216177"></p>
<p>重启之后就发现，用户凭据去系统凭据里面了非常的好用。现在就可以正常抓包了。</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250120020423059.png" alt="image-20250120020423059"></p>
<p>第两种方法，直接挪。</p>
<p>在&#x2F;data&#x2F;misc&#x2F;user&#x2F;0&#x2F;cacerts-added 这个目录下找到自己安装的证书，名字是和哈希值有关，相同哈希值用 .0 .1 .2区分</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250120012336858.png" alt="image-20250120012336858"></p>
<p>将证书拿出来放到&#x2F;system&#x2F;etc&#x2F;security&#x2F;cacert 目录下和上面效果一样。</p>
<p>小黄鸟抓包，这个简单，已经root了，根据提示按步骤来就可以将证书自动放到信任区。</p>
<p>平时还是小黄鸟用的多</p>
<img src="../图片/image-20250120022804407.png" alt="image-20250120022804407" style="zoom:50%;" />



<h2 id="frida环境"><a href="#frida环境" class="headerlink" title="frida环境"></a>frida环境</h2><p>终于最后一步了</p>
<p>本机下载frida 下载frida-tools会自动下载frida</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install frida-tools</span><br><span class="line">pip install loguru click</span><br><span class="line">pip install hexdump</span><br></pre></td></tr></table></figure>



<p>先看看本机下载frida之后查看本机frida版本和手机cpu类型</p>
<p>其实一般都是arm64 看不看都一样，64位的，重要的是frida版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frida --version</span><br><span class="line"></span><br><span class="line">adb shell</span><br><span class="line">getprop ro.product.cpu.abi</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20250120023151356.png" alt="image-20250120023151356"></p>
<p>下载frida-server</p>
<p><a href="https://github.com/frida/frida/releases">https://github.com/frida/frida/releases</a></p>
<p>找到对应frida版本的还有对应手机cpu的frida-server</p>
<p>照我的应该是这个</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250120023658473.png" alt="image-20250120023658473"></p>
<p>解压出来push到手机里</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进入手机端命令：adb shell</span><br><span class="line">切换获取手机的root权限：su</span><br><span class="line">查找文件是否在手机中：cd/data/local/tmp/</span><br><span class="line">4查看路径下的文件并看文件的权限：ls -l</span><br><span class="line">拥有root权限更改文件的权限为777：chmod 777 frida-server-16.5.2-android-x86</span><br><span class="line">在手机中启动运行该文件：·/frida-server-14.0.5-android-x86 &amp;</span><br><span class="line">电脑运行检查手机端服务是否开启成功：frida-ps -U</span><br><span class="line">windows运行端口转发到PC：adb forward tcp:27043 tcp:27043</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20250120024718459.png" alt="image-20250120024718459"></p>
<p>frida-ps -U执行结果如下</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250120025436884.png" alt="image-20250120025436884"></p>
<p>再拿之前的hook脚本测试一下，没毛病，完事了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250120030043346.png" alt="image-20250120030043346"></p>
<p>END</p>
]]></content>
      <categories>
        <category>逆向实践</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>配置centos静态IP</title>
    <url>/2025/01/20/%E9%85%8D%E7%BD%AEcentos%E9%9D%99%E6%80%81IP/</url>
    <content><![CDATA[<h1 id="配置centos静态IP"><a href="#配置centos静态IP" class="headerlink" title="配置centos静态IP"></a>配置centos静态IP</h1><p>水一篇博客。</p>
<p>为啥要配置静态IP</p>
<p>平时我们会通过一些远程链接软件链接虚拟机，一般链接都需要输入IP地址，但是每次重启虚拟机IP地址随机分配一个新的，每次都要链接很不方便。</p>
<p>设置静态ip的必要性：一般我们的虚拟机默认使用的是dhcp协议（根据网段自动分配ip），所以如果我们不设置静态ip的话，虚拟机会自动分配一个IP，虽然可以联网，但当网络断开或者电脑关机后ip地址就会随机改变，这显然不是我们想要的。而设置静态ip，ip会一直不变，方便我们连接虚拟机。</p>
<span id="more"></span>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/sysconfig/network-spcripts/ifcfg-enp33</span><br></pre></td></tr></table></figure>



<p>打开文件，如下图所示，更改配置</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240421130439511.png" alt="image-20240421130439511"></p>
<p>将 <code>BOOTTROPO</code> 更改为static(静态)</p>
<p>在BOOTTROPO下方加入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IPADDR=</span><br><span class="line">//输入自己指定固定的IP地址</span><br><span class="line"></span><br><span class="line">NETMASK=</span><br><span class="line">//代表子网掩码，一般为255.255.255.0</span><br><span class="line"></span><br><span class="line">GATEWAY=</span><br><span class="line">//代表网关，如我是192.168.0网段，网关为192.168.0.1</span><br></pre></td></tr></table></figure>

<p>输入之后保存退出</p>
<p>然后reboot重启，或者 <code>service network restart</code> 重启网卡</p>
<p>重要的是这个配置网卡，一般在取证的时候，给到的服务器有固定IP，这时候需要我们配置一张同网段的网卡才能联网使用。</p>
<p>需要将网络模式设置为NAT模式，然后更改默认NAT的网卡VMnet8的子网IP，起始IP，结束IP，网关</p>
<img src="../图片/image-20240508213751983.png" alt="image-20240508213751983" style="zoom: 33%;" />

<img src="../图片/image-20240508213834626.png" alt="image-20240508213834626" style="zoom:33%;" />

<img src="../图片/image-20240508213917167.png" alt="image-20240508213917167" style="zoom:33%;" />



<p>使用主机ping一下检查网络是否联通</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20240508214505599.png" alt="image-20240508214505599"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>獬豸杯手机手搓</title>
    <url>/2025/03/08/%E7%8D%AC%E8%B1%B8%E6%9D%AF%E6%89%8B%E6%9C%BA%E6%89%8B%E6%90%93/</url>
    <content><![CDATA[<p>参考：<a href="https://www.cnblogs.com/WXjzc/p/18736022">https://www.cnblogs.com/WXjzc/p/18736022</a></p>
<h3 id="手机取证"><a href="#手机取证" class="headerlink" title="手机取证"></a>手机取证</h3><p>手搓版</p>
<p>这个题的关键点在于手机截图，可以从手机截图里获取到很多有用的信息</p>
<p>将文件用FTK挂载起来，很多com.miui的包名，说明这是一个小米手机。</p>
<p>发现不存在图片默认的保存路径  <code>/storage/emulated/(0/)DCIM/Camera</code> </p>
<span id="more"></span>

<p>因为给的检材是data文件夹内，进不去&#x2F;storage 就需要在 <code>/media/0/Android/data/com.miui.gallery/files/gallery_disk_cache/full_size</code> 中找到截图</p>
<p>这些截图几乎包含了下面的答案，软件列表，直播软件，网易会议，白马地图等等</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250307180847855.png" alt="image-20250307180847855"></p>
<h4 id="1-登录的直播APP的IDX是什么？-标准格式：25236541"><a href="#1-登录的直播APP的IDX是什么？-标准格式：25236541" class="headerlink" title="1.登录的直播APP的IDX是什么？[标准格式：25236541]"></a>1.登录的直播APP的IDX是什么？[标准格式：25236541]</h4><h4 id="2-目前直播的等级名称是什么？-标准格式：碌碌无为"><a href="#2-目前直播的等级名称是什么？-标准格式：碌碌无为" class="headerlink" title="2.目前直播的等级名称是什么？[标准格式：碌碌无为]"></a>2.目前直播的等级名称是什么？[标准格式：碌碌无为]</h4><p>35248617</p>
<p>一无所有</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250307180958565.png" alt="image-20250307180958565"></p>
<p>如果没发现截图捏，那就去发现截图（bushi，可以尝试去找直播软件的数据库。</p>
<p>先找到直播软件是什么，找到小米商店的数据库，看一下都下载了啥（从文件系统中查看包名，挨个搜太抽象了，不到万不得已不要这样干）</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250308140917201.png" alt="image-20250308140917201"></p>
<p>在数据库中找到应用以及包名，烟雨直播</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250308141136604.png" alt="image-20250308141136604"></p>
<p>去这个包名下找数据库</p>
<p>在miao.db库中的login表中可以找到id</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250308141615786.png" alt="image-20250308141615786"></p>
<p>xml中也有，只不过特征不明显</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250308143440010.png" alt="image-20250308143440010"></p>
<p>直播等级找不到，去找图片吧（doge）</p>
<h4 id="3-地图中哪座山有绝望坡？-标准格式：太行山"><a href="#3-地图中哪座山有绝望坡？-标准格式：太行山" class="headerlink" title="3.地图中哪座山有绝望坡？[标准格式：太行山]"></a>3.地图中哪座山有绝望坡？[标准格式：太行山]</h4><p>武功山</p>
<p>还是图片</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250308142438405.png" alt="image-20250308142438405"></p>
<p>百度也可以</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250308142512766.png" alt="image-20250308142512766"></p>
<p>找数据库也可以，题目提到绝望坡，说明嫌疑人可能通过浏览器或者地图软件搜索过，根据上面的安装列表找地图软件，白马地图和蔚蓝地图</p>
<p>白马地图是用户自己安装的，有安装时间，肯定先找这个</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250308143109164.png" alt="image-20250308143109164"></p>
<h4 id="4-手机的历史SIM卡中，中国电信卡的IMSI是多少？-标准格式：123456789"><a href="#4-手机的历史SIM卡中，中国电信卡的IMSI是多少？-标准格式：123456789" class="headerlink" title="4.手机的历史SIM卡中，中国电信卡的IMSI是多少？[标准格式：123456789]"></a>4.手机的历史SIM卡中，中国电信卡的IMSI是多少？[标准格式：123456789]</h4><p>460115143563428</p>
<p>截图上的是IMEI，搓数据库</p>
<p> <code>/data/user_de/0/com.android.providers/telephony/databases/telephony.db</code></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250308143625619.png" alt="image-20250308143625619"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250308154422194.png" alt="image-20250308154422194"></p>
<h4 id="5-1月22日16：40的会议号是多少？-标准格式：xxx-xxx-xxx"><a href="#5-1月22日16：40的会议号是多少？-标准格式：xxx-xxx-xxx" class="headerlink" title="5.1月22日16：40的会议号是多少？[标准格式：xxx-xxx-xxx]"></a>5.1月22日16：40的会议号是多少？[标准格式：xxx-xxx-xxx]</h4><h4 id="6-网易会议中个人会议号是多少？-标准格式：2523654199"><a href="#6-网易会议中个人会议号是多少？-标准格式：2523654199" class="headerlink" title="6.网易会议中个人会议号是多少？[标准格式：2523654199]"></a>6.网易会议中个人会议号是多少？[标准格式：2523654199]</h4><p>312-118-071</p>
<p>2679823922</p>
<p>依旧截图</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250308154606029.png" alt="image-20250308154606029"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250308160849976.png" alt="image-20250308160849976"></p>
<p>没截图就翻数据库，网易会议，这里有一点蛛丝马迹，但是不能确定这个就是四点的会议，数据库内没有个人会议号</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250308155651708.png" alt="image-20250308155651708"></p>
<p>在 <code>/media/0/Android/data/com.netease.yunxin.meeting/files/nim/extra_log/imkit_log</code> 下有个日志文件，搜这个人的名称，找到个人会议号</p>
<p>2679823922</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250308160612405.png" alt="image-20250308160612405"></p>
<p>继续往下翻</p>
<p>下一个搜时间戳</p>
<p>312118071</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250308161326411.png" alt="image-20250308161326411"></p>
<p>找到会议号</p>
<h4 id="7-记账软件中一共记了几笔？-标准格式：9"><a href="#7-记账软件中一共记了几笔？-标准格式：9" class="headerlink" title="7.记账软件中一共记了几笔？[标准格式：9]"></a>7.记账软件中一共记了几笔？[标准格式：9]</h4><h4 id="8-谁给了机主100000？-标准格式：某某"><a href="#8-谁给了机主100000？-标准格式：某某" class="headerlink" title="8.谁给了机主100000？[标准格式：某某]"></a>8.谁给了机主100000？[标准格式：某某]</h4><p>4</p>
<p>勇哥</p>
<p>截图</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250308161426668.png" alt="image-20250308161426668"></p>
<p>还是tmd截图</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250308161455617.png" alt="image-20250308161455617"></p>
<p>要是还没找到截图的话，快去找截图吧，别翻破数据库了</p>
<p>&#x2F;data&#x2F;com.csmountainaccount.easy&#x2F;database </p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250308162350204.png" alt="image-20250308162350204"></p>
<p>东西没在db里面，在这个db_manager文件中</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250308162229551.png" alt="image-20250308162229551"></p>
<p>一个四笔，type中1表示支出，2表示收入</p>
<h4 id="9-聊天软件是否需要手机号登录？-标准格式：填写是或者否"><a href="#9-聊天软件是否需要手机号登录？-标准格式：填写是或者否" class="headerlink" title="9.聊天软件是否需要手机号登录？[标准格式：填写是或者否]"></a>9.聊天软件是否需要手机号登录？[标准格式：填写是或者否]</h4><h4 id="10-机主的给对方的活有多少钱？-标准格式：53100"><a href="#10-机主的给对方的活有多少钱？-标准格式：53100" class="headerlink" title="10.机主的给对方的活有多少钱？[标准格式：53100]"></a>10.机主的给对方的活有多少钱？[标准格式：53100]</h4><p>否</p>
<p>30000</p>
<p>聊天软件是盒子IM，自己下载试一下就知道了，而且数据库中用的是username和password</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250308163724225.png" alt="image-20250308163724225"></p>
<p>30000</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250308163802088.png" alt="image-20250308163802088"></p>
<h4 id="11-机主的手机号是多少？-标准格式：13652492155"><a href="#11-机主的手机号是多少？-标准格式：13652492155" class="headerlink" title="11.机主的手机号是多少？[标准格式：13652492155]"></a>11.机主的手机号是多少？[标准格式：13652492155]</h4><p>17751125237</p>
<p>出截图</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250308163929877.png" alt="image-20250308163929877"></p>
<p>在网易会议日志中提到过</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250308164131887.png" alt="image-20250308164131887"></p>
<h4 id="12-手机的IMEI1后四位是多少？-标准格式：2536"><a href="#12-手机的IMEI1后四位是多少？-标准格式：2536" class="headerlink" title="12.手机的IMEI1后四位是多少？[标准格式：2536]"></a>12.手机的IMEI1后四位是多少？[标准格式：2536]</h4><p>1055</p>
<p>截图</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250308143625619.png" alt="image-20250308143625619"></p>
<p>上面问IMSI的数据库中有的是IMEI2</p>
<p>&#x2F;data&#x2F;user_ed&#x2F;0&#x2F;com.android.phone&#x2F;shared_prefs&#x2F;com.android.phone_preferences.xml</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250308164517892.png" alt="image-20250308164517892"></p>
<h4 id="13-手机上一共有几个地图软件？-标准格式：9"><a href="#13-手机上一共有几个地图软件？-标准格式：9" class="headerlink" title="13.手机上一共有几个地图软件？[标准格式：9]"></a>13.手机上一共有几个地图软件？[标准格式：9]</h4><p>3</p>
<p>白马、蔚蓝、百度</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250308164906429.png" alt="image-20250308164906429"></p>
]]></content>
      <categories>
        <category>电子取证</category>
      </categories>
      <tags>
        <tag>电子取证</tag>
      </tags>
  </entry>
  <entry>
    <title>python脚本Windows注册表半自动取证</title>
    <url>/2025/03/11/python%E8%84%9A%E6%9C%ACWindows%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%8D%8A%E8%87%AA%E5%8A%A8%E5%8F%96%E8%AF%81/</url>
    <content><![CDATA[<p>取证的时候没软件有点坐牢，准备写几个小脚本加快手搓速度</p>
<p>演示检材：2025獬豸杯PC镜像</p>
<p>环境：python3.12</p>
<p>​			FTK</p>
<h3 id="获取基本信息"><a href="#获取基本信息" class="headerlink" title="获取基本信息"></a>获取基本信息</h3><span id="more"></span>

<p>照例需要获取计算机的Build版本，计算机名称，系统名称、安装时间、时区、最后一次关机时间、上次登录用户，这些基本信息，这些信息可以直接从注册表中拿到，不需要进行特殊处理（除了时间戳）</p>
<p>收集一下这些信息在注册表中的位置，以及对应的键值</p>
<p>因为只有在我本机和镜像中找到了，就放在了这里，未进行多次实验，有不当支持欢迎斧正。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Build信息  SOFTWARE  SOFTWARE\Microsoft\Windows NT\CurrentVersion  BuildLabEx</span><br><span class="line">Build版本  SOFTWARE  SOFTWARE\Microsoft\Windows NT\CurrentVersion  CurrentBuildNumber</span><br><span class="line">计算机名称  SYSTEM  SYSTEM\ControlSet001\Control\ComputerName\ComputerName  ComputerName</span><br><span class="line">系统名称  SOFTWARE  SOFTWARE\Microsoft\Windows NT\CurrentVersion  ProductName</span><br><span class="line">系统安装时间  SOFTWARE  SOFTWARE\Microsoft\Windows NT\CurrentVersion  InstallDate </span><br><span class="line">系统时区  SYSTEM  SYSTEM\ControlSet001\Control\TimeZoneInformation  TimeZoneKeyName</span><br><span class="line">最后一次关机时间  SYSTEM  SYSTEM\ControlSet001\Control\Windows  ShutdownTime  </span><br><span class="line">上次登录用户  SOFTWARE  SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication\LogonUI  LastLoggedOnUser</span><br></pre></td></tr></table></figure>



<p>使用regipy库进行处理，先将dd镜像用FTK挂载到本地，这里是挂在了H盘</p>
<p>regipy：<a href="https://github.com/mkorman90/regipy">https://github.com/mkorman90/regipy</a></p>
<p>使用 RegistryHive 来确定注册表文件的路径，使用get_key指定键值路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> regipy <span class="keyword">import</span> RegistryHive</span><br><span class="line"><span class="keyword">from</span> regipy.exceptions <span class="keyword">import</span> RegistryKeyNotFoundException</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">system_get</span>(<span class="params">hive, key_path, name, def_name=<span class="literal">None</span></span>):</span><br><span class="line">    key = hive.get_key(key_path)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        date = key.get_value(name)</span><br><span class="line">        <span class="keyword">if</span> def_name == <span class="string">&quot;byte_to_str&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> byte_to_str(date)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> date</span><br><span class="line">    <span class="keyword">except</span> RegistryKeyNotFoundException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;未找到 <span class="subst">&#123;name&#125;</span> 键。 <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">analyze_software_registry</span>(<span class="params">registry_path</span>):</span><br><span class="line"></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;../system_path&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        lines = file.readlines()</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            res = &#123;&#125;</span><br><span class="line">            line = line.strip(<span class="string">&#x27;\n&#x27;</span>).split(<span class="string">&#x27;  &#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(line) == <span class="number">4</span>:</span><br><span class="line">                res[line[<span class="number">0</span>]] = system_get(RegistryHive(<span class="string">f&quot;<span class="subst">&#123;registry_path&#125;</span>/<span class="subst">&#123;line[<span class="number">1</span>]&#125;</span>&quot;</span>), line[<span class="number">2</span>], line[<span class="number">3</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[line[<span class="number">0</span>]] = system_get(RegistryHive(<span class="string">f&quot;<span class="subst">&#123;registry_path&#125;</span>/<span class="subst">&#123;line[<span class="number">1</span>]&#125;</span>&quot;</span>), line[<span class="number">2</span>], line[<span class="number">3</span>], line[<span class="number">4</span>])</span><br><span class="line">            result.append(res)</span><br><span class="line">        <span class="comment"># print(result)</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 将这里的路径替换为你的挂载路径</span></span><br><span class="line">    registry_path = <span class="string">r&#x27;H:/[root]/Windows/System32/config&#x27;</span></span><br><span class="line">    result = analyze_software_registry(registry_path)</span><br></pre></td></tr></table></figure>



<p>直接获取的信息中，系统安装时间是unix时间戳，最后一次关机时间是FILETIME 时间戳，还需要处理时间戳。中间还有一个字节序的转换，简单来说就是，大端字节序就是我们日常的阅读顺序</p>
<blockquote>
<p>10 2c 05 80。 这个十六进制数据如果按照大端字节序转换成十进制就是 271,320,448</p>
<p>如果是小端字节序，就需要从后往前读，两个十六进制数为一组： 80 05 2c 10</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 处理时间戳</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">byte_to_str</span>(<span class="params">byte_time</span>):</span><br><span class="line">    <span class="comment"># 处理 FILETIME 时间戳</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(byte_time, <span class="built_in">bytes</span>):</span><br><span class="line">        res = little_to_big(byte_time.<span class="built_in">hex</span>()) / <span class="number">10000000</span></span><br><span class="line">        unix_seconds = res - <span class="number">11644473600</span></span><br><span class="line">        unix_seconds = datetime.fromtimestamp(unix_seconds)</span><br><span class="line">        <span class="keyword">return</span> unix_seconds.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        unix_seconds = datetime.fromtimestamp(byte_time)</span><br><span class="line">        <span class="keyword">return</span> unix_seconds.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># hex小端字节序转大端字节序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">little_to_big</span>(<span class="params">little_hex</span>):</span><br><span class="line">    little_bytes = <span class="built_in">bytes</span>.fromhex(little_hex)</span><br><span class="line">    num = <span class="built_in">int</span>.from_bytes(little_bytes, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    big_bytes = num.to_bytes(<span class="built_in">len</span>(little_bytes), byteorder=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">    big_hex = <span class="built_in">int</span>(big_bytes.<span class="built_in">hex</span>(), <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> big_hex</span><br></pre></td></tr></table></figure>



<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#123;&#x27;Build信息&#x27;: &#x27;18362.1.amd64fre.19h1_release.190318-1202&#x27;&#125;, &#123;&#x27;Build版本&#x27;: &#x27;18363&#x27;&#125;, &#123;&#x27;计算机名称&#x27;: &#x27;DESKTOP-SBTC549&#x27;&#125;, &#123;&#x27;系统名称&#x27;: &#x27;Windows 10 Education&#x27;&#125;, &#123;&#x27;系统安装时间&#x27;: &#x27;2024-06-12 19:02:06&#x27;&#125;, &#123;&#x27;系统时区&#x27;: &#x27;China Standard Time&#x27;&#125;, &#123;&#x27;最后一次关机时间&#x27;: &#x27;2025-02-10 16:15:30&#x27;&#125;, &#123;&#x27;上次登录用户&#x27;: &#x27;.\\TTT&#x27;&#125;]</span><br></pre></td></tr></table></figure>







<h3 id="获取账户的信息"><a href="#获取账户的信息" class="headerlink" title="获取账户的信息"></a>获取账户的信息</h3><p>账户信息存在SAM文件中，这一部分主要对主要对 <code>SAM\SAM\Domains\Account\Users</code> 目录中的 V 键值对进行分析</p>
<p>这个是镜像 TTT 用户的V值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000f400000003000100f40000000600000000000000fc00000008000000000000000401000000000000000000000401000000000000000000000401000000000000000000000401000000000000000000000401000000000000000000000401000000000000000000000401000000000000000000000401000000000000000000000401000015000000a80000001c01000008000000010000002401000018000000000000003c01000038000000000000007401000018000000000000008c010000180000000000000001001480d4000000e40000001400000044000000020030000200000002c014004400050101010000000000010000000002c01400ff070f0001010000000000050700000002009000040000000000240044000200010500000000000515000000064a693cc7d5a71f57e1f80de8030000000038001b030200010a00000000000f0300000000040000dea22867213ed2af19ad5d79b0c107292756fc20d8ad66f610f268fadf2af80f00001800ff070f0001020000000000052000000020020000000014005b030200010100000000000100000000010200000000000520000000200200000102000000000005200000002002000054005400540000004600610063006500ffffffffffffffffffffffffffffffffffffffffffe1a1a401020000070000000200020000000000e4cf9dd0d3d5d720b26d66d9dc712cb50200020010000000af5788fbd9902cb7182bd4f96e6271cf30bdb1ec83090591fec6c0de090fa8b0e7013610157b17c9bc7b2d313bda45a602000200000000004c2a126f2dceb6ee0b14ed1e27995aff02000200000000005249e2b181774f9b48f9c306ca163d46</span><br></pre></td></tr></table></figure>





<h4 id="获取RID"><a href="#获取RID" class="headerlink" title="获取RID"></a>获取RID</h4><p><code>SAM\SAM\Domains\Account\Users</code> 下的目录代表账户，names目录除外，其余目录的名称就是对应账户的RID值，例如：Administrator账户，对应的RID就是500，那么他的目录名就是 <code>000001F4</code>  （这个转换成十进制就是500）</p>
<p>再记录一个小信息，F的值转换成十六进制，十六进制数的 96-104 位以小端字节序的形式记录了RID。</p>
<h4 id="获取SID"><a href="#获取SID" class="headerlink" title="获取SID"></a>获取SID</h4><p>从这个值中找到 0105 这样的数据，05后面还会有几个0，这一串代表的是该用户（非系统用户，系统用户的我不太明白）的 SID值，</p>
<p>拿出来0105以及之后的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">010500000000000515000000064a693cc7d5a71f57e1f80de80300000000380…………………………</span><br></pre></td></tr></table></figure>



<p>这个 <code>01</code> 是固定的，表示SID版本号后面的 <code>05</code> 表示的是 子权限数量 ，我是直接找的 0105，从网上也没有发现具体的说法，AI更扯，说起始位置可能为 0x30 0x38。</p>
<p>从 0105 之后再获取6字节，这里就是 00 00 00 00 00 05 呈现为大端字节序，是标识符权威值，然后根据子权限数量，来获取 (x-1)段 4字节的子权限列表，这里为 <code>15 00 00 00 </code> <code>06 4a 69 3c </code> <code>c7 d5 a7 1f </code> <code>57 e1 f8 0d</code> ，将获取的四字节从小端序转成大端序，然后转成十进制，得到结果 <code>21</code> <code>1013533190</code> <code>531092935</code> <code>234414423</code> ，为什么是 x-1呢，一般子权限列表中的最后一个是 RID。</p>
<p>拼接得出SID  <code>S-1-5-21-1013533190-531092935-234414423-1000</code> 。完美</p>
<h4 id="获取user"><a href="#获取user" class="headerlink" title="获取user"></a>获取user</h4><p>user的存储前面是有标识符的，结尾需要自己判断，我使用了 <code>5200000002002000001020000000000052000000020020000</code> 来进行判断，那到这个标识符后面的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">54005400540000004600610063006500ffffffffffffffffffffffffffffffffffffffffffe1a1a401020000070000000200020000000000e4cf9dd0d3d5d720b26d66d9dc712cb50200020010000000af5788fbd9902cb7182bd4f96e6271cf30bdb1ec83090591fec6c0de090fa8b0e7013610157b17c9bc7b2d313bda45a602000200000000004c2a126f2dceb6ee0b14ed1e27995aff02000200000000005249e2b181774f9b48f9c306ca163d46</span><br></pre></td></tr></table></figure>



<p>结尾的判断并不是使用标识符，而是从 00 下手，用户名有一个规律，两位十六进制数之后，间隔一个 00 才是下一个十六进制数，我们判断用户名结束就可以使用这样的方法，先将 0000 之前的数据提取出来，防止获取过长，因为出现0000很显然是结束了，节省时间，这样拿到数据 <code>5400540054</code> 而我们需要即对 00 这个间隔来进行判断，有需要将00取出，避免转码是出现乱码。提取结束是 <code>545454</code> hex解码正是 TTT。</p>
<p>PS：至于密码的NT hash我也找到对应的了，但是还不知道怎么处理成取证软件中的形式，下次再说</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250311181720530.png" alt="image-20250311181720530"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250311181815422.png" alt="image-20250311181815422"></p>
<p>小工具代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> regipy <span class="keyword">import</span> RegistryHive</span><br><span class="line"><span class="keyword">from</span> regipy.exceptions <span class="keyword">import</span> RegistryKeyNotFoundException</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">system_get</span>(<span class="params">hive, key_path, name, def_name=<span class="literal">None</span></span>):</span><br><span class="line">    key = hive.get_key(key_path)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        date = key.get_value(name)</span><br><span class="line">        <span class="keyword">if</span> def_name == <span class="string">&quot;byte_to_str&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> byte_to_str(date)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> date</span><br><span class="line">    <span class="keyword">except</span> RegistryKeyNotFoundException <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;未找到 SOFTWARE 键。 <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取电脑基本信息</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">analyze_software_registry</span>(<span class="params">registry_path</span>):</span><br><span class="line"></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;../system_path&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        lines = file.readlines()</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            res = &#123;&#125;</span><br><span class="line">            line = line.strip(<span class="string">&#x27;\n&#x27;</span>).split(<span class="string">&#x27;  &#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(line) == <span class="number">4</span>:</span><br><span class="line">                res[line[<span class="number">0</span>]] = system_get(RegistryHive(<span class="string">f&quot;<span class="subst">&#123;registry_path&#125;</span>/<span class="subst">&#123;line[<span class="number">1</span>]&#125;</span>&quot;</span>), line[<span class="number">2</span>], line[<span class="number">3</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[line[<span class="number">0</span>]] = system_get(RegistryHive(<span class="string">f&quot;<span class="subst">&#123;registry_path&#125;</span>/<span class="subst">&#123;line[<span class="number">1</span>]&#125;</span>&quot;</span>), line[<span class="number">2</span>], line[<span class="number">3</span>], line[<span class="number">4</span>])</span><br><span class="line">            result.append(res)</span><br><span class="line">        <span class="comment"># print(result)</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取用户信息</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_sid_name</span>(<span class="params">registry_path</span>):</span><br><span class="line">    user_list = []</span><br><span class="line">    hive_sam = RegistryHive(<span class="string">f&quot;<span class="subst">&#123;registry_path&#125;</span>/SAM&quot;</span>)</span><br><span class="line">    users_key = hive_sam.get_key(<span class="string">&#x27;SAM\\SAM\\Domains\\Account\\Users&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历 Users 键下的子键（每个子键对应一个用户）</span></span><br><span class="line">    <span class="keyword">for</span> subkey <span class="keyword">in</span> users_key.iter_subkeys():</span><br><span class="line">        <span class="comment"># 获取用户 RID（子键名称通常是用户的 RID，例如 &quot;000001F4&quot;）</span></span><br><span class="line">        user = &#123;&#125;</span><br><span class="line">        user_rid = subkey.name</span><br><span class="line">        <span class="comment"># print(user_rid)</span></span><br><span class="line"></span><br><span class="line">        pattern = <span class="string">r&#x27;^0&#123;1,5&#125;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">bool</span>(re.<span class="keyword">match</span>(pattern, user_rid)):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># RID</span></span><br><span class="line">                f_full_name_key = subkey.get_value(<span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">                rid = little_to_big(f_full_name_key.<span class="built_in">hex</span>()[<span class="number">96</span>:<span class="number">104</span>])</span><br><span class="line">                user[<span class="string">&#x27;RID&#x27;</span>] = rid</span><br><span class="line">            <span class="keyword">except</span> RegistryKeyNotFoundException:</span><br><span class="line">                username = <span class="string">f&quot;User_<span class="subst">&#123;user_rid&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 获取 V键下的 Values</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># SID</span></span><br><span class="line">                v_key = subkey.get_value(<span class="string">&#x27;V&#x27;</span>)</span><br><span class="line">                <span class="built_in">print</span>(v_key.<span class="built_in">hex</span>())</span><br><span class="line">                sid = v_key.<span class="built_in">hex</span>()[<span class="number">576</span>:<span class="number">624</span>]</span><br><span class="line">                sid = <span class="string">f&quot;S-<span class="subst">&#123;get_sid(sid)&#125;</span>-<span class="subst">&#123;rid&#125;</span>&quot;</span></span><br><span class="line">                <span class="comment"># print(sid)</span></span><br><span class="line">                user[<span class="string">&#x27;SID&#x27;</span>] = sid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment"># USERNAME</span></span><br><span class="line">                pattern_name = <span class="string">r&#x27;(5200000002002000001020000000000052000000020020000.*)&#x27;</span></span><br><span class="line">                <span class="keyword">match</span> = re.search(pattern_name, v_key.<span class="built_in">hex</span>())</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">                    result = <span class="keyword">match</span>.group(<span class="number">1</span>)</span><br><span class="line">                    <span class="comment"># print(result[49:])</span></span><br><span class="line">                    temp = result[<span class="number">49</span>:].split(<span class="string">&#x27;0000&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">                    temp = temp.split(<span class="string">&#x27;00&#x27;</span>)</span><br><span class="line">                    res = <span class="string">&quot;&quot;</span></span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> temp:</span><br><span class="line">                        <span class="keyword">if</span> <span class="built_in">len</span>(i) &gt; <span class="number">2</span>:</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            res += i</span><br><span class="line">                    res = <span class="built_in">bytes</span>.fromhex(res).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">                    user[<span class="string">&#x27;username&#x27;</span>] = res</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;未找到匹配的内容。&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span> RegistryKeyNotFoundException:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;用户名: <span class="subst">&#123;username&#125;</span>, 无法找到 SID 信息&quot;</span>)</span><br><span class="line">            user_list.append(user)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">return</span> user_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_network</span>():</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理时间戳</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">byte_to_str</span>(<span class="params">byte_time</span>):</span><br><span class="line">    <span class="comment"># 处理 FILETIME 时间戳</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(byte_time, <span class="built_in">bytes</span>):</span><br><span class="line">        res = little_to_big(byte_time.<span class="built_in">hex</span>()) / <span class="number">10000000</span></span><br><span class="line">        unix_seconds = res - <span class="number">11644473600</span></span><br><span class="line">        unix_seconds = datetime.fromtimestamp(unix_seconds)</span><br><span class="line">        <span class="keyword">return</span> unix_seconds.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        unix_seconds = datetime.fromtimestamp(byte_time)</span><br><span class="line">        <span class="keyword">return</span> unix_seconds.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># hex小端字节序转大端字节序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">little_to_big</span>(<span class="params">little_hex</span>):</span><br><span class="line">    little_bytes = <span class="built_in">bytes</span>.fromhex(little_hex)</span><br><span class="line">    num = <span class="built_in">int</span>.from_bytes(little_bytes, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    big_bytes = num.to_bytes(<span class="built_in">len</span>(little_bytes), byteorder=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">    big_hex = <span class="built_in">int</span>(big_bytes.<span class="built_in">hex</span>(), <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> big_hex</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算SID</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_sid</span>(<span class="params">data</span>):</span><br><span class="line">    sid = []</span><br><span class="line">    temp = <span class="built_in">str</span>(<span class="built_in">int</span>(data[:<span class="number">2</span>], <span class="number">16</span>))</span><br><span class="line">    sid.append(temp)</span><br><span class="line">    num = <span class="built_in">int</span>(data[<span class="number">2</span>:<span class="number">4</span>], <span class="number">16</span>)</span><br><span class="line">    value = <span class="built_in">str</span>(<span class="built_in">int</span>(data[<span class="number">4</span>:<span class="number">16</span>], <span class="number">16</span>))</span><br><span class="line">    sid.append(value)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num-<span class="number">1</span>):</span><br><span class="line">        test = <span class="built_in">str</span>(little_to_big(data[<span class="number">16</span>+i*<span class="number">8</span>:<span class="number">24</span>+i*<span class="number">8</span>]))</span><br><span class="line">        sid.append(test)</span><br><span class="line">    sid = <span class="string">&#x27;-&#x27;</span>.join(sid)</span><br><span class="line">    <span class="keyword">return</span> sid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 将这里的路径替换为你的挂载路径</span></span><br><span class="line">    registry_path = <span class="string">r&#x27;H:/[root]/Windows/System32/config&#x27;</span></span><br><span class="line">    result = analyze_software_registry(registry_path)</span><br><span class="line">    res = get_sid_name(registry_path)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>



<p>运行结果</p>
<p>系统用户的SID处理有点问题，这里的用户的是正常的，还需要大量的验证，时区没进行处理，常见的形式是 （UTC+08:00）北京</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#123;&#x27;RID&#x27;: 500, &#x27;SID&#x27;: &#x27;S-1-1-500&#x27;, &#x27;username&#x27;: &#x27;Administrator&#x27;&#125;, &#123;&#x27;RID&#x27;: 501, &#x27;SID&#x27;: &#x27;S-1-1-501&#x27;, &#x27;username&#x27;: &#x27;Guest&#x27;&#125;, &#123;&#x27;RID&#x27;: 503, &#x27;SID&#x27;: &#x27;S-1-1-503&#x27;, &#x27;username&#x27;: &#x27;DefaultAccount&#x27;&#125;, &#123;&#x27;RID&#x27;: 504, &#x27;SID&#x27;: &#x27;S-1-1-504&#x27;, &#x27;username&#x27;: &#x27;WDAGUtilityAccount&#x27;&#125;, &#123;&#x27;RID&#x27;: 1000, &#x27;SID&#x27;: &#x27;S-1-5-21-1013533190-531092935-234414423-1000&#x27;, &#x27;username&#x27;: &#x27;TTT&#x27;&#125;]</span><br><span class="line"></span><br><span class="line">[&#123;&#x27;Build信息&#x27;: &#x27;18362.1.amd64fre.19h1_release.190318-1202&#x27;&#125;, &#123;&#x27;Build版本&#x27;: &#x27;18363&#x27;&#125;, &#123;&#x27;计算机名称&#x27;: &#x27;DESKTOP-SBTC549&#x27;&#125;, &#123;&#x27;系统名称&#x27;: &#x27;Windows 10 Education&#x27;&#125;, &#123;&#x27;系统安装时间&#x27;: &#x27;2024-06-12 19:02:06&#x27;&#125;, &#123;&#x27;系统时区&#x27;: &#x27;China Standard Time&#x27;&#125;, &#123;&#x27;最后一次关机时间&#x27;: &#x27;2025-02-10 16:15:30&#x27;&#125;, &#123;&#x27;上次登录用户&#x27;: &#x27;.\\TTT&#x27;&#125;]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python脚本 电子取证</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>电子取证</tag>
      </tags>
  </entry>
  <entry>
    <title>vue（vite）+electron项目创建和打包</title>
    <url>/2025/03/13/vue%EF%BC%88vite%EF%BC%89-electron%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA%E5%92%8C%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<h3 id="vue（vite）-electron项目创建打包"><a href="#vue（vite）-electron项目创建打包" class="headerlink" title="vue（vite）+electron项目创建打包"></a>vue（vite）+electron项目创建打包</h3><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><p>先创建构建环境，安装依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm createnpm create vite@latest vue-electron-app --template vue</span><br><span class="line">cd vue-electron-app</span><br><span class="line">npm install</span><br><span class="line">npm install electron electron-builder --save-dev</span><br><span class="line">npm install concurrently --save-dev</span><br><span class="line">npm install vite-plugin-electron --save-dev</span><br><span class="line">npm install @vitejs/plugin-vue --save-dev</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<blockquote>
<p>利用vite构建vue项目</p>
<p>安装依赖</p>
<p>安装electron</p>
<p>安装开发依赖</p>
<p>安装热加载插件</p>
</blockquote>
<p>由于网络问题可能导致安装不全，根据报错再自行补充安装</p>
<h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p>此时项目主要目录结构为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue-electron-app/</span><br><span class="line">├── src/   </span><br><span class="line">|   ├── assets/</span><br><span class="line">|   ├── components/</span><br><span class="line">|   ├── main.js</span><br><span class="line">|   ├── App.vue</span><br><span class="line">|   ├── style.css</span><br><span class="line">├── public/</span><br><span class="line">├── vite.config.js      </span><br><span class="line">├── index.html</span><br><span class="line">└── package.json        </span><br></pre></td></tr></table></figure>



<p>这个目录结构就是vue项目的目录，简单介绍一下，vue调试的时候会先读取根目录下的index.html文件，html文件中指示了main.js函数的位置，在main函数中加载App.vue</p>
<p>用户在App.vue中配置路由，引用其他页面即可</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250312175612798.png" alt="image-20250312175612798"></p>
<p>加入electron为了结构清晰一点，我稍微更改了一下目录结构，因为electron需要先读取他的main.js文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue-electron-app/</span><br><span class="line">├── src/   </span><br><span class="line">|   ├── main/        // (自行创建)</span><br><span class="line">│       └── main.js  </span><br><span class="line">│   ├── components/</span><br><span class="line">│   ├── pages/</span><br><span class="line">│   ├── App.vue</span><br><span class="line">│   ├── main.js</span><br><span class="line">│   ├── style.css</span><br><span class="line">├── public/</span><br><span class="line">├── vite.config.js      </span><br><span class="line">├── index.html</span><br><span class="line">└── package.json   </span><br></pre></td></tr></table></figure>



<h4 id="创建新入口main-js"><a href="#创建新入口main-js" class="headerlink" title="创建新入口main.js"></a>创建新入口main.js</h4><p>在src目录下创建一个 <code>main/main.js</code> 文件</p>
<p>win.loadFile指向vue项目的index.html文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/main/main.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; app, <span class="title class_">BrowserWindow</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义窗口的大小，以及初始化的文件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createWindow</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> win = <span class="keyword">new</span> <span class="title class_">BrowserWindow</span>(&#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">800</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">600</span>,</span><br><span class="line">    <span class="attr">webPreferences</span>: &#123;</span><br><span class="line">      <span class="attr">nodeIntegration</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">contextIsolation</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开发环境加载 Vite 服务器</span></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;development&#x27;</span>) &#123;</span><br><span class="line">    win.<span class="title function_">loadURL</span>(<span class="string">&#x27;http://localhost:5173&#x27;</span>)</span><br><span class="line">    win.<span class="property">webContents</span>.<span class="title function_">openDevTools</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    win.<span class="title function_">loadFile</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../../dist/index.html&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">whenReady</span>().<span class="title function_">then</span>(createWindow)</span><br></pre></td></tr></table></figure>



<p>然后创建一个renderer文件夹，将conmponents目录、App.vue文件、main.js文件以及style.css挪进去。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/renderer/main.js</span></span><br><span class="line"><span class="comment">// vue的入口文件</span></span><br><span class="line"><span class="comment">// 初始配置不需要更改这个</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./style.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>需要在package.json文件中，指向刚刚创建的入口函数main.js，后面build部分可以先不用管，定义好main的位置以及dev代表的指令，name和version随意</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vue-electron-app&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/main/main.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite build&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;serve&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite preview&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;electron:build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm run build &amp;&amp; electron-builder&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;electron:serve&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@vitejs/plugin-vue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.2.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;concurrently&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^8.2.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;electron&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^28.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;electron-builder&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^24.9.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;vite&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;vite-plugin-electron&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.29.0&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;appId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;com.example.vue-electron&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;productName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;VueElectronApp&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;directories&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="string">&quot;output&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;dist/**/*&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;src/**/*&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;win&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nsis&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;icon&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>





<h4 id="更改vite-config-js"><a href="#更改vite-config-js" class="headerlink" title="更改vite.config.js"></a>更改vite.config.js</h4><p>在 vite.config.js 中引入热加载插件，主要build部分可以不进行配置，只是运行的时候会在根目录下创建一个新文件夹 <code>dist-electron</code> 然后文件夹内有一个main.js文件，几乎和main&#x2F;main.js一样，有点稍微破坏结构，这里配置是将这个文件夹生成的位置放到 node_modules 内，隐藏起来。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> electron <span class="keyword">from</span> <span class="string">&#x27;vite-plugin-electron&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">vue</span>(),</span><br><span class="line">    <span class="title function_">electron</span>(&#123;</span><br><span class="line">      <span class="attr">entry</span>: <span class="string">&#x27;src/main/main.js&#x27;</span>,</span><br><span class="line">      <span class="attr">vite</span>: &#123;</span><br><span class="line">        <span class="attr">build</span>: &#123;</span><br><span class="line">          <span class="attr">outDir</span>: <span class="string">&#x27;node_modules/.cache/vite-electron&#x27;</span>,</span><br><span class="line">            <span class="comment">// 禁止写入磁盘</span></span><br><span class="line">          <span class="attr">write</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>





<p>这个时候就可以运行了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20250312194019474.png" alt="image-20250312194019474"></p>
<h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><p>最后来看打包</p>
<p>在package.json中的build字段配置打包，指明名称以及打包到的目录之后就是重点了，files是要打包的内容，首先就是 dist目录，vue打包时会将资源文件copy一份放到dist目录下，直接打包dist目录即可，然后就是main&#x2F;main.js，这个也要打包进去，然后就是刚封装的 vue的核心部分 renderer 目录下的vue文件。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">  <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;appId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;com.example.vue-electron&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;productName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;VueElectronApp&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;directories&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="string">&quot;output&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;dist/**/*&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;src/**/*&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;win&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nsis&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;icon&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<p>这个配置比较简单，这样打包出来的 <code>setup exe</code> 会双击运行直接自动安装到C盘，人都傻了。</p>
<p>一般会放在 <code>user/AppDate/Local/Programs/</code> 目录下，目录名称就是上面productName设置的名称。</p>
<p>如果找不到用 every thing 搜一下就行。想要不直接安装，提高用户体验也可以，两个办法，</p>
<p>一、直接把便携版发过去，不给 setup版本（doge</p>
<p>二、添加安装向导，因为是Windows，</p>
<p>直接使用简单方便快捷好使的NSIS，<a href="https://www.electron.build/nsis">https://www.electron.build/nsis</a> 这个仅支持Windows</p>
<p>如果有更高级的需求可以使用Inno Setup：<a href="https://jrsoftware.org/isdl.php">https://jrsoftware.org/isdl.php</a></p>
<h5 id="NSIS"><a href="#NSIS" class="headerlink" title="NSIS"></a>NSIS</h5><p>在build中继续增加</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">  <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;appId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;com.example.vue-electron&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;productName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;VueElectronApp&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;directories&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="string">&quot;output&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;dist/**/*&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;src/**/*&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;win&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nsis&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;icon&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;nsis&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;oneClick&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span>          <span class="comment">// 是否一键安装</span></span><br><span class="line">      <span class="attr">&quot;allowElevation&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>     <span class="comment">// 是否允许请求提升，如果是false需要管理员权限允许</span></span><br><span class="line">      <span class="attr">&quot;allowToChangeInstallationDirectory&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span>    <span class="comment">// 是否允许修改安装目录</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<p>打包试一下</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250313172610309.png" alt="image-20250313172610309"></p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250313172620523.png" alt="image-20250313172620523"></p>
<p>觉得有点丑，其实大部分都是这样的，如果想改还能设置图标什么的，自行研究吧。</p>
<h5 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h5><p>如果打包之后试运行没有出现页面，检查一下 main&#x2F;main.js 文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/main/main.js</span></span><br><span class="line"><span class="comment">// 这里要用 path.resolve 不要直接写路径，会出现找不到路径的情况，报错也不会提到这里</span></span><br><span class="line">win.<span class="title function_">loadFile</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../../dist/index.html&#x27;</span>));</span><br></pre></td></tr></table></figure>





<p>vue打包生成的index.html和根目录下的index.html是不一样的，直接引用了打包之后的文件，然后 script 标签消失，这个标签仅用于开发环境测试使用，打包之后消失时正常的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/src/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20250313165305411.png" alt="image-20250313165305411"></p>
<p>还要检查package.js中是否将代码打包进入了，不需要选资源文件，因为之前将代码都放在了src目录下，只需要将这个目录打包进入即可</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vue-electron-app&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src/main/main.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite build&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;serve&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite preview&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;electron:build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite build &amp;&amp; electron-builder&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;electron:serve&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@electron-forge/cli&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.7.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@vitejs/plugin-vue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.2.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;concurrently&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^8.2.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;electron&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^28.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;electron-builder&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^24.9.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;vite&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;vite-plugin-electron&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.29.0&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;appId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;com.example.vue-electron&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;productName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;VueElectronApp&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;directories&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;output&quot;</span><span class="punctuation">:</span> <span class="string">&quot;output&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;dist/**/*&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;src/**/*&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;win&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nsis&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;icon&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;nsis&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;oneClick&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;allowElevation&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;allowToChangeInstallationDirectory&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>VUE框架</category>
      </categories>
      <tags>
        <tag>VUE</tag>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title>分析某软件登录逻辑以及协议复现</title>
    <url>/2025/03/14/%E5%88%86%E6%9E%90%E6%9F%90%E8%BD%AF%E4%BB%B6%E7%99%BB%E5%BD%95%E9%80%BB%E8%BE%91%E4%BB%A5%E5%8F%8A%E5%8D%8F%E8%AE%AE%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="分析某软件登录逻辑以及协议复现"><a href="#分析某软件登录逻辑以及协议复现" class="headerlink" title="分析某软件登录逻辑以及协议复现"></a>分析某软件登录逻辑以及协议复现</h3><div style="display: flex; justify-content: center; color: red; font-weight: 650">
    本贴仅作技术交流，如有侵权请在Github的issue联系我立即删帖
</div><br>

<p>工具准备：Pixel XL       &#x2F;&#x2F; 该软件不支持模拟器</p>
<p>​				  雷电APP（脱壳用，不会脱壳，哭）</p>
<p>​				  frida</p>
<span id="more"></span>

<p>符合360加固的特征，用雷电脱个壳，仍jadx编译一下</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250304174645502.png" alt="image-20250304174645502"></p>
<p>尝试一下抓包，抓到两个数据包</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250313194656732.png" alt="image-20250313194656732"></p>
<p>只有第一个有用，下面那个跟登录无关</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /login_jsonp_active.do HTTP/1.1</span><br><span class="line">common: &#123;&quot;uniqueCode&quot;:&quot;dd67d0c0-01e5-492d-8b3b-c35c5fa6ba48&quot;,&quot;appId&quot;:&quot;com.zcool.community&quot;,&quot;channel&quot;:&quot;zcool&quot;,&quot;mobileType&quot;:&quot;android&quot;,&quot;versionCode&quot;:4638&#125;</span><br><span class="line">BaseInfo: &#123;&quot;uniqueCode&quot;:&quot;dd67d0c0-01e5-492d-8b3b-c35c5fa6ba48&quot;,&quot;appId&quot;:&quot;com.zcool.community&quot;,&quot;channel&quot;:&quot;zcool&quot;,&quot;mobileType&quot;:&quot;android&quot;,&quot;versionCode&quot;:4638&#125;</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 624</span><br><span class="line">Host: passport.zcool.com.cn</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Accept-Encoding: gzip</span><br><span class="line">Cookie: HWWAFSESID=a3b2973ef5454da521; HWWAFSESTIME=1741081260467</span><br><span class="line">User-Agent: okhttp/3.12.0</span><br><span class="line"></span><br><span class="line">app=android&amp;key=dTdlMmtGQjZIQk45NEN3dTIzamdVb2xYMVp5dDZnYmgrMGRlK2xjbkpwZjJpWGczb1FhYWxUVUx1%250AaVJ1d01ZeG5mZUpXZzUvT0M0WQpuYnF1NG0wdjZEd0NaSldPMkZGQ1loRmZ5NG1PM1dTMmhGd3d0%250AbVNhaG9vMVRBbitzQWRrZVBubWZxNGt6ajIyUHJpdEVxUGhHM0tKCmMzWmExU2FXWDJ0VjA0S0NE%250AL3owNmNOUEUrMjRwcExDR0VqSVViU2RyVDU2a0RmS0dqOFhKYmNyYjljM0lqbE9IWm5Rajl5UmM1%250AdnMKTDlFc2xLaVJNRU5rUVJ6RnVaN1k0OVBPTklkeVpsYUJwaG5UTlpkTy9DcmJDcmhvTjRZUUM2%250AcjZiSU4xcTdieHlIOTBxNjYyT0RCNwpNZVhzQVcwbjI3eEtUTHVDWmxhQnBoblROWmRPL0NyYkNy%250AaG9Od0dTRVo1aGxrNlAzMHpYOFFIaTJRZEhjM2JBQy9ESC9iQXBidko1CnUybDluN3FOYkFaT1ZO%250AajNaYnlHSjJrVmdBPT0KP2tleUlkPTE%253D%250A</span><br></pre></td></tr></table></figure>



<p>看那么长的数据先从 hashmap下手，hook hashmap</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">showStacks</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">            <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>)</span><br><span class="line">               .<span class="title function_">getStackTraceString</span>(</span><br><span class="line">                    <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new()</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">HashMap</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;java.util.HashMap&#x27;</span>);</span><br><span class="line">    <span class="title class_">HashMap</span>.<span class="property">put</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 打印username的堆栈信息</span></span><br><span class="line">        <span class="keyword">if</span> (a.<span class="title function_">equals</span>(<span class="string">&quot;username&quot;</span>)) &#123;</span><br><span class="line">            <span class="title function_">showStacks</span>();</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hashMap.put :&quot;</span>, a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;put: &quot;</span>, a, b);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">put</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20250313200624941.png" alt="image-20250313200624941"></p>
<p>跟抓到的包对比一下，</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250313201530543.png" alt="image-20250313201530543"></p>
<p>根据这个堆栈信息去寻找登录加密函数，把没用的东西去掉，看看这几个函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.Throwable</span><br><span class="line">	at com.zcool.community.data.api.PassportApi.signIn(PassportApi.java:138)</span><br><span class="line">	at com.zcool.community.module.session.pwdsignin.PwdSigninViewProxy.signin(PwdSigninViewProxy.java:61)</span><br><span class="line">	at com.zcool.community.module.session.pwdsignin.PwdSigninViewFragment$Content.onSubmitClick(PwdSigninViewFragment.java:189)</span><br><span class="line">	at com.zcool.community.module.session.pwdsignin.PwdSigninViewFragment$Content.access$000(PwdSigninViewFragment.java:83)</span><br><span class="line">	at com.zcool.community.module.session.pwdsignin.PwdSigninViewFragment$Content$1.onClick(PwdSigninViewFragment.java:136)</span><br><span class="line">	at com.zcool.inkstone.util.ViewUtil.lambda$onClick$0(ViewUtil.java:46)</span><br><span class="line">	at com.zcool.inkstone.util.-$$Lambda$ViewUtil$AQ3e0vrll-kI-Unlrb6ud-SUkjg.accept(Unknown Source:4)</span><br></pre></td></tr></table></figure>



<p>搜一下 login_jsonp 这个地址先</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250313194913280.png" alt="image-20250313194913280"></p>
<p>进去是个接口，定义了一个 signIn 方法</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250313202739009.png" alt="image-20250313202739009"></p>
<p>再去寻找一下刚刚堆栈的第一个方法，恰好也是 sigin，使用的就是上图接口</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250313202831858.png" alt="image-20250313202831858"></p>
<p>稍微分析了一下 str 是用户名 str2 是用户密码，这个 str3 是处理第三方登录的如qq，微信，测试用的账号密码登录，不管这个</p>
<p>从 str2 跳出去找到 PASSWORD_KEY &#x3D; “password”，石锤了是密码字段，可能为了防止搜明文搜出来吧</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250313203346783.png" alt="image-20250313203346783"></p>
<p>然后就是调用方法 <code>buildAndSetKeyParams</code> 进行数据加密，加密完成时候，发起网络请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; createBaseParams = createBaseParams();</span><br><span class="line">      buildAndSetKeyParams(createBaseParams, createBaseKeyParams);</span><br><span class="line">      createBaseParams.put(NotificationCompat.CATEGORY_SERVICE, <span class="string">&quot;https://www.zcool.com.cn&quot;</span>);</span><br><span class="line">      createBaseParams.put(<span class="string">&quot;appLogin&quot;</span>, <span class="string">&quot;https://www.zcool.com.cn/tologin.do&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.mApiInterface.onKeyLoginWithToken(createBaseParams, createBaseHeaders()).map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;NetSignInInfo, TrustedResponse&lt;TrustedSignInInfo&gt;&gt;() &#123; <span class="comment">// from class: com.zcool.community.data.api.PassportApi.2</span></span><br><span class="line">          <span class="comment">/* JADX WARN: Type inference failed for: r4v1, types: [T, com.zcool.community.data.api.entity.trusted.TrustedSignInInfo] */</span></span><br><span class="line">          <span class="meta">@Override</span> <span class="comment">// io.reactivex.functions.Function</span></span><br><span class="line">          <span class="keyword">public</span> TrustedResponse&lt;TrustedSignInInfo&gt; <span class="title function_">apply</span><span class="params">(<span class="meta">@io</span>.reactivex.annotations.NonNull NetSignInInfo netSignInInfo)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">              com.zcool.community.data.api.entity.net.<span class="type">NetResponse</span> <span class="variable">netResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.zcool.community.data.api.entity.net.NetResponse();</span><br><span class="line">              netResponse.data = netSignInInfo.toTrustedSignInInfo();</span><br><span class="line">              <span class="keyword">if</span> (((TrustedSignInInfo) netResponse.data).result) &#123;</span><br><span class="line">                  netResponse.code = <span class="number">0</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  netResponse.code = -<span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              Log.d(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;response.code:&quot;</span> + netResponse.code);</span><br><span class="line">              netResponse.msg = ((TrustedSignInInfo) netResponse.data).msg;</span><br><span class="line">              <span class="keyword">return</span> netResponse.toTrustedResponse(<span class="keyword">new</span> <span class="title class_">Converter</span>&lt;TrustedSignInInfo, TrustedSignInInfo&gt;() &#123; <span class="comment">// from class: com.zcool.community.data.api.PassportApi.2.1</span></span><br><span class="line">                  <span class="meta">@Override</span> <span class="comment">// com.zcool.community.lang.Converter</span></span><br><span class="line">                  <span class="keyword">public</span> TrustedSignInInfo <span class="title function_">convert</span><span class="params">(TrustedSignInInfo trustedSignInInfo)</span> &#123;</span><br><span class="line">                      <span class="keyword">return</span> trustedSignInInfo;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;).map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;TrustedResponse&lt;TrustedSignInInfo&gt;, TrustedResponse&lt;TrustedSignInInfo&gt;&gt;() &#123; <span class="comment">// from class: com.zcool.community.data.api.PassportApi.1</span></span><br><span class="line">          <span class="meta">@Override</span> <span class="comment">// io.reactivex.functions.Function</span></span><br><span class="line">          <span class="keyword">public</span> TrustedResponse&lt;TrustedSignInInfo&gt; <span class="title function_">apply</span><span class="params">(<span class="meta">@io</span>.reactivex.annotations.NonNull TrustedResponse&lt;TrustedSignInInfo&gt; trustedResponse)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">              <span class="keyword">if</span> (trustedResponse.code == <span class="number">0</span> &amp;&amp; trustedResponse.data.userId &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (!TextUtils.isEmpty(trustedResponse.data.SERVER_COOKIE_V1)) &#123;</span><br><span class="line">                      CookiesHelper.addPassportServerCookieV1(trustedResponse.data.SERVER_COOKIE_V1);</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      Timber.e(<span class="string">&quot;sign in success, but cookie not found&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">                      <span class="keyword">new</span> <span class="title class_">IllegalAccessError</span>(<span class="string">&quot;SERVER_COOKIE_V1 not found&quot;</span>).printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> trustedResponse;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>进入<code>buildAndSetKeyParams</code> 函数，这个是继承父类的方法，父类方法中只有一句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map.put(&quot;key&quot;,EncryptManager.getInstance().encrypt(map2));</span><br></pre></td></tr></table></figure>

<p>在进入找到 EncryptManager.getInstance().encrypt(map2) ，根据最下面的图 <code>EncryptManager.getInstance()</code> 等效于 <code>LazyInstance.access$100();</code> 等效于 <code>LazyInstance.get()</code> 返回结果为 </p>
<p> <code>private static final EncryptManager instance = new EncryptManager()</code> 这个名为 <code>instance</code> 的 <code>EncryptManager</code> 类</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250313204911515.png" alt="image-20250313204911515"></p>
<p>绕了一圈，创建了一个<code>EncryptManager</code> 类 调用这个类的 <code>encrypt</code> 方法，传入map2，map是空的，map2包含用户的各种信息。</p>
<p>hook一下这个方法，查看出入值，返回值和抓包的值是否有一致的部分</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">showStacks</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">            <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>)</span><br><span class="line">                .<span class="title function_">getStackTraceString</span>(</span><br><span class="line">                    <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new()</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">EncryptManager</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.zcool.community.data.api.encrypt.EncryptManager&quot;</span>);</span><br><span class="line">    <span class="title class_">EncryptManager</span>[<span class="string">&quot;encrypt&quot;</span>].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">map</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`EncryptManager.encrypt is called: map=<span class="subst">$&#123;map&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">let</span> result = <span class="variable language_">this</span>[<span class="string">&quot;encrypt&quot;</span>](map);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`EncryptManager.encrypt result=<span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="/../%E5%9B%BE%E7%89%87/image-20250313210119315.png" alt="image-20250313210119315"></p>
<p>处理一下着两份数据，不能说大差不差，只能说完全一样，只有间隔符不一样返回的数值的间隔符是 %0A ，抓包的是 %250A，而发包是要使用url编码，%25在url编码中就是%</p>
<p>这些东西将密文分成了 76 字符一组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">result=</span><br><span class="line">dTdlMmtGQjZIQk45NEN3dTIzamdVb2xYMVp5dDZnYmgrMGRlK2xjbkpwZjJpWGczb1FhYWxUVUx1</span><br><span class="line">%0A</span><br><span class="line">aVJ1d01ZeG5mZUpXZzUvT0M0WQpuYnF1NG0wdjZEd0NaSldPMkZGQ1loRmZ5NG1PM1dTMmhGd3d0</span><br><span class="line">%0A</span><br><span class="line">bVNhaG9vMVRBbitzQWRrZVBubWZxNGt6ajIyUHJpdEVxUGhHM0tKCmMzWmExU2FXWDJ0VjA0S0NE</span><br><span class="line">%0A</span><br><span class="line">L3owNmNOUEUrMjRwcExDR0VqSVViU2RyVDU2a0RmS0dqOFhKYmNyYjljM0lqbE9IWm5Rajl5UmM1</span><br><span class="line">%0A</span><br><span class="line">dnMKTDlFc2xLaVJNRU5rUVJ6RnVaN1k0OVBPTklkeVpsYUJwaG5UTlpkTy9DcmJDcmhvTjRZUUM2</span><br><span class="line">%0A</span><br><span class="line">cjZiSU4xcTdieHlIOTBxNjYyT0RCNwpNZVhzQVcwbjI3eEtUTHVDWmxhQnBoblROWmRPL0NyYkNy</span><br><span class="line">%0A</span><br><span class="line">aG9Od0dTRVo1aGxrNlAzMHpYOFFIaTJRZEhjM2JBQy9ESC9iQXBidko1CnUybDluN3FOYkFaT1ZO</span><br><span class="line">%0A</span><br><span class="line">ajNaYnlHSjJrVmdBPT0KP2tleUlkPTE</span><br><span class="line">%3D</span><br><span class="line">%0A</span><br><span class="line"></span><br><span class="line">app=android&amp;key=</span><br><span class="line">dTdlMmtGQjZIQk45NEN3dTIzamdVb2xYMVp5dDZnYmgrMGRlK2xjbkpwZjJpWGczb1FhYWxUVUx1</span><br><span class="line">%250A</span><br><span class="line">aVJ1d01ZeG5mZUpXZzUvT0M0WQpuYnF1NG0wdjZEd0NaSldPMkZGQ1loRmZ5NG1PM1dTMmhGd3d0</span><br><span class="line">%250A</span><br><span class="line">bVNhaG9vMVRBbitzQWRrZVBubWZxNGt6ajIyUHJpdEVxUGhHM0tKCmMzWmExU2FXWDJ0VjA0S0NE</span><br><span class="line">%250A</span><br><span class="line">L3owNmNOUEUrMjRwcExDR0VqSVViU2RyVDU2a0RmS0dqOFhKYmNyYjljM0lqbE9IWm5Rajl5UmM1</span><br><span class="line">%250A</span><br><span class="line">dnMKTDlFc2xLaVJNRU5rUVJ6RnVaN1k0OVBPTklkeVpsYUJwaG5UTlpkTy9DcmJDcmhvTjRZUUM2</span><br><span class="line">%250A</span><br><span class="line">cjZiSU4xcTdieHlIOTBxNjYyT0RCNwpNZVhzQVcwbjI3eEtUTHVDWmxhQnBoblROWmRPL0NyYkNy</span><br><span class="line">%250A</span><br><span class="line">aG9Od0dTRVo1aGxrNlAzMHpYOFFIaTJRZEhjM2JBQy9ESC9iQXBidko1CnUybDluN3FOYkFaT1ZO</span><br><span class="line">%250A</span><br><span class="line">ajNaYnlHSjJrVmdBPT0KP2tleUlkPTE</span><br><span class="line">%253D</span><br><span class="line">%250A</span><br></pre></td></tr></table></figure>



<p>encrypt就是一个关键方法了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">EncryptManager</span><span class="params">()</span> &#123;</span><br><span class="line">    KEYS.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;F#C@5IOBULR9L415C~ZX*97C&quot;</span>);</span><br><span class="line">    KEYS.put(<span class="string">&quot;5&quot;</span>, <span class="string">&quot;DB&amp;T78AQF&amp;W7T#@~LGP9YC~T&quot;</span>);</span><br><span class="line">    KEYS.put(Constants.VIA_REPORT_TYPE_SHARE_TO_QQ, <span class="string">&quot;3D4BT10H4#DUQLXHJ*WLLN&amp;B&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">encrypt</span><span class="params">(Map map)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="comment">// json序列化，将map数据转换成json字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(map);</span><br><span class="line">    <span class="comment">// 使用DESede加密json</span></span><br><span class="line">    <span class="comment">// DESede又叫3DES，密钥24位，encrypt函数上方就是明文的密钥</span></span><br><span class="line">    stringBuffer.append(DESedeCoder.encode(json, KEYS.get(<span class="string">&quot;1&quot;</span>)));</span><br><span class="line">    <span class="comment">// 拼接keyID参数</span></span><br><span class="line">    stringBuffer.append(<span class="string">&quot;?keyId=&quot;</span>);</span><br><span class="line">    stringBuffer.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">stringBuffer2</span> <span class="operator">=</span> stringBuffer.toString();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// URL编码</span></span><br><span class="line">        <span class="comment">// encryptBASE64(stringBuffer2.getBytes(&quot;UTF-8&quot;))，将加密结果从byte类型转换成可传输的ASCII字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">encode</span> <span class="operator">=</span> URLEncoder.encode(encryptBASE64(stringBuffer2.getBytes(<span class="string">&quot;UTF-8&quot;</span>)), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        Timber.v(<span class="string">&quot;encrypt %s-&gt;%s-&gt;%s&quot;</span>, json, stringBuffer2, encode);</span><br><span class="line">        <span class="keyword">return</span> encode;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>既然进行了url编码，那打印出来的 %0A 就需要还原成换行符了，%3D 解码成 &#x3D; </p>
<p>经过3DES加密之后的结果就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dTdlMmtGQjZIQk45NEN3dTIzamdVb2xYMVp5dDZnYmgrMGRlK2xjbkpwZjJpWGczb1FhYWxUVUx1</span><br><span class="line">aVJ1d01ZeG5mZUpXZzUvT0M0WQpuYnF1NG0wdjZEd0NaSldPMkZGQ1loRmZ5NG1PM1dTMmhGd3d0</span><br><span class="line">bVNhaG9vMVRBbitzQWRrZVBubWZxNGt6ajIyUHJpdEVxUGhHM0tKCmMzWmExU2FXWDJ0VjA0S0NE</span><br><span class="line">L3owNmNOUEUrMjRwcExDR0VqSVViU2RyVDU2a0RmS0dqOFhKYmNyYjljM0lqbE9IWm5Rajl5UmM1</span><br><span class="line">dnMKTDlFc2xLaVJNRU5rUVJ6RnVaN1k0OVBPTklkeVpsYUJwaG5UTlpkTy9DcmJDcmhvTjRZUUM2</span><br><span class="line">cjZiSU4xcTdieHlIOTBxNjYyT0RCNwpNZVhzQVcwbjI3eEtUTHVDWmxhQnBoblROWmRPL0NyYkNy</span><br><span class="line">aG9Od0dTRVo1aGxrNlAzMHpYOFFIaTJRZEhjM2JBQy9ESC9iQXBidko1CnUybDluN3FOYkFaT1ZO</span><br><span class="line">ajNaYnlHSjJrVmdBPT0KP2tleUlkPTE=</span><br></pre></td></tr></table></figure>



<p>ECB的填充模式，没有iv值，先将传入的字符串转换成byte的形式，再将传入的keyID&#x3D;1作为密钥，看起来这个是一个标准的DESede&#x2F;ECB加密</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250314084208467.png" alt="image-20250314084208467"></p>
<p>将原数据base64解码，去除掉拼接的 ?keyId&#x3D;1， 得到密文，尝试DESede解码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u7e2kFB6HBN94Cwu23jgUolX1Zyt6gbh+0de+lcnJpf2iXg3oQaalTULuiRuwMYxnfeJWg5/OC4Y</span><br><span class="line">nbqu4m0v6DwCZJWO2FFCYhFfy4mO3WS2hFwwtmSahoo1TAn+sAdkePnmfq4kzj22PritEqPhG3KJ</span><br><span class="line">c3Za1SaWX2tV04KCD/z06cNPE+24ppLCGEjIUbSdrT56kDfKGj8XJbcrb9c3IjlOHZnQj9yRc5vs</span><br><span class="line">L9EslKiRMENkQRzFuZ7Y49PONIdyZlaBphnTNZdO/CrbCrhoN4YQC6r6bIN1q7bxyH90q662ODB7</span><br><span class="line">MeXsAW0n27xKTLuCZlaBphnTNZdO/CrbCrhoNwGSEZ5hlk6P30zX8QHi2QdHc3bAC/DH/bApbvJ5</span><br><span class="line">u2l9n7qNbAZOVNj3ZbyGJ2kVgA==</span><br><span class="line">?keyId=1</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20250314090130128.png" alt="image-20250314090130128"></p>
<p>解密脚本</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CryptoJS</span> = <span class="built_in">require</span>(<span class="string">&#x27;crypto-js&#x27;</span>);</span><br><span class="line">key = <span class="string">&quot;F#C@5IOBULR9L415C~ZX*97C&quot;</span></span><br><span class="line">data = <span class="string">&quot;u7e2kFB6HBN94Cwu23jgUolX1Zyt6gbh+0de+lcnJpf2iXg3oQaalTULuiRuwMYxnfeJWg5/OC4Ynbqu4m0v6DwCZJWO2FFCYhFfy4mO3WS2hFwwtmSahoo1TAn+sAdkePnmfq4kzj22PritEqPhG3KJc3Za1SaWX2tV04KCD/z06cNPE+24ppLCGEjIUbSdrT56kDfKGj8XJbcrb9c3IjlOHZnQj9yRc5vsL9EslKiRMENkQRzFuZ7Y49PONIdyZlaBphnTNZdO/CrbCrhoN4YQC6r6bIN1q7bxyH90q662ODB7MeXsAW0n27xKTLuCZlaBphnTNZdO/CrbCrhoNwGSEZ5hlk6P30zX8QHi2QdHc3bAC/DH/bApbvJ5u2l9n7qNbAZOVNj3ZbyGJ2kVgA==&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">decodeDESede</span>(<span class="params">data, key</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _key =  <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(key);</span><br><span class="line">    <span class="keyword">var</span> decrypted = <span class="title class_">CryptoJS</span>.<span class="property">TripleDES</span>.<span class="title function_">decrypt</span>(data, _key, &#123;</span><br><span class="line">        <span class="attr">mode</span>: <span class="title class_">CryptoJS</span>.<span class="property">mode</span>.<span class="property">ECB</span>,</span><br><span class="line">        <span class="attr">padding</span>: <span class="title class_">CryptoJS</span>.<span class="property">pad</span>.<span class="property">Pkcs7</span></span><br><span class="line">    &#125;).<span class="title function_">toString</span>(<span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decrypted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">decodeDESede</span>(data, key))</span><br></pre></td></tr></table></figure>



<p><img src="/../%E5%9B%BE%E7%89%87/image-20250314095718537.png" alt="image-20250314095718537"></p>
<p>解密后的数据</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">解密后的数据<span class="punctuation">:</span> </span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;password&quot;</span><span class="punctuation">:</span><span class="string">&quot;12345678&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;common&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;uniqueCode&quot;</span><span class="punctuation">:</span><span class="string">&quot;dd67d0c0-01e5-492d-8b3b-c35c5fa6ba48&quot;</span><span class="punctuation">,</span><span class="attr">&quot;appId&quot;</span><span class="punctuation">:</span><span class="string">&quot;com.zcool.community&quot;</span><span class="punctuation">,</span><span class="attr">&quot;channel&quot;</span><span class="punctuation">:</span><span class="string">&quot;zcool&quot;</span><span class="punctuation">,</span><span class="attr">&quot;mobileType&quot;</span><span class="punctuation">:</span><span class="string">&quot;android&quot;</span><span class="punctuation">,</span><span class="attr">&quot;versionCode&quot;</span><span class="punctuation">:</span><span class="number">4638</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;appLogin&quot;</span><span class="punctuation">:</span><span class="string">&quot;https://www.zcool.com.cn/tologin.do&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;service&quot;</span><span class="punctuation">:</span><span class="string">&quot;https://www.zcool.com.cn&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;appId&quot;</span><span class="punctuation">:</span><span class="string">&quot;1006&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;username&quot;</span><span class="punctuation">:</span><span class="string">&quot;13112345678&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<p>再回头看put数据的方法，这里put了五项，但是map数值不是new的，说明 common字段以及提前构建好了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Single&lt;TrustedResponse&lt;TrustedSignInInfo&gt;&gt; <span class="title function_">signIn</span><span class="params">(String str, String str2, String str3, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">createBaseKeyParams</span> <span class="operator">=</span> createBaseKeyParams();</span><br><span class="line">        createBaseKeyParams.put(<span class="string">&quot;appId&quot;</span>, BaseApi.APP_ID);</span><br><span class="line">        createBaseKeyParams.put(NotificationCompat.CATEGORY_SERVICE, <span class="string">&quot;https://www.zcool.com.cn&quot;</span>);</span><br><span class="line">        createBaseKeyParams.put(<span class="string">&quot;appLogin&quot;</span>, <span class="string">&quot;https://www.zcool.com.cn/tologin.do&quot;</span>);</span><br><span class="line">        createBaseKeyParams.put(<span class="string">&quot;username&quot;</span>, str);</span><br><span class="line">        createBaseKeyParams.put(WifiEnterpriseConfig.PASSWORD_KEY, str2);</span><br><span class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(str3)) &#123;</span><br><span class="line">            createBaseKeyParams.put(<span class="string">&quot;thirdId&quot;</span>, str3);</span><br><span class="line">            createBaseKeyParams.put(<span class="string">&quot;siteId&quot;</span>, Integer.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, String&gt; createBaseParams = createBaseParams();</span><br><span class="line">        buildAndSetKeyParams(createBaseParams, createBaseKeyParams);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.mApiInterface.signIn(createBaseParams, createBaseHeaders()).map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;NetSignInInfo, TrustedResponse&lt;TrustedSignInInfo&gt;&gt;() &#123; <span class="comment">// from class: com.zcool.community.data.api.PassportApi.4</span></span><br><span class="line">            <span class="comment">/* JADX WARN: Type inference failed for: r2v1, types: [T, com.zcool.community.data.api.entity.trusted.TrustedSignInInfo] */</span></span><br><span class="line">            <span class="meta">@Override</span> <span class="comment">// io.reactivex.functions.Function</span></span><br><span class="line">            <span class="keyword">public</span> TrustedResponse&lt;TrustedSignInInfo&gt; <span class="title function_">apply</span><span class="params">(<span class="meta">@io</span>.reactivex.annotations.NonNull NetSignInInfo netSignInInfo)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                com.zcool.community.data.api.entity.net.<span class="type">NetResponse</span> <span class="variable">netResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.zcool.community.data.api.entity.net.NetResponse();</span><br><span class="line">                netResponse.data = netSignInInfo.toTrustedSignInInfo();</span><br><span class="line">                <span class="keyword">if</span> (((TrustedSignInInfo) netResponse.data).result) &#123;</span><br><span class="line">                    netResponse.code = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    netResponse.code = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                netResponse.msg = ((TrustedSignInInfo) netResponse.data).msg;</span><br><span class="line">                <span class="keyword">return</span> netResponse.toTrustedResponse(<span class="keyword">new</span> <span class="title class_">Converter</span>&lt;TrustedSignInInfo, TrustedSignInInfo&gt;() &#123; <span class="comment">// from class: com.zcool.community.data.api.PassportApi.4.1</span></span><br><span class="line">                    <span class="meta">@Override</span> <span class="comment">// com.zcool.community.lang.Converter</span></span><br><span class="line">                    <span class="keyword">public</span> TrustedSignInInfo <span class="title function_">convert</span><span class="params">(TrustedSignInInfo trustedSignInInfo)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> trustedSignInInfo;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;TrustedResponse&lt;TrustedSignInInfo&gt;, TrustedResponse&lt;TrustedSignInInfo&gt;&gt;() &#123; <span class="comment">// from class: com.zcool.community.data.api.PassportApi.3</span></span><br><span class="line">            <span class="meta">@Override</span> <span class="comment">// io.reactivex.functions.Function</span></span><br><span class="line">            <span class="keyword">public</span> TrustedResponse&lt;TrustedSignInInfo&gt; <span class="title function_">apply</span><span class="params">(<span class="meta">@io</span>.reactivex.annotations.NonNull TrustedResponse&lt;TrustedSignInInfo&gt; trustedResponse)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">if</span> (trustedResponse.code == <span class="number">0</span> &amp;&amp; trustedResponse.data.userId &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!TextUtils.isEmpty(trustedResponse.data.SERVER_COOKIE_V1)) &#123;</span><br><span class="line">                        CookiesHelper.addPassportServerCookieV1(trustedResponse.data.SERVER_COOKIE_V1);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        Timber.e(<span class="string">&quot;sign in success, but cookie not found&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">IllegalAccessError</span>(<span class="string">&quot;SERVER_COOKIE_V1 not found&quot;</span>).printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> trustedResponse;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>看common的构建，除了uniqueCode都是固定的，uniqueCode跟自己手机有关，这个字段不用管了</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250314105840308.png" alt="image-20250314105840308"></p>
<p>这样一来数据包传输的东西只有password和username是不固定的，其他的基本固定，可以直接拿数值构建，再来看请求头的构造</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.mApiInterface.signIn(createBaseParams, createBaseHeaders()).map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;NetSignInInfo, TrustedResponse&lt;TrustedSignInInfo&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">                                                                            </span><br><span class="line"><span class="comment">// createBaseParams 是加密后的参数，createBaseHeaders()函数用于构造请求头</span></span><br></pre></td></tr></table></figure>



<p>先获取令牌，由于是首次登录不存在令牌，在请求头添加 common 和 BaseInfo，内容相同</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250314130122238.png" alt="image-20250314130122238"></p>
<img src="../图片/image-20250314105048214.png" alt="image-20250314105048214" style="zoom:50%;" />

<p>请求头的其他部分都是 OkHttp 默认添加的，也不存在时间戳等时间，开始简单仿造一个请求</p>
<p>请求返回的数据经过gzip压缩，之前的请求头上以及表示可以接收gzip压缩了，可以写个判断，这里直接使用了，没判断</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">&#x27;https&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">&#x27;zlib&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求URL</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;https://passport.zcool.com.cn/login_jsonp_active.do&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求头</span></span><br><span class="line"><span class="keyword">const</span> headers = &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;passport.zcool.com.cn&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;Keep-Alive&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;HWWAFSESID=a3b2973ef5454da521; HWWAFSESTIME=1741081260467&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;okhttp/3.12.0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;common&#x27;</span>: &#123;<span class="string">&quot;uniqueCode&quot;</span>:<span class="string">&quot;dd67d0c0-01e5-492d-8b3b-c35c5fa6ba48&quot;</span>,<span class="string">&quot;appId&quot;</span>:<span class="string">&quot;com.zcool.community&quot;</span>,<span class="string">&quot;channel&quot;</span>:<span class="string">&quot;zcool&quot;</span>,<span class="string">&quot;mobileType&quot;</span>:<span class="string">&quot;android&quot;</span>,<span class="string">&quot;versionCode&quot;</span>:<span class="number">4638</span>&#125;,</span><br><span class="line">    <span class="string">&#x27;BaseInfo&#x27;</span>: &#123;<span class="string">&quot;uniqueCode&quot;</span>:<span class="string">&quot;dd67d0c0-01e5-492d-8b3b-c35c5fa6ba48&quot;</span>,<span class="string">&quot;appId&quot;</span>:<span class="string">&quot;com.zcool.community&quot;</span>,<span class="string">&quot;channel&quot;</span>:<span class="string">&quot;zcool&quot;</span>,<span class="string">&quot;mobileType&quot;</span>:<span class="string">&quot;android&quot;</span>,<span class="string">&quot;versionCode&quot;</span>:<span class="number">4638</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求体</span></span><br><span class="line"><span class="keyword">const</span> body = <span class="string">`app=android&amp;key=dTdlMmtGQjZIQk45NEN3dTIzamdVb2xYMVp5dDZnYmgrMGRlK2xjbkpwZjJpWGczb1FhYWxUVUx1%250AaVJ1d01ZeG5mZUpXZzUvT0M0WQpuYnF1NG0wdjZEd0NaSldPMkZGQ1loRmZ5NG1PM1dTMmhGd3d0%250AbVNhaG9vMVRBbitzQWRrZVBubWZxNGt6ajIyUHJpdEVxUGhHM0tKCmMzWmExU2FXWDJ0VjA0S0NE%250AL3owNmNOUEUrMjRwcExDR0VqSVViU2RyVDU2a0RmS0dqOFhKYmNyYjljM0lqbE9IWm5Rajl5UmM1%250AdnMKTDlFc2xLaVJNRU5rUVJ6RnVaN1k0OVBPTklkeVpsYUJwaG5UTlpkTy9DcmJDcmhvTjRZUUM2%250AcjZiSU4xcTdieHlIOTBxNjYyT0RCNwpNZVhzQVcwbjI3eEtUTHVDWmxhQnBoblROWmRPL0NyYkNy%250AaG9Od0dTRVo1aGxrNlAzMHpYOFFIaTJRZEhjM2JBQy9ESC9iQXBidko1CnUybDluN3FOYkFaT1ZO%250AajNaYnlHSjJrVmdBPT0KP2tleUlkPTE%253D%250A`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造请求选项</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">    <span class="attr">hostname</span>: <span class="string">&#x27;passport.zcool.com.cn&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">443</span>,</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/login_jsonp_active.do&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>: headers</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送POST请求</span></span><br><span class="line"><span class="keyword">const</span> req = https.<span class="title function_">request</span>(options, <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> responseData = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> gunzip = zlib.<span class="title function_">createGunzip</span>();</span><br><span class="line">    res.<span class="title function_">pipe</span>(gunzip);</span><br><span class="line">    gunzip.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">        responseData += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    gunzip.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应数据:&#x27;</span>, responseData);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// res.setEncoding(&#x27;utf8&#x27;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// res.on(&#x27;data&#x27;, (chunk) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     responseData += chunk;</span></span><br><span class="line">    <span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// res.on(&#x27;end&#x27;, () =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     console.log(&#x27;响应数据:&#x27;, responseData);</span></span><br><span class="line">    <span class="comment">// &#125;);</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">req.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;请求错误:&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">req.<span class="title function_">write</span>(body);</span><br><span class="line">req.<span class="title function_">end</span>();</span><br></pre></td></tr></table></figure>



<p>和手机上结果相同</p>
<p><img src="/../%E5%9B%BE%E7%89%87/image-20250314160152587.png" alt="image-20250314160152587"></p>
<img src="../图片/image-20250314160228991.png" alt="image-20250314160228991" style="zoom:50%;" />



<p>返回的数据是没有进行加密的，明文传输回来，就不需要写DESede解密方法了，写一个加密方法，完善这个请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;https&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">&#x27;zlib&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CryptoJS</span> = <span class="built_in">require</span>(<span class="string">&#x27;crypto-js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> username = <span class="string">&quot;13112345678&quot;</span></span><br><span class="line"><span class="keyword">let</span> password = <span class="string">&quot;12345678&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> date = <span class="string">`&#123;&quot;password&quot;: <span class="subst">$&#123;password&#125;</span>,&quot;common&quot;:&#123;&quot;uniqueCode&quot;:&quot;dd67d0c0-01e5-492d-8b3b-c35c5fa6ba48&quot;,&quot;appId&quot;:&quot;com.zcool.community&quot;,&quot;channel&quot;:&quot;zcool&quot;,&quot;mobileType&quot;:&quot;android&quot;,&quot;versionCode&quot;:4638&#125;,&quot;appLogin&quot;:&quot;https://www.zcool.com.cn/tologin.do&quot;,&quot;service&quot;:&quot;https://www.zcool.com.cn&quot;,&quot;appId&quot;:&quot;1006&quot;,&quot;username&quot;: <span class="subst">$&#123;username&#125;</span>&#125;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DESede解密</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">decodeDESede</span>(<span class="params">data, key</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> _key =  <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> decrypted = <span class="title class_">CryptoJS</span>.<span class="property">TripleDES</span>.<span class="title function_">decrypt</span>(data, _key, &#123;</span><br><span class="line">        <span class="attr">mode</span>: <span class="title class_">CryptoJS</span>.<span class="property">mode</span>.<span class="property">ECB</span>,</span><br><span class="line">        <span class="attr">padding</span>: <span class="title class_">CryptoJS</span>.<span class="property">pad</span>.<span class="property">Pkcs7</span></span><br><span class="line">    &#125;).<span class="title function_">toString</span>(<span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decrypted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DESede加密</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">encodeDESede</span>(<span class="params">data, key</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> _key =  <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> decrypted = <span class="title class_">CryptoJS</span>.<span class="property">TripleDES</span>.<span class="title function_">encrypt</span>(data, _key, &#123;</span><br><span class="line">        <span class="attr">mode</span>: <span class="title class_">CryptoJS</span>.<span class="property">mode</span>.<span class="property">ECB</span>,</span><br><span class="line">        <span class="attr">padding</span>: <span class="title class_">CryptoJS</span>.<span class="property">pad</span>.<span class="property">Pkcs7</span></span><br><span class="line">    &#125;).<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decrypted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照安卓代码处理body，这里的加密结果没用换行符，测试了一下也没啥问题，理论上没用换行符也不要url编码了。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleBody</span>(<span class="params">body</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = body + <span class="string">&#x27;\n&#x27;</span> + <span class="string">&#x27;?keyId=1&#x27;</span>;</span><br><span class="line">    result = <span class="built_in">encodeURIComponent</span>(<span class="title function_">btoa</span>(result));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`app=android&amp;key=<span class="subst">$&#123;result&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">handleBody</span>(<span class="title function_">encodeDESede</span>(date, key)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造请求</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">post</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> headers = &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;passport.zcool.com.cn&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;Keep-Alive&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;okhttp/3.12.1&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;common&#x27;</span>: &#123;<span class="string">&quot;uniqueCode&quot;</span>:<span class="string">&quot;dd67d0c0-01e5-492d-8b3b-c35c5fa6ba48&quot;</span>,<span class="string">&quot;appId&quot;</span>:<span class="string">&quot;com.zcool.community&quot;</span>,<span class="string">&quot;channel&quot;</span>:<span class="string">&quot;zcool&quot;</span>,<span class="string">&quot;mobileType&quot;</span>:<span class="string">&quot;android&quot;</span>,<span class="string">&quot;versionCode&quot;</span>:<span class="number">4638</span>&#125;,</span><br><span class="line">        <span class="string">&#x27;BaseInfo&#x27;</span>: &#123;<span class="string">&quot;uniqueCode&quot;</span>:<span class="string">&quot;dd67d0c0-01e5-492d-8b3b-c35c5fa6ba48&quot;</span>,<span class="string">&quot;appId&quot;</span>:<span class="string">&quot;com.zcool.community&quot;</span>,<span class="string">&quot;channel&quot;</span>:<span class="string">&quot;zcool&quot;</span>,<span class="string">&quot;mobileType&quot;</span>:<span class="string">&quot;android&quot;</span>,<span class="string">&quot;versionCode&quot;</span>:<span class="number">4638</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> options = &#123;</span><br><span class="line">        <span class="attr">hostname</span>: <span class="string">&#x27;passport.zcool.com.cn&#x27;</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="number">443</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/login_jsonp_active.do&#x27;</span>,</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">        <span class="attr">headers</span>: headers</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> req = http.<span class="title function_">request</span>(options, <span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">        <span class="comment">// console.log(&#x27;STATUS:&#x27;+ res.statusCode);</span></span><br><span class="line">        <span class="comment">// console.log(&#x27;HEADERS:&#x27;+ JSON.stringify(res.headers));</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> body = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> gunzip = zlib.<span class="title function_">createGunzip</span>();</span><br><span class="line">        res.<span class="title function_">pipe</span>(gunzip);</span><br><span class="line"></span><br><span class="line">        gunzip.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span> (<span class="params">chunk</span>) &#123;</span><br><span class="line">            body += chunk;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        gunzip.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应数据：&#x27;</span>, body)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;problem with request:&#x27;</span>+ e.<span class="property">message</span>);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    req.<span class="title function_">write</span>(result);</span><br><span class="line">    req.<span class="title function_">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">post</span>(<span class="title function_">handleBody</span>(<span class="title function_">encodeDESede</span>(date, key)))</span><br></pre></td></tr></table></figure>



<p>这次没怎么hook（汗）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hook代码</span></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">showStacks</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">            <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>)</span><br><span class="line">                .<span class="title function_">getStackTraceString</span>(</span><br><span class="line">                    <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Throwable&quot;</span>).$new()</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">HashMap</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;java.util.HashMap&#x27;</span>);</span><br><span class="line">    <span class="title class_">HashMap</span>.<span class="property">put</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 打印username的堆栈信息</span></span><br><span class="line">        <span class="keyword">if</span> (a.<span class="title function_">equals</span>(<span class="string">&quot;username&quot;</span>)) &#123;</span><br><span class="line">            <span class="title function_">showStacks</span>();</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hashMap.put :&quot;</span>, a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;put: &quot;</span>, a, b);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">put</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> <span class="title class_">EncryptManager</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.zcool.community.data.api.encrypt.EncryptManager&quot;</span>);</span><br><span class="line">    <span class="title class_">EncryptManager</span>[<span class="string">&quot;encrypt&quot;</span>].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">map</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`EncryptManager.encrypt is called: map=<span class="subst">$&#123;map&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">let</span> result = <span class="variable language_">this</span>[<span class="string">&quot;encrypt&quot;</span>](map);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`EncryptManager.encrypt result=<span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>这个软件的登录挺简单的，标准的DESede加密，以及方法和密钥在明文里，没有so层的逆向，请求也比较简单，没有时间戳部分。</p>
]]></content>
      <categories>
        <category>逆向实践</category>
      </categories>
      <tags>
        <tag>安卓逆向</tag>
      </tags>
  </entry>
</search>
